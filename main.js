/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GraphWeaverPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian29 = require("obsidian");

// src/models/AIModels.ts
var AIProvider = /* @__PURE__ */ ((AIProvider2) => {
  AIProvider2["OpenRouter"] = "openrouter";
  AIProvider2["OpenAI"] = "openai";
  AIProvider2["Anthropic"] = "anthropic";
  AIProvider2["Google"] = "google";
  AIProvider2["Groq"] = "groq";
  AIProvider2["Mistral"] = "mistral";
  AIProvider2["Perplexity"] = "perplexity";
  AIProvider2["LMStudio"] = "lmstudio";
  return AIProvider2;
})(AIProvider || {});
var AIModelMap = {
  ["openai" /* OpenAI */]: [
    {
      name: "GPT 4o mini",
      apiName: "gpt-4o-mini",
      capabilities: {
        maxTokens: 16e3,
        supportsFunctions: true,
        supportsStreaming: true
      },
      inputCostPer1M: 0.15,
      outputCostPer1M: 0.6,
      contextWindow: 128e3
    },
    {
      name: "GPT 4o",
      apiName: "gpt-4o",
      capabilities: {
        maxTokens: 16e3,
        supportsFunctions: true,
        supportsStreaming: true,
        supportsVision: true
      },
      inputCostPer1M: 2.5,
      outputCostPer1M: 10,
      contextWindow: 128e3
    },
    {
      name: "GPT o1 Preview",
      apiName: "o1-preview",
      capabilities: {
        maxTokens: 33e3,
        supportsFunctions: true,
        supportsStreaming: true
      },
      inputCostPer1M: 15,
      outputCostPer1M: 60,
      contextWindow: 128e3
    },
    {
      name: "GPT o1 Mini",
      apiName: "o1-mini",
      capabilities: {
        maxTokens: 66e3,
        supportsFunctions: true,
        supportsStreaming: true
      },
      inputCostPer1M: 3,
      outputCostPer1M: 12,
      contextWindow: 128e3
    }
  ],
  ["anthropic" /* Anthropic */]: [
    {
      name: "Claude 3 Haiku",
      apiName: "claude-3-haiku-20240307",
      capabilities: {
        maxTokens: 8192,
        supportsFunctions: true,
        supportsStreaming: true
      },
      inputCostPer1M: 0.25,
      outputCostPer1M: 1.25,
      contextWindow: 2e5
    },
    {
      name: "Claude 3.5 Haiku",
      apiName: "claude-3-5-haiku-20241022",
      capabilities: {
        maxTokens: 8192,
        supportsFunctions: true,
        supportsStreaming: true
      },
      inputCostPer1M: 1,
      outputCostPer1M: 5,
      contextWindow: 2e5
    },
    {
      name: "Claude 3 Sonnet",
      apiName: "claude-3-sonnet-20240229",
      capabilities: {
        maxTokens: 8192,
        supportsFunctions: true,
        supportsStreaming: true,
        supportsVision: true
      },
      inputCostPer1M: 3,
      outputCostPer1M: 15,
      contextWindow: 2e5
    },
    {
      name: "Claude 3 Opus",
      apiName: "claude-3-opus-20240229",
      capabilities: {
        maxTokens: 8192,
        supportsFunctions: true,
        supportsStreaming: true,
        supportsVision: true
      },
      inputCostPer1M: 15,
      outputCostPer1M: 75,
      contextWindow: 2e5
    },
    {
      name: "Claude 3.5 Sonnet",
      apiName: "claude-3-5-sonnet-20241022",
      capabilities: {
        maxTokens: 8192,
        supportsFunctions: true,
        supportsStreaming: true,
        supportsVision: true
      },
      inputCostPer1M: 3,
      outputCostPer1M: 15,
      contextWindow: 2e5
    }
  ],
  ["google" /* Google */]: [
    {
      name: "Gemini 1.5 Flash",
      apiName: "gemini-1.5-flash",
      capabilities: {
        maxTokens: 8192,
        supportsStreaming: true
      },
      inputCostPer1M: 0.075,
      outputCostPer1M: 0.3,
      contextWindow: 1e6
    },
    {
      name: "Gemini 1.5 Flash 8B",
      apiName: "gemini-1.5-flash-8b",
      capabilities: {
        maxTokens: 8192,
        supportsStreaming: true
      },
      inputCostPer1M: 0.0375,
      outputCostPer1M: 0.15,
      contextWindow: 1e6
    },
    {
      name: "Gemini 1.5 Pro",
      apiName: "gemini-1.5-pro",
      capabilities: {
        maxTokens: 8192,
        supportsStreaming: true,
        supportsVision: true
      },
      inputCostPer1M: 2.5,
      outputCostPer1M: 10,
      contextWindow: 2e6
    }
  ],
  ["groq" /* Groq */]: [
    {
      name: "Llama 3.2 90B",
      apiName: "llama-3.2-90b-vision-preview",
      capabilities: {
        maxTokens: 8192,
        supportsStreaming: true
      },
      inputCostPer1M: 0,
      outputCostPer1M: 0,
      contextWindow: 128e3
    },
    {
      name: "Llama 3.1 70B",
      apiName: "llama-3.1-70b-versatile",
      capabilities: {
        maxTokens: 32768,
        supportsStreaming: true
      },
      inputCostPer1M: 0,
      outputCostPer1M: 0,
      contextWindow: 128e3
    },
    {
      name: "Llama 3.2 11B",
      apiName: "llama-3.2-11b-vision-preview",
      capabilities: {
        maxTokens: 8192,
        supportsStreaming: true
      },
      inputCostPer1M: 0,
      outputCostPer1M: 0,
      contextWindow: 128e3
    },
    {
      name: "Llama 3.2 3B (Preview)",
      apiName: "llama-3.2-3b-preview",
      capabilities: {
        maxTokens: 8192,
        supportsStreaming: true
      },
      inputCostPer1M: 0,
      outputCostPer1M: 0,
      contextWindow: 128e3
    },
    {
      name: "Llama 3.2 1B (Preview)",
      apiName: "llama-3.2-1b-preview",
      capabilities: {
        maxTokens: 8192,
        supportsStreaming: true
      },
      inputCostPer1M: 0,
      outputCostPer1M: 0,
      contextWindow: 128e3
    }
  ],
  ["openrouter" /* OpenRouter */]: [
    {
      name: "Claude 3.5 Haiku",
      apiName: "anthropic/claude-3.5-haiku",
      capabilities: {
        maxTokens: 8192,
        supportsFunctions: true,
        supportsStreaming: true
      },
      inputCostPer1M: 1,
      outputCostPer1M: 1,
      contextWindow: 2e5
    },
    {
      name: "Anthropic Claude 3.5 Sonnet",
      apiName: "anthropic/claude-3.5-sonnet",
      capabilities: {
        maxTokens: 8192,
        supportsFunctions: true,
        supportsStreaming: true,
        supportsVision: true
      },
      inputCostPer1M: 3,
      outputCostPer1M: 15,
      contextWindow: 2e5
    },
    {
      name: "Google Gemini Flash 1.5",
      apiName: "google/gemini-flash-1.5",
      capabilities: {
        maxTokens: 8192,
        supportsStreaming: true
      },
      inputCostPer1M: 0.075,
      outputCostPer1M: 0.3,
      contextWindow: 1e6
    },
    {
      name: "Google Gemini Flash 1.5 8B",
      apiName: "google/gemini-flash-1.5-8b",
      capabilities: {
        maxTokens: 8192,
        supportsStreaming: true
      },
      inputCostPer1M: 0.0375,
      outputCostPer1M: 0.15,
      contextWindow: 1e6
    },
    {
      name: "Google Gemini Pro 1.5",
      apiName: "google/gemini-pro-1.5",
      capabilities: {
        maxTokens: 8192,
        supportsStreaming: true,
        supportsVision: true
      },
      inputCostPer1M: 1.25,
      outputCostPer1M: 5,
      contextWindow: 2e6
    },
    {
      name: "Mistral Large",
      apiName: "mistralai/mistral-large-2407",
      capabilities: {
        maxTokens: 128e3,
        supportsStreaming: true
      },
      inputCostPer1M: 2,
      outputCostPer1M: 6,
      contextWindow: 128e3
    },
    {
      name: "Ministral 8b",
      apiName: "mistralai/ministral-8b",
      capabilities: {
        maxTokens: 128e3,
        supportsStreaming: true
      },
      inputCostPer1M: 0.1,
      outputCostPer1M: 0.1,
      contextWindow: 128e3
    },
    {
      name: "OpenAI GPT 4o",
      apiName: "openai/gpt-4o-2024-11-20",
      capabilities: {
        maxTokens: 16e3,
        supportsFunctions: true,
        supportsStreaming: true,
        supportsVision: true
      },
      inputCostPer1M: 2.5,
      outputCostPer1M: 10,
      contextWindow: 128e3
    },
    {
      name: "OpenAI GPT 4o Mini",
      apiName: "openai/gpt-4o-mini",
      capabilities: {
        maxTokens: 16e3,
        supportsFunctions: true,
        supportsStreaming: true
      },
      inputCostPer1M: 0.15,
      outputCostPer1M: 0.6,
      contextWindow: 128e3
    },
    {
      name: "OpenAI o1 Mini",
      apiName: "openai/o1-mini",
      capabilities: {
        maxTokens: 66e3,
        supportsFunctions: true,
        supportsStreaming: true
      },
      inputCostPer1M: 3,
      outputCostPer1M: 12,
      contextWindow: 128e3
    },
    {
      name: "OpenAI o1 Preview",
      apiName: "openai/o1-preview",
      capabilities: {
        maxTokens: 33e3,
        supportsFunctions: true,
        supportsStreaming: true
      },
      inputCostPer1M: 15,
      outputCostPer1M: 60,
      contextWindow: 128e3
    }
  ],
  ["perplexity" /* Perplexity */]: [
    {
      name: "Perplexity Small",
      apiName: "llama-3.1-sonar-small-128k-online",
      capabilities: {
        maxTokens: 4096,
        supportsStreaming: true
      },
      inputCostPer1M: 0.2,
      outputCostPer1M: 0.2,
      contextWindow: 128e3
    },
    {
      name: "Perplexity Large",
      apiName: "llama-3.1-sonar-large-128k-online",
      capabilities: {
        maxTokens: 8192,
        supportsStreaming: true
      },
      inputCostPer1M: 1,
      outputCostPer1M: 1,
      contextWindow: 128e3
    },
    {
      name: "Perplexity Huge",
      apiName: "llama-3.1-sonar-huge-128k-online",
      capabilities: {
        maxTokens: 8192,
        supportsStreaming: true
      },
      inputCostPer1M: 5,
      outputCostPer1M: 5,
      contextWindow: 128e3
    }
  ],
  ["lmstudio" /* LMStudio */]: [
    {
      name: "Custom",
      apiName: "custom",
      capabilities: {
        supportsStreaming: false
      }
    }
  ],
  ["mistral" /* Mistral */]: [
    {
      name: "Mistral Large",
      apiName: "mistral-large-latest",
      capabilities: {
        maxTokens: 8192,
        supportsStreaming: true
      },
      inputCostPer1M: 0,
      outputCostPer1M: 0,
      contextWindow: 128e3
    },
    {
      name: "Ministral 8b",
      apiName: "ministral-8b-latest",
      capabilities: {
        maxTokens: 8192,
        supportsStreaming: true
      },
      inputCostPer1M: 0,
      outputCostPer1M: 0,
      contextWindow: 128e3
    },
    {
      name: "Mistral Nemo",
      apiName: "open-mistral-nemo",
      capabilities: {
        maxTokens: 8192,
        supportsStreaming: true
      },
      inputCostPer1M: 0,
      outputCostPer1M: 0,
      contextWindow: 128e3
    }
  ]
};
var AIModelUtils = {
  /**
   * Get a model by its API name
   */
  getModelByApiName(apiName) {
    for (const models of Object.values(AIModelMap)) {
      const model = models.find((m) => m.apiName === apiName);
      if (model)
        return model;
    }
    return void 0;
  }
};

// src/settings/Settings.ts
var DEFAULT_SETTINGS = {
  aiProvider: {
    selected: "openai" /* OpenAI */,
    apiKeys: {},
    selectedModels: {
      ["openai" /* OpenAI */]: "gpt-4o-mini"
    },
    modelConfigs: {}
  },
  frontMatter: {
    customProperties: [],
    // Ensure this is explicitly initialized as empty array
    autoGenerate: false
  },
  tags: {
    customTags: []
  },
  localLMStudio: {
    enabled: false,
    port: 1234,
    modelName: ""
  },
  ontology: {
    lastGenerated: ""
  },
  knowledgeBloom: {
    selectedModel: "string",
    templateFolder: "Templates",
    // Changed from empty string to provide a default
    outputFolder: "",
    overwriteExisting: false,
    defaultPrompt: "Generate a comprehensive note about {LINK}. Include key concepts, definitions, and relevant examples if applicable."
  }
};

// src/services/AIService.ts
var import_obsidian13 = require("obsidian");

// src/adapters/AIAdapter.ts
var import_obsidian = require("obsidian");
var AIAdapter = class {
  constructor(settingsService, jsonValidationService) {
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    this.apiKey = "";
    this.models = [];
    const aiProviderSettings = this.settingsService.getSetting("aiProvider");
    this.apiKey = aiProviderSettings.apiKeys[this.getProviderType()] || "";
    this.models = AIModelMap[this.getProviderType()];
  }
  // Shared implementation methods
  async generateResponse(prompt, modelApiName, options) {
    try {
      const apiModel = this.getApiModelName(modelApiName);
      if (!apiModel) {
        throw new Error(`No valid model found for ${this.getProviderType()}`);
      }
      if (!this.apiKey && this.getProviderType() !== "lmstudio" /* LMStudio */) {
        throw new Error(`${this.getProviderType()} API key is not set`);
      }
      const settings = this.settingsService.getSettings();
      const temperature = this.getTemperature(settings);
      const maxTokens = (options == null ? void 0 : options.maxTokens) || this.getMaxTokens(settings);
      const response = await this.makeApiRequest({
        model: apiModel,
        prompt,
        temperature,
        maxTokens,
        rawResponse: options == null ? void 0 : options.rawResponse
      });
      const content = this.extractContentFromResponse(response);
      if (options == null ? void 0 : options.rawResponse) {
        return { success: true, data: content };
      }
      const validatedContent = await this.jsonValidationService.validateAndCleanJson(content);
      return { success: true, data: validatedContent };
    } catch (error) {
      return this.handleError(error);
    }
  }
  async testConnection(prompt, modelApiName) {
    try {
      if (!this.isReady()) {
        return false;
      }
      const response = await this.generateResponse(
        prompt || "Return the word 'OK'.",
        modelApiName,
        { rawResponse: true }
      );
      if (!response.success || typeof response.data !== "string") {
        return false;
      }
      return response.data.toLowerCase().includes("ok");
    } catch (error) {
      console.error(`Error in ${this.getProviderType()} test connection:`, error);
      return false;
    }
  }
  getTemperature(settings) {
    var _a, _b;
    return ((_a = settings.advanced) == null ? void 0 : _a.temperature) >= 0 && ((_b = settings.advanced) == null ? void 0 : _b.temperature) <= 1 ? settings.advanced.temperature : 0.7;
  }
  getMaxTokens(settings) {
    var _a;
    return ((_a = settings.advanced) == null ? void 0 : _a.maxTokens) > 0 ? settings.advanced.maxTokens : 1e3;
  }
  handleError(error) {
    console.error(`Error in ${this.getProviderType()} API call:`, error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    new import_obsidian.Notice(`${this.getProviderType()} API Error: ${errorMessage}`);
    return { success: false, error: errorMessage };
  }
  async validateApiKey() {
    try {
      if (!this.isReady()) {
        throw new Error(`${this.getProviderType()} is not properly configured`);
      }
      const isValid = await this.testConnection(
        "Return the word 'OK'.",
        this.models[0].apiName
      );
      if (isValid) {
        new import_obsidian.Notice(`${this.getProviderType()} API key validated successfully`);
        return true;
      } else {
        throw new Error("Failed to validate API key");
      }
    } catch (error) {
      console.error(`Error validating ${this.getProviderType()} API key:`, error);
      new import_obsidian.Notice(`Failed to validate ${this.getProviderType()} API key: ${error instanceof Error ? error.message : "Unknown error occurred"}`);
      return false;
    }
  }
  getAvailableModels() {
    return this.models.map((model) => model.apiName);
  }
  setApiKey(apiKey) {
    this.apiKey = apiKey;
  }
  getApiKey() {
    return this.apiKey;
  }
  configure(config) {
    if (config == null ? void 0 : config.apiKey) {
      this.setApiKey(config.apiKey);
    }
  }
  isReady() {
    return (!!this.apiKey || this.getProviderType() === "lmstudio" /* LMStudio */) && this.models.length > 0;
  }
  getApiModelName(modelApiName) {
    var _a;
    const model = this.models.find((m) => m.apiName === modelApiName);
    if (!model) {
      console.warn(`Model ${modelApiName} not found for ${this.getProviderType()}. Using first available model.`);
      return ((_a = this.models[0]) == null ? void 0 : _a.apiName) || modelApiName;
    }
    return model.apiName;
  }
};

// src/adapters/OpenAIAdapter.ts
var import_obsidian2 = require("obsidian");
var OpenAIAdapter = class extends AIAdapter {
  constructor(settingsService, jsonValidationService) {
    super(settingsService, jsonValidationService);
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    const aiProviderSettings = this.settingsService.getSetting("aiProvider");
    this.apiKey = aiProviderSettings.apiKeys["openai" /* OpenAI */] || "";
    this.models = AIModelMap["openai" /* OpenAI */];
  }
  async makeApiRequest(params) {
    return await (0, import_obsidian2.requestUrl)({
      url: "https://api.openai.com/v1/chat/completions",
      method: "POST",
      headers: {
        "Authorization": `Bearer ${this.apiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: params.model,
        messages: [
          {
            role: "system",
            content: params.rawResponse ? "You are a helpful assistant." : "You are a helpful assistant that responds in JSON format."
          },
          { role: "user", content: params.prompt }
        ],
        temperature: params.temperature,
        max_tokens: params.maxTokens,
        response_format: params.rawResponse ? void 0 : { type: "json_object" }
      })
    });
  }
  extractContentFromResponse(response) {
    var _a, _b, _c, _d;
    if (!((_d = (_c = (_b = (_a = response.json) == null ? void 0 : _a.choices) == null ? void 0 : _b[0]) == null ? void 0 : _c.message) == null ? void 0 : _d.content)) {
      throw new Error("Invalid response format from OpenAI API");
    }
    return response.json.choices[0].message.content;
  }
  getProviderType() {
    return "openai" /* OpenAI */;
  }
};

// src/adapters/AnthropicAdapter.ts
var import_obsidian3 = require("obsidian");
var AnthropicAdapter = class extends AIAdapter {
  constructor(settingsService, jsonValidationService) {
    super(settingsService, jsonValidationService);
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    const aiProviderSettings = this.settingsService.getSetting("aiProvider");
    this.apiKey = aiProviderSettings.apiKeys["anthropic" /* Anthropic */] || "";
    this.models = AIModelMap["anthropic" /* Anthropic */];
  }
  async generateResponse(prompt, modelApiName, options) {
    try {
      const apiModel = this.getApiModelName(modelApiName);
      if (!apiModel) {
        throw new Error(`Invalid model: ${modelApiName} for ${this.getProviderType()}`);
      }
      if (!this.apiKey) {
        throw new Error("Anthropic API key is not set");
      }
      const settings = this.settingsService.getSettings();
      const temperature = this.getTemperature(settings);
      const maxTokens = (options == null ? void 0 : options.maxTokens) || this.getMaxTokens(settings);
      const response = await this.makeApiRequest({ model: apiModel, prompt, temperature, maxTokens, rawResponse: options == null ? void 0 : options.rawResponse });
      const content = this.extractContentFromResponse(response);
      if (options == null ? void 0 : options.rawResponse) {
        return { success: true, data: content };
      }
      const validatedContent = await this.jsonValidationService.validateAndCleanJson(content);
      return { success: true, data: validatedContent };
    } catch (error) {
      return this.handleError(error);
    }
  }
  getTemperature(settings) {
    return settings.advanced.temperature >= 0 && settings.advanced.temperature <= 1 ? settings.advanced.temperature : 0.7;
  }
  getMaxTokens(settings) {
    return settings.advanced.maxTokens > 0 ? settings.advanced.maxTokens : 1e3;
  }
  async makeApiRequest(params) {
    return await (0, import_obsidian3.requestUrl)({
      url: "https://api.anthropic.com/v1/messages",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.apiKey,
        "anthropic-version": "2023-06-01"
      },
      body: JSON.stringify({
        model: params.model,
        messages: [{ role: "user", content: params.prompt }],
        max_tokens: params.maxTokens,
        temperature: params.temperature
      })
    });
  }
  extractContentFromResponse(response) {
    var _a, _b, _c;
    if (!((_c = (_b = (_a = response.json) == null ? void 0 : _a.content) == null ? void 0 : _b[0]) == null ? void 0 : _c.text)) {
      throw new Error("Invalid response format from Anthropic API");
    }
    return response.json.content[0].text;
  }
  handleError(error) {
    console.error("Error in Anthropic API call:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    new import_obsidian3.Notice(`Anthropic API Error: ${errorMessage}`);
    return { success: false, error: errorMessage };
  }
  getAvailableModels() {
    return this.models.map((model) => model.apiName);
  }
  getProviderType() {
    return "anthropic" /* Anthropic */;
  }
  setApiKey(apiKey) {
    this.apiKey = apiKey;
  }
  getApiKey() {
    return this.apiKey;
  }
  configure(config) {
  }
  isReady() {
    return !!this.apiKey;
  }
  getApiModelName(modelApiName) {
    const model = this.models.find((m) => m.apiName === modelApiName);
    if (!model) {
      throw new Error(`Model ${modelApiName} not found for ${this.getProviderType()}`);
    }
    return model.apiName;
  }
};

// src/adapters/GeminiAdapter.ts
var import_obsidian4 = require("obsidian");
var GeminiAdapter = class extends AIAdapter {
  constructor(settingsService, jsonValidationService) {
    super(settingsService, jsonValidationService);
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    const aiProviderSettings = this.settingsService.getSetting("aiProvider");
    this.apiKey = aiProviderSettings.apiKeys["google" /* Google */] || "";
    this.models = AIModelMap["google" /* Google */];
  }
  /**
   * Generate a response using the Gemini API
   */
  async generateResponse(prompt, modelApiName, options) {
    try {
      const apiModel = this.getApiModelName(modelApiName);
      if (!apiModel) {
        throw new Error(`No valid model found for ${this.getProviderType()}`);
      }
      if (!this.apiKey) {
        throw new Error("Google API key is not set");
      }
      const settings = this.settingsService.getSettings();
      const temperature = this.getTemperature(settings);
      const maxTokens = (options == null ? void 0 : options.maxTokens) || this.getMaxTokens(settings);
      const response = await this.makeApiRequest({
        model: apiModel,
        prompt,
        temperature,
        maxTokens,
        rawResponse: options == null ? void 0 : options.rawResponse
      });
      const content = this.extractContentFromResponse(response);
      if (options == null ? void 0 : options.rawResponse) {
        return { success: true, data: content };
      }
      try {
        const validatedContent = await this.jsonValidationService.validateAndCleanJson(content);
        return { success: true, data: validatedContent };
      } catch (jsonError) {
        return {
          success: true,
          data: { response: content }
        };
      }
    } catch (error) {
      return this.handleError(error);
    }
  }
  /**
   * Make a request to the Gemini API
   */
  async makeApiRequest(params) {
    const systemPrompt = params.rawResponse ? "You are a helpful assistant." : "You are a helpful assistant that responds in JSON format. Your response should be valid JSON with a 'response' field containing your answer.";
    const requestBody = {
      contents: [
        {
          parts: [
            { text: systemPrompt },
            { text: params.prompt }
          ]
        }
      ],
      generationConfig: {
        temperature: params.temperature,
        maxOutputTokens: params.maxTokens,
        topK: 40,
        topP: 0.95
      }
    };
    return await (0, import_obsidian4.requestUrl)({
      url: `https://generativelanguage.googleapis.com/v1/models/${params.model}:generateContent`,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-goog-api-key": this.apiKey
      },
      body: JSON.stringify(requestBody)
    });
  }
  /**
   * Extract content from Gemini API response
   */
  extractContentFromResponse(response) {
    var _a, _b, _c, _d, _e, _f;
    if (!((_f = (_e = (_d = (_c = (_b = (_a = response.json) == null ? void 0 : _a.candidates) == null ? void 0 : _b[0]) == null ? void 0 : _c.content) == null ? void 0 : _d.parts) == null ? void 0 : _e[0]) == null ? void 0 : _f.text)) {
      throw new Error("Invalid response format from Gemini API");
    }
    return response.json.candidates[0].content.parts[0].text;
  }
  /**
   * Get temperature setting
   */
  getTemperature(settings) {
    var _a, _b;
    return ((_a = settings.advanced) == null ? void 0 : _a.temperature) >= 0 && ((_b = settings.advanced) == null ? void 0 : _b.temperature) <= 1 ? settings.advanced.temperature : 0.7;
  }
  /**
   * Get max tokens setting
   */
  getMaxTokens(settings) {
    var _a;
    return ((_a = settings.advanced) == null ? void 0 : _a.maxTokens) > 0 ? settings.advanced.maxTokens : 1e3;
  }
  /**
   * Handle errors in API calls
   */
  handleError(error) {
    console.error("Error in Gemini API call:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    new import_obsidian4.Notice(`Gemini API Error: ${errorMessage}`);
    return { success: false, error: errorMessage };
  }
  /**
   * Get available models
   */
  getAvailableModels() {
    return this.models.map((model) => model.apiName);
  }
  /**
   * Get provider type
   */
  getProviderType() {
    return "google" /* Google */;
  }
  /**
   * Set API key
   */
  setApiKey(apiKey) {
    this.apiKey = apiKey;
  }
  /**
   * Get API key
   */
  getApiKey() {
    return this.apiKey;
  }
  /**
   * Configure the adapter
   */
  configure(config) {
    if (config == null ? void 0 : config.apiKey) {
      this.setApiKey(config.apiKey);
    }
  }
  /**
   * Check if adapter is ready
   */
  isReady() {
    return !!this.apiKey && this.models.length > 0;
  }
  /**
   * Get API model name
   */
  getApiModelName(modelApiName) {
    var _a;
    const model = this.models.find((m) => m.apiName === modelApiName);
    if (!model) {
      console.warn(`Model ${modelApiName} not found for ${this.getProviderType()}. Using first available model.`);
      return ((_a = this.models[0]) == null ? void 0 : _a.apiName) || modelApiName;
    }
    return model.apiName;
  }
};

// src/adapters/GroqAdapter.ts
var import_obsidian5 = require("obsidian");
var GroqAdapter = class extends AIAdapter {
  constructor(settingsService, jsonValidationService) {
    super(settingsService, jsonValidationService);
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    const aiProviderSettings = this.settingsService.getSetting("aiProvider");
    this.apiKey = aiProviderSettings.apiKeys["groq" /* Groq */] || "";
    this.models = AIModelMap["groq" /* Groq */];
  }
  /**
   * Generate a response using the Groq API
   */
  async generateResponse(prompt, modelApiName, options) {
    try {
      const apiModel = this.getApiModelName(modelApiName);
      if (!apiModel) {
        throw new Error(`No valid model found for ${this.getProviderType()}`);
      }
      if (!this.apiKey) {
        throw new Error("Groq API key is not set");
      }
      const settings = this.settingsService.getSettings();
      const temperature = this.getTemperature(settings);
      const maxTokens = (options == null ? void 0 : options.maxTokens) || this.getMaxTokens(settings);
      const response = await this.makeApiRequest({
        model: apiModel,
        prompt,
        temperature,
        maxTokens,
        rawResponse: options == null ? void 0 : options.rawResponse
      });
      const content = this.extractContentFromResponse(response);
      if (options == null ? void 0 : options.rawResponse) {
        return { success: true, data: content };
      }
      const validatedContent = await this.jsonValidationService.validateAndCleanJson(content);
      return { success: true, data: validatedContent };
    } catch (error) {
      return this.handleError(error);
    }
  }
  /**
   * Make a request to the Groq API
   */
  async makeApiRequest(params) {
    var _a;
    const response = await (0, import_obsidian5.requestUrl)({
      url: "https://api.groq.com/openai/v1/chat/completions",
      method: "POST",
      headers: {
        "Authorization": `Bearer ${this.apiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: params.model,
        messages: [
          {
            role: "system",
            content: params.rawResponse ? "You are a helpful assistant." : "You are a helpful assistant that responds in JSON format."
          },
          { role: "user", content: params.prompt }
        ],
        temperature: params.temperature,
        max_tokens: params.maxTokens,
        response_format: params.rawResponse ? void 0 : { type: "json_object" }
      })
    });
    if (response.status !== 200) {
      const errorBody = response.json;
      throw new Error(
        `API request failed with status ${response.status}: ${((_a = errorBody == null ? void 0 : errorBody.error) == null ? void 0 : _a.message) || "Unknown error"}`
      );
    }
    return response;
  }
  /**
   * Extract content from API response
   */
  extractContentFromResponse(response) {
    var _a, _b, _c, _d;
    if (!((_d = (_c = (_b = (_a = response.json) == null ? void 0 : _a.choices) == null ? void 0 : _b[0]) == null ? void 0 : _c.message) == null ? void 0 : _d.content)) {
      throw new Error("Invalid response format from Groq API");
    }
    return response.json.choices[0].message.content;
  }
  /**
   * Get temperature setting
   */
  getTemperature(settings) {
    var _a, _b;
    return ((_a = settings.advanced) == null ? void 0 : _a.temperature) >= 0 && ((_b = settings.advanced) == null ? void 0 : _b.temperature) <= 1 ? settings.advanced.temperature : 0.7;
  }
  /**
   * Get max tokens setting
   */
  getMaxTokens(settings) {
    var _a;
    return ((_a = settings.advanced) == null ? void 0 : _a.maxTokens) > 0 ? settings.advanced.maxTokens : 1e3;
  }
  /**
   * Handle errors in API calls
   */
  handleError(error) {
    console.error("Error in Groq API call:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    new import_obsidian5.Notice(`Groq API Error: ${errorMessage}`);
    return { success: false, error: errorMessage };
  }
  /**
   * Get available models
   */
  getAvailableModels() {
    return this.models.map((model) => model.apiName);
  }
  /**
   * Get provider type
   */
  getProviderType() {
    return "groq" /* Groq */;
  }
  /**
   * Set API key
   */
  setApiKey(apiKey) {
    this.apiKey = apiKey;
  }
  /**
   * Get API key
   */
  getApiKey() {
    return this.apiKey;
  }
  /**
   * Configure the adapter
   */
  configure(config) {
    if (config == null ? void 0 : config.apiKey) {
      this.setApiKey(config.apiKey);
    }
  }
  /**
   * Check if adapter is ready
   */
  isReady() {
    return !!this.apiKey && this.models.length > 0;
  }
  /**
   * Get API model name
   */
  getApiModelName(modelApiName) {
    var _a;
    const model = this.models.find((m) => m.apiName === modelApiName);
    if (!model) {
      console.warn(`Model ${modelApiName} not found for ${this.getProviderType()}. Using first available model.`);
      return ((_a = this.models[0]) == null ? void 0 : _a.apiName) || modelApiName;
    }
    return model.apiName;
  }
};

// src/adapters/OpenRouterAdapter.ts
var import_obsidian6 = require("obsidian");
var OpenRouterAdapter = class extends AIAdapter {
  constructor(settingsService, jsonValidationService) {
    super(settingsService, jsonValidationService);
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    const aiProviderSettings = this.settingsService.getSetting("aiProvider");
    this.apiKey = aiProviderSettings.apiKeys["openrouter" /* OpenRouter */] || "";
    this.models = AIModelMap["openrouter" /* OpenRouter */];
  }
  async makeApiRequest(params) {
    return await (0, import_obsidian6.requestUrl)({
      url: "https://openrouter.ai/api/v1/chat/completions",
      method: "POST",
      headers: {
        "Authorization": `Bearer ${this.apiKey}`,
        "Content-Type": "application/json",
        "HTTP-Referer": window.location.href,
        "X-Title": "Obsidian GraphWeaver Plugin"
      },
      body: JSON.stringify({
        model: params.model,
        messages: [
          {
            role: "system",
            content: params.rawResponse ? "You are a helpful assistant." : "You are a helpful assistant that responds in JSON format."
          },
          { role: "user", content: params.prompt }
        ],
        temperature: params.temperature,
        max_tokens: params.maxTokens,
        response_format: params.rawResponse ? void 0 : { type: "json_object" }
      })
    });
  }
  extractContentFromResponse(response) {
    var _a, _b, _c, _d;
    if (!((_d = (_c = (_b = (_a = response.json) == null ? void 0 : _a.choices) == null ? void 0 : _b[0]) == null ? void 0 : _c.message) == null ? void 0 : _d.content)) {
      throw new Error("Invalid response format from OpenRouter API");
    }
    return response.json.choices[0].message.content;
  }
  getProviderType() {
    return "openrouter" /* OpenRouter */;
  }
};

// src/adapters/LMStudioAdapter.ts
var import_obsidian7 = require("obsidian");
var LMStudioAdapter = class extends AIAdapter {
  constructor(settingsService, jsonValidationService) {
    super(settingsService, jsonValidationService);
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    this.updateSettings();
  }
  async makeApiRequest(params) {
    return await (0, import_obsidian7.requestUrl)({
      url: `http://localhost:${this.port}/v1/chat/completions`,
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: params.model,
        messages: [
          {
            role: "system",
            content: params.rawResponse ? "You are a helpful assistant." : "You are a helpful assistant that responds in JSON format."
          },
          { role: "user", content: params.prompt }
        ],
        temperature: params.temperature,
        max_tokens: params.maxTokens,
        response_format: params.rawResponse ? void 0 : { type: "json_schema" },
        stream: false
      })
    });
  }
  extractContentFromResponse(response) {
    var _a, _b, _c, _d;
    if (!((_d = (_c = (_b = (_a = response.json) == null ? void 0 : _a.choices) == null ? void 0 : _b[0]) == null ? void 0 : _c.message) == null ? void 0 : _d.content)) {
      throw new Error("Invalid response format from LM Studio API");
    }
    return response.json.choices[0].message.content;
  }
  async generateResponse(prompt, model = "default", options) {
    try {
      if (!this.isReady()) {
        throw new Error("LM Studio settings are not properly configured");
      }
      const response = await this.makeApiRequest({
        model: this.model,
        prompt,
        temperature: 0.7,
        maxTokens: (options == null ? void 0 : options.maxTokens) || 1e3,
        rawResponse: options == null ? void 0 : options.rawResponse
      });
      if (response.status !== 200) {
        throw new Error(`API request failed with status ${response.status}`);
      }
      const content = this.extractContentFromResponse(response);
      if (options == null ? void 0 : options.rawResponse) {
        return {
          success: true,
          data: content
        };
      }
      const validatedContent = await this.jsonValidationService.validateAndCleanJson(content);
      return {
        success: true,
        data: validatedContent
      };
    } catch (error) {
      console.error("Error in LM Studio API call:", error);
      new import_obsidian7.Notice(`LM Studio API Error: ${error instanceof Error ? error.message : "Unknown error occurred"}`);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error occurred"
      };
    }
  }
  createJsonSchema() {
    return {
      name: "assistant_response",
      strict: "true",
      schema: {
        type: "object",
        properties: {
          response: {
            type: "string"
          }
        },
        required: ["response"]
      }
    };
  }
  getAvailableModels() {
    return [this.model];
  }
  getProviderType() {
    return "lmstudio" /* LMStudio */;
  }
  setApiKey(apiKey) {
  }
  getApiKey() {
    return "";
  }
  configure(config) {
    if (config.model) {
      this.model = config.model;
    }
    if (config.port) {
      this.port = config.port.toString();
    }
    this.settingsService.updateNestedSetting("localLMStudio", "modelName", this.model);
    this.settingsService.updateNestedSetting("localLMStudio", "port", parseInt(this.port, 10));
  }
  isReady() {
    return !!this.model && !!this.port;
  }
  getApiModelName(modelName) {
    return modelName || "default";
  }
  updateSettings() {
    const localLMStudioSettings = this.settingsService.getSetting("localLMStudio");
    this.model = localLMStudioSettings.modelName;
    this.port = localLMStudioSettings.port.toString();
  }
};

// src/adapters/PerplexityAdapter.ts
var import_obsidian8 = require("obsidian");
var PerplexityAdapter = class extends AIAdapter {
  constructor(settingsService, jsonValidationService) {
    super(settingsService, jsonValidationService);
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    const aiProviderSettings = this.settingsService.getSetting("aiProvider");
    this.apiKey = aiProviderSettings.apiKeys["perplexity" /* Perplexity */] || "";
    this.models = AIModelMap["perplexity" /* Perplexity */];
  }
  async makeApiRequest(params) {
    try {
      const response = await (0, import_obsidian8.requestUrl)({
        url: "https://api.perplexity.ai/chat/completions",
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.apiKey}`,
          "Content-Type": "application/json",
          "Accept": "application/json"
        },
        body: JSON.stringify({
          model: params.model,
          messages: [
            {
              role: "system",
              content: "Be precise and concise."
            },
            {
              role: "user",
              content: params.prompt
            }
          ],
          temperature: params.temperature,
          max_tokens: params.maxTokens
        })
      });
      if (response.status !== 200) {
        console.error(`Perplexity API Error: Status ${response.status}`);
        console.error("Response Body:", response.text);
      }
      return response;
    } catch (error) {
      console.error("PerplexityAdapter makeApiRequest encountered an error:", error);
      throw error;
    }
  }
  extractContentFromResponse(response) {
    var _a, _b, _c, _d;
    if (!((_d = (_c = (_b = (_a = response.json) == null ? void 0 : _a.choices) == null ? void 0 : _b[0]) == null ? void 0 : _c.message) == null ? void 0 : _d.content)) {
      throw new Error("Invalid response format from Perplexity API");
    }
    return response.json.choices[0].message.content;
  }
  getProviderType() {
    return "perplexity" /* Perplexity */;
  }
};

// src/adapters/MistralAdapter.ts
var import_obsidian9 = require("obsidian");
var MistralAdapter = class extends AIAdapter {
  constructor() {
    super(...arguments);
    this.apiEndpoint = "https://api.mistral.ai/v1/chat/completions";
  }
  getProviderType() {
    return "mistral" /* Mistral */;
  }
  async makeApiRequest(params) {
    try {
      const payload = {
        model: params.model,
        messages: [
          {
            role: "user",
            content: params.prompt
          }
        ],
        temperature: params.temperature,
        max_tokens: params.maxTokens,
        top_p: 1,
        stream: false,
        response_format: params.rawResponse ? void 0 : { type: "json_object" }
      };
      const response = await (0, import_obsidian9.requestUrl)({
        url: this.apiEndpoint,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.apiKey}`
        },
        body: JSON.stringify(payload)
      });
      return response;
    } catch (error) {
      console.error(`MistralAdapter makeApiRequest error:`, error);
      throw error;
    }
  }
  extractContentFromResponse(response) {
    try {
      const data = response.json;
      return data.choices[0].message.content;
    } catch (error) {
      console.error(`MistralAdapter extractContentFromResponse error:`, error);
      throw new Error("Failed to parse response from Mistral API.");
    }
  }
};

// src/utils/ErrorHandler.ts
var ErrorHandler = class {
  static handleError(error, context) {
    console.error(`${context} error: ${error.message}`, error);
    throw error;
  }
};

// src/generators/BaseGenerator.ts
var BaseGenerator = class {
  constructor(aiAdapter, settingsService) {
    this.aiAdapter = aiAdapter;
    this.settingsService = settingsService;
  }
  /**
   * Generate content based on input and settings.
   * @param input The input data for generation
   * @returns Promise resolving to the generated content
   */
  async generate(input) {
    try {
      if (!this.validateInput(input)) {
        throw new Error("Invalid input provided");
      }
      const prompt = this.preparePrompt(input);
      const model = await this.getCurrentModel();
      const aiResponse = await this.aiAdapter.generateResponse(prompt, model);
      if (!aiResponse.success || !aiResponse.data) {
        throw new Error(aiResponse.error || "Failed to generate content");
      }
      return this.formatOutput(aiResponse.data, input);
    } catch (error) {
      return ErrorHandler.handleError(error, this.constructor.name);
    }
  }
  /**
   * Get the current model for this generator.
   * @returns The model identifier string
   */
  async getCurrentModel() {
    var _a, _b;
    const settings = this.getSettings();
    const providerType = this.aiAdapter.getProviderType();
    const modelApiName = (_b = (_a = settings.aiProvider) == null ? void 0 : _a.selectedModels) == null ? void 0 : _b[providerType];
    if (!modelApiName) {
      throw new Error(`No model selected for provider: ${providerType}`);
    }
    return modelApiName;
  }
  /**
   * Get the selected model from settings.
   * Can be overridden by subclasses to use specific model settings.
   */
  getSelectedModel(settings) {
    var _a, _b;
    const provider = this.aiAdapter.getProviderType();
    return (_b = (_a = settings.aiProvider) == null ? void 0 : _a.selectedModels) == null ? void 0 : _b[provider];
  }
  /**
   * Get the current settings for this generator.
   */
  getSettings() {
    return this.settingsService.getSettings();
  }
  /**
   * Validate the input before generation.
   * @param input The input to validate
   */
  validateInput(input) {
    return input !== null && typeof input === "object";
  }
  /**
   * Handle errors that occur during generation.
   * @param error The error that occurred
   */
  handleError(error) {
    console.error(`${this.constructor.name} error: ${error.message}`, error);
    throw error;
  }
  /**
   * Utility method to clean and format text content
   */
  cleanContent(content) {
    return content.trim().replace(/\n{3,}/g, "\n\n");
  }
  /**
   * Utility method to validate JSON data
   */
  isValidJson(data) {
    try {
      JSON.parse(JSON.stringify(data));
      return true;
    } catch (e) {
      return false;
    }
  }
};

// src/generators/FrontMatterGenerator.ts
var FrontMatterGenerator = class extends BaseGenerator {
  constructor(aiAdapter, settingsService, jsonSchemaGenerator) {
    super(aiAdapter, settingsService);
    this.jsonSchemaGenerator = jsonSchemaGenerator;
  }
  /**
   * Generates front matter for the provided content
   * @param input The input containing content and optional properties
   * @returns Promise resolving to content with front matter
   */
  async generate(input) {
    const settings = this.getSettings();
    const completeInput = {
      ...input,
      customProperties: input.customProperties || settings.frontMatter.customProperties,
      customTags: input.customTags || settings.tags.customTags.map((tag) => tag.name)
    };
    const prompt = this.preparePrompt(completeInput);
    const model = await this.getCurrentModel();
    const aiResponse = await this.aiAdapter.generateResponse(prompt, model);
    if (!aiResponse.success || !aiResponse.data) {
      return { content: input.content };
    }
    return this.formatOutput(aiResponse.data, completeInput);
  }
  /**
   * Prepares the AI prompt with schema and context
   * @param input The input containing content and properties
   * @returns Formatted prompt string
   */
  preparePrompt(input) {
    var _a, _b;
    const schema = this.jsonSchemaGenerator.generateBaseSchema();
    const propertyPrompt = ((_a = input.customProperties) == null ? void 0 : _a.map(
      (prop) => `${prop.name} (${prop.type}): ${prop.description}`
    ).join("\n")) || "";
    const tagPrompt = ((_b = input.customTags) == null ? void 0 : _b.join(", ")) || "";
    return `
    # MISSION
    Act as an expert analyzer and creator of metadata, with a specialization in ontological organization for Obsidian Vaults. Generate ONLY front matter fields based on the provided schema and available properties/tags.
    
    # GUIDELINES
    - You must ONLY use the properties provided in the schema
    - Prioritize using available tags, but remain flexible in choosing additional relevant tags
    - Return ONLY the formatted JSON object with front matter fields
    - OMIT the content field in your response
    
    ## Custom Properties
    ${propertyPrompt}
    
    ## Available Tags
    ${tagPrompt}
    
    ## Note Content for Reference (OMIT FROM OUTPUT)
    ${input.content}
    
    ## JSON Schema for Front Matter Fields:
    ${JSON.stringify(schema, null, 2)}
    
    Generate ONLY the front matter fields as JSON. Do not include any other text or the note content.
    `;
  }
  /**
   * Formats AI response into proper front matter structure
   * @param aiResponse The AI response data
   * @param originalInput The original input parameters
   * @returns Formatted output with front matter
   */
  formatOutput(aiResponse, originalInput) {
    const parsedResponse = this.parseAIResponse(aiResponse);
    if (!parsedResponse) {
      return { content: originalInput.content };
    }
    if ("content" in parsedResponse) {
      delete parsedResponse.content;
    }
    const frontMatter = this.convertToFrontMatter(parsedResponse);
    const finalContent = this.mergeFrontMatter(originalInput.content, frontMatter);
    return { content: finalContent };
  }
  /**
   * Parses and validates AI response
   */
  parseAIResponse(data) {
    if (typeof data === "object" && data !== null) {
      return data;
    }
    try {
      const parsed = JSON.parse(data);
      if (typeof parsed === "object" && parsed !== null) {
        return parsed;
      }
    } catch (error) {
      console.error("FrontMatterGenerator: Error parsing AI response as JSON:", error);
    }
    return null;
  }
  /**
   * Converts parsed response to YAML front matter format
   */
  convertToFrontMatter(data) {
    return Object.entries(data).map(([key, value]) => {
      if (Array.isArray(value)) {
        return `${key}:
${value.map((item) => `  - ${item}`).join("\n")}`;
      } else if (typeof value === "object" && value !== null) {
        return `${key}: ${JSON.stringify(value)}`;
      } else {
        return `${key}: ${value}`;
      }
    }).join("\n");
  }
  /**
   * Merges front matter with original content
   */
  mergeFrontMatter(content, frontMatter) {
    const hasFrontMatter = content.trim().startsWith("---");
    if (!hasFrontMatter) {
      return `---
${frontMatter}
---

${content.trim()}`;
    }
    const parts = content.split("---");
    if (parts.length >= 3) {
      const existingFrontMatter = parts[1].trim();
      const contentParts = parts.slice(2).join("---").trim();
      return `---
${frontMatter}
---
${contentParts}`;
    }
    return `---
${frontMatter}
---

${content.trim()}`;
  }
};

// src/generators/WikilinkGenerator.ts
var WikilinkGenerator = class extends BaseGenerator {
  constructor(aiAdapter, settingsService) {
    super(aiAdapter, settingsService);
    /**
     * Collection of regex patterns used throughout the generator
     */
    this.PATTERNS = {
      WIKILINK_REGEX: /\[\[([^\[\]]*(?:\[\[[^\[\]]*\]\][^\[\]]*)*)\]\]/g,
      SIMPLE_WIKILINK_REGEX: /\[\[([^\]]+)\]\]/g,
      MALFORMED_REGEX: /\[\[[^\]\[]*(?:\](?!\])|$)|(?:\[\[)+[^\]\[]*\]\]/g,
      CODE_BLOCK_REGEX: /`[^`]*`|```[\s\S]*?```/g,
      INLINE_CODE_REGEX: /`[^`]+`/g,
      SPECIAL_CHARS_REGEX: /[!@#$%^&*(),.?":{}|<>]/g
    };
    /**
     * Configuration constants for wikilink processing
     */
    this.CONFIG = {
      MAX_LINK_LENGTH: 100,
      MAX_NESTING_DEPTH: 5,
      CONTEXT_WINDOW_SIZE: 100,
      ALLOWED_SPECIAL_CHARS: ["'", "-", "_", "&", "."]
    };
  }
  /**
   * Generate wikilinks for the provided content
   * @param input WikilinkInput containing content and context
   * @returns Promise<WikilinkOutput> with processed content
   */
  async generate(input) {
    if (!this.validateInput(input)) {
      throw new Error("Invalid input for wikilink generation");
    }
    const prompt = this.preparePrompt(input);
    const model = await this.getCurrentModel();
    const aiResponse = await this.aiAdapter.generateResponse(prompt, model);
    return this.formatOutput(aiResponse.data, input);
  }
  /**
   * Prepares the AI prompt for generating wikilink suggestions
   */
  preparePrompt(input) {
    const settings = this.getSettings();
    const customTags = settings.tags.customTags.map((tag) => tag.name).join(", ") || "";
    return `
# MISSION
Act as an expert in recommending wikilinks for potential future research notes related to the current CONTENT for an Obsidian Vault.

# INSTRUCTIONS
1. Analyze the CONTENT of the note and the EXISTING NOTES in the vault.
2. Suggest key phrases, proper nouns, people, places, events, and concepts that would make for a relevant and practical note.
3. Consider the existing pages in the vault and prioritize linking to them. 
4. Ignore all tags and front matter when generating.

# CONTENT
${input.content}

# EXISTING NOTES
${input.existingPages.join(", ")}

Provide your suggestions as a JSON array of strings, omitting all characters before or after, including backticks.
        `;
  }
  /**
   * Format the AI response into wikilink output
   */
  formatOutput(aiResponse, originalInput) {
    const suggestedLinks = this.parseSuggestedLinks(aiResponse);
    let processedContent = originalInput.content;
    processedContent = this.addNewWikilinks(processedContent, suggestedLinks);
    processedContent = this.cleanNestedWikilinks(processedContent);
    return { content: processedContent };
  }
  /**
   * Adds new wikilinks while preserving existing ones and handling edge cases
   */
  addNewWikilinks(content, suggestedLinks) {
    const codeBlocks = /* @__PURE__ */ new Map();
    let processedContent = this.protectCodeBlocks(content, codeBlocks);
    const existingWikilinks = this.extractExistingWikilinks(processedContent);
    const existingWikilinksWithBrackets = new Set(
      Array.from(processedContent.matchAll(this.PATTERNS.SIMPLE_WIKILINK_REGEX)).map((match) => match[0])
    );
    suggestedLinks.filter((link) => this.isValidWikilinkText(link)).sort((a, b) => b.length - a.length).forEach((phrase) => {
      if (!existingWikilinks.includes(phrase.toLowerCase())) {
        const regex = new RegExp(`\\b${this.escapeRegExp(phrase)}\\b`, "gi");
        processedContent = processedContent.replace(regex, (match, offset) => {
          if (this.isWithinExistingWikilink(processedContent, offset, match.length, existingWikilinksWithBrackets) || this.isWithinProtectedContext(processedContent, offset)) {
            return match;
          }
          return `[[${this.normalizeWikilinkText(match)}]]`;
        });
      }
    });
    return this.restoreCodeBlocks(processedContent, codeBlocks);
  }
  /**
   * Cleans up nested wikilinks while preserving valid structure
   */
  cleanNestedWikilinks(content) {
    const processedWikilinks = /* @__PURE__ */ new Set();
    let result = content;
    const matches = Array.from(content.matchAll(this.PATTERNS.WIKILINK_REGEX)).map((match) => ({
      full: match[0],
      inner: match[1],
      index: match.index,
      length: match[0].length,
      depth: this.calculateNestingDepth(match[0])
    })).filter((match) => match.depth <= this.CONFIG.MAX_NESTING_DEPTH).sort((a, b) => b.length - a.length);
    const processedPositions = /* @__PURE__ */ new Set();
    for (const match of matches) {
      if (processedPositions.has(match.index))
        continue;
      if (match.inner.includes("[[")) {
        const cleanedText = this.removeNestedDuplicates(match.inner);
        if (this.isValidWikilinkText(cleanedText) && !processedWikilinks.has(cleanedText.toLowerCase())) {
          processedWikilinks.add(cleanedText.toLowerCase());
          result = this.safeReplace(
            result,
            match.index,
            match.length,
            `[[${this.normalizeWikilinkText(cleanedText)}]]`
          );
          processedPositions.add(match.index);
        }
      } else {
        processedWikilinks.add(match.inner.toLowerCase());
      }
    }
    console.log("WikilinkGenerator: Nested wikilinks cleaned");
    return result;
  }
  /**
   * Extracts existing wikilinks from content
   */
  extractExistingWikilinks(content) {
    const matches = content.match(this.PATTERNS.SIMPLE_WIKILINK_REGEX) || [];
    return matches.map((match) => match.slice(2, -2).toLowerCase());
  }
  /**
   * Removes nested duplicates while preserving outer structure
   */
  removeNestedDuplicates(text) {
    return text.replace(/\[\[([^\[\]]+)\]\]/g, "$1");
  }
  /**
   * Validates if text is suitable for a wikilink
   */
  isValidWikilinkText(text) {
    if (!text || typeof text !== "string")
      return false;
    const trimmed = text.trim();
    if (trimmed.length === 0 || trimmed.length > this.CONFIG.MAX_LINK_LENGTH)
      return false;
    const bracketCount = (trimmed.match(/[\[\]]/g) || []).length;
    if (bracketCount % 2 !== 0)
      return false;
    return !trimmed.match(this.PATTERNS.MALFORMED_REGEX);
  }
  /**
   * Normalizes text for wikilink usage with title case capitalization
   * @param text - The text to be normalized
   * @returns Normalized text with title case capitalization
   */
  normalizeWikilinkText(text) {
    const trimmed = text.trim();
    let normalized = trimmed.replace(/\s+/g, " ");
    normalized = normalized.replace(
      this.PATTERNS.SPECIAL_CHARS_REGEX,
      (char) => this.CONFIG.ALLOWED_SPECIAL_CHARS.includes(char) ? char : ""
    );
    return this.toTitleCase(normalized);
  }
  /**
   * Converts a string to title case, capitalizing the first letter of each significant word
   */
  toTitleCase(text) {
    const minorWords = /* @__PURE__ */ new Set([
      "a",
      "an",
      "the",
      "and",
      "but",
      "or",
      "for",
      "nor",
      "as",
      "at",
      "by",
      "for",
      "from",
      "in",
      "into",
      "near",
      "of",
      "on",
      "onto",
      "to",
      "with"
    ]);
    return text.split(" ").map((word, index) => {
      if (index === 0 || word.length > 3 || !minorWords.has(word.toLowerCase())) {
        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
      }
      return word.toLowerCase();
    }).join(" ");
  }
  /**
   * Checks if a position is within an existing wikilink
   */
  isWithinExistingWikilink(content, offset, length, existingWikilinks) {
    const contextStart = Math.max(0, offset - this.CONFIG.CONTEXT_WINDOW_SIZE);
    const contextEnd = Math.min(
      content.length,
      offset + length + this.CONFIG.CONTEXT_WINDOW_SIZE
    );
    const context = content.slice(contextStart, contextEnd);
    return Array.from(existingWikilinks).some((wikilink) => {
      const wikiLinkIndex = context.indexOf(wikilink);
      if (wikiLinkIndex === -1)
        return false;
      const absoluteWikiLinkStart = contextStart + wikiLinkIndex;
      const absoluteWikiLinkEnd = absoluteWikiLinkStart + wikilink.length;
      return offset >= absoluteWikiLinkStart && offset + length <= absoluteWikiLinkEnd;
    });
  }
  /**
   * Protects code blocks from processing
   */
  protectCodeBlocks(content, codeBlocks) {
    let processedContent = content;
    let counter = 0;
    processedContent = processedContent.replace(
      this.PATTERNS.CODE_BLOCK_REGEX,
      (match) => {
        const placeholder = `__CODE_BLOCK_${counter}__`;
        codeBlocks.set(placeholder, match);
        counter++;
        return placeholder;
      }
    );
    processedContent = processedContent.replace(
      this.PATTERNS.INLINE_CODE_REGEX,
      (match) => {
        const placeholder = `__INLINE_CODE_${counter}__`;
        codeBlocks.set(placeholder, match);
        counter++;
        return placeholder;
      }
    );
    return processedContent;
  }
  /**
   * Restores protected code blocks
   */
  restoreCodeBlocks(content, codeBlocks) {
    let processedContent = content;
    for (const [placeholder, original] of codeBlocks.entries()) {
      processedContent = processedContent.replace(placeholder, original);
    }
    return processedContent;
  }
  /**
   * Checks if a position is within a protected context
   */
  isWithinProtectedContext(content, offset) {
    const codeMatches = Array.from(content.matchAll(this.PATTERNS.CODE_BLOCK_REGEX));
    for (const match of codeMatches) {
      if (match.index !== void 0 && offset >= match.index && offset < match.index + match[0].length) {
        return true;
      }
    }
    const inlineMatches = Array.from(content.matchAll(this.PATTERNS.INLINE_CODE_REGEX));
    for (const match of inlineMatches) {
      if (match.index !== void 0 && offset >= match.index && offset < match.index + match[0].length) {
        return true;
      }
    }
    return false;
  }
  /**
   * Calculates the nesting depth of a wikilink
   */
  calculateNestingDepth(text) {
    let maxDepth = 0;
    let currentDepth = 0;
    for (let i = 0; i < text.length - 1; i++) {
      if (text[i] === "[" && text[i + 1] === "[") {
        currentDepth++;
        maxDepth = Math.max(maxDepth, currentDepth);
        i++;
      } else if (text[i] === "]" && text[i + 1] === "]") {
        currentDepth--;
        i++;
      }
    }
    return maxDepth;
  }
  /**
   * Safely replaces text at a specific position
   */
  safeReplace(text, start, length, replacement) {
    return text.slice(0, start) + replacement + text.slice(start + length);
  }
  /**
   * Parses suggested links from AI response
   */
  parseSuggestedLinks(aiResponse) {
    if (typeof aiResponse === "string") {
      try {
        aiResponse = JSON.parse(aiResponse);
      } catch (error) {
        console.error("WikilinkGenerator: Failed to parse AI response as JSON:", error);
        return [];
      }
    }
    if (Array.isArray(aiResponse)) {
      return aiResponse.filter((item) => typeof item === "string");
    }
    if (typeof aiResponse === "object" && aiResponse !== null) {
      const arrayValues = Object.values(aiResponse).find(Array.isArray);
      if (arrayValues) {
        return arrayValues.filter((item) => typeof item === "string");
      }
    }
    console.error("WikilinkGenerator: Unexpected AI response format:", aiResponse);
    return [];
  }
  /**
   * Escapes special regex characters in a string
   */
  escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
};

// src/generators/OntologyGenerator.ts
var OntologyGenerator = class extends BaseGenerator {
  constructor(aiAdapter, settingsService) {
    super(aiAdapter, settingsService);
  }
  /**
   * Main method to generate ontology.
   * @param input - Input parameters for ontology generation.
   * @returns Promise resolving to the generated ontology.
   */
  async generate(input) {
    if (!this.validateInput(input)) {
      throw new Error("Invalid input for ontology generation");
    }
    const prompt = this.preparePrompt(input);
    const aiResponse = await this.aiAdapter.generateResponse(prompt, input.modelApiName);
    return this.formatOutput(aiResponse.data);
  }
  /**
   * Prepares the AI prompt based on the input.
   * @param input - Input parameters for ontology generation.
   * @returns Formatted prompt string.
   */
  preparePrompt(input) {
    const fileNames = input.files.map((file) => file.basename).join(", ");
    const folderNames = input.folders.map((folder) => folder.name).join(", ");
    const tags = input.tags.join(", ");
    return `
# MISSION
Act as an expert in Ontological Science, specializing in taking unstructured information from an Obsidian vault, and creating tags to create a means of connecting the information.
Analyze the following information about a knowledge base and synthesize an ontology.
Based on the overall structure and content, suggest a set of tags that would create a cohesive and useful ontology for this knowledge base.

**File Names:**
${fileNames}

**Folder Names:** 
${folderNames}

**Existing Tags:** 
${tags}

${input.userContext ? `**Additional Context:** ${input.userContext}` : ""}

For each suggested tag in the ontology, provide:
{
    "Name": {
        "description": "a brief but robust instruction on what this tag represents, and when it should be applied",
    }
}

Consider the following when creating the ontology:
1. Identify overarching themes and concepts present in the knowledge base.
2. Suggest tags that would help categorize and connect information across different files and folders.
3. Build upon existing tags, either by refining them or suggesting complementary tags.
4. Aim for a balance between specificity and generality in the suggested tags.
5. Consider the hierarchical structure implied by the folder organization.
6. Omit all spaces from tags names (e.g. AlbertEinstein instead of Albert Einstein)

Provide your response as a JSON object where the keys are the tag names and the values are objects containing the description.
Suggest enough tags to form a comprehensive ontology for this knowledge base.
        `;
  }
  /**
   * Formats the AI response into the OntologyResult structure.
   * @param aiResponse - Raw AI response data.
   * @returns OntologyResult containing suggested tags.
   */
  formatOutput(aiResponse) {
    let parsedResponse;
    if (typeof aiResponse === "string") {
      try {
        const fixedJson = this.fixIncompleteJson(aiResponse);
        parsedResponse = JSON.parse(fixedJson);
      } catch (error) {
        console.error("Failed to parse AI response as JSON:", error);
        throw new Error("Invalid AI response: unable to parse as JSON");
      }
    } else if (typeof aiResponse === "object" && aiResponse !== null) {
      parsedResponse = aiResponse;
    } else {
      console.error("Unexpected AI response format:", aiResponse);
      throw new Error("Invalid AI response format: expected an object or valid JSON string");
    }
    if (typeof parsedResponse !== "object" || parsedResponse === null) {
      throw new Error("Invalid AI response format: expected an object after parsing");
    }
    const suggestedTags = Object.entries(parsedResponse).map(([name, value]) => {
      if (typeof value === "object" && value !== null && "description" in value) {
        return {
          name: String(name).trim(),
          description: String(value.description).trim(),
          type: value.type || "string"
          // Default to 'string' if type not provided
        };
      } else {
        console.warn(`Unexpected format for tag ${name}:`, value);
        return null;
      }
    }).filter(
      (tag) => tag !== null && typeof tag.name === "string" && tag.name.length > 0 && typeof tag.description === "string" && tag.description.length > 0 && typeof tag.type === "string"
    );
    if (suggestedTags.length === 0) {
      throw new Error("No valid tags found in AI response");
    }
    return { suggestedTags };
  }
  /**
   * Attempts to fix incomplete JSON strings.
   * @param json - Raw JSON string.
   * @returns Fixed JSON string.
   */
  fixIncompleteJson(json) {
    let fixedJson = json.trim();
    if (!fixedJson.endsWith("}")) {
      fixedJson += "}}";
    }
    fixedJson = fixedJson.replace(/,\s*}$/, "}");
    return fixedJson;
  }
};

// src/generators/BatchProcessor.ts
var import_obsidian10 = require("obsidian");

// src/models/ProcessingTypes.ts
var DEFAULT_PROCESSING_OPTIONS = {
  chunkSize: 10,
  delayBetweenChunks: 1e3,
  maxRetries: 3,
  generateFrontMatter: true,
  generateWikilinks: false,
  maxConcurrentProcessing: 3
};

// src/generators/BatchProcessor.ts
var BatchProcessor = class extends BaseGenerator {
  constructor(aiAdapter, settingsService, frontMatterGenerator, wikilinkGenerator, databaseService, app) {
    super(aiAdapter, settingsService);
    this.frontMatterGenerator = frontMatterGenerator;
    this.wikilinkGenerator = wikilinkGenerator;
    this.databaseService = databaseService;
    this.app = app;
    this.NOTIFICATION_INTERVAL = 2e3;
    this.lastNotificationTime = 0;
    this.processStartTime = 0;
    this.processingTimeout = null;
    this.eventEmitter = new import_obsidian10.Events();
    this.options = DEFAULT_PROCESSING_OPTIONS;
    this.currentStatus = this.getDefaultStatus();
  }
  /**
   * Main generation method
   */
  async generate(input) {
    if (!this.validateInput(input)) {
      throw new Error("Invalid input for batch processing");
    }
    this.processStartTime = Date.now();
    this.options = { ...this.options, ...input.options };
    try {
      await this.startProcessing(input.files);
      const results = await this.processFiles(input);
      const stats = await this.finalizeProcessing(results);
      return {
        fileResults: results,
        stats
      };
    } catch (error) {
      await this.handleError(error);
      throw error;
    } finally {
      await this.cleanup();
    }
  }
  /**
   * Start processing and initialize status
   */
  async startProcessing(files) {
    this.currentStatus = {
      state: "running",
      filesQueued: files.length,
      filesProcessed: 0,
      filesRemaining: files.length,
      startTime: this.processStartTime,
      errors: []
    };
    this.emitEvent("start", { status: this.currentStatus });
  }
  /**
   * Process all files in chunks
   */
  async processFiles(input) {
    const chunks = this.createChunks(input.files);
    const results = [];
    for (const chunk of chunks) {
      if (this.currentStatus.state === "paused") {
        await this.waitForResume();
      }
      this.emitEvent("chunkStart", chunk);
      const chunkResults = await this.processChunk(chunk, input);
      results.push(...chunkResults);
      this.emitEvent("chunkComplete", chunk);
      if (chunks.indexOf(chunk) < chunks.length - 1) {
        await this.delay(this.options.delayBetweenChunks);
      }
    }
    return results;
  }
  /**
   * Process a single chunk of files
   */
  async processChunk(chunk, input) {
    const files = chunk.files.map((path) => this.app.vault.getAbstractFileByPath(path)).filter((file) => file instanceof import_obsidian10.TFile);
    const results = await Promise.all(
      files.map((file) => this.processFile(file, input))
    );
    this.updateProgress(results.filter((r) => r.success).length);
    return results;
  }
  /**
   * Process a single file
   */
  async processFile(file, input) {
    const startTime = Date.now();
    this.emitEvent("fileStart", { file: file.path });
    try {
      let content = await this.app.vault.read(file);
      const processed = await this.generateContent(content, input);
      await this.app.vault.modify(file, processed.content);
      const result = {
        path: file.path,
        success: true,
        processingTime: Date.now() - startTime,
        ...processed.flags
      };
      this.emitEvent("fileComplete", { result });
      return result;
    } catch (error) {
      const errorResult = this.createErrorResult(file, error);
      this.handleProcessingError(errorResult.error);
      return errorResult.result;
    }
  }
  /**
   * Generate content for a file
   */
  async generateContent(content, input) {
    let frontMatterGenerated = false;
    let wikilinksGenerated = false;
    let processedContent = content;
    if (input.generateFrontMatter) {
      const result = await this.frontMatterGenerator.generate({ content: processedContent });
      frontMatterGenerated = result.content !== processedContent;
      processedContent = result.content;
    }
    if (input.generateWikilinks) {
      const pages = this.app.vault.getMarkdownFiles().map((file) => file.basename);
      const result = await this.wikilinkGenerator.generate({
        content: processedContent,
        existingPages: pages
      });
      wikilinksGenerated = result.content !== processedContent;
      processedContent = result.content;
    }
    return {
      content: processedContent,
      flags: { frontMatterGenerated, wikilinksGenerated }
    };
  }
  /**
   * Finalize processing and calculate stats
   */
  async finalizeProcessing(results) {
    const endTime = Date.now();
    const successfulFiles = results.filter((r) => r.success);
    const stats = {
      totalFiles: results.length,
      processedFiles: successfulFiles.length,
      errorFiles: results.length - successfulFiles.length,
      skippedFiles: 0,
      startTime: this.processStartTime,
      endTime,
      averageProcessingTime: this.calculateAverageTime(successfulFiles)
    };
    await this.databaseService.addProcessingStats(stats);
    this.emitEvent("complete", stats);
    return stats;
  }
  /**
   * Update processing progress
   */
  updateProgress(processedCount) {
    this.currentStatus.filesProcessed += processedCount;
    this.currentStatus.filesRemaining -= processedCount;
    const elapsed = Date.now() - (this.currentStatus.startTime || 0);
    const filesPerMs = this.currentStatus.filesProcessed / elapsed;
    this.currentStatus.estimatedTimeRemaining = this.currentStatus.filesRemaining / filesPerMs;
    this.emitEvent("progress", this.currentStatus);
    this.maybeShowNotification();
  }
  maybeShowNotification() {
    const now = Date.now();
    if (now - this.lastNotificationTime > this.NOTIFICATION_INTERVAL) {
      const { filesProcessed, filesQueued } = this.currentStatus;
      new import_obsidian10.Notice(
        `Processing files: ${filesProcessed}/${filesQueued} (${Math.round(filesProcessed / filesQueued * 100)}%)`
      );
      this.lastNotificationTime = now;
    }
  }
  // Helper methods
  getDefaultStatus() {
    return {
      state: "idle",
      filesQueued: 0,
      filesProcessed: 0,
      filesRemaining: 0,
      errors: []
    };
  }
  createChunks(files) {
    const chunks = [];
    for (let i = 0; i < files.length; i += this.options.chunkSize) {
      chunks.push({
        files: files.slice(i, i + this.options.chunkSize).map((f) => f.path),
        index: Math.floor(i / this.options.chunkSize),
        size: Math.min(this.options.chunkSize, files.length - i)
      });
    }
    return chunks;
  }
  createErrorResult(file, error) {
    const errorInfo = {
      filePath: file.path,
      error: error.message,
      timestamp: Date.now(),
      retryCount: 0
    };
    const result = {
      path: file.path,
      success: false,
      error: error.message,
      processingTime: 0,
      frontMatterGenerated: false,
      wikilinksGenerated: false
    };
    return { error: errorInfo, result };
  }
  calculateAverageTime(results) {
    if (results.length === 0)
      return 0;
    const totalTime = results.reduce((sum, r) => sum + r.processingTime, 0);
    return totalTime / results.length;
  }
  handleProcessingError(error) {
    this.currentStatus.errors.push(error);
    this.emitEvent("error", error);
  }
  async waitForResume() {
    return new Promise((resolve) => {
      const check = () => {
        if (this.currentStatus.state === "running") {
          resolve();
        } else {
          this.processingTimeout = window.setTimeout(check, 100);
        }
      };
      check();
    });
  }
  async delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  async cleanup() {
    if (this.processingTimeout !== null) {
      clearTimeout(this.processingTimeout);
    }
    this.currentStatus.state = "idle";
  }
  // Public methods for external control
  on(event, callback) {
    this.eventEmitter.on(event, callback);
  }
  pause() {
    if (this.currentStatus.state === "running") {
      this.currentStatus.state = "paused";
      this.emitEvent("pause", null);
    }
  }
  resume() {
    if (this.currentStatus.state === "paused") {
      this.currentStatus.state = "running";
      this.emitEvent("resume", null);
    }
  }
  emitEvent(type, data) {
    this.eventEmitter.trigger(type, data);
  }
  validateInput(input) {
    return Array.isArray(input.files) && input.files.length > 0 && typeof input.generateFrontMatter === "boolean" && (typeof input.generateWikilinks === "boolean" || input.generateWikilinks === void 0);
  }
  // Required BaseGenerator methods
  preparePrompt(_input) {
    return "";
  }
  formatOutput(_aiResponse, _originalInput) {
    return {
      fileResults: [],
      stats: {
        totalFiles: 0,
        processedFiles: 0,
        skippedFiles: 0,
        errorFiles: 0,
        startTime: 0,
        averageProcessingTime: 0
      }
    };
  }
};

// src/generators/JsonSchemaGenerator.ts
var JsonSchemaGenerator = class {
  constructor(settingsService) {
    this.settingsService = settingsService;
  }
  generateSchemaForTopic(topic) {
    const baseSchema = this.generateBaseSchema();
    return baseSchema;
  }
  generateBaseSchema() {
    const settings = this.settingsService.getSettings();
    const schema = {
      type: "object",
      properties: {},
      required: []
    };
    settings.frontMatter.customProperties.forEach((property) => {
      schema.properties[property.name] = {
        type: this.getJsonSchemaType(property.type),
        description: `Create ${property.description}`
      };
    });
    schema.properties.tags = {
      type: "array",
      items: {
        type: "string",
        enum: settings.tags.customTags.map((tag) => tag.name)
      },
      description: "Select appropriate tags from the provided list"
    };
    schema.additionalProperties = false;
    return schema;
  }
  getJsonSchemaType(propertyType) {
    switch (propertyType) {
      case "number":
        return "number";
      case "boolean":
        return "boolean";
      case "array":
        return "array";
      default:
        return "string";
    }
  }
};

// src/generators/KnowledgeBloomGenerator.ts
var import_obsidian11 = require("obsidian");
var KnowledgeBloomGenerator = class extends BaseGenerator {
  constructor(aiAdapter, settingsService, app, frontMatterGenerator) {
    super(aiAdapter, settingsService);
    this.app = app;
    this.currentInput = null;
    this.frontMatterGenerator = frontMatterGenerator;
  }
  /**
   * Generate new notes from wikilinks in the source document
   * @param input The input parameters for generation
   * @returns Promise resolving to generated notes
   */
  async generate(input) {
    if (!this.validateInput(input)) {
      throw new Error("Invalid input for Knowledge Bloom generation");
    }
    const wikilinks = await this.extractWikilinks(input.sourceFile);
    if (wikilinks.length === 0) {
      throw new Error("No wikilinks found in the source file.");
    }
    const folderPath = this.getFolderPath(input.sourceFile);
    const output = { generatedNotes: [] };
    const generationPromises = wikilinks.map(
      (link) => this.processWikilink(link, folderPath, input, output)
    );
    await Promise.allSettled(generationPromises);
    return output;
  }
  /**
   * Capitalize each word in a title
   */
  capitalizeTitle(title) {
    return title.split(/[\s-]/).map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
  }
  /**
   * Process a single wikilink to generate a new note
   */
  async processWikilink(link, folderPath, input, output) {
    try {
      const capitalizedLink = this.capitalizeTitle(link);
      if (this.doesNoteExist(capitalizedLink, folderPath)) {
        console.log(`KnowledgeBloomGenerator: Note for "${capitalizedLink}" already exists. Skipping.`);
        return;
      }
      const markdownContent = await this.generateMarkdownContent(capitalizedLink, input);
      const finalContent = await this.addFrontMatter(markdownContent);
      const newFilePath = `${folderPath}/${capitalizedLink}.md`;
      await this.app.vault.create(newFilePath, finalContent);
      output.generatedNotes.push({ title: capitalizedLink, content: finalContent });
    } catch (error) {
      console.error(`Error processing wikilink "${link}":`, error);
      new import_obsidian11.Notice(`Failed to generate note for "${link}": ${error.message}`);
    }
  }
  /**
   * Generate markdown content for a single wikilink
   */
  async generateMarkdownContent(link, input) {
    const prompt = this.preparePrompt({
      ...input,
      currentWikilink: link,
      currentNoteTitle: input.sourceFile.basename
    });
    const model = await this.getCurrentModel();
    const options = { rawResponse: true };
    const response = await this.aiAdapter.generateResponse(prompt, model, options);
    if (!response.success || !response.data) {
      throw new Error(`Failed to generate content for "${link}": ${response.error || "Unknown error"}`);
    }
    let content = response.data;
    if (typeof content === "object" && content !== null) {
      const contentObj = content;
      if ("content" in contentObj && typeof contentObj.content === "string") {
        content = contentObj.content;
      } else if ("response" in contentObj && typeof contentObj.response === "string") {
        content = contentObj.response;
      } else {
        content = JSON.stringify(content);
      }
    }
    const contentString = String(content).trim();
    return contentString.replace(/^---\n[\s\S]*?\n---\n*/g, "");
  }
  /**
   * Add front matter to the generated content
   */
  async addFrontMatter(content) {
    const frontMatterInput = {
      content,
      customProperties: this.extractCustomProperties(content),
      customTags: this.extractCustomTags(content)
    };
    const frontMatterResult = await this.frontMatterGenerator.generate(frontMatterInput);
    return frontMatterResult.content;
  }
  /**
   * Extract unique wikilinks from a file
   */
  async extractWikilinks(file) {
    const content = await this.app.vault.read(file);
    const wikilinks = content.match(/\[\[([^\]]+)\]\]/g) || [];
    const links = wikilinks.map((link) => link.slice(2, -2));
    return Array.from(new Set(links.map((link) => link.toLowerCase())));
  }
  /**
   * Extract custom properties from content
   */
  extractCustomProperties(content) {
    try {
      return this.settingsService.getSettings().frontMatter.customProperties;
    } catch (error) {
      console.error("Error extracting custom properties:", error);
      return [];
    }
  }
  /**
   * Extract custom tags from content
   */
  extractCustomTags(content) {
    try {
      return this.settingsService.getSettings().tags.customTags.map((tag) => tag.name);
    } catch (error) {
      console.error("Error extracting custom tags:", error);
      return [];
    }
  }
  /**
   * Prepare the AI prompt for content generation
   */
  preparePrompt(input) {
    if (!input.currentWikilink || !input.currentNoteTitle) {
      throw new Error("Missing required wikilink or note title");
    }
    const basePrompt = input.template || `
# MISSION
Act as an expert Research Assistant that specializes in writing structured notes that are accessible and practical based on a provided topic.

# GUIDELINES
- Write the note in Markdown format.
- OMIT any JSON objects or front matter.
- Ensure the content is well-structured and comprehensive.
- OMIT any words before or after the Markdown content.
`;
    const relationContext = `
# CONTEXT
You are creating a new note about [[${input.currentWikilink}]] which was referenced in the note [[${input.currentNoteTitle}]].
Your task is to generate content that not only explains ${input.currentWikilink} but also considers its relationship to ${input.currentNoteTitle}.
`;
    const finalPrompt = `${relationContext}
${basePrompt}
${input.userPrompt ? `
## Additional Context:
${input.userPrompt}` : ""}`;
    return finalPrompt.trim();
  }
  /**
   * Check if a note exists at the given path
   */
  doesNoteExist(title, folderPath) {
    const filePath = `${folderPath}/${title}.md`;
    const file = this.app.vault.getAbstractFileByPath(filePath);
    return file instanceof import_obsidian11.TFile;
  }
  /**
   * Get the folder path for the new note
   */
  getFolderPath(file) {
    const pathSegments = file.path.split("/");
    pathSegments.pop();
    return pathSegments.join("/");
  }
  formatOutput(output) {
    return output;
  }
};

// src/services/BaseService.ts
var import_events = require("events");
var import_obsidian12 = require("obsidian");
var BaseService = class {
  constructor() {
    this.emitter = new import_events.EventEmitter();
  }
  handleError(message, error) {
    console.error(message, error);
    new import_obsidian12.Notice(`${message} ${error instanceof Error ? error.message : "Unknown error"}`);
  }
  async saveData(callback, data) {
    try {
      if (callback && data !== void 0) {
        await callback(data);
      }
    } catch (error) {
      this.handleError("Error saving data:", error);
      throw error;
    }
  }
  deepMerge(target, source) {
    if (!source) {
      return target;
    }
    const output = { ...target };
    Object.keys(source).forEach((key) => {
      const targetValue = output[key];
      const sourceValue = source[key];
      if (Array.isArray(targetValue) && Array.isArray(sourceValue)) {
        output[key] = sourceValue;
      } else if (this.isObject(targetValue) && this.isObject(sourceValue)) {
        output[key] = this.deepMerge(
          targetValue,
          sourceValue
        );
      } else if (sourceValue !== void 0) {
        output[key] = sourceValue;
      }
    });
    return output;
  }
  isObject(item) {
    return Boolean(
      item && typeof item === "object" && !Array.isArray(item) && !(item instanceof Date) && !(item instanceof RegExp)
    );
  }
  on(event, listener) {
    this.emitter.on(event, listener);
  }
  emit(event, ...args) {
    this.emitter.emit(event, ...args);
  }
  async executeWithHandling(operation) {
    try {
      return await operation();
    } catch (error) {
      return ErrorHandler.handleError(error, this.constructor.name);
    }
  }
};

// src/services/AIService.ts
var AIService = class extends BaseService {
  constructor(app, settingsService, jsonValidationService, databaseService) {
    super();
    this.app = app;
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    this.databaseService = databaseService;
    this.adapters = /* @__PURE__ */ new Map();
    this.initializeAdapters();
    this.initializeGenerators();
  }
  /**
   * Initializes all AI adapters based on supported providers.
   */
  initializeAdapters() {
    this.adapters = /* @__PURE__ */ new Map([
      ["openai" /* OpenAI */, new OpenAIAdapter(this.settingsService, this.jsonValidationService)],
      ["anthropic" /* Anthropic */, new AnthropicAdapter(this.settingsService, this.jsonValidationService)],
      ["google" /* Google */, new GeminiAdapter(this.settingsService, this.jsonValidationService)],
      ["groq" /* Groq */, new GroqAdapter(this.settingsService, this.jsonValidationService)],
      ["openrouter" /* OpenRouter */, new OpenRouterAdapter(this.settingsService, this.jsonValidationService)],
      ["lmstudio" /* LMStudio */, new LMStudioAdapter(this.settingsService, this.jsonValidationService)],
      ["perplexity" /* Perplexity */, new PerplexityAdapter(this.settingsService, this.jsonValidationService)]
      // Initialize PerplexityAdapter
    ]);
  }
  getCurrentAdapter() {
    const provider = this.getCurrentProvider();
    return this.getAdapterForProvider(provider);
  }
  /**
   * Initializes all generators required for AI operations.
   */
  initializeGenerators() {
    const currentProvider = this.getCurrentProvider();
    const currentAdapter = this.getAdapterForProvider(currentProvider);
    this.jsonSchemaGenerator = new JsonSchemaGenerator(this.settingsService);
    this.frontMatterGenerator = new FrontMatterGenerator(currentAdapter, this.settingsService, this.jsonSchemaGenerator);
    this.wikilinkGenerator = new WikilinkGenerator(currentAdapter, this.settingsService);
    this.ontologyGenerator = new OntologyGenerator(currentAdapter, this.settingsService);
    this.batchProcessor = new BatchProcessor(
      currentAdapter,
      this.settingsService,
      this.frontMatterGenerator,
      this.wikilinkGenerator,
      this.databaseService,
      this.app
      // Add this parameter
    );
    this.knowledgeBloomGenerator = new KnowledgeBloomGenerator(
      currentAdapter,
      this.settingsService,
      this.app,
      this.frontMatterGenerator
      // Pass FrontMatterGenerator here
    );
  }
  /**
   * Reinitializes adapters and generators. Useful after updating settings.
   */
  reinitialize() {
    this.initializeAdapters();
    this.initializeGenerators();
  }
  /**
   * Retrieves the current AI provider selected in settings.
   */
  getCurrentProvider() {
    return this.settingsService.getAIProviderSettings().selected;
  }
  /**
   * Retrieves the current model API name for a given provider.
   * @param provider - The AI provider.
   */
  getCurrentModel(provider) {
    const aiProviderSettings = this.settingsService.getAIProviderSettings();
    let modelApiName = aiProviderSettings.selectedModels[provider];
    if (!modelApiName) {
      if (provider === "mistral" /* Mistral */) {
        modelApiName = "mistral-large-latest";
        aiProviderSettings.selectedModels[provider] = modelApiName;
        this.settingsService.updateAIProviderSettings(provider, { selectedModels: aiProviderSettings.selectedModels });
      } else if (provider === "perplexity" /* Perplexity */) {
        modelApiName = "perplexity-large";
        aiProviderSettings.selectedModels[provider] = modelApiName;
        this.settingsService.updateAIProviderSettings(provider, { selectedModels: aiProviderSettings.selectedModels });
      } else {
        throw new Error(`No model selected for provider: ${provider}`);
      }
    }
    return modelApiName;
  }
  /**
   * Retrieves the default model API name based on the current provider.
   */
  getDefaultModel() {
    const provider = this.getCurrentProvider();
    return this.getCurrentModel(provider);
  }
  /**
   * Sets the default model API name for the current provider.
   * @param modelApiName - The model API name to set as default.
   */
  async setDefaultModel(modelApiName) {
    const provider = this.getCurrentProvider();
    const aiProviderSettings = this.settingsService.getAIProviderSettings();
    aiProviderSettings.selectedModels[provider] = modelApiName;
    await this.settingsService.updateAIProviderSettings(provider, { selectedModels: aiProviderSettings.selectedModels });
    this.reinitialize();
  }
  /**
   * Retrieves all available models for a given provider.
   * @param provider - The AI provider.
   */
  getAvailableModels(provider) {
    const adapter = this.getAdapterForProvider(provider);
    return adapter.getAvailableModels();
  }
  /**
   * Retrieves all supported AI providers.
   */
  getSupportedProviders() {
    return Array.from(this.adapters.keys());
  }
  /**
   * Retrieves the adapter corresponding to a given provider.
   * @param provider - The AI provider.
   */
  getAdapterForProvider(provider) {
    switch (provider) {
      case "openai" /* OpenAI */:
        return new OpenAIAdapter(this.settingsService, this.jsonValidationService);
      case "anthropic" /* Anthropic */:
        return new AnthropicAdapter(this.settingsService, this.jsonValidationService);
      case "google" /* Google */:
        return new GeminiAdapter(this.settingsService, this.jsonValidationService);
      case "groq" /* Groq */:
        return new GroqAdapter(this.settingsService, this.jsonValidationService);
      case "openrouter" /* OpenRouter */:
        return new OpenRouterAdapter(this.settingsService, this.jsonValidationService);
      case "lmstudio" /* LMStudio */:
        return new LMStudioAdapter(this.settingsService, this.jsonValidationService);
      case "perplexity" /* Perplexity */:
        return new PerplexityAdapter(this.settingsService, this.jsonValidationService);
      case "mistral" /* Mistral */:
        return new MistralAdapter(this.settingsService, this.jsonValidationService);
      default:
        throw new Error(`No adapter found for provider: ${provider}`);
    }
  }
  /**
   * Validates the API key for a given provider.
   * @param provider - The AI provider.
   */
  async validateApiKey(provider) {
    const adapter = this.getAdapterForProvider(provider);
    try {
      return await adapter.validateApiKey();
    } catch (error) {
      console.error(`Error validating API key for ${provider}:`, error);
      return false;
    }
  }
  /**
   * Updates plugin settings and reinitializes services.
   * @param newSettings - Partial plugin settings to update.
   */
  async updateSettings(newSettings) {
    await this.settingsService.updateSettings(newSettings);
    this.reinitialize();
  }
  /**
   * Retrieves the root folder of the vault.
   */
  getVaultRoot() {
    return this.app.vault.getRoot();
  }
  /**
   * Retrieves a list of existing markdown pages in the vault.
   */
  getExistingPages() {
    return this.app.vault.getMarkdownFiles().map((file) => file.basename);
  }
  /**
   * Tests the connection to a given AI provider by validating the API key and making a test request.
   * @param provider - The AI provider to test.
   */
  async testConnection(provider) {
    try {
      const adapter = this.getAdapterForProvider(provider);
      const modelApiName = this.getCurrentModel(provider);
      const testPrompt = "This is a test prompt. Please respond with the word 'OK'.";
      return await adapter.testConnection(testPrompt, modelApiName);
    } catch (error) {
      console.error(`Error testing connection to ${provider}:`, error);
      return false;
    }
  }
  /**
   * Generates a response from the AI based on the provided prompt.
   * @param prompt - The input prompt for the AI.
   */
  async generateResponse(prompt) {
    return this.executeWithHandling(async () => {
      const provider = this.getCurrentProvider();
      const modelApiName = this.getCurrentModel(provider);
      const adapter = this.getAdapterForProvider(provider);
      return await adapter.generateResponse(prompt, modelApiName);
    });
  }
  /**
   * Retrieves a list of AI providers that have valid API keys set.
   */
  getProvidersWithApiKeys() {
    const aiProviderSettings = this.settingsService.getAIProviderSettings();
    return Object.entries(aiProviderSettings.apiKeys).filter(([_, apiKey]) => apiKey && apiKey.trim() !== "").map(([provider, _]) => provider);
  }
  /**
   * Generates front matter content using AI.
   * @param content - The content for which to generate front matter.
   * @returns Promise<FrontMatterOutput> - The generated front matter result
   */
  async generateFrontMatter(content) {
    try {
      const input = {
        content,
        customProperties: this.extractCustomProperties(content),
        customTags: this.extractCustomTags(content)
      };
      return await this.frontMatterGenerator.generate(input);
    } catch (error) {
      console.error("Error generating front matter:", error);
      throw new Error(`Failed to generate front matter: ${error.message}`);
    }
  }
  /**
   * Generates wikilinks for the given content using AI.
   * @param content - The content for which to generate wikilinks.
   * @returns Promise<WikilinkOutput> - The generated wikilinks result
   */
  async generateWikilinks(content) {
    try {
      const existingPages = this.getExistingPages();
      return await this.wikilinkGenerator.generate({
        content,
        existingPages
      });
    } catch (error) {
      console.error("Error generating wikilinks:", error);
      throw new Error(`Failed to generate wikilinks: ${error.message}`);
    }
  }
  /**
   * Generates ontology based on the provided input.
   * @param input - The input parameters for ontology generation.
   * @returns The generated ontology result.
   */
  async generateOntology(input) {
    try {
      const ontologyResult = await this.ontologyGenerator.generate(input);
      return ontologyResult;
    } catch (error) {
      console.error("Error generating ontology:", error);
      throw new Error(`Failed to generate ontology: ${error.message}`);
    }
  }
  /**
   * Updates tags based on the suggested tags.
   * @param suggestedTags - Array of suggested tags to update.
   */
  async updateTags(suggestedTags) {
    try {
      const settings = this.settingsService.getSettings();
      const existingTagNames = new Set(settings.tags.customTags.map((tag) => tag.name));
      const newTags = suggestedTags.filter((tag) => !existingTagNames.has(tag.name));
      if (newTags.length === 0) {
        new import_obsidian13.Notice("No new tags to add.");
        return;
      }
      settings.tags.customTags.push(...newTags);
      await this.settingsService.updateSettings({ tags: settings.tags });
      new import_obsidian13.Notice(`Added ${newTags.length} new tags successfully!`);
    } catch (error) {
      console.error("Error updating tags:", error);
      throw new Error(`Failed to update tags: ${error.message}`);
    }
  }
  /**
   * Retrieves all available AI models across all providers.
   */
  getAllAvailableModels() {
    const availableModels = [];
    for (const provider of Object.values(AIProvider)) {
      try {
        const adapter = this.getAdapterForProvider(provider);
        if (adapter.isReady()) {
          const models = this.getAvailableModels(provider);
          models.forEach((modelName) => {
            const model = this.getModelDetails(provider, modelName);
            if (model) {
              availableModels.push({ provider, model });
            }
          });
        }
      } catch (error) {
        console.warn(`Skipping provider ${provider} due to error:`, error);
      }
    }
    const localLMStudioSettings = this.settingsService.getSettings().localLMStudio;
    if (localLMStudioSettings.enabled && localLMStudioSettings.modelName) {
      availableModels.push({
        provider: "lmstudio" /* LMStudio */,
        model: { name: localLMStudioSettings.modelName, apiName: "custom" }
      });
    }
    return availableModels;
  }
  /**
   * Retrieves model details based on provider and model name.
   * @param provider - The AI provider.
   * @param modelName - The name of the model.
   */
  getModelDetails(provider, modelName) {
    const models = AIModelMap[provider];
    return models.find((model) => model.apiName === modelName);
  }
  /**
   * Generates Knowledge Bloom content using AI.
   * @param sourceFile - The file containing wikilinks to generate notes for.
   * @param userPrompt - Optional user-provided context for note generation.
   * @param template - Optional template for note generation.
   * @returns Promise<KnowledgeBloomOutput> - The generated notes and metadata
   */
  async generateKnowledgeBloom(sourceFile, userPrompt, template) {
    return this.knowledgeBloomGenerator.generate({
      sourceFile,
      userPrompt,
      template
    });
  }
  /**
   * Extracts custom properties from content based on settings.
   * @param content - The content to extract properties from.
   * @returns Array of PropertyTag.
   */
  extractCustomProperties(content) {
    const settings = this.settingsService.getSettings();
    return settings.frontMatter.customProperties;
  }
  /**
   * Extracts custom tags from content based on settings.
   * @param content - The content to extract tags from.
   * @returns Array of tag names.
   */
  extractCustomTags(content) {
    const settings = this.settingsService.getSettings();
    return settings.tags.customTags.map((tag) => tag.name);
  }
};

// src/services/JsonValidationService.ts
var import_obsidian14 = require("obsidian");
var JsonValidationService = class {
  /**
   * Basic validation of JSON data format
   * @param data The data to validate
   * @returns True if the data is valid JSON, false otherwise
   */
  validate(data) {
    try {
      if (typeof data === "object" && data !== null) {
        return true;
      }
      if (typeof data === "string") {
        JSON.parse(data);
        return true;
      }
      return false;
    } catch (error) {
      console.error("JsonValidationService: JSON Validation Error:", error);
      return false;
    }
  }
  /**
   * Cleans and validates JSON string input
   * @param jsonString The JSON string to validate and clean
   * @returns The parsed JSON object
   */
  validateAndCleanJson(jsonString) {
    try {
      jsonString = jsonString.trim();
      jsonString = jsonString.replace(/^```json?\s*|\s*```$/g, "");
      const parsedJson = JSON.parse(jsonString);
      return parsedJson;
    } catch (error) {
      console.error("JsonValidationService: Error validating JSON:", error);
      new import_obsidian14.Notice(`Invalid JSON format: ${error instanceof Error ? error.message : "Unknown error"}`);
      throw new Error("Invalid JSON format");
    }
  }
  /**
   * Attempts to fix and parse potentially malformed JSON
   * @param str The JSON string to fix and parse
   * @returns The parsed JSON object or null if parsing fails
   */
  fixAndParseJson(str) {
    try {
      return JSON.parse(str);
    } catch (e) {
      try {
        str = str.replace(/(\w+)(?=\s*:)/g, '"$1"');
        str = str.replace(/'/g, '"');
        str = str.replace(/,\s*([\]}])/g, "$1");
        const fixedJson = JSON.parse(str);
        console.log("JsonValidationService: Successfully fixed and parsed JSON:", fixedJson);
        return fixedJson;
      } catch (fixError) {
        console.error("JsonValidationService: Failed to fix and parse JSON:", fixError);
        return null;
      }
    }
  }
};

// src/services/SettingsService.ts
var SettingsService = class extends BaseService {
  constructor(plugin, initialSettings) {
    super();
    this.plugin = plugin;
    this.settings = initialSettings;
    this.jsonValidationService = new JsonValidationService();
  }
  async loadSettings() {
    var _a;
    const data = await this.plugin.loadData();
    const mergedSettings = this.deepMerge(DEFAULT_SETTINGS, data || {});
    this.settings = {
      ...mergedSettings,
      aiProvider: {
        ...mergedSettings.aiProvider,
        selected: ((_a = mergedSettings.aiProvider) == null ? void 0 : _a.selected) || DEFAULT_SETTINGS.aiProvider.selected
      }
    };
  }
  getSettings() {
    var _a;
    const settings = { ...this.settings };
    if ((_a = settings.frontMatter) == null ? void 0 : _a.customProperties) {
      const props = settings.frontMatter.customProperties;
      settings.frontMatter.customProperties = Array.isArray(props) ? props : Object.values(props).filter((v) => v && typeof v === "object" && "name" in v);
    }
    return settings;
  }
  getSetting(key) {
    return this.settings[key];
  }
  getNestedSetting(key, nestedKey) {
    return this.settings[key][nestedKey];
  }
  async updateSettings(newSettings) {
    var _a;
    const mergedSettings = this.deepMerge(this.settings, newSettings);
    this.settings = {
      ...mergedSettings,
      aiProvider: {
        ...mergedSettings.aiProvider,
        selected: ((_a = mergedSettings.aiProvider) == null ? void 0 : _a.selected) || this.settings.aiProvider.selected
      }
    };
    await this.saveSettings();
    this.emitter.emit("settingsChanged", this.settings);
  }
  async updateSetting(key, value) {
    this.settings[key] = value;
    await this.saveSettings();
    this.emitter.emit("settingsChanged", { [key]: value });
  }
  async updateNestedSetting(key, nestedKey, value) {
    if (key === "frontMatter" && nestedKey === "customProperties") {
      const currentValue = this.settings[key][nestedKey];
      const existingProps = Array.isArray(currentValue) ? currentValue : Object.values(currentValue).filter(
        (v) => v !== null && typeof v === "object" && "name" in v
      );
      const valueAsArray = Array.isArray(value) ? value : [value];
      this.settings[key] = {
        ...this.settings[key],
        [nestedKey]: [...existingProps, ...valueAsArray]
      };
    } else if (Array.isArray(this.settings[key][nestedKey])) {
      const currentArray = this.settings[key][nestedKey];
      const valueAsArray = Array.isArray(value) ? value : [value];
      this.settings[key] = {
        ...this.settings[key],
        [nestedKey]: [...currentArray, ...valueAsArray]
      };
    } else {
      this.settings[key] = {
        ...this.settings[key],
        [nestedKey]: value
      };
    }
    await this.saveSettings();
    this.emitter.emit("settingsChanged", {
      [key]: { [nestedKey]: this.settings[key][nestedKey] }
    });
  }
  async updateAIProviderSettings(provider, settings) {
    this.settings.aiProvider = this.deepMerge(this.settings.aiProvider, settings);
    await this.saveSettings();
    this.emitter.emit("settingsChanged", { aiProvider: this.settings.aiProvider });
  }
  getAIProviderSettings() {
    return this.settings.aiProvider;
  }
  async updateLocalLMStudioSettings(settings) {
    this.settings.localLMStudio = this.deepMerge(this.settings.localLMStudio, settings);
    await this.saveSettings();
    this.emitter.emit("settingsChanged", { localLMStudio: this.settings.localLMStudio });
  }
  getLocalLMStudioSettings() {
    return this.settings.localLMStudio;
  }
  getKnowledgeBloomSettings() {
    return this.settings.knowledgeBloom;
  }
  async updateKnowledgeBloomSettings(settings) {
    this.settings.knowledgeBloom = this.deepMerge(this.settings.knowledgeBloom, settings);
    await this.saveSettings();
    this.emitter.emit("settingsChanged", { knowledgeBloom: this.settings.knowledgeBloom });
  }
  async updateKnowledgeBloomSetting(key, value) {
    this.settings.knowledgeBloom[key] = value;
    await this.saveSettings();
    this.emitter.emit("settingsChanged", { knowledgeBloom: { [key]: value } });
  }
  async updateTags(newTags) {
    const existingTags = this.settings.tags.customTags || [];
    const mergedTags = [...existingTags];
    for (const newTag of newTags) {
      const existingIndex = mergedTags.findIndex((t) => t.name === newTag.name);
      if (existingIndex !== -1) {
        mergedTags[existingIndex] = { ...mergedTags[existingIndex], ...newTag };
      } else {
        mergedTags.push(newTag);
      }
    }
    this.settings.tags.customTags = mergedTags;
    await this.saveSettings();
    this.emitter.emit("settingsChanged", { tags: { customTags: mergedTags } });
  }
  async resetToDefault() {
    this.settings = { ...DEFAULT_SETTINGS };
    await this.saveSettings();
    this.emitter.emit("settingsReset");
  }
  onSettingsChanged(listener) {
    this.emitter.on("settingsChanged", listener);
  }
  onSettingsReset(listener) {
    this.emitter.on("settingsReset", listener);
  }
  async saveSettings() {
    try {
      await this.plugin.saveData(this.settings);
    } catch (error) {
      console.error("Failed to save settings:", error);
      throw error;
    }
  }
  // Getter for JsonValidationService
  getJsonValidationService() {
    return this.jsonValidationService;
  }
};

// src/services/DatabaseService.ts
var DatabaseService = class extends BaseService {
  constructor(saveCallback) {
    super();
    this.saveCallback = saveCallback;
    this.MAX_HISTORY_LENGTH = 100;
    this.PRUNE_THRESHOLD = 1e3;
    this.MONTH_IN_MS = 30 * 24 * 60 * 60 * 1e3;
    this.data = this.getDefaultData();
  }
  /**
   * Save data with callback and timestamp
   */
  async save() {
    this.data.lastUpdated = Date.now();
    await this.saveData(() => {
      if (this.saveCallback) {
        return this.saveCallback(this.data);
      }
      return Promise.resolve();
    });
  }
  /**
   * Load database from persistent storage
   */
  async load(loadData) {
    try {
      const savedData = await loadData();
      if (savedData) {
        this.data = this.migrateDataIfNeeded(savedData);
        await this.pruneOldRecordsIfNeeded();
      }
    } catch (error) {
      console.error("DatabaseService: Error loading data:", error);
      this.data = this.getDefaultData();
    }
  }
  /**
   * Get default database structure
   */
  getDefaultData() {
    return {
      processedFiles: [],
      processingState: {
        lastProcessedFiles: [],
        queuedFiles: [],
        errors: [],
        isPaused: false,
        currentChunkIndex: 0
      },
      processingStats: [],
      errors: [],
      lastUpdated: Date.now()
    };
  }
  /**
   * Migrate data structure if needed
   */
  migrateDataIfNeeded(savedData) {
    const migratedData = {
      ...this.getDefaultData(),
      ...savedData
    };
    migratedData.processingStats = (savedData.processingStats || []).map((stat) => ({
      ...stat,
      // Use endTime if available, otherwise fallback to startTime
      timestamp: stat.endTime || stat.startTime || Date.now()
    }));
    return migratedData;
  }
  /**
   * Mark file as processed with result
   */
  async markFileAsProcessed(file, result) {
    const existingIndex = this.data.processedFiles.findIndex((f) => f.path === file.path);
    const processedFile = {
      path: file.path,
      lastProcessed: Date.now(),
      lastModified: file.stat.mtime,
      frontMatterGenerated: result.frontMatterGenerated,
      wikilinksGenerated: result.wikilinksGenerated,
      processingTime: result.processingTime,
      retryCount: existingIndex !== -1 ? this.data.processedFiles[existingIndex].retryCount + 1 : 0,
      error: result.error
    };
    if (existingIndex !== -1) {
      this.data.processedFiles[existingIndex] = processedFile;
    } else {
      this.data.processedFiles.push(processedFile);
    }
    await this.save();
  }
  /**
   * Check if file needs processing
   */
  needsProcessing(file) {
    const processedFile = this.data.processedFiles.find((f) => f.path === file.path);
    if (!processedFile)
      return true;
    const needsUpdate = file.stat.mtime > processedFile.lastProcessed;
    const hasError = !!processedFile.error;
    return needsUpdate || hasError;
  }
  /**
   * Add processing statistics with validation
   */
  async addProcessingStats(stats) {
    const timestamp = Date.now();
    const validatedStats = {
      totalFiles: stats.totalFiles || 0,
      processedFiles: stats.processedFiles || 0,
      errorFiles: stats.errorFiles || 0,
      skippedFiles: stats.skippedFiles || 0,
      startTime: stats.startTime || timestamp,
      endTime: stats.endTime || timestamp,
      averageProcessingTime: stats.averageProcessingTime || 0,
      timestamp
    };
    this.data.processingStats.unshift(validatedStats);
    if (this.data.processingStats.length > this.MAX_HISTORY_LENGTH) {
      this.data.processingStats = this.data.processingStats.slice(0, this.MAX_HISTORY_LENGTH);
    }
    await this.save();
  }
  /**
   * Get processing statistics with fallback
   */
  getProcessingStats(days) {
    const stats = this.data.processingStats || [];
    if (days) {
      const cutoff = Date.now() - days * 24 * 60 * 60 * 1e3;
      return stats.filter((stat) => (stat.timestamp || stat.startTime) > cutoff);
    }
    return stats;
  }
  /**
   * Get summary of processing statistics
   */
  getProcessingStatsSummary() {
    if (this.data.processingStats.length === 0) {
      return {
        totalProcessed: 0,
        totalErrors: 0,
        averageTime: 0,
        successRate: 100,
        lastProcessed: 0
      };
    }
    const stats = this.data.processingStats;
    const totalProcessed = stats.reduce((sum, stat) => sum + stat.processedFiles, 0);
    const totalErrors = stats.reduce((sum, stat) => sum + stat.errorFiles, 0);
    const averageTime = stats.reduce((sum, stat) => sum + stat.averageProcessingTime, 0) / stats.length;
    const successRate = totalProcessed > 0 ? (totalProcessed - totalErrors) / totalProcessed * 100 : 100;
    const lastProcessed = stats[0].timestamp;
    return {
      totalProcessed,
      totalErrors,
      averageTime,
      successRate,
      lastProcessed
    };
  }
  /**
   * Get recent errors
   */
  getRecentErrors(limit = 10) {
    return this.data.errors.slice(0, limit);
  }
  /**
   * Add processing error
   */
  async addError(error) {
    this.data.errors.unshift(error);
    await this.save();
  }
  /**
   * Get persistent processing state
   */
  async loadProcessingState() {
    return this.data.processingState;
  }
  /**
   * Save persistent processing state
   */
  async saveProcessingState(state) {
    this.data.processingState = state;
    await this.save();
  }
  /**
   * Reset processing state to default
   */
  async resetProcessingState() {
    this.data.processingState = this.getDefaultData().processingState;
    await this.save();
  }
  /**
   * Prune old records if threshold exceeded
   */
  async pruneOldRecordsIfNeeded() {
    if (this.data.processedFiles.length <= this.PRUNE_THRESHOLD) {
      return;
    }
    const cutoff = Date.now() - this.MONTH_IN_MS;
    this.data.processedFiles = this.data.processedFiles.filter(
      (file) => file.lastProcessed > cutoff || file.error
    );
    this.data.errors = this.data.errors.filter(
      (error) => error.timestamp > cutoff
    );
    await this.save();
  }
  /**
   * Get stats for specific file
   */
  getFileStats(filePath) {
    return this.data.processedFiles.find((f) => f.path === filePath);
  }
  /**
   * Get summary of file processing history
   */
  getFileProcessingSummary() {
    const today = new Date().setHours(0, 0, 0, 0);
    const files = this.data.processedFiles;
    return {
      totalFiles: files.length,
      processedToday: files.filter((f) => f.lastProcessed > today).length,
      errorCount: files.filter((f) => f.error).length,
      averageProcessingTime: this.calculateAverageProcessingTime()
    };
  }
  /**
   * Calculate average processing time
   */
  calculateAverageProcessingTime() {
    const recentFiles = this.data.processedFiles.filter((f) => !f.error).slice(0, 100);
    if (recentFiles.length === 0)
      return 0;
    const totalTime = recentFiles.reduce((sum, file) => sum + file.processingTime, 0);
    return totalTime / recentFiles.length;
  }
};

// src/services/AutoGenerateService.ts
var import_obsidian15 = require("obsidian");
var AutoGenerateService = class extends BaseService {
  constructor(app, vault, aiService, settingsService, databaseService, jsonValidationService) {
    super();
    this.app = app;
    this.vault = vault;
    this.aiService = aiService;
    this.settingsService = settingsService;
    this.databaseService = databaseService;
    this.isProcessing = false;
    this.isStartupComplete = false;
    this.options = DEFAULT_PROCESSING_OPTIONS;
    this.NOTIFICATION_TIMEOUT = 3e3;
    this.jsonValidationService = jsonValidationService;
    this.initializeBatchProcessor();
  }
  /**
   * Initialize the batch processor and set up event handlers
   */
  initializeBatchProcessor() {
    this.batchProcessor = new BatchProcessor(
      this.aiService.getCurrentAdapter(),
      this.settingsService,
      this.aiService.frontMatterGenerator,
      this.aiService.wikilinkGenerator,
      this.databaseService,
      this.app
    );
    this.setupEventHandlers();
  }
  /**
   * Set up event handlers for processing events
   */
  setupEventHandlers() {
    this.batchProcessor.on("start", () => {
      this.isProcessing = true;
      this.showNotification("Starting vault content analysis...");
    });
    this.batchProcessor.on("complete", (stats) => {
      this.isProcessing = false;
      this.handleProcessingComplete(stats);
    });
    this.batchProcessor.on("error", (error) => {
      console.error("Processing error:", error);
      this.showNotification(`Error processing file: ${error.filePath}`, true);
    });
    ["progress", "pause", "resume", "error"].forEach((event) => {
      this.batchProcessor.on(event, (data) => {
        this.emitter.emit(event, data);
      });
    });
  }
  /**
   * Start automatic generation process
   * Only runs during initial vault startup
   */
  async runAutoGenerate() {
    if (!this.shouldRunAutoGenerate()) {
      return;
    }
    try {
      const unprocessedFiles = await this.getUnprocessedFiles();
      if (unprocessedFiles.length === 0) {
        this.completeStartup();
        return;
      }
      await this.processFiles(unprocessedFiles);
      this.completeStartup();
    } catch (error) {
      this.handleError("Error during startup generation process:", error);
      this.completeStartup();
    }
  }
  /**
   * Check if auto-generate should run
   */
  shouldRunAutoGenerate() {
    if (this.isStartupComplete) {
      return false;
    }
    if (this.isProcessing) {
      return false;
    }
    const settings = this.settingsService.getSettings();
    if (!settings.frontMatter.autoGenerate) {
      this.completeStartup();
      return false;
    }
    return true;
  }
  /**
   * Mark startup as complete
   */
  completeStartup() {
    this.isStartupComplete = true;
    console.log("AutoGenerateService: Startup processing completed");
  }
  /**
   * Get files that need processing
   */
  async getUnprocessedFiles() {
    const allFiles = this.vault.getMarkdownFiles();
    const needsProcessing = await Promise.all(
      allFiles.map(async (file) => ({
        file,
        needsProcessing: await this.isUnprocessedFile(file)
      }))
    );
    return needsProcessing.filter((result) => result.needsProcessing).map((result) => result.file);
  }
  /**
   * Check if a file needs processing
   */
  async isUnprocessedFile(file) {
    try {
      if (this.isFileBeingProcessed(file)) {
        return false;
      }
      if (!this.databaseService.needsProcessing(file)) {
        return false;
      }
      const content = await this.vault.read(file);
      if (content.trim().length < 10) {
        return false;
      }
      if (content.startsWith("---\n")) {
        return false;
      }
      return true;
    } catch (error) {
      this.handleError(`Error checking file ${file.path}:`, error);
      return false;
    }
  }
  /**
   * Check if a file is currently being processed
   */
  isFileBeingProcessed(file) {
    return this.isProcessing;
  }
  /**
   * Process a batch of files
   */
  async processFiles(files) {
    const settings = this.settingsService.getSettings();
    const result = await this.batchProcessor.generate({
      files,
      generateFrontMatter: true,
      // generateWikilinks is now optional and can be omitted
      options: this.options
    });
    await this.updateDatabase(result);
  }
  /**
   * Update database with processing results
   */
  async updateDatabase(result) {
    await Promise.all(result.fileResults.map(
      (fileResult) => this.databaseService.markFileAsProcessed(
        this.vault.getAbstractFileByPath(fileResult.path),
        fileResult
      )
    ));
  }
  /**
   * Handle processing completion
   */
  handleProcessingComplete(stats) {
    let message = `Initial vault analysis complete: ${stats.processedFiles} files processed`;
    if (stats.errorFiles > 0) {
      message += `, ${stats.errorFiles} errors`;
    }
    if (stats.endTime && stats.startTime) {
      const seconds = Math.round((stats.endTime - stats.startTime) / 1e3);
      message += ` in ${seconds}s`;
    }
    this.showNotification(message);
  }
  /**
   * Show notification to user
   */
  showNotification(message, isError = false) {
    if (isError) {
      console.error(message);
    }
    new import_obsidian15.Notice(message, this.NOTIFICATION_TIMEOUT);
  }
  /**
   * Update processing options
   */
  updateOptions(options) {
    this.options = { ...this.options, ...options };
  }
  /**
   * Clean up resources
   */
  destroy() {
    this.emitter.removeAllListeners();
    this.isStartupComplete = false;
    this.isProcessing = false;
  }
  /**
   * Initialize the status bar
   * Note: Status bar is now handled by main.ts
   */
  initializeStatusBar(_statusBarEl) {
    return;
  }
  initializeAdapters() {
    this.adapters = /* @__PURE__ */ new Map([
      ["openai" /* OpenAI */, new OpenAIAdapter(this.settingsService, this.jsonValidationService)],
      ["anthropic" /* Anthropic */, new AnthropicAdapter(this.settingsService, this.jsonValidationService)],
      ["google" /* Google */, new GeminiAdapter(this.settingsService, this.jsonValidationService)],
      ["groq" /* Groq */, new GroqAdapter(this.settingsService, this.jsonValidationService)],
      ["openrouter" /* OpenRouter */, new OpenRouterAdapter(this.settingsService, this.jsonValidationService)],
      ["lmstudio" /* LMStudio */, new LMStudioAdapter(this.settingsService, this.jsonValidationService)],
      ["perplexity" /* Perplexity */, new PerplexityAdapter(this.settingsService, this.jsonValidationService)],
      ["mistral" /* Mistral */, new MistralAdapter(this.settingsService, this.jsonValidationService)]
    ]);
  }
  async someMethod() {
    await this.executeWithHandling(async () => {
    });
  }
};

// src/settings/GraphWeaverSettingTab.ts
var import_obsidian27 = require("obsidian");

// src/components/accordions/ModelHookupAccordion.ts
var import_obsidian17 = require("obsidian");

// src/components/accordions/BaseAccordion.ts
var import_obsidian16 = require("obsidian");
var import_events2 = require("events");
var BaseAccordion = class {
  constructor(app, parentEl, settingsService, aiService) {
    this.app = app;
    this.parentEl = parentEl;
    this.settingsService = settingsService;
    this.aiService = aiService;
    this.isOpen = false;
    this.eventEmitter = new import_events2.EventEmitter();
    this.containerEl = parentEl;
  }
  createAccordion(title, description) {
    this.accordionEl = this.containerEl.createDiv({ cls: "gw-accordion" });
    this.headerEl = this.accordionEl.createDiv({ cls: "gw-accordion-header" });
    const titleWrapper = this.headerEl.createDiv({ cls: "gw-accordion-title-wrapper" });
    titleWrapper.createSpan({ text: title, cls: "gw-accordion-title" });
    this.toggleIcon = this.headerEl.createSpan({ cls: "gw-accordion-toggle" });
    this.updateToggleIcon();
    const descriptionEl = this.accordionEl.createDiv({ cls: "gw-accordion-description" });
    descriptionEl.createSpan({ text: description });
    this.contentEl = this.accordionEl.createDiv({ cls: "gw-accordion-content" });
    this.contentEl.style.display = "none";
    this.headerEl.addEventListener("click", () => this.toggleAccordion());
    return this.contentEl;
  }
  toggleAccordion() {
    this.isOpen = !this.isOpen;
    this.contentEl.style.display = this.isOpen ? "block" : "none";
    this.updateToggleIcon();
    this.accordionEl.classList.toggle("gw-accordion-open", this.isOpen);
  }
  updateToggleIcon() {
    this.toggleIcon.empty();
    const iconText = document.createTextNode(this.isOpen ? "\u2796" : "\u2795");
    this.toggleIcon.appendChild(iconText);
  }
  createSettingItem(name, desc) {
    const setting = new import_obsidian16.Setting(this.contentEl);
    setting.setName(name).setDesc(desc);
    setting.settingEl.classList.add("gw-setting-item");
    return setting;
  }
  // Add utility methods for creating common setting types
  createToggleSetting(name, desc, currentValue, onChangePath) {
    new import_obsidian16.Setting(this.contentEl).setName(name).setDesc(desc).addToggle((toggle) => toggle.setValue(currentValue).onChange(async (value) => {
      await this.settingsService.updateNestedSetting(
        onChangePath.section,
        onChangePath.key,
        value
      );
    }));
  }
  createTextSetting(name, desc, placeholder, currentValue, onChangePath) {
    let textComponent;
    new import_obsidian16.Setting(this.contentEl).setName(name).setDesc(desc).addText((text) => {
      textComponent = text;
      text.setPlaceholder(placeholder).setValue(currentValue).onChange(async (value) => {
        await this.settingsService.updateNestedSetting(
          onChangePath.section,
          onChangePath.key,
          value
        );
      });
    });
    return textComponent;
  }
  createTextAreaSetting(name, desc, placeholder, currentValue, rows = 4) {
    let textAreaComponent;
    new import_obsidian16.Setting(this.contentEl).setName(name).setDesc(desc).addTextArea((text) => {
      textAreaComponent = text;
      text.setPlaceholder(placeholder).setValue(currentValue);
      text.inputEl.rows = rows;
    });
    return textAreaComponent;
  }
  createButton(name, desc, buttonText, onClick, setCta = false) {
    let buttonComponent;
    new import_obsidian16.Setting(this.contentEl).setName(name).setDesc(desc).addButton((button) => {
      buttonComponent = button;
      button.setButtonText(buttonText);
      if (setCta)
        button.setCta();
      button.onClick(onClick);
    });
    return buttonComponent;
  }
  showNotice(message) {
    new import_obsidian16.Notice(message);
  }
  emitEvent(type, data) {
    this.eventEmitter.emit(type, data);
  }
};

// src/components/accordions/ModelHookupAccordion.ts
var ModelHookupAccordion = class extends BaseAccordion {
  constructor(app, containerEl, settingsService, aiService) {
    super(app, containerEl, settingsService, aiService);
    this.app = app;
    this.containerEl = containerEl;
    this.settingsService = settingsService;
    this.aiService = aiService;
  }
  render() {
    const contentEl = this.createAccordion(
      "\u{1F50C} Model Hookup",
      "Configure AI providers and models."
    );
    this.createProviderDropdown(contentEl);
    this.settingsContainer = contentEl.createDiv({ cls: "provider-settings" });
    this.renderProviderSettings();
  }
  createProviderDropdown(containerEl) {
    const settings = this.settingsService.getSettings();
    new import_obsidian17.Setting(containerEl).setName("AI Provider").setDesc("Select the AI provider to use").addDropdown((dropdown) => {
      this.providerDropdown = dropdown;
      Object.values(AIProvider).forEach((provider) => {
        dropdown.addOption(provider, this.getFormattedProviderName(provider));
      });
      dropdown.setValue(settings.aiProvider.selected).onChange(async (value) => {
        await this.settingsService.updateNestedSetting("aiProvider", "selected", value);
        this.aiService.reinitialize();
        this.renderProviderSettings();
      });
    });
  }
  renderProviderSettings() {
    const provider = this.providerDropdown.getValue();
    this.settingsContainer.empty();
    if (provider === "lmstudio" /* LMStudio */) {
      this.renderLocalSettings();
    } else {
      this.renderCloudSettings(provider);
      this.createModelDropdown(this.settingsContainer, provider);
    }
    this.createTestButton(this.settingsContainer, provider);
  }
  renderCloudSettings(provider) {
    this.createProviderLink(this.settingsContainer, provider);
    this.createApiKeyInput(this.settingsContainer, provider);
  }
  renderLocalSettings() {
    this.createPortInput(this.settingsContainer);
    this.createModelNameInput(this.settingsContainer);
  }
  createApiKeyInput(containerEl, provider) {
    const settings = this.settingsService.getSettings();
    new import_obsidian17.Setting(containerEl).setName("API Key").setDesc(`Enter your API key for ${this.getFormattedProviderName(provider)}`).addText((text) => {
      text.setPlaceholder("Enter API Key").setValue(settings.aiProvider.apiKeys[provider] || "").onChange(async (value) => {
        const currentApiKeys = this.settingsService.getNestedSetting("aiProvider", "apiKeys");
        const updatedApiKeys = { ...currentApiKeys, [provider]: value };
        await this.settingsService.updateNestedSetting("aiProvider", "apiKeys", updatedApiKeys);
        this.aiService.reinitialize();
      });
      text.inputEl.type = "password";
    });
  }
  createPortInput(containerEl) {
    const settings = this.settingsService.getSettings();
    new import_obsidian17.Setting(containerEl).setName("LM Studio Port").setDesc("Enter the port number for your local LM Studio instance").addText((text) => {
      text.setPlaceholder("Enter port number").setValue(settings.localLMStudio.port.toString()).onChange(async (value) => {
        const port = parseInt(value, 10);
        if (!isNaN(port)) {
          await this.settingsService.updateNestedSetting("localLMStudio", "port", port);
          this.aiService.reinitialize();
        }
      });
    });
  }
  createModelNameInput(containerEl) {
    const settings = this.settingsService.getSettings();
    new import_obsidian17.Setting(containerEl).setName("Model Name").setDesc("Enter the name of the local model you want to use").addText((text) => {
      text.setPlaceholder("Enter model name").setValue(settings.localLMStudio.modelName).onChange(async (value) => {
        await this.settingsService.updateNestedSetting("localLMStudio", "modelName", value);
        await this.settingsService.updateNestedSetting("aiProvider", "selectedModels", {
          ...this.settingsService.getNestedSetting("aiProvider", "selectedModels"),
          ["lmstudio" /* LMStudio */]: value
        });
        this.aiService.reinitialize();
      });
    });
  }
  createModelDropdown(containerEl, provider) {
    const settings = this.settingsService.getSettings();
    const models = AIModelMap[provider];
    new import_obsidian17.Setting(containerEl).setName("Model").setDesc(`Select the AI model for ${this.getFormattedProviderName(provider)}`).addDropdown((dropdown) => {
      var _a;
      models.forEach((model) => {
        dropdown.addOption(model.apiName, model.name);
      });
      const currentModel = settings.aiProvider.selectedModels[provider] || (((_a = models[0]) == null ? void 0 : _a.apiName) || "");
      dropdown.setValue(currentModel).onChange(async (value) => {
        const currentSelectedModels = this.settingsService.getNestedSetting("aiProvider", "selectedModels");
        const updatedSelectedModels = { ...currentSelectedModels, [provider]: value };
        await this.settingsService.updateNestedSetting("aiProvider", "selectedModels", updatedSelectedModels);
        this.renderModelSettings(modelSettingsContainer, value);
      });
      const modelSettingsContainer = containerEl.createDiv({ cls: "model-settings" });
      this.renderModelSettings(modelSettingsContainer, currentModel);
    });
  }
  renderModelSettings(containerEl, modelApiName) {
    var _a, _b;
    containerEl.empty();
    const settings = this.settingsService.getSettings();
    const model = AIModelUtils.getModelByApiName(modelApiName);
    const modelConfigs = settings.aiProvider.modelConfigs;
    const modelConfig = (modelConfigs || {})[modelApiName] || {
      temperature: 0.7,
      maxTokens: ((_a = model == null ? void 0 : model.capabilities) == null ? void 0 : _a.maxTokens) || 4096
    };
    new import_obsidian17.Setting(containerEl).setName("Temperature").setDesc("Controls randomness in responses (0.0-1.0)").addSlider((slider) => {
      slider.setLimits(0, 1, 0.1).setValue(modelConfig.temperature).onChange(async (value) => {
        await this.updateModelConfig(modelApiName, "temperature", value);
      });
    }).addText((text) => {
      text.setPlaceholder("0.0-1.0").setValue(modelConfig.temperature.toString()).onChange(async (value) => {
        const temp = parseFloat(value);
        if (!isNaN(temp) && temp >= 0 && temp <= 1) {
          await this.updateModelConfig(modelApiName, "temperature", temp);
        }
      });
    });
    new import_obsidian17.Setting(containerEl).setName("Max Tokens").setDesc(`Maximum response length (max: ${((_b = model == null ? void 0 : model.capabilities) == null ? void 0 : _b.maxTokens) || "unknown"})`).addText((text) => {
      text.setPlaceholder("Enter max tokens").setValue(modelConfig.maxTokens.toString()).onChange(async (value) => {
        const tokens = parseInt(value);
        if (!isNaN(tokens) && tokens > 0) {
          await this.updateModelConfig(modelApiName, "maxTokens", tokens);
        }
      });
    });
  }
  async updateModelConfig(modelApiName, key, value) {
    const settings = this.settingsService.getSettings();
    const modelConfigs = settings.aiProvider.modelConfigs;
    const currentConfigs = modelConfigs || {};
    const modelConfig = currentConfigs[modelApiName] || { temperature: 0.7, maxTokens: 4096 };
    const updatedConfigs = {
      ...currentConfigs,
      [modelApiName]: {
        ...modelConfig,
        [key]: value
      }
    };
    await this.settingsService.updateNestedSetting("aiProvider", "modelConfigs", updatedConfigs);
  }
  createTestButton(containerEl, provider) {
    new import_obsidian17.Setting(containerEl).addButton((button) => {
      button.setButtonText("Test Connection").onClick(async () => {
        button.setDisabled(true);
        button.setButtonText("Testing...");
        const result = await this.aiService.testConnection(provider);
        button.setDisabled(false);
        button.setButtonText("Test Connection");
        if (result) {
          new import_obsidian17.Notice(`Successfully connected to ${this.getFormattedProviderName(provider)}`);
        } else {
          new import_obsidian17.Notice(`Failed to connect to ${this.getFormattedProviderName(provider)}. Please check your settings and try again.`);
        }
      });
    });
  }
  createProviderLink(containerEl, provider) {
    const websiteUrl = this.getProviderWebsite(provider);
    const linkText = provider === "lmstudio" /* LMStudio */ ? "LM Studio Documentation" : "Get API Key";
    const linkEl = containerEl.createEl("a", {
      text: linkText,
      href: websiteUrl,
      cls: "provider-link"
    });
    linkEl.setAttribute("target", "_blank");
    const providerLabel = containerEl.createEl("span", {
      text: ` for ${this.getFormattedProviderName(provider)}`,
      cls: "provider-label"
    });
  }
  getProviderWebsite(provider) {
    const websiteMap = {
      ["openai" /* OpenAI */]: "https://platform.openai.com/api-keys",
      ["anthropic" /* Anthropic */]: "https://console.anthropic.com/settings/keys",
      ["google" /* Google */]: "https://aistudio.google.com/apikey",
      ["groq" /* Groq */]: "https://console.groq.com/keys",
      ["openrouter" /* OpenRouter */]: "https://openrouter.ai/settings/keys",
      ["lmstudio" /* LMStudio */]: "https://lmstudio.ai/docs/basics/server",
      ["perplexity" /* Perplexity */]: "https://docs.perplexity.ai/guides/getting-started",
      ["mistral" /* Mistral */]: "https://docs.mistral.ai/getting-started/quickstart/"
    };
    return websiteMap[provider] || "#";
  }
  getFormattedProviderName(provider) {
    const formattedNames = {
      ["openai" /* OpenAI */]: "OpenAI",
      ["anthropic" /* Anthropic */]: "Anthropic",
      ["google" /* Google */]: "Google Gemini",
      ["groq" /* Groq */]: "Groq",
      ["openrouter" /* OpenRouter */]: "OpenRouter",
      ["lmstudio" /* LMStudio */]: "LM Studio",
      ["perplexity" /* Perplexity */]: "Perplexity",
      ["mistral" /* Mistral */]: "Mistral"
    };
    return formattedNames[provider] || provider;
  }
};

// src/components/accordions/PropertyManagerAccordion.ts
var import_obsidian20 = require("obsidian");

// src/components/modals/EditPropertiesModal.ts
var import_obsidian19 = require("obsidian");

// src/components/modals/BaseModal.ts
var import_obsidian18 = require("obsidian");
var BaseModal = class extends import_obsidian18.Modal {
  constructor(app) {
    super(app);
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.createHeader();
    this.renderContent();
    this.createFooter();
  }
  createHeader() {
    const header = this.contentEl.createDiv("modal-header");
    header.createEl("h2", { text: this.getTitle() });
  }
  createFooter() {
  }
  // Common method to create select all checkbox
  createSelectAllCheckbox(containerEl, listEl) {
    const selectAllContainer = containerEl.createDiv({ cls: "gw-select-all-container" });
    const selectAllCheckbox = selectAllContainer.createEl("input", { type: "checkbox" });
    selectAllContainer.createEl("span", { text: "Select All" });
    selectAllCheckbox.addEventListener("change", () => {
      const checkboxes = listEl.querySelectorAll('input[type="checkbox"]');
      checkboxes.forEach((checkbox) => {
        checkbox.checked = selectAllCheckbox.checked;
      });
    });
    return selectAllCheckbox;
  }
  // Common method to update parent checkboxes
  updateParentCheckboxes(checkbox) {
    var _a, _b, _c;
    let parentFolderEl = (_b = (_a = checkbox.closest(".folder")) == null ? void 0 : _a.parentElement) == null ? void 0 : _b.closest(".folder");
    while (parentFolderEl) {
      const parentCheckbox = parentFolderEl.querySelector(".folder-checkbox");
      const childCheckboxes = parentFolderEl.querySelectorAll(":scope > .folder-content .folder > .folder-name > .folder-checkbox, :scope > .folder-content .file > .file-checkbox");
      const allChecked = Array.from(childCheckboxes).every((cb) => cb.checked);
      const someChecked = Array.from(childCheckboxes).some((cb) => cb.checked);
      parentCheckbox.checked = allChecked;
      parentCheckbox.indeterminate = !allChecked && someChecked;
      parentFolderEl = (_c = parentFolderEl.parentElement) == null ? void 0 : _c.closest(".folder");
    }
  }
  showError(message) {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("p", { text: message, cls: "error-message" });
  }
  // ...any other shared methods or properties...
};

// src/components/modals/EditPropertiesModal.ts
var EditPropertiesModal = class extends BaseModal {
  constructor(app, properties, onSubmit) {
    super(app);
    this.properties = Array.isArray(properties) ? [...properties] : [];
    this.onSubmit = onSubmit;
  }
  getTitle() {
    return "Edit Properties";
  }
  renderContent() {
    const { contentEl } = this;
    this.propertyListEl = contentEl.createDiv({ cls: "gw-modal-property-list" });
    this.selectAllCheckbox = this.createSelectAllCheckbox(contentEl, this.propertyListEl);
    this.renderPropertyList();
    const buttonContainer = contentEl.createDiv({ cls: "gw-modal-button-container" });
    new import_obsidian19.Setting(buttonContainer).addButton((btn) => btn.setButtonText("Delete Selected").setWarning().onClick(() => this.deleteSelectedProperties())).addButton((btn) => btn.setButtonText("Save").setCta().onClick(() => this.handleSubmit(this.properties))).addButton((btn) => btn.setButtonText("Cancel").onClick(() => this.close()));
  }
  async handleSubmit(data) {
    this.onSubmit(data);
    this.close();
  }
  renderPropertyList() {
    this.propertyListEl.empty();
    const table = this.propertyListEl.createEl("table", { cls: "gw-modal-property-table" });
    const headerRow = table.createEl("tr");
    headerRow.createEl("th", { text: "Drag" });
    headerRow.createEl("th", { text: "Name" });
    headerRow.createEl("th", { text: "Description" });
    headerRow.createEl("th", { text: "Type" });
    headerRow.createEl("th", { text: "Delete" });
    this.properties.forEach((property, index) => {
      const row = table.createEl("tr", { attr: { draggable: "true", "data-index": index.toString() } });
      row.addEventListener("dragstart", this.onDragStart.bind(this));
      row.addEventListener("dragover", this.onDragOver.bind(this));
      row.addEventListener("drop", this.onDrop.bind(this));
      row.createEl("td", { text: "\u2261", cls: "gw-drag-handle" });
      this.createEditableCell(row, property, "name", index);
      this.createEditableCell(row, property, "description", index);
      this.createTypeDropdown(row, property, index);
      const deleteCell = row.createEl("td");
      const deleteCheckbox = deleteCell.createEl("input", { type: "checkbox" });
      deleteCheckbox.dataset.index = index.toString();
      deleteCheckbox.addEventListener("change", () => this.updateSelectAllCheckbox());
    });
  }
  updateSelectAllCheckbox() {
    const checkboxes = this.propertyListEl.querySelectorAll('input[type="checkbox"]');
    const allChecked = Array.from(checkboxes).every((checkbox) => checkbox.checked);
    this.selectAllCheckbox.checked = allChecked;
  }
  createEditableCell(row, property, field, index) {
    const cell = row.createEl("td");
    const input = new import_obsidian19.TextComponent(cell);
    input.setValue(property[field]).onChange((value) => {
      this.properties[index][field] = value;
    });
  }
  createTypeDropdown(row, property, index) {
    const cell = row.createEl("td");
    const dropdown = new import_obsidian19.DropdownComponent(cell);
    const types = ["string", "number", "boolean", "array", "date"];
    types.forEach((type) => {
      dropdown.addOption(type, type);
    });
    dropdown.setValue(property.type).onChange((value) => {
      this.properties[index].type = value;
    });
  }
  deleteSelectedProperties() {
    const checkboxes = this.propertyListEl.querySelectorAll('input[type="checkbox"]:checked');
    const indicesToDelete = Array.from(checkboxes).map((cb) => parseInt(cb.dataset.index || "", 10)).sort((a, b) => b - a);
    indicesToDelete.forEach((index) => {
      this.properties.splice(index, 1);
    });
    this.renderPropertyList();
    this.updateSelectAllCheckbox();
  }
  onDragStart(e) {
    var _a;
    const target = e.target;
    (_a = e.dataTransfer) == null ? void 0 : _a.setData("text/plain", target.dataset.index || "");
  }
  onDragOver(e) {
    e.preventDefault();
  }
  onDrop(e) {
    var _a, _b;
    e.preventDefault();
    const fromIndex = parseInt(((_a = e.dataTransfer) == null ? void 0 : _a.getData("text/plain")) || "", 10);
    const toIndex = parseInt(((_b = e.target.closest("tr")) == null ? void 0 : _b.dataset.index) || "", 10);
    if (!isNaN(fromIndex) && !isNaN(toIndex)) {
      const [reorderedItem] = this.properties.splice(fromIndex, 1);
      this.properties.splice(toIndex, 0, reorderedItem);
      this.renderPropertyList();
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/components/accordions/PropertyManagerAccordion.ts
var PropertyManagerAccordion = class extends BaseAccordion {
  constructor(app, containerEl, settingsService, aiService) {
    super(app, containerEl, settingsService, aiService);
    this.app = app;
    this.containerEl = containerEl;
    this.settingsService = settingsService;
    this.aiService = aiService;
  }
  render() {
    const contentEl = this.createAccordion(
      "\u{1F4CA} Property Management",
      "Create and manage custom properties for your notes."
    );
    this.createPropertyEditor(contentEl);
    this.createButtonRow(contentEl);
  }
  createPropertyEditor(containerEl) {
    const settings = this.settingsService.getSettings();
    new import_obsidian20.Setting(containerEl).setName("Property Name").setDesc("Enter a unique name for this property").addText((text) => {
      this.nameInput = text;
      text.setPlaceholder("Enter property name");
    });
    new import_obsidian20.Setting(containerEl).setName("Property Description").setDesc("Describe the purpose of this property").addTextArea((textArea) => {
      this.descriptionInput = textArea;
      textArea.setPlaceholder("Enter property description");
    });
    new import_obsidian20.Setting(containerEl).setName("Property Type").setDesc("Select the data type for this property").addDropdown((dropdown) => {
      this.typeDropdown = dropdown;
      dropdown.addOption("string", "String").addOption("number", "Number").addOption("boolean", "Boolean").addOption("array", "Array").addOption("date", "Date").setValue("string");
    });
  }
  createButtonRow(containerEl) {
    this.createButton(
      "Add Property",
      "Create a new property",
      "Add Property",
      () => this.addProperty(),
      true
    );
    this.createButton(
      "Edit Properties",
      "Modify or delete existing properties",
      "Edit Properties",
      () => this.openEditModal(),
      false
    );
  }
  async addProperty() {
    var _a;
    const name = this.nameInput.getValue().trim();
    const description = ((_a = this.descriptionInput.getValue()) == null ? void 0 : _a.trim()) || "";
    const type = this.typeDropdown.getValue();
    if (!name) {
      this.showNotice("Property name cannot be empty.");
      return;
    }
    const settings = this.settingsService.getSettings();
    const existingProps = Array.isArray(settings.frontMatter.customProperties) ? settings.frontMatter.customProperties : [];
    if (existingProps.some((p) => p.name === name)) {
      this.showNotice("A property with this name already exists.");
      return;
    }
    const newProperty = {
      name,
      description,
      type
    };
    await this.settingsService.updateNestedSetting(
      "frontMatter",
      "customProperties",
      [newProperty]
    );
    new import_obsidian20.Notice(`Property "${name}" has been added.`);
    this.nameInput.setValue("");
    this.descriptionInput.setValue("");
    this.typeDropdown.setValue("string");
  }
  openEditModal() {
    const settings = this.settingsService.getSettings();
    const properties = Array.isArray(settings.frontMatter.customProperties) ? settings.frontMatter.customProperties : [];
    const modal = new EditPropertiesModal(
      this.app,
      properties,
      async (updatedProperties) => {
        await this.settingsService.updateNestedSetting(
          "frontMatter",
          "customProperties",
          updatedProperties
        );
      }
    );
    modal.open();
  }
};

// src/components/accordions/TagManagerAccordion.ts
var import_obsidian22 = require("obsidian");

// src/components/modals/EditTagsModal.ts
var import_obsidian21 = require("obsidian");
var EditTagsModal = class extends BaseModal {
  constructor(app, tags, onSubmit) {
    super(app);
    this.tags = [...tags];
    this.onSubmit = onSubmit;
  }
  getTitle() {
    return "Edit Tags";
  }
  renderContent() {
    const { contentEl } = this;
    this.tagListEl = contentEl.createDiv({ cls: "gw-modal-tag-list" });
    this.selectAllCheckbox = this.createSelectAllCheckbox(contentEl, this.tagListEl);
    this.renderTagList();
    const buttonContainer = contentEl.createDiv({ cls: "gw-modal-button-container" });
    new import_obsidian21.Setting(buttonContainer).addButton((btn) => btn.setButtonText("Delete Selected").setWarning().onClick(() => this.deleteSelectedTags())).addButton((btn) => btn.setButtonText("Save").setCta().onClick(() => this.handleSubmit(this.tags))).addButton((btn) => btn.setButtonText("Cancel").onClick(() => this.close()));
  }
  async handleSubmit(data) {
    const validTags = data.filter((tag) => tag.name && tag.description);
    this.onSubmit(validTags);
    this.close();
  }
  renderTagList() {
    this.tagListEl.empty();
    const table = this.tagListEl.createEl("table", { cls: "gw-modal-tag-table" });
    const headerRow = table.createEl("tr");
    headerRow.createEl("th", { text: "Drag" });
    headerRow.createEl("th", { text: "Name" });
    headerRow.createEl("th", { text: "Description" });
    headerRow.createEl("th", { text: "Delete" });
    this.tags.forEach((tag, index) => {
      const row = table.createEl("tr", { attr: { draggable: "true", "data-index": index.toString() } });
      row.addEventListener("dragstart", this.onDragStart.bind(this));
      row.addEventListener("dragover", this.onDragOver.bind(this));
      row.addEventListener("drop", this.onDrop.bind(this));
      row.createEl("td", { text: "\u2261", cls: "gw-drag-handle" });
      this.createEditableCell(row, tag, "name", index);
      this.createEditableCell(row, tag, "description", index);
      const deleteCell = row.createEl("td");
      const deleteCheckbox = deleteCell.createEl("input", { type: "checkbox" });
      deleteCheckbox.dataset.index = index.toString();
      deleteCheckbox.addEventListener("change", () => this.updateSelectAllCheckbox());
    });
  }
  // Add drag and drop handlers
  onDragStart(e) {
    var _a;
    const target = e.target;
    (_a = e.dataTransfer) == null ? void 0 : _a.setData("text/plain", target.dataset.index || "");
  }
  onDragOver(e) {
    e.preventDefault();
  }
  onDrop(e) {
    var _a, _b;
    e.preventDefault();
    const fromIndex = parseInt(((_a = e.dataTransfer) == null ? void 0 : _a.getData("text/plain")) || "", 10);
    const toIndex = parseInt(((_b = e.target.closest("tr")) == null ? void 0 : _b.dataset.index) || "", 10);
    if (!isNaN(fromIndex) && !isNaN(toIndex)) {
      const [reorderedItem] = this.tags.splice(fromIndex, 1);
      this.tags.splice(toIndex, 0, reorderedItem);
      this.renderTagList();
    }
  }
  updateSelectAllCheckbox() {
    const checkboxes = this.tagListEl.querySelectorAll('input[type="checkbox"]');
    const allChecked = Array.from(checkboxes).every((checkbox) => checkbox.checked);
    this.selectAllCheckbox.checked = allChecked;
  }
  createEditableCell(row, tag, field, index) {
    const cell = row.createEl("td");
    const input = field === "name" ? new import_obsidian21.TextComponent(cell) : new import_obsidian21.TextAreaComponent(cell);
    input.setValue(tag[field]).onChange((value) => {
      this.tags[index][field] = value;
    });
  }
  deleteSelectedTags() {
    const checkboxes = this.tagListEl.querySelectorAll('input[type="checkbox"]:checked');
    const indicesToDelete = Array.from(checkboxes).map((cb) => parseInt(cb.dataset.index || "", 10)).sort((a, b) => b - a);
    indicesToDelete.forEach((index) => {
      this.tags.splice(index, 1);
    });
    this.renderTagList();
    this.updateSelectAllCheckbox();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/components/accordions/TagManagerAccordion.ts
var TagManagerAccordion = class extends BaseAccordion {
  constructor(app, containerEl, settingsService, aiService) {
    super(app, containerEl, settingsService, aiService);
    this.app = app;
    this.containerEl = containerEl;
    this.settingsService = settingsService;
    this.aiService = aiService;
  }
  render() {
    const contentEl = this.createAccordion(
      "\u{1F3F7}\uFE0F Tag Management",
      "Create and manage custom tags for your notes."
    );
    this.createTagEditor(contentEl);
    this.createButtonRow(contentEl);
  }
  createTagEditor(containerEl) {
    new import_obsidian22.Setting(containerEl).setName("Tag Name").setDesc("Enter a unique name for this tag").addText((text) => {
      this.nameInput = text;
      text.setPlaceholder("Enter tag name");
    });
    new import_obsidian22.Setting(containerEl).setName("Tag Description").setDesc("Describe the purpose of this tag").addTextArea((textArea) => {
      this.descriptionInput = textArea;
      textArea.setPlaceholder("Enter tag description");
    });
  }
  createButtonRow(containerEl) {
    this.createButton(
      "Add Tag",
      "Create a new tag",
      "Add Tag",
      () => this.addTag(),
      true
    );
    this.createButton(
      "Edit Tags",
      "Modify or delete existing tags",
      "Edit Tags",
      () => this.openEditModal(),
      false
    );
  }
  addTag() {
    var _a;
    const name = this.nameInput.getValue().trim();
    const description = ((_a = this.descriptionInput.getValue()) == null ? void 0 : _a.trim()) || "";
    if (!name) {
      this.showNotice("Tag name cannot be empty.");
      return;
    }
    const settings = this.settingsService.getSettings();
    if (settings.tags.customTags.some((t) => t.name === name)) {
      this.showNotice("A tag with this name already exists.");
      return;
    }
    const newTag = {
      name,
      description,
      type: "string"
    };
    settings.tags.customTags.push(newTag);
    this.settingsService.updateSettings(settings);
    new import_obsidian22.Notice(`Tag "${name}" has been added.`);
    this.nameInput.setValue("");
    this.descriptionInput.setValue("");
  }
  openEditModal() {
    const modal = new EditTagsModal(
      this.app,
      this.settingsService.getSettings().tags.customTags,
      (updatedTags) => {
        const settings = this.settingsService.getSettings();
        settings.tags.customTags = updatedTags;
        this.settingsService.updateSettings(settings);
      }
    );
    modal.open();
  }
};

// src/components/accordions/OntologyGenerationAccordion.ts
var import_obsidian24 = require("obsidian");

// src/components/modals/OntologyGeneratorModal.ts
var import_obsidian23 = require("obsidian");
var OntologyGeneratorModal = class extends BaseModal {
  constructor(app, aiService, onGenerate) {
    super(app);
    this.aiService = aiService;
    this.onGenerate = onGenerate;
    this.vaultStats = { files: [], folders: [], tags: [] };
    this.availableModels = [];
  }
  getTitle() {
    return "Generate Ontology";
  }
  renderContent() {
    this.loadingEl.hide();
    this.contentEl.empty();
    this.contentEl.createEl("h2", { text: "Generate Ontology" });
    this.renderVaultStats();
    this.renderModelSelection();
    this.renderUserContextInput();
    this.renderGuidedQuestions();
    this.renderButtons();
  }
  async handleSubmit(data) {
    this.onGenerate(data);
    this.close();
  }
  async onOpen() {
    this.contentEl.empty();
    this.contentEl.addClass("ontology-generator-modal");
    this.loadingEl = this.contentEl.createDiv("loading-container");
    this.loadingEl.innerHTML = '<div class="spinner"></div><p>Retrieving vault statistics and available models...</p>';
    try {
      await this.loadVaultStats();
      this.availableModels = this.aiService.getAllAvailableModels();
      this.renderContent();
    } catch (error) {
      console.error("Error loading data:", error);
      this.showError("An error occurred while retrieving data.");
    }
  }
  async loadVaultStats() {
    this.vaultStats.files = this.app.vault.getMarkdownFiles();
    this.vaultStats.folders = this.app.vault.getAllLoadedFiles().filter((file) => file instanceof import_obsidian23.TFolder);
    this.vaultStats.tags = await this.getAllTags(this.vaultStats.files);
  }
  async getAllTags(files) {
    const tagSet = /* @__PURE__ */ new Set();
    for (const file of files) {
      const content = await this.app.vault.read(file);
      const tags = content.match(/#[\w-]+/g);
      if (tags) {
        tags.forEach((tag) => tagSet.add(tag));
      }
    }
    return Array.from(tagSet);
  }
  renderVaultStats() {
    const statsEl = this.contentEl.createDiv("vault-stats");
    statsEl.createEl("h3", { text: "Vault Statistics" });
    const listEl = statsEl.createEl("ul");
    listEl.createEl("li", { text: `Files: ${this.vaultStats.files.length}` });
    listEl.createEl("li", { text: `Folders: ${this.vaultStats.folders.length}` });
    listEl.createEl("li", { text: `Tags: ${this.vaultStats.tags.length}` });
  }
  renderModelSelection() {
    const modelSetting = new import_obsidian23.Setting(this.contentEl).setName("AI Model").setDesc("Select the AI model to use for ontology generation");
    if (this.availableModels.length === 0) {
      modelSetting.setDesc("No AI models available. Please add API keys in the API Integration settings.");
      return;
    }
    modelSetting.addDropdown((dropdown) => {
      this.modelSelect = dropdown;
      this.availableModels.forEach(({ provider, model }) => {
        const optionText = `${provider} - ${model.name}`;
        dropdown.addOption(`${provider}:${model.apiName}`, optionText);
      });
      if (this.availableModels.length > 0) {
        const firstModel = this.availableModels[0];
        dropdown.setValue(`${firstModel.provider}:${firstModel.model.apiName}`);
      }
    });
  }
  renderUserContextInput() {
    const contextSetting = new import_obsidian23.Setting(this.contentEl).setName("Additional Context").setDesc("Provide any additional context or information about your knowledge base that might help in generating a more accurate ontology.").addTextArea((text) => {
      this.userContextInput = text;
      text.inputEl.rows = 4;
      text.inputEl.cols = 50;
      return text;
    });
  }
  renderGuidedQuestions() {
    const questionsEl = this.contentEl.createDiv("guided-questions");
    questionsEl.createEl("h4", { text: "Guided Questions" });
    questionsEl.createEl("p", { text: "Consider the following questions when providing additional context:" });
    const questionsList = questionsEl.createEl("ul");
    [
      "What are the main themes or topics in your knowledge base?",
      "Are there any specific hierarchies or relationships between concepts that you want to emphasize?",
      "What are your goals for organizing your knowledge base?"
    ].forEach((question) => {
      questionsList.createEl("li", { text: question });
    });
  }
  renderButtons() {
    const buttonContainer = this.contentEl.createDiv("button-container");
    this.generateButton = new import_obsidian23.ButtonComponent(buttonContainer).setButtonText("Generate Ontology").setCta().setDisabled(this.availableModels.length === 0).onClick(() => this.handleOntologyGeneration());
    new import_obsidian23.ButtonComponent(buttonContainer).setButtonText("Cancel").onClick(() => this.close());
  }
  async handleOntologyGeneration() {
    const modelValue = this.modelSelect.getValue();
    if (!modelValue) {
      new import_obsidian23.Notice("Please select an AI model first.");
      return;
    }
    const [provider, modelApiName] = modelValue.split(":");
    this.generateButton.setDisabled(true);
    const loadingNotice = new import_obsidian23.Notice("Generating ontology...", 0);
    try {
      const input = {
        ...this.vaultStats,
        provider,
        modelApiName,
        userContext: this.userContextInput.getValue()
      };
      const ontology = await this.aiService.generateOntology(input);
      await this.aiService.updateTags(ontology.suggestedTags);
      loadingNotice.hide();
      new import_obsidian23.Notice("Ontology generated and tags updated successfully!", 3e3);
      this.onGenerate(ontology);
      this.close();
    } catch (error) {
      loadingNotice.hide();
      new import_obsidian23.Notice(`Failed to generate ontology: ${error.message}`, 5e3);
    } finally {
      this.generateButton.setDisabled(false);
    }
  }
  showError(message) {
    super.showError(message);
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/components/accordions/OntologyGenerationAccordion.ts
var OntologyGenerationAccordion = class extends BaseAccordion {
  constructor(app, containerEl, settingsService, aiService) {
    super(app, containerEl, settingsService, aiService);
  }
  render() {
    const contentEl = this.createAccordion(
      "\u{1F578} Ontology Generator",
      "Generate ontology tags for your knowledge base."
    );
    this.createDescription(contentEl);
    this.createGenerateButton(contentEl);
  }
  createDescription(containerEl) {
    const descEl = containerEl.createDiv({ cls: "ontology-description" });
    descEl.createEl("p", { text: "The Ontology Generator analyzes your vault's structure, including tags, file names, and folder names, to create a comprehensive set of suggested tags. This tool helps you:" });
    const listEl = descEl.createEl("ul");
    [
      "Discover new connections in your knowledge base",
      "Improve note categorization and searchability",
      "Save time on manual tagging",
      "Gain insights into your collected information"
    ].forEach((item) => {
      listEl.createEl("li", { text: item });
    });
  }
  createGenerateButton(containerEl) {
    this.createButton(
      "",
      "",
      "Generate Ontology",
      () => this.openGeneratorModal(),
      true
    );
  }
  openGeneratorModal() {
    new OntologyGeneratorModal(
      this.app,
      this.aiService,
      this.handleGeneratedOntology.bind(this)
    ).open();
  }
  async handleGeneratedOntology(generatedOntology) {
    const currentSettings = this.settingsService.getSettings();
    const updatedSettings = {
      ...currentSettings,
      ontology: {
        ...currentSettings.ontology,
        lastGenerated: JSON.stringify(generatedOntology)
      }
    };
    await this.settingsService.updateSettings(updatedSettings);
    new import_obsidian24.Notice("Ontology has been successfully generated and saved to your settings.");
  }
};

// src/components/modals/BatchProcessorModal.ts
var import_obsidian25 = require("obsidian");
var BatchProcessorModal = class extends BaseModal {
  constructor(app, aiService, settingsService) {
    super(app);
    this.aiService = aiService;
    this.settingsService = settingsService;
  }
  getTitle() {
    return "Batch Processor";
  }
  renderContent() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Select Files/Folders to Process" });
    const fileExplorer = contentEl.createDiv({ cls: "file-explorer" });
    this.renderVaultStructure(fileExplorer);
    this.createButtons(contentEl);
  }
  async handleSubmit() {
    const selectedPaths = this.getSelectedPaths();
    if (selectedPaths.length === 0) {
      new import_obsidian25.Notice("No files selected for processing. Please select files or folders to update.");
      return;
    }
    this.close();
    await this.processSelectedFiles(selectedPaths);
  }
  renderVaultStructure(containerEl) {
    const rootFolder = this.app.vault.getRoot();
    const validChildren = rootFolder.children.filter(
      (item) => item instanceof import_obsidian25.TFile || item instanceof import_obsidian25.TFolder
    );
    const { folders, files } = this.separateItemsByType(validChildren);
    folders.sort((a, b) => a.name.localeCompare(b.name));
    folders.forEach((folder) => {
      this.renderFolder(containerEl, folder);
    });
    files.sort((a, b) => a.name.localeCompare(b.name));
    files.forEach((file) => {
      containerEl.appendChild(this.createFileElement(file));
    });
  }
  separateItemsByType(items) {
    return items.reduce((acc, item) => {
      if (item instanceof import_obsidian25.TFolder) {
        acc.folders.push(item);
      } else if (item instanceof import_obsidian25.TFile) {
        acc.files.push(item);
      }
      return acc;
    }, { folders: [], files: [] });
  }
  renderFolder(containerEl, folder) {
    const folderEl = this.createFolderElement(folder);
    containerEl.appendChild(folderEl);
    const contentEl = folderEl.querySelector(".folder-content");
    const validChildren = folder.children.filter(
      (item) => item instanceof import_obsidian25.TFile || item instanceof import_obsidian25.TFolder
    );
    const { folders, files } = this.separateItemsByType(validChildren);
    folders.sort((a, b) => a.name.localeCompare(b.name));
    folders.forEach((subfolder) => {
      this.renderFolder(contentEl, subfolder);
    });
    files.sort((a, b) => a.name.localeCompare(b.name));
    files.forEach((file) => {
      contentEl.appendChild(this.createFileElement(file));
    });
  }
  createFolderElement(folder) {
    const folderEl = document.createElement("div");
    folderEl.className = "folder collapsed";
    const nameEl = folderEl.createDiv({ cls: "folder-name" });
    const arrowIcon = nameEl.createSpan({ cls: "collapse-icon" });
    arrowIcon.innerHTML = "\u25B8";
    nameEl.createSpan({ cls: "icon folder-icon", text: "\u{1F4C1}" });
    const checkbox = nameEl.createEl("input", { type: "checkbox" });
    checkbox.className = "folder-checkbox";
    nameEl.createSpan({ text: folder.name });
    const contentEl = folderEl.createDiv({ cls: "folder-content" });
    folderEl.setAttribute("data-path", folder.path);
    nameEl.addEventListener("click", (e) => {
      if (e.target !== checkbox) {
        folderEl.classList.toggle("collapsed");
        arrowIcon.innerHTML = folderEl.classList.contains("collapsed") ? "\u25B8" : "\u25BE";
      }
    });
    checkbox.addEventListener("change", () => {
      this.handleFolderCheckboxChange(checkbox);
      const isChecked = checkbox.checked;
      const childCheckboxes = contentEl.querySelectorAll("input[type='checkbox']");
      childCheckboxes.forEach((childBox) => {
        childBox.checked = isChecked;
        childBox.indeterminate = false;
      });
    });
    return folderEl;
  }
  createFileElement(file) {
    const fileEl = document.createElement("div");
    fileEl.className = "file";
    fileEl.createSpan({ cls: "icon file-icon", text: "\u{1F4C4}" });
    const checkbox = fileEl.createEl("input", { type: "checkbox" });
    checkbox.className = "file-checkbox";
    fileEl.createSpan({ text: file.name });
    fileEl.setAttribute("data-path", file.path);
    checkbox.addEventListener("change", () => this.handleFileCheckboxChange(checkbox));
    return fileEl;
  }
  handleFolderCheckboxChange(checkbox) {
    const folderEl = checkbox.closest(".folder");
    if (!folderEl)
      return;
    const descendantCheckboxes = folderEl.querySelectorAll("input[type='checkbox']");
    descendantCheckboxes.forEach((childCheckbox) => {
      childCheckbox.checked = checkbox.checked;
      childCheckbox.indeterminate = false;
    });
    this.updateParentCheckboxes(checkbox);
  }
  handleFileCheckboxChange(checkbox) {
    this.updateParentCheckboxes(checkbox);
  }
  updateParentCheckboxes(checkbox) {
    super.updateParentCheckboxes(checkbox);
  }
  createButtons(containerEl) {
    const buttonContainer = containerEl.createDiv({ cls: "button-container" });
    buttonContainer.createEl("button", { text: "Cancel", cls: "mod-cancel" }).addEventListener("click", () => this.close());
    buttonContainer.createEl("button", { text: "Confirm", cls: "mod-cta" }).addEventListener("click", () => this.confirmUpdate());
  }
  async confirmUpdate() {
    const selectedPaths = this.getSelectedPaths();
    if (selectedPaths.length === 0) {
      new import_obsidian25.Notice("No files selected for processing. Please select files or folders to update.");
      return;
    }
    this.close();
    await this.processSelectedFiles(selectedPaths);
  }
  getSelectedPaths() {
    const selectedPaths = [];
    const fileCheckboxes = this.contentEl.querySelectorAll(".file-checkbox:checked");
    fileCheckboxes.forEach((checkbox) => {
      const fileEl = checkbox.closest(".file");
      if (fileEl) {
        const path = fileEl.getAttribute("data-path");
        if (path) {
          selectedPaths.push(path);
        }
      }
    });
    return selectedPaths;
  }
  async processSelectedFiles(selectedPaths) {
    const totalFiles = selectedPaths.length;
    let updatedCount = 0;
    let errorCount = 0;
    const progressNotice = new import_obsidian25.Notice(`Processing 0/${totalFiles} files...`, 0);
    for (const path of selectedPaths) {
      try {
        const file = this.app.vault.getAbstractFileByPath(path);
        if (file instanceof import_obsidian25.TFile) {
          await this.updateFile(file);
          updatedCount++;
          progressNotice.setMessage(`Processing ${updatedCount}/${totalFiles} files...`);
        }
      } catch (error) {
        console.error(`Error updating file ${path}:`, error);
        errorCount++;
      }
    }
    progressNotice.hide();
    let message = `Updated ${updatedCount} file${updatedCount !== 1 ? "s" : ""} successfully.`;
    if (errorCount > 0) {
      message += ` Encountered errors in ${errorCount} file${errorCount !== 1 ? "s" : ""}.`;
    }
    new import_obsidian25.Notice(message, 5e3);
  }
  async updateFile(file) {
    const content = await this.app.vault.read(file);
    const updatedContent = await this.processContent(content);
    await this.app.vault.modify(file, updatedContent);
  }
  async processContent(content) {
    let processedContent = content;
    const frontMatterOutput = await this.aiService.generateFrontMatter(processedContent);
    if (frontMatterOutput.success && frontMatterOutput.frontMatter) {
      processedContent = this.addOrUpdateFrontMatter(processedContent, frontMatterOutput.frontMatter);
    }
    const settings = this.settingsService.getSettings();
    return processedContent;
  }
  addOrUpdateFrontMatter(content, newFrontMatter) {
    const frontMatterRegex = /^---\n[\s\S]*?\n---\n*/;
    if (frontMatterRegex.test(content)) {
      return content.replace(frontMatterRegex, `${newFrontMatter}

`);
    } else {
      return `${newFrontMatter}

${content}`;
    }
  }
};

// src/components/accordions/BatchProcessorAccordion.ts
var BatchProcessorAccordion = class extends BaseAccordion {
  constructor(app, containerEl, settingsService, aiService) {
    super(app, containerEl, settingsService, aiService);
  }
  render() {
    const contentEl = this.createAccordion(
      "\u{1F504} Batch Processor",
      "Process multiple files to generate front matter and wikilinks."
    );
    this.createAutoGenerateToggle(contentEl);
    this.createRunBatchProcessorButton(contentEl);
  }
  createAutoGenerateToggle(containerEl) {
    const settings = this.settingsService.getSettings();
    this.createToggleSetting(
      "Auto-generate Front Matter",
      "Automatically generate front matter for new or unprocessed notes when you open your vault.",
      settings.frontMatter.autoGenerate,
      {
        section: "frontMatter",
        key: "autoGenerate",
        value: settings.frontMatter.autoGenerate
      }
    );
  }
  createRunBatchProcessorButton(containerEl) {
    this.createButton(
      "Run Batch Processor",
      "Manually process multiple files to generate front matter and wikilinks.",
      "Run Batch Processor",
      () => {
        const modal = new BatchProcessorModal(this.app, this.aiService, this.settingsService);
        modal.open();
      },
      true
    );
  }
};

// src/components/accordions/KnowledgeBloomAccordion.ts
var import_obsidian26 = require("obsidian");
var KnowledgeBloomAccordion = class extends BaseAccordion {
  constructor(app, containerEl, settingsService, aiService) {
    super(app, containerEl, settingsService, aiService);
    this.app = app;
    this.settingsService = settingsService;
    this.aiService = aiService;
  }
  render() {
    const contentEl = this.createAccordion(
      "\u{1F33A} Knowledge Bloom",
      "Generate notes from wikilinks using templates."
    );
    this.createDescription(contentEl);
    this.createModelSelector(contentEl);
    this.createTemplateFolderSetting(contentEl);
  }
  createDescription(containerEl) {
    const descEl = containerEl.createDiv({ cls: "knowledge-bloom-description" });
    descEl.createEl("p", { text: "Knowledge Bloom analyzes your notes, extracts wikilinks, and generates new notes using your templates." });
  }
  createModelSelector(containerEl) {
    const selectorEl = containerEl.createDiv({ cls: "knowledge-bloom-model-selector" });
    new import_obsidian26.Setting(selectorEl).setName("AI Model").setDesc("Select the AI model to use for Knowledge Bloom").addDropdown((dropdown) => {
      this.modelSelector = dropdown;
      this.updateModelOptions();
      dropdown.onChange(async (value) => {
        await this.settingsService.updateKnowledgeBloomSetting("selectedModel", value);
        this.aiService.reinitialize();
      });
    });
  }
  updateModelOptions() {
    const currentProvider = this.aiService.getCurrentProvider();
    const models = this.aiService.getAvailableModels(currentProvider);
    const currentModel = this.settingsService.getKnowledgeBloomSettings().selectedModel;
    this.modelSelector.selectEl.innerHTML = "";
    models.forEach((model) => {
      this.modelSelector.addOption(model, model);
    });
    if (currentModel && models.includes(currentModel)) {
      this.modelSelector.setValue(currentModel);
    } else if (models.length > 0) {
      this.modelSelector.setValue(models[0]);
      this.settingsService.updateKnowledgeBloomSetting("selectedModel", models[0]);
    }
  }
  createTemplateFolderSetting(containerEl) {
    const knowledgeBloomSettings = this.settingsService.getKnowledgeBloomSettings();
    new import_obsidian26.Setting(containerEl).setName("Templates Folder").setDesc("Path to your templates folder (e.g., 'Templates' or 'Templates/Knowledge Bloom')").addText((text) => {
      this.templateFolderInput = text;
      text.setValue(knowledgeBloomSettings.templateFolder).onChange(async (value) => {
        await this.settingsService.updateKnowledgeBloomSetting("templateFolder", value);
        await this.settingsService.saveSettings();
      });
    });
  }
  // Remove the createGenerateButton and openKnowledgeBloomModal methods as they're no longer needed
};

// src/settings/GraphWeaverSettingTab.ts
var GraphWeaverSettingTab = class extends import_obsidian27.PluginSettingTab {
  // Replace with your actual plugin type
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "GraphWeaver" });
    const modelHookupContainer = containerEl.createDiv();
    new ModelHookupAccordion(
      this.app,
      modelHookupContainer,
      this.plugin.settingsService,
      this.plugin.aiService
    ).render();
    const propertyManagerContainer = containerEl.createDiv();
    new PropertyManagerAccordion(
      this.app,
      propertyManagerContainer,
      this.plugin.settingsService,
      this.plugin.aiService
    ).render();
    const tagManagerContainer = containerEl.createDiv();
    new TagManagerAccordion(
      this.app,
      tagManagerContainer,
      this.plugin.settingsService,
      this.plugin.aiService
    ).render();
    const ontologyGenerationContainer = containerEl.createDiv();
    new OntologyGenerationAccordion(
      this.app,
      ontologyGenerationContainer,
      this.plugin.settingsService,
      this.plugin.aiService
    ).render();
    const knowledgeBloomContainer = containerEl.createDiv();
    new KnowledgeBloomAccordion(
      this.app,
      knowledgeBloomContainer,
      this.plugin.settingsService,
      this.plugin.aiService
    ).render();
    const batchProcessorContainer = containerEl.createDiv();
    new BatchProcessorAccordion(
      this.app,
      batchProcessorContainer,
      this.plugin.settingsService,
      this.plugin.aiService
    ).render();
  }
};

// src/components/modals/KnowledgeBloomModal.ts
var import_obsidian28 = require("obsidian");
var KnowledgeBloomModal = class extends BaseModal {
  constructor(app, sourceFile, settingsService, aiService) {
    super(app);
    this.sourceFile = sourceFile;
    this.settingsService = settingsService;
    this.aiService = aiService;
    this.templates = [];
  }
  getTitle() {
    return "Knowledge Bloom Generator";
  }
  async onOpen() {
    this.titleEl.setText("Knowledge Bloom Generator");
    await this.loadTemplates();
    this.renderContent();
  }
  async loadTemplates() {
    var _a;
    const templateFolder = ((_a = this.settingsService.getSettings().knowledgeBloom) == null ? void 0 : _a.templateFolder) || "";
    if (!templateFolder) {
      new import_obsidian28.Notice("Please set a templates folder in Knowledge Bloom settings.");
      return;
    }
    try {
      const folder = this.app.vault.getAbstractFileByPath(templateFolder);
      if (!folder)
        throw new Error("Templates folder not found");
      this.templates = await this.app.vault.getAllLoadedFiles().filter(
        (file) => file instanceof import_obsidian28.TFile && file.extension === "md" && file.path.startsWith(templateFolder)
      );
    } catch (error) {
      console.error("Error loading templates:", error);
      new import_obsidian28.Notice("Failed to load templates. Check your template folder path.");
    }
  }
  renderContent() {
    const { contentEl } = this;
    new import_obsidian28.Setting(contentEl).setName("Note Template").setDesc("Select a template for the generated notes").addDropdown((dropdown) => {
      this.templateSelect = dropdown;
      this.templates.forEach((template) => {
        dropdown.addOption(template.path, template.basename);
      });
    });
    new import_obsidian28.Setting(contentEl).setName("Additional Context").setDesc("Provide any additional context for note generation").addTextArea((text) => {
      this.contextInput = text;
      text.inputEl.rows = 4;
      text.inputEl.cols = 50;
      return text;
    });
    const buttonContainer = contentEl.createDiv("button-container");
    new import_obsidian28.Setting(buttonContainer).addButton((button) => {
      this.generateButton = button;
      button.setButtonText("Generate Notes").setCta().onClick(() => this.handleGenerate());
    }).addButton(
      (button) => button.setButtonText("Cancel").onClick(() => this.close())
    );
  }
  async handleSubmit() {
    this.close();
  }
  async handleGenerate() {
    const templatePath = this.templateSelect.getValue();
    if (!templatePath) {
      new import_obsidian28.Notice("Please select a template first.");
      return;
    }
    this.generateButton.setDisabled(true);
    this.generateButton.setButtonText("Generating...");
    try {
      const templateFile = this.app.vault.getAbstractFileByPath(templatePath);
      const template = await this.app.vault.read(templateFile);
      const result = await this.aiService.generateKnowledgeBloom(
        this.sourceFile,
        this.contextInput.getValue(),
        template
      );
      if (result.generatedNotes.length > 0) {
        new import_obsidian28.Notice(`Generated ${result.generatedNotes.length} new notes!`);
        this.close();
      } else {
        new import_obsidian28.Notice("No new notes were generated.");
      }
    } catch (error) {
      new import_obsidian28.Notice(`Failed to generate notes: ${error.message}`);
    } finally {
      this.generateButton.setDisabled(false);
      this.generateButton.setButtonText("Generate Notes");
    }
  }
};

// main.ts
var GraphWeaverPlugin = class extends import_obsidian29.Plugin {
  constructor() {
    super(...arguments);
    this.hasProcessedVaultStartup = false;
  }
  /**
   * Initialize plugin on load
   */
  async onload() {
    try {
      await this.initializeServices();
      this.addPluginFunctionality();
    } catch (error) {
      new import_obsidian29.Notice("Error loading GraphWeaver plugin. Check console for details.");
    }
  }
  /**
   * Initialize all plugin services
   */
  async initializeServices() {
    await this.loadSettings();
    this.settingsService = new SettingsService(this, this.settings);
    this.jsonValidationService = new JsonValidationService();
    this.databaseService = new DatabaseService();
    await this.databaseService.load(this.loadData.bind(this));
    this.aiService = new AIService(
      this.app,
      this.settingsService,
      this.jsonValidationService,
      this.databaseService
    );
    this.batchProcessor = new BatchProcessor(
      this.aiService.getCurrentAdapter(),
      this.settingsService,
      this.aiService.frontMatterGenerator,
      this.aiService.wikilinkGenerator,
      this.databaseService,
      this.app
    );
    this.autoGenerateService = new AutoGenerateService(
      this.app,
      this.app.vault,
      this.aiService,
      this.settingsService,
      this.databaseService,
      this.jsonValidationService
    );
  }
  /**
   * Add plugin functionality
   */
  addPluginFunctionality() {
    this.addSettingTab(new GraphWeaverSettingTab(this.app, this));
    this.addRibbonIcon("brain-circuit", "GraphWeaver", this.showPluginMenu.bind(this));
    this.addCommands();
    this.registerEvents();
  }
  /**
   * Register plugin events
   */
  registerEvents() {
    this.registerEvent(
      this.app.workspace.on("layout-change", this.onLayoutChange.bind(this))
    );
  }
  /**
   * Add plugin commands
   */
  addCommands() {
    this.addCommand({
      id: "generate-frontmatter",
      name: "Generate Frontmatter",
      callback: this.generateFrontmatter.bind(this)
    });
    this.addCommand({
      id: "generate-wikilinks",
      name: "Generate Wikilinks",
      callback: this.generateWikilinks.bind(this)
    });
    this.addCommand({
      id: "generate-knowledge-bloom",
      name: "Generate Knowledge Bloom",
      callback: this.generateKnowledgeBloom.bind(this)
    });
  }
  /**
   * Handle layout changes - only triggers vault startup processing once
   */
  onLayoutChange() {
    if (this.app.workspace.layoutReady && !this.hasProcessedVaultStartup) {
      this.onVaultOpen();
    }
  }
  /**
   * Handle vault opening - processes files only on initial startup
   */
  async onVaultOpen() {
    if (this.hasProcessedVaultStartup) {
      return;
    }
    if (this.settings.frontMatter.autoGenerate) {
      await this.autoGenerateService.runAutoGenerate();
      this.hasProcessedVaultStartup = true;
    }
  }
  /**
   * Show plugin menu
   */
  showPluginMenu(evt) {
    const menu = new import_obsidian29.Menu();
    menu.addItem((item) => item.setTitle("Generate Frontmatter").setIcon("file-plus").onClick(this.generateFrontmatter.bind(this)));
    menu.addItem((item) => item.setTitle("Generate Wikilinks").setIcon("link").onClick(this.generateWikilinks.bind(this)));
    menu.addItem((item) => item.setTitle("Generate Knowledge Bloom").setIcon("flower").onClick(this.generateKnowledgeBloom.bind(this)));
    menu.showAtMouseEvent(evt);
  }
  /**
   * Process a single file
   */
  async processFile(file, generateFrontMatter, generateWikilinks) {
    const result = await this.batchProcessor.generate({
      files: [file],
      generateFrontMatter,
      generateWikilinks
    });
    return result.fileResults[0];
  }
  /**
   * Generate front matter for active file
   * Handles UI interaction and coordinates between services
   */
  async generateFrontmatter() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian29.Notice("No active file. Please open a file to generate frontmatter.");
      return;
    }
    try {
      new import_obsidian29.Notice("Generating frontmatter...");
      const result = await this.batchProcessor.generate({
        files: [activeFile],
        generateFrontMatter: true,
        generateWikilinks: false
      });
      if (result.fileResults[0].success) {
        new import_obsidian29.Notice("Frontmatter generated successfully!");
      } else if (result.fileResults[0].error) {
        new import_obsidian29.Notice(`Error: ${result.fileResults[0].error}`);
      }
    } catch (error) {
      console.error("Error generating frontmatter:", error);
      new import_obsidian29.Notice("Error generating frontmatter. Check console for details.");
    }
  }
  /**
   * Generate wikilinks for active file
   * Handles UI interaction and coordinates between services
   */
  async generateWikilinks() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian29.Notice("No active file. Please open a file to generate wikilinks.");
      return;
    }
    try {
      new import_obsidian29.Notice("Generating wikilinks...");
      const result = await this.batchProcessor.generate({
        files: [activeFile],
        generateFrontMatter: false,
        generateWikilinks: true
      });
      if (result.fileResults[0].success) {
        new import_obsidian29.Notice("Wikilinks generated successfully!");
      } else if (result.fileResults[0].error) {
        new import_obsidian29.Notice(`Error: ${result.fileResults[0].error}`);
      }
    } catch (error) {
      console.error("Error generating wikilinks:", error);
      new import_obsidian29.Notice("Error generating wikilinks. Check console for details.");
    }
  }
  /**
   * Generate knowledge bloom for active file
   * Handles UI interaction and file operations
   */
  async generateKnowledgeBloom() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian29.Notice("No active file. Please open a file to generate Knowledge Bloom.");
      return;
    }
    const modal = new KnowledgeBloomModal(
      this.app,
      activeFile,
      this.settingsService,
      this.aiService
    );
    modal.open();
  }
  /**
   * Create or update a note
   */
  async createOrUpdateNote(title, content) {
    const filePath = `${title}.md`;
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian29.TFile) {
      await this.app.vault.modify(file, content);
    } else {
      await this.app.vault.create(filePath, content);
    }
  }
  /**
   * Load plugin settings
   */
  async loadSettings() {
    const data = await this.loadData();
    this.settings = { ...DEFAULT_SETTINGS, ...data };
  }
  /**
   * Save plugin settings
   */
  async saveSettings() {
    await this.saveData(this.settings);
    await this.settingsService.updateSettings(this.settings);
  }
  /**
   * Clean up on plugin unload
   */
  async onunload() {
    await this.databaseService.saveData(this.saveData.bind(this));
    if (this.autoGenerateService) {
      this.autoGenerateService.destroy();
    }
    this.hasProcessedVaultStartup = false;
  }
  // Public getters for plugin state
  getSettings() {
    return this.settings;
  }
  getSettingsService() {
    return this.settingsService;
  }
  getAIService() {
    return this.aiService;
  }
};
