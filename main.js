/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GraphWeaverPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian27 = require("obsidian");

// src/models/AIModels.ts
var AIProvider = /* @__PURE__ */ ((AIProvider2) => {
  AIProvider2["OpenAI"] = "openai";
  AIProvider2["Anthropic"] = "anthropic";
  AIProvider2["Google"] = "google";
  AIProvider2["Groq"] = "groq";
  AIProvider2["OpenRouter"] = "openrouter";
  AIProvider2["LMStudio"] = "lmstudio";
  return AIProvider2;
})(AIProvider || {});
var AIModelMap = {
  ["openai" /* OpenAI */]: [
    {
      name: "GPT 4o mini",
      apiName: "gpt-4o-mini",
      capabilities: {
        maxTokens: 128e3,
        supportsFunctions: true,
        supportsStreaming: true
      }
    },
    {
      name: "GPT 4o",
      apiName: "gpt-4o",
      capabilities: {
        maxTokens: 128e3,
        supportsFunctions: true,
        supportsStreaming: true,
        supportsVision: true
      }
    },
    {
      name: "GPT o1 Preview",
      apiName: "o1-preview",
      capabilities: {
        maxTokens: 128e3,
        supportsFunctions: true,
        supportsStreaming: true
      }
    },
    {
      name: "GPT o1 Mini",
      apiName: "o1-mini",
      capabilities: {
        maxTokens: 128e3,
        supportsFunctions: true,
        supportsStreaming: true
      }
    }
  ],
  ["anthropic" /* Anthropic */]: [
    {
      name: "Claude 3 Haiku",
      apiName: "claude-3-haiku-20240307",
      capabilities: {
        maxTokens: 2e5,
        supportsFunctions: true,
        supportsStreaming: true
      }
    },
    {
      name: "Claude 3 Sonnet",
      apiName: "claude-3-sonnet-20240229",
      capabilities: {
        maxTokens: 2e5,
        supportsFunctions: true,
        supportsStreaming: true,
        supportsVision: true
      }
    },
    {
      name: "Claude 3 Opus",
      apiName: "claude-3-opus-20240229",
      capabilities: {
        maxTokens: 2e5,
        supportsFunctions: true,
        supportsStreaming: true,
        supportsVision: true
      }
    },
    {
      name: "Claude 3.5 Sonnet",
      apiName: "claude-3-5-sonnet-20240620",
      capabilities: {
        maxTokens: 2e5,
        supportsFunctions: true,
        supportsStreaming: true,
        supportsVision: true
      }
    }
  ],
  ["google" /* Google */]: [
    {
      name: "Gemini 1.5 Flash",
      apiName: "gemini-1.5-flash",
      capabilities: {
        maxTokens: 32e3,
        supportsStreaming: true
      }
    },
    {
      name: "Gemini 1.5 Flash 8B",
      apiName: "gemini-1.5-flash-8b",
      capabilities: {
        maxTokens: 32e3,
        supportsStreaming: true
      }
    },
    {
      name: "Gemini 1.5 Pro",
      apiName: "gemini-1.5-pro",
      capabilities: {
        maxTokens: 32e3,
        supportsStreaming: true,
        supportsVision: true
      }
    }
  ],
  ["groq" /* Groq */]: [
    {
      name: "Llama 3.1 70B",
      apiName: "llama-3.1-70b-versatile",
      capabilities: {
        maxTokens: 32e3,
        supportsStreaming: true
      }
    },
    {
      name: "Llama 3.1 8B",
      apiName: "llama-3.1-8b-instant",
      capabilities: {
        maxTokens: 32e3,
        supportsStreaming: true
      }
    },
    {
      name: "Llama 3.2 1B (Preview)",
      apiName: "llama-3.2-1b-preview",
      capabilities: {
        maxTokens: 32e3,
        supportsStreaming: true
      }
    },
    {
      name: "Llama 3.2 3B (Preview)",
      apiName: "llama-3.2-3b-preview",
      capabilities: {
        maxTokens: 32e3,
        supportsStreaming: true
      }
    }
  ],
  ["openrouter" /* OpenRouter */]: [
    {
      name: "Anthropic Claude 3 Haiku",
      apiName: "anthropic/claude-3-haiku",
      capabilities: {
        maxTokens: 2e5,
        supportsFunctions: true,
        supportsStreaming: true
      }
    },
    {
      name: "Anthropic Claude 3 Opus",
      apiName: "anthropic/claude-3-opus",
      capabilities: {
        maxTokens: 2e5,
        supportsFunctions: true,
        supportsStreaming: true,
        supportsVision: true
      }
    },
    {
      name: "Anthropic Claude 3.5 Sonnet",
      apiName: "anthropic/claude-3.5-sonnet",
      capabilities: {
        maxTokens: 2e5,
        supportsFunctions: true,
        supportsStreaming: true,
        supportsVision: true
      }
    },
    {
      name: "Google Gemini Flash 1.5",
      apiName: "google/gemini-flash-1.5",
      capabilities: {
        maxTokens: 32e3,
        supportsStreaming: true
      }
    },
    {
      name: "Google Gemini Flash 1.5 8B",
      apiName: "google/gemini-flash-1.5-8b",
      capabilities: {
        maxTokens: 32e3,
        supportsStreaming: true
      }
    },
    {
      name: "Google Gemini Pro 1.5",
      apiName: "google/gemini-pro-1.5",
      capabilities: {
        maxTokens: 32e3,
        supportsStreaming: true,
        supportsVision: true
      }
    },
    {
      name: "Mistralai Mistral Large",
      apiName: "mistralai/mistral-large",
      capabilities: {
        maxTokens: 32e3,
        supportsStreaming: true
      }
    },
    {
      name: "Mistralai Mistral Nemo",
      apiName: "mistralai/mistral-nemo",
      capabilities: {
        maxTokens: 32e3,
        supportsStreaming: true
      }
    },
    {
      name: "OpenAI GPT 4o",
      apiName: "openai/gpt-4o",
      capabilities: {
        maxTokens: 128e3,
        supportsFunctions: true,
        supportsStreaming: true,
        supportsVision: true
      }
    },
    {
      name: "OpenAI GPT 4o Mini",
      apiName: "openai/gpt-4o-mini",
      capabilities: {
        maxTokens: 128e3,
        supportsFunctions: true,
        supportsStreaming: true
      }
    },
    {
      name: "OpenAI o1 Mini",
      apiName: "openai/o1-mini",
      capabilities: {
        maxTokens: 128e3,
        supportsFunctions: true,
        supportsStreaming: true
      }
    },
    {
      name: "OpenAI o1 Preview",
      apiName: "openai/o1-preview",
      capabilities: {
        maxTokens: 128e3,
        supportsFunctions: true,
        supportsStreaming: true
      }
    }
  ],
  ["lmstudio" /* LMStudio */]: [
    {
      name: "Custom",
      apiName: "custom",
      capabilities: {
        supportsStreaming: false
      }
    }
  ]
};

// src/settings/Settings.ts
var DEFAULT_SETTINGS = {
  aiProvider: {
    selected: "openai" /* OpenAI */,
    apiKeys: {},
    selectedModels: {
      ["openai" /* OpenAI */]: "gpt-4o-mini"
    }
  },
  frontMatter: {
    customProperties: [],
    autoGenerate: false
  },
  tags: {
    customTags: []
  },
  localLMStudio: {
    enabled: false,
    port: 1234,
    modelName: ""
  },
  advanced: {
    maxTokens: 4096,
    temperature: 0.3,
    generateWikilinks: false,
    minWordCount: 5,
    maxLinksPerNote: 10
  },
  ontology: {
    lastGenerated: ""
  },
  knowledgeBloom: {
    selectedModel: "string",
    outputFolder: "",
    overwriteExisting: false,
    defaultPrompt: "Generate a comprehensive note about {LINK}. Include key concepts, definitions, and relevant examples if applicable."
  }
};

// src/services/AIService.ts
var import_obsidian9 = require("obsidian");

// src/adapters/OpenAIAdapter.ts
var import_obsidian = require("obsidian");
var OpenAIAdapter = class {
  constructor(settingsService, jsonValidationService) {
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    const aiProviderSettings = this.settingsService.getSetting("aiProvider");
    this.apiKey = aiProviderSettings.apiKeys["openai" /* OpenAI */] || "";
    this.models = AIModelMap["openai" /* OpenAI */];
  }
  /**
   * Generate a response using the OpenAI API
   */
  async generateResponse(prompt, modelApiName, options) {
    try {
      const apiModel = this.getApiModelName(modelApiName);
      if (!apiModel) {
        throw new Error(`No valid model found for ${this.getProviderType()}`);
      }
      if (!this.apiKey) {
        throw new Error("OpenAI API key is not set");
      }
      const settings = this.settingsService.getSettings();
      const temperature = this.getTemperature(settings);
      const maxTokens = (options == null ? void 0 : options.maxTokens) || this.getMaxTokens(settings);
      const response = await this.makeApiRequest({
        model: apiModel,
        prompt,
        temperature,
        maxTokens,
        rawResponse: options == null ? void 0 : options.rawResponse
      });
      const content = this.extractContentFromResponse(response);
      if (options == null ? void 0 : options.rawResponse) {
        return { success: true, data: content };
      }
      const validatedContent = await this.jsonValidationService.validateAndCleanJson(content);
      return { success: true, data: validatedContent };
    } catch (error) {
      return this.handleError(error);
    }
  }
  /**
   * Test connection to OpenAI API
   */
  async testConnection(prompt, modelApiName) {
    try {
      if (!this.apiKey) {
        return false;
      }
      const response = await this.generateResponse(
        prompt || "Return the word 'OK'.",
        modelApiName,
        { rawResponse: true }
      );
      if (!response.success || typeof response.data !== "string") {
        return false;
      }
      return response.data.toLowerCase().includes("ok");
    } catch (error) {
      console.error("Error in OpenAI test connection:", error);
      return false;
    }
  }
  /**
   * Make a request to the OpenAI API
   */
  async makeApiRequest(params) {
    var _a;
    const response = await (0, import_obsidian.requestUrl)({
      url: "https://api.openai.com/v1/chat/completions",
      method: "POST",
      headers: {
        "Authorization": `Bearer ${this.apiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: params.model,
        messages: [
          {
            role: "system",
            content: params.rawResponse ? "You are a helpful assistant." : "You are a helpful assistant that responds in JSON format."
          },
          { role: "user", content: params.prompt }
        ],
        temperature: params.temperature,
        max_tokens: params.maxTokens,
        n: 1,
        stream: false,
        response_format: params.rawResponse ? void 0 : { type: "json_object" }
      })
    });
    if (response.status !== 200) {
      const errorBody = response.json;
      throw new Error(
        `API request failed with status ${response.status}: ${((_a = errorBody == null ? void 0 : errorBody.error) == null ? void 0 : _a.message) || "Unknown error"}`
      );
    }
    return response;
  }
  /**
   * Extract content from API response
   */
  extractContentFromResponse(response) {
    var _a, _b, _c, _d;
    if (!((_d = (_c = (_b = (_a = response.json) == null ? void 0 : _a.choices) == null ? void 0 : _b[0]) == null ? void 0 : _c.message) == null ? void 0 : _d.content)) {
      throw new Error("Invalid response format from OpenAI API");
    }
    return response.json.choices[0].message.content;
  }
  /**
   * Get temperature setting
   */
  getTemperature(settings) {
    var _a, _b;
    return ((_a = settings.advanced) == null ? void 0 : _a.temperature) >= 0 && ((_b = settings.advanced) == null ? void 0 : _b.temperature) <= 1 ? settings.advanced.temperature : 0.7;
  }
  /**
   * Get max tokens setting
   */
  getMaxTokens(settings) {
    var _a;
    return ((_a = settings.advanced) == null ? void 0 : _a.maxTokens) > 0 ? settings.advanced.maxTokens : 1e3;
  }
  /**
   * Handle errors in API calls
   */
  handleError(error) {
    console.error("Error in OpenAI API call:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    new import_obsidian.Notice(`OpenAI API Error: ${errorMessage}`);
    return { success: false, error: errorMessage };
  }
  /**
   * Validate API key
   */
  async validateApiKey() {
    try {
      if (!this.apiKey) {
        throw new Error("OpenAI API key is not set");
      }
      if (this.models.length === 0) {
        throw new Error("No models available for OpenAI");
      }
      const isValid = await this.testConnection(
        "Return the word 'OK'.",
        this.models[0].apiName
      );
      if (isValid) {
        new import_obsidian.Notice("OpenAI API key validated successfully");
        return true;
      } else {
        throw new Error("Failed to validate API key");
      }
    } catch (error) {
      console.error("Error validating OpenAI API key:", error);
      new import_obsidian.Notice(`Failed to validate OpenAI API key: ${error instanceof Error ? error.message : "Unknown error occurred"}`);
      return false;
    }
  }
  /**
   * Get available models
   */
  getAvailableModels() {
    return this.models.map((model) => model.apiName);
  }
  /**
   * Get provider type
   */
  getProviderType() {
    return "openai" /* OpenAI */;
  }
  /**
   * Set API key
   */
  setApiKey(apiKey) {
    this.apiKey = apiKey;
  }
  /**
   * Get API key
   */
  getApiKey() {
    return this.apiKey;
  }
  /**
   * Configure the adapter
   */
  configure(config) {
    if (config == null ? void 0 : config.apiKey) {
      this.setApiKey(config.apiKey);
    }
  }
  /**
   * Check if adapter is ready
   */
  isReady() {
    return !!this.apiKey && this.models.length > 0;
  }
  /**
   * Get API model name
   */
  getApiModelName(modelApiName) {
    var _a;
    const model = this.models.find((m) => m.apiName === modelApiName);
    if (!model) {
      console.warn(`Model ${modelApiName} not found for ${this.getProviderType()}. Using first available model.`);
      return ((_a = this.models[0]) == null ? void 0 : _a.apiName) || modelApiName;
    }
    return model.apiName;
  }
};

// src/adapters/AnthropicAdapter.ts
var import_obsidian2 = require("obsidian");
var AnthropicAdapter = class {
  constructor(settingsService, jsonValidationService) {
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    const aiProviderSettings = this.settingsService.getSetting("aiProvider");
    this.apiKey = aiProviderSettings.apiKeys["anthropic" /* Anthropic */] || "";
    this.models = AIModelMap["anthropic" /* Anthropic */];
  }
  async generateResponse(prompt, modelApiName, options) {
    try {
      const apiModel = this.getApiModelName(modelApiName);
      if (!apiModel) {
        throw new Error(`Invalid model: ${modelApiName} for ${this.getProviderType()}`);
      }
      if (!this.apiKey) {
        throw new Error("Anthropic API key is not set");
      }
      const settings = this.settingsService.getSettings();
      const temperature = this.getTemperature(settings);
      const maxTokens = (options == null ? void 0 : options.maxTokens) || this.getMaxTokens(settings);
      const response = await this.makeApiRequest(apiModel, prompt, temperature, maxTokens);
      const content = this.extractContentFromResponse(response);
      if (options == null ? void 0 : options.rawResponse) {
        return { success: true, data: content };
      }
      const validatedContent = await this.jsonValidationService.validateAndCleanJson(content);
      return { success: true, data: validatedContent };
    } catch (error) {
      return this.handleError(error);
    }
  }
  async testConnection(prompt, modelApiName) {
    try {
      if (!this.apiKey) {
        throw new Error("Anthropic API key is not set");
      }
      const apiModel = this.getApiModelName(modelApiName);
      const response = await this.makeApiRequest(apiModel, prompt, 0.7, 50);
      const content = this.extractContentFromResponse(response);
      return content.toLowerCase().includes("ok");
    } catch (error) {
      console.error("Error in Anthropic test connection:", error);
      return false;
    }
  }
  getTemperature(settings) {
    return settings.advanced.temperature >= 0 && settings.advanced.temperature <= 1 ? settings.advanced.temperature : 0.7;
  }
  getMaxTokens(settings) {
    return settings.advanced.maxTokens > 0 ? settings.advanced.maxTokens : 1e3;
  }
  async makeApiRequest(apiModel, prompt, temperature, maxTokens) {
    const requestBody = {
      model: apiModel,
      messages: [{ role: "user", content: prompt }],
      max_tokens: maxTokens,
      temperature
    };
    const response = await (0, import_obsidian2.requestUrl)({
      url: "https://api.anthropic.com/v1/messages",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.apiKey,
        "anthropic-version": "2023-06-01"
      },
      body: JSON.stringify(requestBody)
    });
    if (response.status !== 200) {
      throw new Error(`API request failed with status ${response.status}: ${response.text}`);
    }
    return response;
  }
  extractContentFromResponse(response) {
    return response.json.content[0].text;
  }
  handleError(error) {
    console.error("Error in Anthropic API call:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    new import_obsidian2.Notice(`Anthropic API Error: ${errorMessage}`);
    return { success: false, error: errorMessage };
  }
  async validateApiKey() {
    try {
      if (!this.apiKey) {
        throw new Error("Anthropic API key is not set");
      }
      const response = await this.testConnection("Return the word 'OK'.", this.models[0].apiName);
      if (response) {
        new import_obsidian2.Notice("Anthropic API key validated successfully");
        return true;
      } else {
        throw new Error("Failed to validate API key");
      }
    } catch (error) {
      console.error("Error validating Anthropic API key:", error);
      new import_obsidian2.Notice(`Failed to validate Anthropic API key: ${error instanceof Error ? error.message : "Unknown error occurred"}`);
      return false;
    }
  }
  getAvailableModels() {
    return this.models.map((model) => model.apiName);
  }
  getProviderType() {
    return "anthropic" /* Anthropic */;
  }
  setApiKey(apiKey) {
    this.apiKey = apiKey;
  }
  getApiKey() {
    return this.apiKey;
  }
  configure(config) {
  }
  isReady() {
    return !!this.apiKey;
  }
  getApiModelName(modelApiName) {
    const model = this.models.find((m) => m.apiName === modelApiName);
    if (!model) {
      throw new Error(`Model ${modelApiName} not found for ${this.getProviderType()}`);
    }
    return model.apiName;
  }
};

// src/adapters/GeminiAdapter.ts
var import_obsidian3 = require("obsidian");
var GeminiAdapter = class {
  constructor(settingsService, jsonValidationService) {
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    const aiProviderSettings = this.settingsService.getSetting("aiProvider");
    this.apiKey = aiProviderSettings.apiKeys["google" /* Google */] || "";
    this.models = AIModelMap["google" /* Google */];
  }
  /**
   * Generate a response using the Gemini API
   */
  async generateResponse(prompt, modelApiName, options) {
    try {
      const apiModel = this.getApiModelName(modelApiName);
      if (!apiModel) {
        throw new Error(`No valid model found for ${this.getProviderType()}`);
      }
      if (!this.apiKey) {
        throw new Error("Google API key is not set");
      }
      const settings = this.settingsService.getSettings();
      const temperature = this.getTemperature(settings);
      const maxTokens = (options == null ? void 0 : options.maxTokens) || this.getMaxTokens(settings);
      const response = await this.makeApiRequest({
        model: apiModel,
        prompt,
        temperature,
        maxTokens,
        rawResponse: options == null ? void 0 : options.rawResponse
      });
      const content = this.extractContentFromResponse(response);
      if (options == null ? void 0 : options.rawResponse) {
        return { success: true, data: content };
      }
      try {
        const validatedContent = await this.jsonValidationService.validateAndCleanJson(content);
        return { success: true, data: validatedContent };
      } catch (jsonError) {
        return {
          success: true,
          data: { response: content }
        };
      }
    } catch (error) {
      return this.handleError(error);
    }
  }
  /**
   * Test connection to Gemini API
   */
  async testConnection(prompt, modelApiName) {
    try {
      if (!this.apiKey) {
        return false;
      }
      const response = await this.generateResponse(
        prompt || "Return the word 'OK'.",
        modelApiName,
        { rawResponse: true }
      );
      if (!response.success || typeof response.data !== "string") {
        return false;
      }
      return response.data.toLowerCase().includes("ok");
    } catch (error) {
      console.error("Error in Gemini test connection:", error);
      return false;
    }
  }
  /**
   * Make a request to the Gemini API
   */
  async makeApiRequest(params) {
    var _a;
    const systemPrompt = params.rawResponse ? "You are a helpful assistant." : "You are a helpful assistant that responds in JSON format. Your response should be valid JSON with a 'response' field containing your answer.";
    const requestBody = {
      contents: [
        {
          parts: [
            { text: systemPrompt },
            { text: params.prompt }
          ]
        }
      ],
      generationConfig: {
        temperature: params.temperature,
        maxOutputTokens: params.maxTokens,
        topK: 40,
        topP: 0.95
      }
    };
    const response = await (0, import_obsidian3.requestUrl)({
      url: `https://generativelanguage.googleapis.com/v1/models/${params.model}:generateContent`,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-goog-api-key": this.apiKey
      },
      body: JSON.stringify(requestBody)
    });
    if (response.status !== 200) {
      const errorBody = response.json;
      throw new Error(
        `API request failed with status ${response.status}: ${((_a = errorBody == null ? void 0 : errorBody.error) == null ? void 0 : _a.message) || response.text}`
      );
    }
    return response;
  }
  /**
   * Extract content from Gemini API response
   */
  extractContentFromResponse(response) {
    var _a, _b, _c, _d, _e, _f;
    if (!((_f = (_e = (_d = (_c = (_b = (_a = response.json) == null ? void 0 : _a.candidates) == null ? void 0 : _b[0]) == null ? void 0 : _c.content) == null ? void 0 : _d.parts) == null ? void 0 : _e[0]) == null ? void 0 : _f.text)) {
      throw new Error("Invalid response format from Gemini API");
    }
    const content = response.json.candidates[0].content;
    return content.parts[0].text;
  }
  /**
   * Get temperature setting
   */
  getTemperature(settings) {
    var _a, _b;
    return ((_a = settings.advanced) == null ? void 0 : _a.temperature) >= 0 && ((_b = settings.advanced) == null ? void 0 : _b.temperature) <= 1 ? settings.advanced.temperature : 0.7;
  }
  /**
   * Get max tokens setting
   */
  getMaxTokens(settings) {
    var _a;
    return ((_a = settings.advanced) == null ? void 0 : _a.maxTokens) > 0 ? settings.advanced.maxTokens : 1e3;
  }
  /**
   * Handle errors in API calls
   */
  handleError(error) {
    console.error("Error in Gemini API call:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    new import_obsidian3.Notice(`Gemini API Error: ${errorMessage}`);
    return { success: false, error: errorMessage };
  }
  /**
   * Validate API key
   */
  async validateApiKey() {
    try {
      if (!this.apiKey) {
        throw new Error("Google API key is not set");
      }
      if (this.models.length === 0) {
        throw new Error("No models available for Gemini");
      }
      const isValid = await this.testConnection(
        "Return the word 'OK'.",
        this.models[0].apiName
      );
      if (isValid) {
        new import_obsidian3.Notice("Gemini API key validated successfully");
        return true;
      } else {
        throw new Error("Failed to validate API key");
      }
    } catch (error) {
      console.error("Error validating Gemini API key:", error);
      new import_obsidian3.Notice(`Failed to validate Gemini API key: ${error instanceof Error ? error.message : "Unknown error occurred"}`);
      return false;
    }
  }
  /**
   * Get available models
   */
  getAvailableModels() {
    return this.models.map((model) => model.apiName);
  }
  /**
   * Get provider type
   */
  getProviderType() {
    return "google" /* Google */;
  }
  /**
   * Set API key
   */
  setApiKey(apiKey) {
    this.apiKey = apiKey;
  }
  /**
   * Get API key
   */
  getApiKey() {
    return this.apiKey;
  }
  /**
   * Configure the adapter
   */
  configure(config) {
    if (config == null ? void 0 : config.apiKey) {
      this.setApiKey(config.apiKey);
    }
  }
  /**
   * Check if adapter is ready
   */
  isReady() {
    return !!this.apiKey && this.models.length > 0;
  }
  /**
   * Get API model name
   */
  getApiModelName(modelApiName) {
    var _a;
    const model = this.models.find((m) => m.apiName === modelApiName);
    if (!model) {
      console.warn(`Model ${modelApiName} not found for ${this.getProviderType()}. Using first available model.`);
      return ((_a = this.models[0]) == null ? void 0 : _a.apiName) || modelApiName;
    }
    return model.apiName;
  }
};

// src/adapters/GroqAdapter.ts
var import_obsidian4 = require("obsidian");
var GroqAdapter = class {
  constructor(settingsService, jsonValidationService) {
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    const aiProviderSettings = this.settingsService.getSetting("aiProvider");
    this.apiKey = aiProviderSettings.apiKeys["groq" /* Groq */] || "";
    this.models = AIModelMap["groq" /* Groq */];
  }
  /**
   * Generate a response using the Groq API
   */
  async generateResponse(prompt, modelApiName, options) {
    try {
      const apiModel = this.getApiModelName(modelApiName);
      if (!apiModel) {
        throw new Error(`No valid model found for ${this.getProviderType()}`);
      }
      if (!this.apiKey) {
        throw new Error("Groq API key is not set");
      }
      const settings = this.settingsService.getSettings();
      const temperature = this.getTemperature(settings);
      const maxTokens = (options == null ? void 0 : options.maxTokens) || this.getMaxTokens(settings);
      const response = await this.makeApiRequest({
        model: apiModel,
        prompt,
        temperature,
        maxTokens,
        rawResponse: options == null ? void 0 : options.rawResponse
      });
      const content = this.extractContentFromResponse(response);
      if (options == null ? void 0 : options.rawResponse) {
        return { success: true, data: content };
      }
      const validatedContent = await this.jsonValidationService.validateAndCleanJson(content);
      return { success: true, data: validatedContent };
    } catch (error) {
      return this.handleError(error);
    }
  }
  /**
   * Test connection to Groq API
   */
  async testConnection(prompt, modelApiName) {
    try {
      if (!this.apiKey) {
        throw new Error("Groq API key is not set");
      }
      const response = await this.generateResponse(
        prompt || "Return the word 'OK'.",
        modelApiName,
        { rawResponse: true }
      );
      if (!response.success || typeof response.data !== "string") {
        return false;
      }
      return response.data.toLowerCase().includes("ok");
    } catch (error) {
      console.error("Error in Groq test connection:", error);
      return false;
    }
  }
  /**
   * Make a request to the Groq API
   */
  async makeApiRequest(params) {
    var _a;
    const response = await (0, import_obsidian4.requestUrl)({
      url: "https://api.groq.com/openai/v1/chat/completions",
      method: "POST",
      headers: {
        "Authorization": `Bearer ${this.apiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: params.model,
        messages: [
          {
            role: "system",
            content: params.rawResponse ? "You are a helpful assistant." : "You are a helpful assistant that responds in JSON format."
          },
          { role: "user", content: params.prompt }
        ],
        temperature: params.temperature,
        max_tokens: params.maxTokens,
        response_format: params.rawResponse ? void 0 : { type: "json_object" }
      })
    });
    if (response.status !== 200) {
      const errorBody = response.json;
      throw new Error(
        `API request failed with status ${response.status}: ${((_a = errorBody == null ? void 0 : errorBody.error) == null ? void 0 : _a.message) || "Unknown error"}`
      );
    }
    return response;
  }
  /**
   * Extract content from API response
   */
  extractContentFromResponse(response) {
    var _a, _b, _c, _d;
    if (!((_d = (_c = (_b = (_a = response.json) == null ? void 0 : _a.choices) == null ? void 0 : _b[0]) == null ? void 0 : _c.message) == null ? void 0 : _d.content)) {
      throw new Error("Invalid response format from Groq API");
    }
    return response.json.choices[0].message.content;
  }
  /**
   * Get temperature setting
   */
  getTemperature(settings) {
    var _a, _b;
    return ((_a = settings.advanced) == null ? void 0 : _a.temperature) >= 0 && ((_b = settings.advanced) == null ? void 0 : _b.temperature) <= 1 ? settings.advanced.temperature : 0.7;
  }
  /**
   * Get max tokens setting
   */
  getMaxTokens(settings) {
    var _a;
    return ((_a = settings.advanced) == null ? void 0 : _a.maxTokens) > 0 ? settings.advanced.maxTokens : 1e3;
  }
  /**
   * Handle errors in API calls
   */
  handleError(error) {
    console.error("Error in Groq API call:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    new import_obsidian4.Notice(`Groq API Error: ${errorMessage}`);
    return { success: false, error: errorMessage };
  }
  /**
   * Validate API key
   */
  async validateApiKey() {
    try {
      if (!this.apiKey) {
        throw new Error("Groq API key is not set");
      }
      if (this.models.length === 0) {
        throw new Error("No models available for Groq");
      }
      const isValid = await this.testConnection(
        "Return the word 'OK'.",
        this.models[0].apiName
      );
      if (isValid) {
        new import_obsidian4.Notice("Groq API key validated successfully");
        return true;
      } else {
        throw new Error("Failed to validate API key");
      }
    } catch (error) {
      console.error("Error validating Groq API key:", error);
      new import_obsidian4.Notice(`Failed to validate Groq API key: ${error instanceof Error ? error.message : "Unknown error occurred"}`);
      return false;
    }
  }
  /**
   * Get available models
   */
  getAvailableModels() {
    return this.models.map((model) => model.apiName);
  }
  /**
   * Get provider type
   */
  getProviderType() {
    return "groq" /* Groq */;
  }
  /**
   * Set API key
   */
  setApiKey(apiKey) {
    this.apiKey = apiKey;
  }
  /**
   * Get API key
   */
  getApiKey() {
    return this.apiKey;
  }
  /**
   * Configure the adapter
   */
  configure(config) {
    if (config == null ? void 0 : config.apiKey) {
      this.setApiKey(config.apiKey);
    }
  }
  /**
   * Check if adapter is ready
   */
  isReady() {
    return !!this.apiKey && this.models.length > 0;
  }
  /**
   * Get API model name
   */
  getApiModelName(modelApiName) {
    var _a;
    const model = this.models.find((m) => m.apiName === modelApiName);
    if (!model) {
      console.warn(`Model ${modelApiName} not found for ${this.getProviderType()}. Using first available model.`);
      return ((_a = this.models[0]) == null ? void 0 : _a.apiName) || modelApiName;
    }
    return model.apiName;
  }
};

// src/adapters/OpenRouterAdapter.ts
var import_obsidian5 = require("obsidian");
var OpenRouterAdapter = class {
  constructor(settingsService, jsonValidationService) {
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    const aiProviderSettings = this.settingsService.getSetting("aiProvider");
    this.apiKey = aiProviderSettings.apiKeys["openrouter" /* OpenRouter */] || "";
    this.models = AIModelMap["openrouter" /* OpenRouter */];
  }
  /**
   * Generate a response using the OpenRouter API
   */
  async generateResponse(prompt, modelApiName, options) {
    try {
      const apiModel = this.getApiModelName(modelApiName);
      if (!apiModel) {
        throw new Error(`No valid model found for ${this.getProviderType()}`);
      }
      if (!this.apiKey) {
        throw new Error("OpenRouter API key is not set");
      }
      const settings = this.settingsService.getSettings();
      const temperature = this.getTemperature(settings);
      const maxTokens = (options == null ? void 0 : options.maxTokens) || this.getMaxTokens(settings);
      const response = await this.makeApiRequest(
        apiModel,
        prompt,
        temperature,
        maxTokens,
        options == null ? void 0 : options.rawResponse
      );
      const content = this.extractContentFromResponse(response);
      if (options == null ? void 0 : options.rawResponse) {
        return { success: true, data: content };
      }
      const validatedContent = await this.jsonValidationService.validateAndCleanJson(content);
      return { success: true, data: validatedContent };
    } catch (error) {
      return this.handleError(error);
    }
  }
  /**
   * Test connection to OpenRouter API
   */
  async testConnection(prompt, modelApiName) {
    try {
      if (!this.apiKey) {
        return false;
      }
      const response = await this.generateResponse(
        prompt || "Return the word 'OK'.",
        modelApiName,
        { rawResponse: true }
      );
      if (!response.success || typeof response.data !== "string") {
        return false;
      }
      return response.data.toLowerCase().includes("ok");
    } catch (error) {
      console.error("Error in OpenRouter test connection:", error);
      return false;
    }
  }
  /**
   * Make a request to the OpenRouter API
   */
  async makeApiRequest(apiModel, prompt, temperature, maxTokens, rawResponse) {
    const response = await (0, import_obsidian5.requestUrl)({
      url: `https://openrouter.ai/api/v1/chat/completions`,
      method: "POST",
      headers: {
        "Authorization": `Bearer ${this.apiKey}`,
        "Content-Type": "application/json",
        "HTTP-Referer": "https://github.com/yourusername/obsidian-plugin",
        // Replace with your plugin's URL
        "X-Title": "Obsidian Plugin"
        // Replace with your plugin's name
      },
      body: JSON.stringify({
        model: apiModel,
        messages: [
          {
            role: "system",
            content: rawResponse ? "You are a helpful assistant." : "You are a helpful assistant that responds in JSON format."
          },
          { role: "user", content: prompt }
        ],
        temperature,
        max_tokens: maxTokens,
        response_format: rawResponse ? void 0 : { type: "json_object" }
      })
    });
    if (response.status !== 200) {
      throw new Error(`API request failed with status ${response.status}`);
    }
    return response;
  }
  /**
   * Extract content from API response
   */
  extractContentFromResponse(response) {
    var _a, _b, _c, _d;
    if (!((_d = (_c = (_b = (_a = response.json) == null ? void 0 : _a.choices) == null ? void 0 : _b[0]) == null ? void 0 : _c.message) == null ? void 0 : _d.content)) {
      throw new Error("Invalid response format from OpenRouter API");
    }
    return response.json.choices[0].message.content;
  }
  /**
   * Get temperature setting
   */
  getTemperature(settings) {
    var _a, _b;
    return ((_a = settings.advanced) == null ? void 0 : _a.temperature) >= 0 && ((_b = settings.advanced) == null ? void 0 : _b.temperature) <= 1 ? settings.advanced.temperature : 0.7;
  }
  /**
   * Get max tokens setting
   */
  getMaxTokens(settings) {
    var _a;
    return ((_a = settings.advanced) == null ? void 0 : _a.maxTokens) > 0 ? settings.advanced.maxTokens : 1e3;
  }
  /**
   * Handle errors in API calls
   */
  handleError(error) {
    console.error("Error in OpenRouter API call:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    new import_obsidian5.Notice(`OpenRouter API Error: ${errorMessage}`);
    return { success: false, error: errorMessage };
  }
  /**
   * Validate API key
   */
  async validateApiKey() {
    try {
      if (!this.apiKey) {
        throw new Error("OpenRouter API key is not set");
      }
      if (this.models.length === 0) {
        throw new Error("No models available for OpenRouter");
      }
      const isValid = await this.testConnection(
        "Return the word 'OK'.",
        this.models[0].apiName
      );
      if (isValid) {
        new import_obsidian5.Notice("OpenRouter API key validated successfully");
        return true;
      } else {
        throw new Error("Failed to validate API key");
      }
    } catch (error) {
      console.error("Error validating OpenRouter API key:", error);
      new import_obsidian5.Notice(`Failed to validate OpenRouter API key: ${error instanceof Error ? error.message : "Unknown error occurred"}`);
      return false;
    }
  }
  /**
   * Get available models
   */
  getAvailableModels() {
    return this.models.map((model) => model.apiName);
  }
  /**
   * Get provider type
   */
  getProviderType() {
    return "openrouter" /* OpenRouter */;
  }
  /**
   * Set API key
   */
  setApiKey(apiKey) {
    this.apiKey = apiKey;
  }
  /**
   * Get API key
   */
  getApiKey() {
    return this.apiKey;
  }
  /**
   * Configure the adapter
   */
  configure(config) {
    if (config == null ? void 0 : config.apiKey) {
      this.setApiKey(config.apiKey);
    }
  }
  /**
   * Check if adapter is ready
   */
  isReady() {
    return !!this.apiKey && this.models.length > 0;
  }
  /**
   * Get API model name
   */
  getApiModelName(modelApiName) {
    var _a;
    const model = this.models.find((m) => m.apiName === modelApiName);
    if (!model) {
      console.warn(`Model ${modelApiName} not found for ${this.getProviderType()}. Using first available model.`);
      return ((_a = this.models[0]) == null ? void 0 : _a.apiName) || modelApiName;
    }
    return model.apiName;
  }
};

// src/adapters/LMStudioAdapter.ts
var import_obsidian6 = require("obsidian");
var LMStudioAdapter = class {
  constructor(settingsService, jsonValidationService) {
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    this.updateSettings();
  }
  async generateResponse(prompt, model = "default", options) {
    try {
      if (!this.isReady()) {
        throw new Error("LM Studio settings are not properly configured");
      }
      const response = await (0, import_obsidian6.requestUrl)({
        url: `http://localhost:${this.port}/v1/chat/completions`,
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          model: this.model,
          messages: [
            {
              role: "system",
              content: (options == null ? void 0 : options.rawResponse) ? "You are a helpful assistant." : "You are a helpful assistant that responds in JSON format."
            },
            {
              role: "user",
              content: prompt
            }
          ],
          response_format: (options == null ? void 0 : options.rawResponse) ? void 0 : {
            type: "json_schema",
            json_schema: this.createJsonSchema()
          },
          temperature: 0.7,
          max_tokens: (options == null ? void 0 : options.maxTokens) || 1e3,
          stream: false
        })
      });
      if (response.status !== 200) {
        throw new Error(`API request failed with status ${response.status}`);
      }
      const content = response.json.choices[0].message.content;
      if (options == null ? void 0 : options.rawResponse) {
        return {
          success: true,
          data: content
        };
      }
      const validatedContent = await this.jsonValidationService.validateAndCleanJson(content);
      return {
        success: true,
        data: validatedContent
      };
    } catch (error) {
      console.error("Error in LM Studio API call:", error);
      new import_obsidian6.Notice(`LM Studio API Error: ${error instanceof Error ? error.message : "Unknown error occurred"}`);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error occurred"
      };
    }
  }
  createJsonSchema() {
    return {
      name: "assistant_response",
      strict: "true",
      schema: {
        type: "object",
        properties: {
          response: {
            type: "string"
          }
        },
        required: ["response"]
      }
    };
  }
  async testConnection(prompt, model = "default") {
    try {
      if (!this.isReady()) {
        return false;
      }
      const response = await this.generateResponse("Return the word 'OK'.", model);
      if (!response.success || !response.data) {
        return false;
      }
      if (typeof response.data === "object" && response.data !== null && "response" in response.data && typeof response.data.response === "string") {
        return response.data.response.toLowerCase().includes("ok");
      }
      return false;
    } catch (error) {
      console.error("Error in LM Studio test connection:", error);
      return false;
    }
  }
  async validateApiKey() {
    return this.isReady();
  }
  getAvailableModels() {
    return [this.model];
  }
  getProviderType() {
    return "lmstudio" /* LMStudio */;
  }
  setApiKey(apiKey) {
  }
  getApiKey() {
    return "";
  }
  configure(config) {
    if (config.model) {
      this.model = config.model;
    }
    if (config.port) {
      this.port = config.port.toString();
    }
    this.settingsService.updateNestedSetting("localLMStudio", "modelName", this.model);
    this.settingsService.updateNestedSetting("localLMStudio", "port", parseInt(this.port, 10));
  }
  isReady() {
    return !!this.model && !!this.port;
  }
  getApiModelName(modelName) {
    return modelName;
  }
  updateSettings() {
    const localLMStudioSettings = this.settingsService.getSetting("localLMStudio");
    this.model = localLMStudioSettings.modelName;
    this.port = localLMStudioSettings.port.toString();
  }
};

// src/generators/BaseGenerator.ts
var BaseGenerator = class {
  constructor(aiAdapter, settingsService) {
    this.aiAdapter = aiAdapter;
    this.settingsService = settingsService;
  }
  /**
   * Generate content based on input and settings.
   * @param input The input data for generation
   * @returns Promise resolving to the generated content
   */
  async generate(input) {
    try {
      if (!this.validateInput(input)) {
        throw new Error("Invalid input provided");
      }
      const prompt = this.preparePrompt(input);
      const model = await this.getCurrentModel();
      const aiResponse = await this.aiAdapter.generateResponse(prompt, model);
      if (!aiResponse.success || !aiResponse.data) {
        throw new Error(aiResponse.error || "Failed to generate content");
      }
      return this.formatOutput(aiResponse.data, input);
    } catch (error) {
      return this.handleError(error);
    }
  }
  /**
   * Get the current model for this generator.
   * @returns The model identifier string
   */
  async getCurrentModel() {
    const settings = this.getSettings();
    const selectedModel = this.getSelectedModel(settings);
    if (!selectedModel) {
      throw new Error(`No model selected for ${this.constructor.name}`);
    }
    return selectedModel;
  }
  /**
   * Get the selected model from settings.
   * Can be overridden by subclasses to use specific model settings.
   */
  getSelectedModel(settings) {
    var _a, _b;
    const provider = this.aiAdapter.getProviderType();
    return (_b = (_a = settings.aiProvider) == null ? void 0 : _a.selectedModels) == null ? void 0 : _b[provider];
  }
  /**
   * Get the current settings for this generator.
   */
  getSettings() {
    return this.settingsService.getSettings();
  }
  /**
   * Validate the input before generation.
   * @param input The input to validate
   */
  validateInput(input) {
    return input !== null && input !== void 0;
  }
  /**
   * Handle errors that occur during generation.
   * @param error The error that occurred
   */
  handleError(error) {
    const errorMessage = `${this.constructor.name} error: ${error.message}`;
    console.error(errorMessage);
    throw new Error(errorMessage);
  }
  /**
   * Utility method to clean and format text content
   */
  cleanContent(content) {
    return content.trim().replace(/\n{3,}/g, "\n\n");
  }
  /**
   * Utility method to validate JSON data
   */
  isValidJson(data) {
    try {
      JSON.parse(JSON.stringify(data));
      return true;
    } catch (e) {
      return false;
    }
  }
};

// src/generators/FrontMatterGenerator.ts
var FrontMatterGenerator = class extends BaseGenerator {
  constructor(aiAdapter, settingsService, jsonSchemaGenerator) {
    super(aiAdapter, settingsService);
    this.jsonSchemaGenerator = jsonSchemaGenerator;
  }
  /**
   * Generates front matter for the provided content
   * @param input The input containing content and optional properties
   * @returns Promise resolving to content with front matter
   */
  async generate(input) {
    console.log("FrontMatterGenerator: Starting generation");
    try {
      const settings = this.getSettings();
      const completeInput = {
        ...input,
        customProperties: input.customProperties || settings.frontMatter.customProperties,
        customTags: input.customTags || settings.tags.customTags.map((tag) => tag.name)
      };
      const prompt = this.preparePrompt(completeInput);
      const model = await this.getCurrentModel();
      console.log("FrontMatterGenerator: Sending request to AI");
      const aiResponse = await this.aiAdapter.generateResponse(prompt, model);
      if (!aiResponse.success || !aiResponse.data) {
        console.error("FrontMatterGenerator: AI response was unsuccessful or empty");
        return { content: input.content };
      }
      return this.formatOutput(aiResponse.data, completeInput);
    } catch (error) {
      console.error("FrontMatterGenerator: Error during generation:", error);
      return { content: input.content };
    }
  }
  /**
   * Prepares the AI prompt with schema and context
   * @param input The input containing content and properties
   * @returns Formatted prompt string
   */
  preparePrompt(input) {
    var _a, _b;
    const schema = this.jsonSchemaGenerator.generateBaseSchema();
    const propertyPrompt = ((_a = input.customProperties) == null ? void 0 : _a.map(
      (prop) => `${prop.name} (${prop.type}): ${prop.description}`
    ).join("\n")) || "";
    const tagPrompt = ((_b = input.customTags) == null ? void 0 : _b.join(", ")) || "";
    return `
# MISSION
Act as an expert analyzer and creator of metadata, with a specialization in ontological organization. Use the custom properties and available tags below to generate JSON formatted text based on the provided schema, using the note content for reference.

# GUIDELINES
- You must ONLY use the properties provided, taking the description of the property as guidance for generation.
- Prioritize use of the available tags, but remain flexible in choosing additional tags that would be useful in labelling the note content.
- Omit all other text including words before or after or backticks, returning ONLY the formatted JSON.

## Custom Properties
${propertyPrompt}

## Available Tags
${tagPrompt}

## Note Content
Below is the content of the note you can use to generate completed JSON schema. Omit it from your generation.
${input.content}

## JSON Schema:
${JSON.stringify(schema, null, 2)}

Remember, return only the properly formatted JSON with no words before or after, or backticks.
`;
  }
  /**
   * Formats AI response into proper front matter structure
   * @param aiResponse The AI response data
   * @param originalInput The original input parameters
   * @returns Formatted output with front matter
   */
  formatOutput(aiResponse, originalInput) {
    const parsedResponse = this.parseAIResponse(aiResponse);
    if (!parsedResponse) {
      return { content: originalInput.content };
    }
    const frontMatter = this.convertToFrontMatter(parsedResponse);
    const finalContent = this.mergeFrontMatter(originalInput.content, frontMatter);
    return { content: finalContent };
  }
  /**
   * Parses and validates AI response
   */
  parseAIResponse(data) {
    if (typeof data === "object" && data !== null) {
      return data;
    }
    try {
      const parsed = JSON.parse(data);
      if (typeof parsed === "object" && parsed !== null) {
        return parsed;
      }
    } catch (error) {
      console.error("Error parsing AI response:", error);
    }
    return null;
  }
  /**
   * Converts parsed response to YAML front matter format
   */
  convertToFrontMatter(data) {
    return Object.entries(data).map(([key, value]) => {
      if (Array.isArray(value)) {
        return `${key}:
${value.map((item) => `  - ${item}`).join("\n")}`;
      } else if (typeof value === "object" && value !== null) {
        return `${key}: ${JSON.stringify(value)}`;
      } else {
        return `${key}: ${value}`;
      }
    }).join("\n");
  }
  /**
   * Merges front matter with original content
   */
  mergeFrontMatter(content, frontMatter) {
    const hasFrontMatter = content.trim().startsWith("---");
    if (!hasFrontMatter) {
      return `---
${frontMatter}
---

${content.trim()}`;
    }
    const parts = content.split("---");
    if (parts.length >= 3) {
      const existingFrontMatter = parts[1].trim();
      const contentParts = parts.slice(2).join("---").trim();
      return `---
${frontMatter}
---
${contentParts}`;
    }
    return `---
${frontMatter}
---

${content.trim()}`;
  }
  /**
   * Validates input parameters
   */
  validateInput(input) {
    return typeof input.content === "string" && input.content.trim().length > 0;
  }
  /**
   * Gets the current AI model
   */
  async getCurrentModel() {
    var _a, _b;
    const settings = this.getSettings();
    const providerType = this.aiAdapter.getProviderType();
    const modelApiName = (_b = (_a = settings.aiProvider) == null ? void 0 : _a.selectedModels) == null ? void 0 : _b[providerType];
    if (!modelApiName) {
      throw new Error(`No model selected for provider: ${providerType}`);
    }
    return modelApiName;
  }
};

// src/generators/WikilinkGenerator.ts
var WikilinkGenerator = class extends BaseGenerator {
  constructor(aiAdapter, settingsService) {
    super(aiAdapter, settingsService);
    /**
     * Collection of regex patterns used throughout the generator
     */
    this.PATTERNS = {
      WIKILINK_REGEX: /\[\[([^\[\]]*(?:\[\[[^\[\]]*\]\][^\[\]]*)*)\]\]/g,
      SIMPLE_WIKILINK_REGEX: /\[\[([^\]]+)\]\]/g,
      MALFORMED_REGEX: /\[\[[^\]\[]*(?:\](?!\])|$)|(?:\[\[)+[^\]\[]*\]\]/g,
      CODE_BLOCK_REGEX: /`[^`]*`|```[\s\S]*?```/g,
      INLINE_CODE_REGEX: /`[^`]+`/g,
      SPECIAL_CHARS_REGEX: /[!@#$%^&*(),.?":{}|<>]/g
    };
    /**
     * Configuration constants for wikilink processing
     */
    this.CONFIG = {
      MAX_LINK_LENGTH: 100,
      MAX_NESTING_DEPTH: 5,
      CONTEXT_WINDOW_SIZE: 100,
      ALLOWED_SPECIAL_CHARS: ["'", "-", "_", "&", "."]
    };
  }
  /**
   * Generate wikilinks for the provided content
   * @param input WikilinkInput containing content and context
   * @returns Promise<WikilinkOutput> with processed content
   */
  async generate(input) {
    if (!this.validateInput(input)) {
      throw new Error("Invalid input for wikilink generation");
    }
    try {
      const prompt = this.preparePrompt(input);
      const model = await this.getCurrentModel();
      const aiResponse = await this.aiAdapter.generateResponse(prompt, model);
      return this.formatOutput(aiResponse.data, input);
    } catch (error) {
      return this.handleError(error);
    }
  }
  /**
   * Prepares the AI prompt for generating wikilink suggestions
   */
  preparePrompt(input) {
    const settings = this.getSettings();
    const customTags = settings.tags.customTags.map((tag) => tag.name).join(", ") || "";
    return `
# MISSION
Act as an expert in recommending wikilinks for potential future research notes.
Analyze the following content and suggest key phrases, proper nouns, people, places, events, and concepts that would make for a relevant and practical note.
Consider the existing pages in the vault and prioritize linking to them. Ignore all tags and front matter when generating.

# CONTENT
${input.content}

# EXISTING PAGES
${input.existingPages.join(", ")}

Provide your suggestions as a JSON array of strings, omitting all characters before or after, including backticks.
        `;
  }
  /**
   * Format the AI response into wikilink output
   */
  formatOutput(aiResponse, originalInput) {
    const suggestedLinks = this.parseSuggestedLinks(aiResponse);
    let processedContent = originalInput.content;
    processedContent = this.addNewWikilinks(processedContent, suggestedLinks);
    processedContent = this.cleanNestedWikilinks(processedContent);
    return { content: processedContent };
  }
  /**
   * Adds new wikilinks while preserving existing ones and handling edge cases
   */
  addNewWikilinks(content, suggestedLinks) {
    const codeBlocks = /* @__PURE__ */ new Map();
    let processedContent = this.protectCodeBlocks(content, codeBlocks);
    const existingWikilinks = this.extractExistingWikilinks(processedContent);
    const existingWikilinksWithBrackets = new Set(
      Array.from(processedContent.matchAll(this.PATTERNS.SIMPLE_WIKILINK_REGEX)).map((match) => match[0])
    );
    suggestedLinks.filter((link) => this.isValidWikilinkText(link)).sort((a, b) => b.length - a.length).forEach((phrase) => {
      if (!existingWikilinks.includes(phrase.toLowerCase())) {
        const regex = new RegExp(`\\b${this.escapeRegExp(phrase)}\\b`, "gi");
        processedContent = processedContent.replace(regex, (match, offset) => {
          if (this.isWithinExistingWikilink(processedContent, offset, match.length, existingWikilinksWithBrackets) || this.isWithinProtectedContext(processedContent, offset)) {
            return match;
          }
          return `[[${this.normalizeWikilinkText(match)}]]`;
        });
      }
    });
    return this.restoreCodeBlocks(processedContent, codeBlocks);
  }
  /**
   * Cleans up nested wikilinks while preserving valid structure
   */
  cleanNestedWikilinks(content) {
    const processedWikilinks = /* @__PURE__ */ new Set();
    let result = content;
    const matches = Array.from(content.matchAll(this.PATTERNS.WIKILINK_REGEX)).map((match) => ({
      full: match[0],
      inner: match[1],
      index: match.index,
      length: match[0].length,
      depth: this.calculateNestingDepth(match[0])
    })).filter((match) => match.depth <= this.CONFIG.MAX_NESTING_DEPTH).sort((a, b) => b.length - a.length);
    const processedPositions = /* @__PURE__ */ new Set();
    for (const match of matches) {
      if (processedPositions.has(match.index))
        continue;
      if (match.inner.includes("[[")) {
        const cleanedText = this.removeNestedDuplicates(match.inner);
        if (this.isValidWikilinkText(cleanedText) && !processedWikilinks.has(cleanedText.toLowerCase())) {
          processedWikilinks.add(cleanedText.toLowerCase());
          result = this.safeReplace(
            result,
            match.index,
            match.length,
            `[[${this.normalizeWikilinkText(cleanedText)}]]`
          );
          processedPositions.add(match.index);
        }
      } else {
        processedWikilinks.add(match.inner.toLowerCase());
      }
    }
    return result;
  }
  /**
   * Extracts existing wikilinks from content
   */
  extractExistingWikilinks(content) {
    const matches = content.match(this.PATTERNS.SIMPLE_WIKILINK_REGEX) || [];
    return matches.map((match) => match.slice(2, -2).toLowerCase());
  }
  /**
   * Removes nested duplicates while preserving outer structure
   */
  removeNestedDuplicates(text) {
    return text.replace(/\[\[([^\[\]]+)\]\]/g, "$1");
  }
  /**
   * Validates if text is suitable for a wikilink
   */
  isValidWikilinkText(text) {
    if (!text || typeof text !== "string")
      return false;
    const trimmed = text.trim();
    if (trimmed.length === 0 || trimmed.length > this.CONFIG.MAX_LINK_LENGTH)
      return false;
    const bracketCount = (trimmed.match(/[\[\]]/g) || []).length;
    if (bracketCount % 2 !== 0)
      return false;
    return !trimmed.match(this.PATTERNS.MALFORMED_REGEX);
  }
  /**
   * Normalizes text for wikilink usage while preserving original capitalization
   * @param text - The text to be normalized
   * @returns Normalized text with preserved capitalization
   */
  normalizeWikilinkText(text) {
    const originalText = text.trim();
    let normalized = originalText.replace(/\s+/g, " ");
    normalized = normalized.replace(
      this.PATTERNS.SPECIAL_CHARS_REGEX,
      (char) => this.CONFIG.ALLOWED_SPECIAL_CHARS.includes(char) ? char : ""
    );
    if (normalized.toLowerCase() === originalText.toLowerCase()) {
      return originalText;
    }
    return normalized;
  }
  /**
   * Checks if a position is within an existing wikilink
   */
  isWithinExistingWikilink(content, offset, length, existingWikilinks) {
    const contextStart = Math.max(0, offset - this.CONFIG.CONTEXT_WINDOW_SIZE);
    const contextEnd = Math.min(
      content.length,
      offset + length + this.CONFIG.CONTEXT_WINDOW_SIZE
    );
    const context = content.slice(contextStart, contextEnd);
    return Array.from(existingWikilinks).some((wikilink) => {
      const wikiLinkIndex = context.indexOf(wikilink);
      if (wikiLinkIndex === -1)
        return false;
      const absoluteWikiLinkStart = contextStart + wikiLinkIndex;
      const absoluteWikiLinkEnd = absoluteWikiLinkStart + wikilink.length;
      return offset >= absoluteWikiLinkStart && offset + length <= absoluteWikiLinkEnd;
    });
  }
  /**
   * Protects code blocks from processing
   */
  protectCodeBlocks(content, codeBlocks) {
    let processedContent = content;
    let counter = 0;
    processedContent = processedContent.replace(
      this.PATTERNS.CODE_BLOCK_REGEX,
      (match) => {
        const placeholder = `__CODE_BLOCK_${counter}__`;
        codeBlocks.set(placeholder, match);
        counter++;
        return placeholder;
      }
    );
    processedContent = processedContent.replace(
      this.PATTERNS.INLINE_CODE_REGEX,
      (match) => {
        const placeholder = `__INLINE_CODE_${counter}__`;
        codeBlocks.set(placeholder, match);
        counter++;
        return placeholder;
      }
    );
    return processedContent;
  }
  /**
   * Restores protected code blocks
   */
  restoreCodeBlocks(content, codeBlocks) {
    let processedContent = content;
    for (const [placeholder, original] of codeBlocks.entries()) {
      processedContent = processedContent.replace(placeholder, original);
    }
    return processedContent;
  }
  /**
   * Checks if a position is within a protected context
   */
  isWithinProtectedContext(content, offset) {
    const codeMatches = Array.from(content.matchAll(this.PATTERNS.CODE_BLOCK_REGEX));
    for (const match of codeMatches) {
      if (match.index !== void 0 && offset >= match.index && offset < match.index + match[0].length) {
        return true;
      }
    }
    const inlineMatches = Array.from(content.matchAll(this.PATTERNS.INLINE_CODE_REGEX));
    for (const match of inlineMatches) {
      if (match.index !== void 0 && offset >= match.index && offset < match.index + match[0].length) {
        return true;
      }
    }
    return false;
  }
  /**
   * Calculates the nesting depth of a wikilink
   */
  calculateNestingDepth(text) {
    let maxDepth = 0;
    let currentDepth = 0;
    for (let i = 0; i < text.length - 1; i++) {
      if (text[i] === "[" && text[i + 1] === "[") {
        currentDepth++;
        maxDepth = Math.max(maxDepth, currentDepth);
        i++;
      } else if (text[i] === "]" && text[i + 1] === "]") {
        currentDepth--;
        i++;
      }
    }
    return maxDepth;
  }
  /**
   * Safely replaces text at a specific position
   */
  safeReplace(text, start, length, replacement) {
    return text.slice(0, start) + replacement + text.slice(start + length);
  }
  /**
   * Parses suggested links from AI response
   */
  parseSuggestedLinks(aiResponse) {
    if (typeof aiResponse === "string") {
      try {
        aiResponse = JSON.parse(aiResponse);
      } catch (error) {
        console.error("Failed to parse AI response as JSON:", error);
        return [];
      }
    }
    if (Array.isArray(aiResponse)) {
      return aiResponse.filter((item) => typeof item === "string");
    }
    if (typeof aiResponse === "object" && aiResponse !== null) {
      const arrayValues = Object.values(aiResponse).find(Array.isArray);
      if (arrayValues) {
        return arrayValues.filter((item) => typeof item === "string");
      }
    }
    console.error("Unexpected AI response format:", aiResponse);
    return [];
  }
  /**
   * Validates the input structure
   */
  validateInput(input) {
    return typeof input.content === "string" && input.content.trim().length > 0 && Array.isArray(input.existingPages) && input.existingPages.every((page) => typeof page === "string");
  }
  /**
   * Gets the current AI model
   */
  async getCurrentModel() {
    var _a, _b;
    const settings = this.getSettings();
    const providerType = this.aiAdapter.getProviderType();
    const selectedModel = (_b = (_a = settings.aiProvider) == null ? void 0 : _a.selectedModels) == null ? void 0 : _b[providerType];
    if (!selectedModel) {
      throw new Error(`No model selected for provider type: ${providerType}`);
    }
    return selectedModel;
  }
  /**
   * Escapes special regex characters in a string
   */
  escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  /**
   * Handles errors in wikilink generation
   */
  handleError(error) {
    console.error(`Wikilink generation error: ${error.message}`);
    throw new Error(`Wikilink generation failed: ${error.message}`);
  }
};

// src/generators/OntologyGenerator.ts
var OntologyGenerator = class extends BaseGenerator {
  constructor(aiAdapter, settingsService) {
    super(aiAdapter, settingsService);
  }
  /**
   * Main method to generate ontology.
   * @param input - Input parameters for ontology generation.
   * @returns Promise resolving to the generated ontology.
   */
  async generate(input) {
    if (!this.validateInput(input)) {
      throw new Error("Invalid input for ontology generation");
    }
    try {
      const prompt = this.preparePrompt(input);
      const aiResponse = await this.aiAdapter.generateResponse(prompt, input.modelApiName);
      return this.formatOutput(aiResponse.data);
    } catch (error) {
      this.handleError(error);
    }
  }
  /**
   * Prepares the AI prompt based on the input.
   * @param input - Input parameters for ontology generation.
   * @returns Formatted prompt string.
   */
  preparePrompt(input) {
    const fileNames = input.files.map((file) => file.basename).join(", ");
    const folderNames = input.folders.map((folder) => folder.name).join(", ");
    const tags = input.tags.join(", ");
    return `
# MISSION
Act as an expert in Ontological Science, specializing in taking unstructured information from an Obsidian vault, and creating tags to create a means of connecting the information.
Analyze the following information about a knowledge base and synthesize an ontology.
Based on the overall structure and content, suggest a set of tags that would create a cohesive and useful ontology for this knowledge base.

**Files:**
${fileNames}

**Folders:** 
${folderNames}

**Existing Tags:** 
${tags}

${input.userContext ? `**Additional Context:** ${input.userContext}` : ""}

For each suggested tag in the ontology, provide:
{
    "Name": {
        "description": "a brief but robust instruction on what this tag represents, and when it should be applied",
    }
}

Consider the following when creating the ontology:
1. Identify overarching themes and concepts present in the knowledge base.
2. Suggest tags that would help categorize and connect information across different files and folders.
3. Build upon existing tags, either by refining them or suggesting complementary tags.
4. Aim for a balance between specificity and generality in the suggested tags.
5. Consider the hierarchical structure implied by the folder organization.
6. Omit all spaces from tags names (e.g. AlbertEinstein instead of Albert Einstein)

Provide your response as a JSON object where the keys are the tag names and the values are objects containing the description.
Suggest enough tags to form a comprehensive ontology for this knowledge base.
        `;
  }
  /**
   * Formats the AI response into the OntologyResult structure.
   * @param aiResponse - Raw AI response data.
   * @returns OntologyResult containing suggested tags.
   */
  formatOutput(aiResponse) {
    let parsedResponse;
    if (typeof aiResponse === "string") {
      try {
        const fixedJson = this.fixIncompleteJson(aiResponse);
        parsedResponse = JSON.parse(fixedJson);
      } catch (error) {
        console.error("Failed to parse AI response as JSON:", error);
        throw new Error("Invalid AI response: unable to parse as JSON");
      }
    } else if (typeof aiResponse === "object" && aiResponse !== null) {
      parsedResponse = aiResponse;
    } else {
      console.error("Unexpected AI response format:", aiResponse);
      throw new Error("Invalid AI response format: expected an object or valid JSON string");
    }
    if (typeof parsedResponse !== "object" || parsedResponse === null) {
      throw new Error("Invalid AI response format: expected an object after parsing");
    }
    const suggestedTags = Object.entries(parsedResponse).map(([name, value]) => {
      if (typeof value === "object" && value !== null && "description" in value) {
        return {
          name: String(name).trim(),
          description: String(value.description).trim(),
          type: value.type || "string",
          // Default to 'string' if type not provided
          required: value.required !== void 0 ? Boolean(value.required) : false,
          // Default to false
          multipleValues: value.multipleValues !== void 0 ? Boolean(value.multipleValues) : false
          // Default to false
        };
      } else {
        console.warn(`Unexpected format for tag ${name}:`, value);
        return null;
      }
    }).filter(
      (tag) => tag !== null && typeof tag.name === "string" && tag.name.length > 0 && typeof tag.description === "string" && tag.description.length > 0 && typeof tag.type === "string" && typeof tag.required === "boolean" && typeof tag.multipleValues === "boolean"
    );
    if (suggestedTags.length === 0) {
      throw new Error("No valid tags found in AI response");
    }
    return { suggestedTags };
  }
  /**
   * Attempts to fix incomplete JSON strings.
   * @param json - Raw JSON string.
   * @returns Fixed JSON string.
   */
  fixIncompleteJson(json) {
    let fixedJson = json.trim();
    if (!fixedJson.endsWith("}")) {
      fixedJson += "}}";
    }
    fixedJson = fixedJson.replace(/,\s*}$/, "}");
    return fixedJson;
  }
  /**
   * Validates the input parameters for ontology generation.
   * @param input - Input parameters.
   * @returns Boolean indicating validity.
   */
  validateInput(input) {
    return Array.isArray(input.files) && Array.isArray(input.folders) && Array.isArray(input.tags);
  }
  /**
   * Retrieves the current model selection for ontology generation.
   * @returns Promise resolving to the selected model identifier.
   */
  async getCurrentModel() {
    var _a, _b;
    const settings = this.settingsService.getSettings();
    const providerType = this.aiAdapter.getProviderType();
    const selectedModel = (_b = (_a = settings.aiProvider) == null ? void 0 : _a.selectedModels) == null ? void 0 : _b[providerType];
    if (!selectedModel) {
      throw new Error(`No model selected for provider type: ${providerType}`);
    }
    return selectedModel;
  }
  /**
   * Handles errors during ontology generation.
   * @param error - The error encountered.
   */
  handleError(error) {
    console.error(`Ontology generation error: ${error.message}`, error);
    throw new Error(`Ontology generation failed: ${error.message}`);
  }
};

// src/generators/BatchProcessor.ts
var import_obsidian7 = require("obsidian");
var import_events = require("events");

// src/models/ProcessingTypes.ts
var DEFAULT_PROCESSING_OPTIONS = {
  chunkSize: 10,
  delayBetweenChunks: 1e3,
  maxRetries: 3,
  generateFrontMatter: true,
  generateWikilinks: false,
  maxConcurrentProcessing: 3
};

// src/generators/BatchProcessor.ts
var BatchProcessor = class extends BaseGenerator {
  constructor(aiAdapter, settingsService, frontMatterGenerator, wikilinkGenerator, databaseService, app) {
    super(aiAdapter, settingsService);
    this.frontMatterGenerator = frontMatterGenerator;
    this.wikilinkGenerator = wikilinkGenerator;
    this.databaseService = databaseService;
    this.app = app;
    this.NOTIFICATION_INTERVAL = 2e3;
    this.lastNotificationTime = 0;
    this.processStartTime = 0;
    this.processingTimeout = null;
    this.eventEmitter = new import_events.EventEmitter();
    this.options = DEFAULT_PROCESSING_OPTIONS;
    this.currentStatus = this.getDefaultStatus();
  }
  /**
   * Main generation method
   */
  async generate(input) {
    if (!this.validateInput(input)) {
      throw new Error("Invalid input for batch processing");
    }
    this.processStartTime = Date.now();
    this.options = { ...this.options, ...input.options };
    try {
      await this.startProcessing(input.files);
      const results = await this.processFiles(input);
      const stats = await this.finalizeProcessing(results);
      return {
        fileResults: results,
        stats
      };
    } catch (error) {
      await this.handleError(error);
      throw error;
    } finally {
      await this.cleanup();
    }
  }
  /**
   * Start processing and initialize status
   */
  async startProcessing(files) {
    this.currentStatus = {
      state: "running",
      filesQueued: files.length,
      filesProcessed: 0,
      filesRemaining: files.length,
      startTime: this.processStartTime,
      errors: []
    };
    this.emitEvent("start", { status: this.currentStatus });
  }
  /**
   * Process all files in chunks
   */
  async processFiles(input) {
    const chunks = this.createChunks(input.files);
    const results = [];
    for (const chunk of chunks) {
      if (this.currentStatus.state === "paused") {
        await this.waitForResume();
      }
      this.emitEvent("chunkStart", chunk);
      const chunkResults = await this.processChunk(chunk, input);
      results.push(...chunkResults);
      this.emitEvent("chunkComplete", chunk);
      if (chunks.indexOf(chunk) < chunks.length - 1) {
        await this.delay(this.options.delayBetweenChunks);
      }
    }
    return results;
  }
  /**
   * Process a single chunk of files
   */
  async processChunk(chunk, input) {
    const files = chunk.files.map((path) => this.app.vault.getAbstractFileByPath(path)).filter((file) => file instanceof import_obsidian7.TFile);
    const results = await Promise.all(
      files.map((file) => this.processFile(file, input))
    );
    this.updateProgress(results.filter((r) => r.success).length);
    return results;
  }
  /**
   * Process a single file
   */
  async processFile(file, input) {
    const startTime = Date.now();
    this.emitEvent("fileStart", { file: file.path });
    try {
      let content = await this.app.vault.read(file);
      const processed = await this.generateContent(content, input);
      await this.app.vault.modify(file, processed.content);
      const result = {
        path: file.path,
        success: true,
        processingTime: Date.now() - startTime,
        ...processed.flags
      };
      this.emitEvent("fileComplete", { result });
      return result;
    } catch (error) {
      const errorResult = this.createErrorResult(file, error);
      this.handleProcessingError(errorResult.error);
      return errorResult.result;
    }
  }
  /**
   * Generate content for a file
   */
  async generateContent(content, input) {
    let frontMatterGenerated = false;
    let wikilinksGenerated = false;
    let processedContent = content;
    if (input.generateFrontMatter) {
      const result = await this.frontMatterGenerator.generate({ content: processedContent });
      frontMatterGenerated = result.content !== processedContent;
      processedContent = result.content;
    }
    if (input.generateWikilinks) {
      const pages = this.app.vault.getMarkdownFiles().map((file) => file.basename);
      const result = await this.wikilinkGenerator.generate({
        content: processedContent,
        existingPages: pages
      });
      wikilinksGenerated = result.content !== processedContent;
      processedContent = result.content;
    }
    return {
      content: processedContent,
      flags: { frontMatterGenerated, wikilinksGenerated }
    };
  }
  /**
   * Finalize processing and calculate stats
   */
  async finalizeProcessing(results) {
    const endTime = Date.now();
    const successfulFiles = results.filter((r) => r.success);
    const stats = {
      totalFiles: results.length,
      processedFiles: successfulFiles.length,
      errorFiles: results.length - successfulFiles.length,
      skippedFiles: 0,
      startTime: this.processStartTime,
      endTime,
      averageProcessingTime: this.calculateAverageTime(successfulFiles)
    };
    await this.databaseService.addProcessingStats(stats);
    this.emitEvent("complete", stats);
    return stats;
  }
  /**
   * Update processing progress
   */
  updateProgress(processedCount) {
    this.currentStatus.filesProcessed += processedCount;
    this.currentStatus.filesRemaining -= processedCount;
    const elapsed = Date.now() - (this.currentStatus.startTime || 0);
    const filesPerMs = this.currentStatus.filesProcessed / elapsed;
    this.currentStatus.estimatedTimeRemaining = this.currentStatus.filesRemaining / filesPerMs;
    this.emitEvent("progress", this.currentStatus);
    this.maybeShowNotification();
  }
  maybeShowNotification() {
    const now = Date.now();
    if (now - this.lastNotificationTime > this.NOTIFICATION_INTERVAL) {
      const { filesProcessed, filesQueued } = this.currentStatus;
      new import_obsidian7.Notice(
        `Processing files: ${filesProcessed}/${filesQueued} (${Math.round(filesProcessed / filesQueued * 100)}%)`
      );
      this.lastNotificationTime = now;
    }
  }
  // Helper methods
  getDefaultStatus() {
    return {
      state: "idle",
      filesQueued: 0,
      filesProcessed: 0,
      filesRemaining: 0,
      errors: []
    };
  }
  createChunks(files) {
    const chunks = [];
    for (let i = 0; i < files.length; i += this.options.chunkSize) {
      chunks.push({
        files: files.slice(i, i + this.options.chunkSize).map((f) => f.path),
        index: Math.floor(i / this.options.chunkSize),
        size: Math.min(this.options.chunkSize, files.length - i)
      });
    }
    return chunks;
  }
  createErrorResult(file, error) {
    const errorInfo = {
      filePath: file.path,
      error: error.message,
      timestamp: Date.now(),
      retryCount: 0
    };
    const result = {
      path: file.path,
      success: false,
      error: error.message,
      processingTime: 0,
      frontMatterGenerated: false,
      wikilinksGenerated: false
    };
    return { error: errorInfo, result };
  }
  calculateAverageTime(results) {
    if (results.length === 0)
      return 0;
    const totalTime = results.reduce((sum, r) => sum + r.processingTime, 0);
    return totalTime / results.length;
  }
  handleProcessingError(error) {
    this.currentStatus.errors.push(error);
    this.emitEvent("error", error);
  }
  async waitForResume() {
    return new Promise((resolve) => {
      const check = () => {
        if (this.currentStatus.state === "running") {
          resolve();
        } else {
          this.processingTimeout = setTimeout(check, 100);
        }
      };
      check();
    });
  }
  async delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  async cleanup() {
    if (this.processingTimeout) {
      clearTimeout(this.processingTimeout);
    }
    this.currentStatus.state = "idle";
  }
  // Public methods for external control
  on(event, callback) {
    this.eventEmitter.on(event, callback);
  }
  pause() {
    if (this.currentStatus.state === "running") {
      this.currentStatus.state = "paused";
      this.emitEvent("pause", null);
    }
  }
  resume() {
    if (this.currentStatus.state === "paused") {
      this.currentStatus.state = "running";
      this.emitEvent("resume", null);
    }
  }
  emitEvent(type, data) {
    this.eventEmitter.emit(type, data);
  }
  validateInput(input) {
    return Array.isArray(input.files) && input.files.length > 0 && typeof input.generateFrontMatter === "boolean" && typeof input.generateWikilinks === "boolean";
  }
  // Required BaseGenerator methods
  preparePrompt(_input) {
    return "";
  }
  formatOutput(_aiResponse, _originalInput) {
    return {
      fileResults: [],
      stats: {
        totalFiles: 0,
        processedFiles: 0,
        skippedFiles: 0,
        errorFiles: 0,
        startTime: 0,
        averageProcessingTime: 0
      }
    };
  }
};

// src/generators/JsonSchemaGenerator.ts
var JsonSchemaGenerator = class {
  constructor(settingsService) {
    this.settingsService = settingsService;
  }
  generateSchemaForTopic(topic) {
    const baseSchema = this.generateBaseSchema();
    return baseSchema;
  }
  generateBaseSchema() {
    const settings = this.settingsService.getSettings();
    const schema = {
      type: "object",
      properties: {},
      required: []
    };
    settings.frontMatter.customProperties.forEach((property) => {
      schema.properties[property.name] = {
        type: this.getJsonSchemaType(property.type),
        description: `Create ${property.description}`
      };
      if (property.required) {
        schema.required.push(property.name);
      }
    });
    schema.properties.tags = {
      type: "array",
      items: {
        type: "string",
        enum: settings.tags.customTags.map((tag) => tag.name)
      },
      description: "Select appropriate tags for the document from the provided list"
    };
    schema.properties.content = {
      type: "string",
      description: "Main content of the note in Markdown format"
    };
    return schema;
  }
  getJsonSchemaType(propertyType) {
    switch (propertyType) {
      case "number":
        return "number";
      case "boolean":
        return "boolean";
      case "array":
        return "array";
      default:
        return "string";
    }
  }
};

// src/generators/KnowledgeBloomGenerator.ts
var import_obsidian8 = require("obsidian");
var KnowledgeBloomGenerator = class extends BaseGenerator {
  constructor(aiAdapter, settingsService, app, frontMatterGenerator) {
    super(aiAdapter, settingsService);
    this.app = app;
    this.currentInput = null;
    this.frontMatterGenerator = frontMatterGenerator;
  }
  /**
   * Generate new notes from wikilinks in the source document
   * @param input The input parameters for generation
   * @returns Promise resolving to generated notes
   */
  async generate(input) {
    this.currentInput = input;
    console.log("KnowledgeBloomGenerator: Starting generation process");
    try {
      if (!this.validateInput(input)) {
        throw new Error("Invalid input for Knowledge Bloom generation");
      }
      const wikilinks = await this.extractWikilinks(input.sourceFile);
      console.log(`KnowledgeBloomGenerator: Found ${wikilinks.length} unique wikilinks`);
      if (wikilinks.length === 0) {
        throw new Error("No wikilinks found in the source file.");
      }
      const folderPath = this.getFolderPath(input.sourceFile);
      const output = { generatedNotes: [] };
      const generationPromises = wikilinks.map(
        (link) => this.processWikilink(link, folderPath, input, output)
      );
      await Promise.allSettled(generationPromises);
      return output;
    } catch (error) {
      return this.handleError(error);
    } finally {
      this.currentInput = null;
    }
  }
  /**
   * Process a single wikilink to generate a new note
   */
  async processWikilink(link, folderPath, input, output) {
    try {
      if (this.doesNoteExist(link, folderPath)) {
        console.log(`KnowledgeBloomGenerator: Note for "${link}" already exists. Skipping.`);
        return;
      }
      const markdownContent = await this.generateMarkdownContent(link, input);
      const finalContent = await this.addFrontMatter(markdownContent);
      const newFilePath = `${folderPath}/${link}.md`;
      await this.app.vault.create(newFilePath, finalContent);
      output.generatedNotes.push({ title: link, content: finalContent });
      console.log(`KnowledgeBloomGenerator: Successfully generated note for "${link}".`);
    } catch (error) {
      console.error(`Error processing wikilink "${link}":`, error);
      new import_obsidian8.Notice(`Failed to generate note for "${link}": ${error.message}`);
    }
  }
  /**
   * Generate markdown content for a single wikilink
   */
  async generateMarkdownContent(link, input) {
    const prompt = this.preparePrompt({
      ...input,
      currentWikilink: link,
      currentNoteTitle: input.sourceFile.basename
    });
    const model = await this.getCurrentModel();
    const options = { rawResponse: true };
    const response = await this.aiAdapter.generateResponse(prompt, model, options);
    if (!response.success || !response.data) {
      throw new Error(`Failed to generate content for "${link}": ${response.error || "Unknown error"}`);
    }
    let content = response.data;
    if (typeof content === "object" && content !== null) {
      const contentObj = content;
      if ("content" in contentObj && typeof contentObj.content === "string") {
        content = contentObj.content;
      } else if ("response" in contentObj && typeof contentObj.response === "string") {
        content = contentObj.response;
      } else {
        content = JSON.stringify(content);
      }
    }
    const contentString = String(content).trim();
    return contentString.replace(/^---\n[\s\S]*?\n---\n*/g, "");
  }
  /**
   * Add front matter to the generated content
   */
  async addFrontMatter(content) {
    const frontMatterInput = {
      content,
      customProperties: this.extractCustomProperties(content),
      customTags: this.extractCustomTags(content)
    };
    const frontMatterResult = await this.frontMatterGenerator.generate(frontMatterInput);
    return frontMatterResult.content;
  }
  /**
   * Extract unique wikilinks from a file
   */
  async extractWikilinks(file) {
    const content = await this.app.vault.read(file);
    const wikilinks = content.match(/\[\[([^\]]+)\]\]/g) || [];
    const links = wikilinks.map((link) => link.slice(2, -2));
    return Array.from(new Set(links.map((link) => link.toLowerCase())));
  }
  /**
   * Extract custom properties from content
   */
  extractCustomProperties(content) {
    try {
      return this.settingsService.getSettings().frontMatter.customProperties;
    } catch (error) {
      console.error("Error extracting custom properties:", error);
      return [];
    }
  }
  /**
   * Extract custom tags from content
   */
  extractCustomTags(content) {
    try {
      return this.settingsService.getSettings().tags.customTags.map((tag) => tag.name);
    } catch (error) {
      console.error("Error extracting custom tags:", error);
      return [];
    }
  }
  /**
   * Prepare the AI prompt for content generation
   */
  preparePrompt(input) {
    if (!input.currentWikilink || !input.currentNoteTitle) {
      throw new Error("Missing required wikilink or note title");
    }
    return `
# MISSION
Act as an expert Research Assistant that specializes in writing structured notes that are accessible and practical based on a provided topic.

# GUIDELINES
- Write the note in Markdown format.
- Do NOT include any JSON objects or front matter.
- Ensure the content is well-structured and comprehensive.
- Omit any words before or after the Markdown content.

# TOPIC
Write a detailed note about "${input.currentWikilink}" in relation to "${input.currentNoteTitle}".

${input.userPrompt ? `## Additional Context:
${input.userPrompt}` : ""}
`;
  }
  /**
   * Check if a note exists at the given path
   */
  doesNoteExist(title, folderPath) {
    const filePath = `${folderPath}/${title}.md`;
    const file = this.app.vault.getAbstractFileByPath(filePath);
    return file instanceof import_obsidian8.TFile;
  }
  /**
   * Get the folder path for the new note
   */
  getFolderPath(file) {
    const pathSegments = file.path.split("/");
    pathSegments.pop();
    return pathSegments.join("/");
  }
  /**
   * Validate the input parameters
   */
  validateInput(input) {
    const isValid = (input == null ? void 0 : input.sourceFile) instanceof import_obsidian8.TFile;
    console.log(`KnowledgeBloomGenerator: Input validation result: ${isValid}`);
    return isValid;
  }
  /**
   * Get the current AI model
   */
  async getCurrentModel() {
    var _a;
    const settings = this.getSettings();
    const selectedModel = (_a = settings.knowledgeBloom) == null ? void 0 : _a.selectedModel;
    if (!selectedModel) {
      throw new Error("No model selected for Knowledge Bloom.");
    }
    return selectedModel;
  }
  /**
   * Handle generation errors
   */
  handleError(error) {
    console.error(`KnowledgeBloomGenerator: Knowledge Bloom generation error: ${error.message}`, error);
    new import_obsidian8.Notice(`Knowledge Bloom generation failed: ${error.message}`);
    throw error;
  }
  /**
   * Format output (not used in this implementation)
   */
  formatOutput(_aiResponse, _originalInput) {
    throw new Error("Method not implemented - using custom generate method");
  }
};

// src/services/AIService.ts
var AIService = class {
  constructor(app, settingsService, jsonValidationService, databaseService) {
    this.app = app;
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    this.databaseService = databaseService;
    this.adapters = /* @__PURE__ */ new Map();
    this.initializeAdapters();
    this.initializeGenerators();
  }
  /**
   * Initializes all AI adapters based on supported providers.
   */
  initializeAdapters() {
    this.adapters = /* @__PURE__ */ new Map([
      ["openai" /* OpenAI */, new OpenAIAdapter(this.settingsService, this.jsonValidationService)],
      ["anthropic" /* Anthropic */, new AnthropicAdapter(this.settingsService, this.jsonValidationService)],
      ["google" /* Google */, new GeminiAdapter(this.settingsService, this.jsonValidationService)],
      ["groq" /* Groq */, new GroqAdapter(this.settingsService, this.jsonValidationService)],
      ["openrouter" /* OpenRouter */, new OpenRouterAdapter(this.settingsService, this.jsonValidationService)],
      ["lmstudio" /* LMStudio */, new LMStudioAdapter(this.settingsService, this.jsonValidationService)]
    ]);
  }
  getCurrentAdapter() {
    const provider = this.getCurrentProvider();
    return this.getAdapterForProvider(provider);
  }
  /**
   * Initializes all generators required for AI operations.
   */
  initializeGenerators() {
    const currentProvider = this.getCurrentProvider();
    const currentAdapter = this.getAdapterForProvider(currentProvider);
    this.jsonSchemaGenerator = new JsonSchemaGenerator(this.settingsService);
    this.frontMatterGenerator = new FrontMatterGenerator(currentAdapter, this.settingsService, this.jsonSchemaGenerator);
    this.wikilinkGenerator = new WikilinkGenerator(currentAdapter, this.settingsService);
    this.ontologyGenerator = new OntologyGenerator(currentAdapter, this.settingsService);
    this.batchProcessor = new BatchProcessor(
      currentAdapter,
      this.settingsService,
      this.frontMatterGenerator,
      this.wikilinkGenerator,
      this.databaseService,
      this.app
      // Add this parameter
    );
    this.knowledgeBloomGenerator = new KnowledgeBloomGenerator(
      currentAdapter,
      this.settingsService,
      this.app,
      this.frontMatterGenerator
      // Pass FrontMatterGenerator here
    );
  }
  /**
   * Reinitializes adapters and generators. Useful after updating settings.
   */
  reinitialize() {
    this.initializeAdapters();
    this.initializeGenerators();
  }
  /**
   * Retrieves the current AI provider selected in settings.
   */
  getCurrentProvider() {
    return this.settingsService.getAIProviderSettings().selected;
  }
  /**
   * Retrieves the current model API name for a given provider.
   * @param provider - The AI provider.
   */
  getCurrentModel(provider) {
    const aiProviderSettings = this.settingsService.getAIProviderSettings();
    const modelApiName = aiProviderSettings.selectedModels[provider];
    if (!modelApiName) {
      throw new Error(`No model selected for provider: ${provider}`);
    }
    return modelApiName;
  }
  /**
   * Retrieves the default model API name based on the current provider.
   */
  getDefaultModel() {
    const provider = this.getCurrentProvider();
    return this.getCurrentModel(provider);
  }
  /**
   * Sets the default model API name for the current provider.
   * @param modelApiName - The model API name to set as default.
   */
  async setDefaultModel(modelApiName) {
    const provider = this.getCurrentProvider();
    const aiProviderSettings = this.settingsService.getAIProviderSettings();
    aiProviderSettings.selectedModels[provider] = modelApiName;
    await this.settingsService.updateAIProviderSettings(provider, { selectedModels: aiProviderSettings.selectedModels });
    this.reinitialize();
  }
  /**
   * Retrieves all available models for a given provider.
   * @param provider - The AI provider.
   */
  getAvailableModels(provider) {
    const adapter = this.getAdapterForProvider(provider);
    return adapter.getAvailableModels();
  }
  /**
   * Retrieves all supported AI providers.
   */
  getSupportedProviders() {
    return Array.from(this.adapters.keys());
  }
  /**
   * Retrieves the adapter corresponding to a given provider.
   * @param provider - The AI provider.
   */
  getAdapterForProvider(provider) {
    const adapter = this.adapters.get(provider);
    if (!adapter) {
      throw new Error(`No adapter found for provider: ${provider}`);
    }
    return adapter;
  }
  /**
   * Validates the API key for a given provider.
   * @param provider - The AI provider.
   */
  async validateApiKey(provider) {
    const adapter = this.getAdapterForProvider(provider);
    try {
      return await adapter.validateApiKey();
    } catch (error) {
      console.error(`Error validating API key for ${provider}:`, error);
      return false;
    }
  }
  /**
   * Updates plugin settings and reinitializes services.
   * @param newSettings - Partial plugin settings to update.
   */
  async updateSettings(newSettings) {
    await this.settingsService.updateSettings(newSettings);
    this.reinitialize();
  }
  /**
   * Retrieves the root folder of the vault.
   */
  getVaultRoot() {
    return this.app.vault.getRoot();
  }
  /**
   * Retrieves a list of existing markdown pages in the vault.
   */
  getExistingPages() {
    return this.app.vault.getMarkdownFiles().map((file) => file.basename);
  }
  /**
   * Tests the connection to a given AI provider by validating the API key and making a test request.
   * @param provider - The AI provider to test.
   */
  async testConnection(provider) {
    try {
      const adapter = this.getAdapterForProvider(provider);
      const modelApiName = this.getCurrentModel(provider);
      const testPrompt = "This is a test prompt. Please respond with the word 'OK'.";
      return await adapter.testConnection(testPrompt, modelApiName);
    } catch (error) {
      console.error(`Error testing connection to ${provider}:`, error);
      return false;
    }
  }
  /**
   * Generates a response from the AI based on the provided prompt.
   * @param prompt - The input prompt for the AI.
   */
  async generateResponse(prompt) {
    const provider = this.getCurrentProvider();
    const modelApiName = this.getCurrentModel(provider);
    const adapter = this.getAdapterForProvider(provider);
    try {
      return await adapter.generateResponse(prompt, modelApiName);
    } catch (error) {
      console.error("Error generating response:", error);
      throw new Error(`Failed to generate response: ${error.message}`);
    }
  }
  /**
   * Retrieves a list of AI providers that have valid API keys set.
   */
  getProvidersWithApiKeys() {
    const aiProviderSettings = this.settingsService.getAIProviderSettings();
    return Object.entries(aiProviderSettings.apiKeys).filter(([_, apiKey]) => apiKey && apiKey.trim() !== "").map(([provider, _]) => provider);
  }
  /**
   * Generates front matter for the given content.
   * @param content - The content for which to generate front matter.
   */
  async generateFrontMatter(content) {
    try {
      const input = {
        content,
        customProperties: this.extractCustomProperties(content),
        customTags: this.extractCustomTags(content)
      };
      const frontMatterResult = await this.frontMatterGenerator.generate(input);
      return frontMatterResult.content;
    } catch (error) {
      console.error("Error generating front matter:", error);
      throw new Error(`Failed to generate front matter: ${error.message}`);
    }
  }
  /**
   * Generates wikilinks for the given content.
   * @param content - The content for which to generate wikilinks.
   * @returns Updated content with wikilinks generated.
   */
  async generateWikilinks(content) {
    try {
      const existingPages = this.getExistingPages();
      const wikilinkResult = await this.wikilinkGenerator.generate({
        content,
        existingPages
      });
      return wikilinkResult.content;
    } catch (error) {
      console.error("Error generating wikilinks:", error);
      throw new Error(`Failed to generate wikilinks: ${error.message}`);
    }
  }
  /**
   * Generates ontology based on the provided input.
   * @param input - The input parameters for ontology generation.
   * @returns The generated ontology result.
   */
  async generateOntology(input) {
    try {
      const ontologyResult = await this.ontologyGenerator.generate(input);
      return ontologyResult;
    } catch (error) {
      console.error("Error generating ontology:", error);
      throw new Error(`Failed to generate ontology: ${error.message}`);
    }
  }
  /**
   * Updates tags based on the suggested tags.
   * @param suggestedTags - Array of suggested tags to update.
   */
  async updateTags(suggestedTags) {
    try {
      const settings = this.settingsService.getSettings();
      const existingTagNames = new Set(settings.tags.customTags.map((tag) => tag.name));
      const newTags = suggestedTags.filter((tag) => !existingTagNames.has(tag.name));
      if (newTags.length === 0) {
        new import_obsidian9.Notice("No new tags to add.");
        return;
      }
      settings.tags.customTags.push(...newTags);
      await this.settingsService.updateSettings({ tags: settings.tags });
      new import_obsidian9.Notice(`Added ${newTags.length} new tags successfully!`);
    } catch (error) {
      console.error("Error updating tags:", error);
      throw new Error(`Failed to update tags: ${error.message}`);
    }
  }
  /**
   * Retrieves all available AI models across all providers.
   */
  getAllAvailableModels() {
    const availableModels = [];
    for (const provider of Object.values(AIProvider)) {
      try {
        const adapter = this.getAdapterForProvider(provider);
        if (adapter.isReady()) {
          const models = this.getAvailableModels(provider);
          models.forEach((modelName) => {
            const model = this.getModelDetails(provider, modelName);
            if (model) {
              availableModels.push({ provider, model });
            }
          });
        }
      } catch (error) {
        console.warn(`Skipping provider ${provider} due to error:`, error);
      }
    }
    const localLMStudioSettings = this.settingsService.getSettings().localLMStudio;
    if (localLMStudioSettings.enabled && localLMStudioSettings.modelName) {
      availableModels.push({
        provider: "lmstudio" /* LMStudio */,
        model: { name: localLMStudioSettings.modelName, apiName: "custom" }
      });
    }
    return availableModels;
  }
  /**
   * Retrieves model details based on provider and model name.
   * @param provider - The AI provider.
   * @param modelName - The name of the model.
   */
  getModelDetails(provider, modelName) {
    const models = AIModelMap[provider];
    return models.find((model) => model.apiName === modelName);
  }
  /**
   * Generates new notes based on wikilinks in the given file.
   * @param sourceFile - The file containing wikilinks to generate notes for.
   * @param userPrompt - Optional user-provided context for note generation.
   */
  async generateKnowledgeBloom(sourceFile, userPrompt) {
    try {
      const knowledgeBloomSettings = this.settingsService.getSettings().knowledgeBloom;
      const selectedModel = knowledgeBloomSettings.selectedModel;
      return await this.knowledgeBloomGenerator.generate({ sourceFile, userPrompt });
    } catch (error) {
      console.error("Error generating Knowledge Bloom:", error);
      throw new Error(`Knowledge Bloom generation failed: ${error.message}`);
    }
  }
  /**
   * Extracts custom properties from content based on settings.
   * @param content - The content to extract properties from.
   * @returns Array of PropertyTag.
   */
  extractCustomProperties(content) {
    const settings = this.settingsService.getSettings();
    return settings.frontMatter.customProperties;
  }
  /**
   * Extracts custom tags from content based on settings.
   * @param content - The content to extract tags from.
   * @returns Array of tag names.
   */
  extractCustomTags(content) {
    const settings = this.settingsService.getSettings();
    return settings.tags.customTags.map((tag) => tag.name);
  }
};

// src/services/SettingsService.ts
var import_events2 = require("events");

// src/services/JsonValidationService.ts
var import_obsidian10 = require("obsidian");
var JsonValidationService = class {
  /**
   * Basic validation of JSON data format
   * @param data The data to validate
   * @returns True if the data is valid JSON, false otherwise
   */
  validate(data) {
    try {
      if (typeof data === "object" && data !== null) {
        return true;
      }
      if (typeof data === "string") {
        JSON.parse(data);
        return true;
      }
      return false;
    } catch (error) {
      console.error("JSON Validation Error:", error);
      return false;
    }
  }
  /**
   * Cleans and validates JSON string input
   * @param jsonString The JSON string to validate and clean
   * @returns The parsed JSON object
   */
  validateAndCleanJson(jsonString) {
    try {
      jsonString = jsonString.trim();
      jsonString = jsonString.replace(/^```json?\s*|\s*```$/g, "");
      return JSON.parse(jsonString);
    } catch (error) {
      console.error("Error validating JSON:", error);
      new import_obsidian10.Notice(`Invalid JSON format: ${error instanceof Error ? error.message : "Unknown error"}`);
      throw new Error("Invalid JSON format");
    }
  }
  /**
   * Attempts to fix and parse potentially malformed JSON
   * @param str The JSON string to fix and parse
   * @returns The parsed JSON object or null if parsing fails
   */
  fixAndParseJson(str) {
    try {
      return JSON.parse(str);
    } catch (e) {
      try {
        str = str.replace(/(\w+)(?=\s*:)/g, '"$1"');
        str = str.replace(/'/g, '"');
        str = str.replace(/,\s*([\]}])/g, "$1");
        return JSON.parse(str);
      } catch (e2) {
        console.error("Failed to parse JSON:", e2);
        return null;
      }
    }
  }
};

// src/services/SettingsService.ts
var SettingsService = class {
  constructor(plugin, initialSettings) {
    this.plugin = plugin;
    this.settings = initialSettings;
    this.emitter = new import_events2.EventEmitter();
    this.jsonValidationService = new JsonValidationService();
  }
  async loadSettings() {
    const data = await this.plugin.loadData();
    this.settings = this.deepMerge(DEFAULT_SETTINGS, data);
  }
  getSettings() {
    return this.settings;
  }
  getSetting(key) {
    return this.settings[key];
  }
  getNestedSetting(key, nestedKey) {
    return this.settings[key][nestedKey];
  }
  async updateSettings(newSettings) {
    this.settings = this.deepMerge(this.settings, newSettings);
    await this.saveSettings();
    this.emitter.emit("settingsChanged", this.settings);
  }
  async updateSetting(key, value) {
    this.settings[key] = value;
    await this.saveSettings();
    this.emitter.emit("settingsChanged", { [key]: value });
  }
  async updateNestedSetting(key, nestedKey, value) {
    this.settings[key][nestedKey] = value;
    await this.saveSettings();
    this.emitter.emit("settingsChanged", { [key]: { [nestedKey]: value } });
  }
  async updateAIProviderSettings(provider, settings) {
    this.settings.aiProvider = this.deepMerge(this.settings.aiProvider, settings);
    await this.saveSettings();
    this.emitter.emit("settingsChanged", { aiProvider: this.settings.aiProvider });
  }
  getAIProviderSettings() {
    return this.settings.aiProvider;
  }
  async updateLocalLMStudioSettings(settings) {
    this.settings.localLMStudio = this.deepMerge(this.settings.localLMStudio, settings);
    await this.saveSettings();
    this.emitter.emit("settingsChanged", { localLMStudio: this.settings.localLMStudio });
  }
  getLocalLMStudioSettings() {
    return this.settings.localLMStudio;
  }
  getKnowledgeBloomSettings() {
    return this.settings.knowledgeBloom;
  }
  async updateKnowledgeBloomSettings(settings) {
    this.settings.knowledgeBloom = this.deepMerge(this.settings.knowledgeBloom, settings);
    await this.saveSettings();
    this.emitter.emit("settingsChanged", { knowledgeBloom: this.settings.knowledgeBloom });
  }
  async updateKnowledgeBloomSetting(key, value) {
    this.settings.knowledgeBloom[key] = value;
    await this.saveSettings();
    this.emitter.emit("settingsChanged", { knowledgeBloom: { [key]: value } });
  }
  async updateTags(newTags) {
    const existingTags = this.settings.tags.customTags || [];
    const mergedTags = [...existingTags];
    for (const newTag of newTags) {
      const existingIndex = mergedTags.findIndex((t) => t.name === newTag.name);
      if (existingIndex !== -1) {
        mergedTags[existingIndex] = { ...mergedTags[existingIndex], ...newTag };
      } else {
        mergedTags.push(newTag);
      }
    }
    this.settings.tags.customTags = mergedTags;
    await this.saveSettings();
    this.emitter.emit("settingsChanged", { tags: { customTags: mergedTags } });
  }
  async resetToDefault() {
    this.settings = { ...DEFAULT_SETTINGS };
    await this.saveSettings();
    this.emitter.emit("settingsReset");
  }
  onSettingsChanged(listener) {
    this.emitter.on("settingsChanged", listener);
  }
  onSettingsReset(listener) {
    this.emitter.on("settingsReset", listener);
  }
  async saveSettings() {
    await this.plugin.saveData(this.settings);
  }
  deepMerge(target, source) {
    if (!this.isObject(target) || !this.isObject(source)) {
      return source;
    }
    const output = { ...target };
    for (const key in source) {
      if (source.hasOwnProperty(key)) {
        if (this.isObject(source[key]) && this.isObject(target[key])) {
          output[key] = this.deepMerge(
            target[key],
            source[key]
          );
        } else if (source[key] !== void 0) {
          output[key] = source[key];
        }
      }
    }
    return output;
  }
  isObject(item) {
    return item !== null && typeof item === "object" && !Array.isArray(item);
  }
  // Getter for JsonValidationService
  getJsonValidationService() {
    return this.jsonValidationService;
  }
};

// src/services/DatabaseService.ts
var DatabaseService = class {
  constructor(saveCallback) {
    this.saveCallback = saveCallback;
    this.MAX_HISTORY_LENGTH = 100;
    this.PRUNE_THRESHOLD = 1e3;
    this.MONTH_IN_MS = 30 * 24 * 60 * 60 * 1e3;
    this.data = this.getDefaultData();
  }
  /**
   * Save data with callback and timestamp
   */
  async save() {
    try {
      this.data.lastUpdated = Date.now();
      if (this.saveCallback) {
        await this.saveCallback(this.data);
      }
      console.log("DatabaseService: Data saved successfully");
    } catch (error) {
      console.error("DatabaseService: Error saving data:", error);
      throw error;
    }
  }
  /**
   * Save data with external callback
   */
  async saveData(callback) {
    try {
      this.data.lastUpdated = Date.now();
      if (callback) {
        await callback(this.data);
      }
      console.log("DatabaseService: Data saved successfully");
    } catch (error) {
      console.error("DatabaseService: Error saving data:", error);
      throw error;
    }
  }
  /**
   * Load database from persistent storage
   */
  async load(loadData) {
    try {
      const savedData = await loadData();
      if (savedData) {
        this.data = this.migrateDataIfNeeded(savedData);
        await this.pruneOldRecordsIfNeeded();
      }
      console.log("DatabaseService: Data loaded successfully");
    } catch (error) {
      console.error("DatabaseService: Error loading data:", error);
      this.data = this.getDefaultData();
    }
  }
  /**
   * Get default database structure
   */
  getDefaultData() {
    return {
      processedFiles: [],
      processingState: {
        lastProcessedFiles: [],
        queuedFiles: [],
        errors: [],
        isPaused: false,
        currentChunkIndex: 0
      },
      processingStats: [],
      errors: [],
      lastUpdated: Date.now()
    };
  }
  /**
   * Migrate data structure if needed
   */
  migrateDataIfNeeded(savedData) {
    const migratedData = {
      ...this.getDefaultData(),
      ...savedData
    };
    migratedData.processingStats = (savedData.processingStats || []).map((stat) => ({
      ...stat,
      // Use endTime if available, otherwise fallback to startTime
      timestamp: stat.endTime || stat.startTime || Date.now()
    }));
    return migratedData;
  }
  /**
   * Mark file as processed with result
   */
  async markFileAsProcessed(file, result) {
    const existingIndex = this.data.processedFiles.findIndex((f) => f.path === file.path);
    const processedFile = {
      path: file.path,
      lastProcessed: Date.now(),
      lastModified: file.stat.mtime,
      frontMatterGenerated: result.frontMatterGenerated,
      wikilinksGenerated: result.wikilinksGenerated,
      processingTime: result.processingTime,
      retryCount: existingIndex !== -1 ? this.data.processedFiles[existingIndex].retryCount + 1 : 0,
      error: result.error
    };
    if (existingIndex !== -1) {
      this.data.processedFiles[existingIndex] = processedFile;
    } else {
      this.data.processedFiles.push(processedFile);
    }
    await this.save();
  }
  /**
   * Check if file needs processing
   */
  needsProcessing(file) {
    const processedFile = this.data.processedFiles.find((f) => f.path === file.path);
    if (!processedFile)
      return true;
    const needsUpdate = file.stat.mtime > processedFile.lastProcessed;
    const hasError = !!processedFile.error;
    return needsUpdate || hasError;
  }
  /**
   * Add processing statistics with validation
   */
  async addProcessingStats(stats) {
    const timestamp = Date.now();
    const validatedStats = {
      totalFiles: stats.totalFiles || 0,
      processedFiles: stats.processedFiles || 0,
      errorFiles: stats.errorFiles || 0,
      skippedFiles: stats.skippedFiles || 0,
      startTime: stats.startTime || timestamp,
      endTime: stats.endTime || timestamp,
      averageProcessingTime: stats.averageProcessingTime || 0,
      timestamp
    };
    this.data.processingStats.unshift(validatedStats);
    if (this.data.processingStats.length > this.MAX_HISTORY_LENGTH) {
      this.data.processingStats = this.data.processingStats.slice(0, this.MAX_HISTORY_LENGTH);
    }
    await this.save();
  }
  /**
   * Get processing statistics with fallback
   */
  getProcessingStats(days) {
    const stats = this.data.processingStats || [];
    if (days) {
      const cutoff = Date.now() - days * 24 * 60 * 60 * 1e3;
      return stats.filter((stat) => (stat.timestamp || stat.startTime) > cutoff);
    }
    return stats;
  }
  /**
   * Get summary of processing statistics
   */
  getProcessingStatsSummary() {
    if (this.data.processingStats.length === 0) {
      return {
        totalProcessed: 0,
        totalErrors: 0,
        averageTime: 0,
        successRate: 100,
        lastProcessed: 0
      };
    }
    const stats = this.data.processingStats;
    const totalProcessed = stats.reduce((sum, stat) => sum + stat.processedFiles, 0);
    const totalErrors = stats.reduce((sum, stat) => sum + stat.errorFiles, 0);
    const averageTime = stats.reduce((sum, stat) => sum + stat.averageProcessingTime, 0) / stats.length;
    const successRate = totalProcessed > 0 ? (totalProcessed - totalErrors) / totalProcessed * 100 : 100;
    const lastProcessed = stats[0].timestamp;
    return {
      totalProcessed,
      totalErrors,
      averageTime,
      successRate,
      lastProcessed
    };
  }
  /**
   * Get recent errors
   */
  getRecentErrors(limit = 10) {
    return this.data.errors.slice(0, limit);
  }
  /**
   * Add processing error
   */
  async addError(error) {
    this.data.errors.unshift(error);
    await this.save();
  }
  /**
   * Get persistent processing state
   */
  async loadProcessingState() {
    return this.data.processingState;
  }
  /**
   * Save persistent processing state
   */
  async saveProcessingState(state) {
    this.data.processingState = state;
    await this.save();
  }
  /**
   * Reset processing state to default
   */
  async resetProcessingState() {
    this.data.processingState = this.getDefaultData().processingState;
    await this.save();
  }
  /**
   * Prune old records if threshold exceeded
   */
  async pruneOldRecordsIfNeeded() {
    if (this.data.processedFiles.length <= this.PRUNE_THRESHOLD) {
      return;
    }
    const cutoff = Date.now() - this.MONTH_IN_MS;
    this.data.processedFiles = this.data.processedFiles.filter(
      (file) => file.lastProcessed > cutoff || file.error
    );
    this.data.errors = this.data.errors.filter(
      (error) => error.timestamp > cutoff
    );
    await this.save();
  }
  /**
   * Get stats for specific file
   */
  getFileStats(filePath) {
    return this.data.processedFiles.find((f) => f.path === filePath);
  }
  /**
   * Get summary of file processing history
   */
  getFileProcessingSummary() {
    const today = new Date().setHours(0, 0, 0, 0);
    const files = this.data.processedFiles;
    return {
      totalFiles: files.length,
      processedToday: files.filter((f) => f.lastProcessed > today).length,
      errorCount: files.filter((f) => f.error).length,
      averageProcessingTime: this.calculateAverageProcessingTime()
    };
  }
  /**
   * Calculate average processing time
   */
  calculateAverageProcessingTime() {
    const recentFiles = this.data.processedFiles.filter((f) => !f.error).slice(0, 100);
    if (recentFiles.length === 0)
      return 0;
    const totalTime = recentFiles.reduce((sum, file) => sum + file.processingTime, 0);
    return totalTime / recentFiles.length;
  }
};

// src/services/AutoGenerateService.ts
var import_obsidian11 = require("obsidian");
var import_events3 = require("events");
var AutoGenerateService = class {
  constructor(app, vault, aiService, settingsService, databaseService) {
    this.app = app;
    this.vault = vault;
    this.aiService = aiService;
    this.settingsService = settingsService;
    this.databaseService = databaseService;
    this.isProcessing = false;
    this.isStartupComplete = false;
    this.options = DEFAULT_PROCESSING_OPTIONS;
    this.NOTIFICATION_TIMEOUT = 3e3;
    this.eventEmitter = new import_events3.EventEmitter();
    this.initializeBatchProcessor();
  }
  /**
   * Initialize the batch processor and set up event handlers
   */
  initializeBatchProcessor() {
    this.batchProcessor = new BatchProcessor(
      this.aiService.getCurrentAdapter(),
      this.settingsService,
      this.aiService.frontMatterGenerator,
      this.aiService.wikilinkGenerator,
      this.databaseService,
      this.app
    );
    this.setupEventHandlers();
  }
  /**
   * Set up event handlers for processing events
   */
  setupEventHandlers() {
    this.batchProcessor.on("start", () => {
      this.isProcessing = true;
      this.showNotification("Starting vault content analysis...");
    });
    this.batchProcessor.on("complete", (stats) => {
      this.isProcessing = false;
      this.handleProcessingComplete(stats);
    });
    this.batchProcessor.on("error", (error) => {
      console.error("Processing error:", error);
      this.showNotification(`Error processing file: ${error.filePath}`, true);
    });
    ["progress", "pause", "resume", "error"].forEach((event) => {
      this.batchProcessor.on(event, (data) => {
        this.eventEmitter.emit(event, data);
      });
    });
  }
  /**
   * Start automatic generation process
   * Only runs during initial vault startup
   */
  async runAutoGenerate() {
    if (!this.shouldRunAutoGenerate()) {
      return;
    }
    try {
      const unprocessedFiles = await this.getUnprocessedFiles();
      if (unprocessedFiles.length === 0) {
        console.log("AutoGenerateService: No files need processing");
        this.completeStartup();
        return;
      }
      await this.processFiles(unprocessedFiles);
      this.completeStartup();
    } catch (error) {
      this.handleError("Error during startup generation process:", error);
      this.completeStartup();
    }
  }
  /**
   * Check if auto-generate should run
   */
  shouldRunAutoGenerate() {
    if (this.isStartupComplete) {
      console.log("AutoGenerateService: Startup already completed");
      return false;
    }
    if (this.isProcessing) {
      console.log("AutoGenerateService: Already processing files");
      return false;
    }
    const settings = this.settingsService.getSettings();
    if (!settings.frontMatter.autoGenerate) {
      console.log("AutoGenerateService: Auto-generate is disabled");
      this.completeStartup();
      return false;
    }
    return true;
  }
  /**
   * Mark startup as complete
   */
  completeStartup() {
    this.isStartupComplete = true;
    console.log("AutoGenerateService: Startup processing completed");
  }
  /**
   * Get files that need processing
   */
  async getUnprocessedFiles() {
    const allFiles = this.vault.getMarkdownFiles();
    const needsProcessing = await Promise.all(
      allFiles.map(async (file) => ({
        file,
        needsProcessing: await this.isUnprocessedFile(file)
      }))
    );
    return needsProcessing.filter((result) => result.needsProcessing).map((result) => result.file);
  }
  /**
   * Check if a file needs processing
   */
  async isUnprocessedFile(file) {
    try {
      if (this.isFileBeingProcessed(file)) {
        return false;
      }
      if (!this.databaseService.needsProcessing(file)) {
        return false;
      }
      const content = await this.vault.read(file);
      if (content.trim().length < 10) {
        return false;
      }
      if (content.startsWith("---\n")) {
        return false;
      }
      return true;
    } catch (error) {
      this.handleError(`Error checking file ${file.path}:`, error);
      return false;
    }
  }
  /**
   * Check if a file is currently being processed
   */
  isFileBeingProcessed(file) {
    return this.isProcessing;
  }
  /**
   * Process a batch of files
   */
  async processFiles(files) {
    const settings = this.settingsService.getSettings();
    const result = await this.batchProcessor.generate({
      files,
      generateFrontMatter: true,
      generateWikilinks: settings.advanced.generateWikilinks,
      options: this.options
    });
    await this.updateDatabase(result);
  }
  /**
   * Update database with processing results
   */
  async updateDatabase(result) {
    await Promise.all(result.fileResults.map(
      (fileResult) => this.databaseService.markFileAsProcessed(
        this.vault.getAbstractFileByPath(fileResult.path),
        fileResult
      )
    ));
  }
  /**
   * Handle processing completion
   */
  handleProcessingComplete(stats) {
    let message = `Initial vault analysis complete: ${stats.processedFiles} files processed`;
    if (stats.errorFiles > 0) {
      message += `, ${stats.errorFiles} errors`;
    }
    if (stats.endTime && stats.startTime) {
      const seconds = Math.round((stats.endTime - stats.startTime) / 1e3);
      message += ` in ${seconds}s`;
    }
    this.showNotification(message);
  }
  /**
   * Handle errors
   */
  handleError(message, error) {
    console.error(message, error);
    this.showNotification(
      `${message} ${error instanceof Error ? error.message : "Unknown error"}`,
      true
    );
  }
  /**
   * Show notification to user
   */
  showNotification(message, isError = false) {
    if (isError) {
      console.error(message);
    }
    new import_obsidian11.Notice(message, this.NOTIFICATION_TIMEOUT);
  }
  /**
   * Update processing options
   */
  updateOptions(options) {
    this.options = { ...this.options, ...options };
  }
  /**
   * Clean up resources
   */
  destroy() {
    this.eventEmitter.removeAllListeners();
    this.isStartupComplete = false;
    this.isProcessing = false;
  }
  /**
   * Initialize the status bar
   * Note: Status bar is now handled by main.ts
   */
  initializeStatusBar(_statusBarEl) {
    return;
  }
};

// src/components/status/ProcessingStatusBar.ts
var import_obsidian13 = require("obsidian");

// src/components/modals/StatusHistoryModal.ts
var import_obsidian12 = require("obsidian");
var StatusHistoryModal = class extends import_obsidian12.Modal {
  constructor(app, currentStatus, recentStats) {
    super(app);
    this.currentStatus = currentStatus;
    this.recentStats = recentStats;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("status-history-modal");
    contentEl.createEl("h2", { text: "Processing Status & History" });
    const currentStatusEl = contentEl.createDiv({ cls: "gw-accordion-content" });
    this.renderCurrentStatus(currentStatusEl);
    const historyEl = contentEl.createDiv({ cls: "gw-accordion-content" });
    this.renderProcessingHistory(historyEl);
  }
  /**
   * Render the current processing status
   */
  renderCurrentStatus(containerEl) {
    const statusEl = containerEl.createDiv({ cls: "gw-property-editor" });
    statusEl.createEl("h3", { text: "Current Status", cls: "gw-accordion-title" });
    const detailsEl = statusEl.createDiv({ cls: "gw-modal-property-list" });
    const progressPct = this.currentStatus.filesQueued > 0 ? Math.round(this.currentStatus.filesProcessed / this.currentStatus.filesQueued * 100) : 0;
    detailsEl.createSpan({
      text: `Status: ${this.currentStatus.state.toUpperCase()}`,
      cls: `gw-status-badge gw-status-${this.currentStatus.state}`
    });
    detailsEl.createEl("p", {
      text: `Progress: ${this.currentStatus.filesProcessed}/${this.currentStatus.filesQueued} files (${progressPct}%)`
    });
    if (this.currentStatus.currentFile) {
      detailsEl.createEl("p", {
        text: `Current File: ${this.currentStatus.currentFile}`
      });
    }
    if (this.currentStatus.estimatedTimeRemaining) {
      const minutes = Math.round(this.currentStatus.estimatedTimeRemaining / 6e4);
      detailsEl.createEl("p", {
        text: `Estimated Time Remaining: ${minutes} minutes`
      });
    }
    if (this.currentStatus.errors.length > 0) {
      const errorEl = statusEl.createDiv({ cls: "gw-property-editor" });
      errorEl.createEl("h4", { text: "Recent Errors", cls: "gw-accordion-title" });
      const errorList = errorEl.createEl("ul");
      this.currentStatus.errors.slice(-5).forEach((error) => {
        errorList.createEl("li", {
          text: `${error.filePath}: ${error.error}`
        });
      });
    }
  }
  /**
   * Render the processing history
   */
  renderProcessingHistory(containerEl) {
    containerEl.createEl("h3", { text: "Processing History", cls: "gw-accordion-title" });
    if (this.recentStats.length === 0) {
      containerEl.createEl("p", {
        text: "No processing history available yet.",
        cls: "no-history"
      });
      return;
    }
    const tableEl = containerEl.createEl("table", { cls: "gw-modal-property-table history-table" });
    const headerRow = tableEl.createEl("tr");
    ["Time", "Files", "Success", "Errors", "Duration", "Avg Time"].forEach((header) => {
      headerRow.createEl("th", { text: header });
    });
    this.recentStats.forEach((stat) => {
      const row = tableEl.createEl("tr");
      row.createEl("td", {
        text: new Date(stat.startTime).toLocaleTimeString()
      });
      row.createEl("td", {
        text: `${stat.processedFiles}/${stat.totalFiles}`
      });
      row.createEl("td", {
        text: `${stat.processedFiles - stat.errorFiles}`,
        cls: "success-count"
      });
      row.createEl("td", {
        text: `${stat.errorFiles}`,
        cls: stat.errorFiles > 0 ? "error-count" : ""
      });
      const duration = stat.endTime ? Math.round((stat.endTime - stat.startTime) / 1e3) : 0;
      row.createEl("td", {
        text: `${duration}s`
      });
      row.createEl("td", {
        text: `${Math.round(stat.averageProcessingTime)}ms`
      });
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/components/status/ProcessingStatusBar.ts
var ProcessingState2 = /* @__PURE__ */ ((ProcessingState3) => {
  ProcessingState3["IDLE"] = "idle";
  ProcessingState3["RUNNING"] = "running";
  ProcessingState3["ERROR"] = "error";
  return ProcessingState3;
})(ProcessingState2 || {});
var ProcessingStatusBar = class {
  constructor(app, statusBar, eventEmitter, aiService, settingsService, databaseService, config = {}) {
    this.app = app;
    this.statusBar = statusBar;
    this.eventEmitter = eventEmitter;
    this.aiService = aiService;
    this.settingsService = settingsService;
    this.databaseService = databaseService;
    this.config = config;
    this.DEFAULT_CONFIG = {
      showTooltips: true,
      updateInterval: 1e3,
      animationEnabled: true
    };
    this.currentState = "idle" /* IDLE */;
    this.currentStatus = this.getDefaultStatus();
    this.statusBarItem = this.createStatusBarItem();
    this.iconContainer = this.createIconContainer();
    this.initialize();
  }
  /**
   * Initialize the status bar component
   */
  initialize() {
    this.setupEventListeners();
    this.updateDisplay();
    this.startPeriodicUpdates();
  }
  /**
   * Create the main status bar item
   */
  createStatusBarItem() {
    const item = this.statusBar.createEl("div", {
      cls: "processing-status-bar mod-clickable"
    });
    if (this.getConfig().showTooltips) {
      item.setAttribute("aria-label", "Processing Status");
    }
    item.addEventListener("click", this.handleClick.bind(this));
    return item;
  }
  /**
   * Create the icon container
   */
  createIconContainer() {
    return this.statusBarItem.createDiv({
      cls: "processing-status-icon",
      attr: {
        "aria-hidden": "true"
      }
    });
  }
  /**
   * Set up all event listeners
   */
  setupEventListeners() {
    this.eventEmitter.on("start", ({ status }) => {
      if (status) {
        this.updateStatus("running" /* RUNNING */, status);
      }
    });
    this.eventEmitter.on("complete", async (stats) => {
      const hasErrors = this.currentStatus.errors.length > 0;
      this.updateStatus(
        hasErrors ? "error" /* ERROR */ : "idle" /* IDLE */,
        this.createCompleteStatus(stats)
      );
    });
    this.eventEmitter.on("progress", (status) => {
      if (status) {
        this.updateStatus(this.currentState, status);
      }
    });
    this.eventEmitter.on("error", () => {
      this.updateStatus("error" /* ERROR */, this.currentStatus);
    });
  }
  /**
   * Update current status and trigger display update
   */
  updateStatus(state, status) {
    this.currentState = state;
    this.currentStatus = status;
    this.updateDisplay();
  }
  /**
   * Update the visual display of the status bar
   */
  updateDisplay() {
    this.updateStateClasses();
    this.updateIcon();
    if (this.getConfig().showTooltips) {
      this.updateTooltip();
    }
  }
  /**
   * Update the status bar state classes
   */
  updateStateClasses() {
    Object.values(ProcessingState2).forEach((state) => {
      this.statusBarItem.removeClass(`status-${state}`);
    });
    this.statusBarItem.addClass(`status-${this.currentState}`);
  }
  /**
   * Update the status icon
   */
  updateIcon() {
    this.iconContainer.empty();
    (0, import_obsidian13.setIcon)(this.iconContainer, "loader-2");
    this.iconContainer.toggleClass(
      "animated",
      this.getConfig().animationEnabled && this.currentState === "running" /* RUNNING */
    );
  }
  /**
   * Update the tooltip text
   */
  updateTooltip() {
    const tooltipText = this.getTooltipText();
    this.statusBarItem.setAttribute("aria-label", tooltipText);
    this.statusBarItem.dataset.tooltip = tooltipText;
  }
  /**
   * Get the current tooltip text based on state and status
   */
  getTooltipText() {
    const { filesProcessed, filesQueued } = this.currentStatus;
    switch (this.currentState) {
      case "running" /* RUNNING */:
        return `Processing: ${filesProcessed}/${filesQueued} files`;
      case "error" /* ERROR */:
        return `Error: ${this.currentStatus.errors.length} errors occurred`;
      case "idle" /* IDLE */:
        return filesProcessed > 0 ? `Complete: ${filesProcessed} files processed` : "Ready";
      default:
        return "Unknown status";
    }
  }
  /**
   * Handle status bar click
   */
  async handleClick() {
    const recentStats = await this.databaseService.getProcessingStats();
    new StatusHistoryModal(
      this.app,
      this.getSafeStatus(),
      recentStats
    ).open();
  }
  /**
   * Start periodic status updates
   */
  startPeriodicUpdates() {
    if (this.updateInterval) {
      clearInterval(this.updateInterval);
    }
    this.updateInterval = setInterval(() => {
      if (this.currentState === "running" /* RUNNING */) {
        this.updateDisplay();
      }
    }, this.getConfig().updateInterval);
  }
  /**
   * Get merged configuration with defaults
   */
  getConfig() {
    return { ...this.DEFAULT_CONFIG, ...this.config };
  }
  /**
   * Get default status object
   */
  getDefaultStatus() {
    return {
      state: "idle",
      filesQueued: 0,
      filesProcessed: 0,
      filesRemaining: 0,
      errors: []
    };
  }
  /**
   * Create status object for completion
   */
  createCompleteStatus(stats) {
    return {
      state: "idle",
      filesQueued: stats.totalFiles,
      filesProcessed: stats.processedFiles,
      filesRemaining: 0,
      errors: this.currentStatus.errors || []
    };
  }
  /**
   * Get safe status object with default values
   */
  getSafeStatus() {
    return {
      ...this.currentStatus,
      errors: this.currentStatus.errors || [],
      filesQueued: this.currentStatus.filesQueued || 0,
      filesProcessed: this.currentStatus.filesProcessed || 0,
      filesRemaining: this.currentStatus.filesRemaining || 0,
      state: this.currentStatus.state || "idle"
    };
  }
  /**
   * Clean up resources
   */
  destroy() {
    if (this.updateInterval) {
      clearInterval(this.updateInterval);
    }
    this.eventEmitter.removeAllListeners();
    this.statusBarItem.remove();
  }
};

// src/settings/GraphWeaverSettingTab.ts
var import_obsidian26 = require("obsidian");

// src/components/accordions/ModelHookupAccordion.ts
var import_obsidian15 = require("obsidian");

// src/components/accordions/BaseAccordion.ts
var import_obsidian14 = require("obsidian");
var BaseAccordion = class {
  constructor(containerEl) {
    this.isOpen = false;
    this.containerEl = containerEl;
  }
  createAccordion(title, description) {
    this.accordionEl = this.containerEl.createDiv({ cls: "gw-accordion" });
    this.headerEl = this.accordionEl.createDiv({ cls: "gw-accordion-header" });
    const titleWrapper = this.headerEl.createDiv({ cls: "gw-accordion-title-wrapper" });
    titleWrapper.createSpan({ text: title, cls: "gw-accordion-title" });
    this.toggleIcon = this.headerEl.createSpan({ cls: "gw-accordion-toggle" });
    this.updateToggleIcon();
    const descriptionEl = this.accordionEl.createDiv({ cls: "gw-accordion-description" });
    descriptionEl.createSpan({ text: description });
    this.contentEl = this.accordionEl.createDiv({ cls: "gw-accordion-content" });
    this.contentEl.style.display = "none";
    this.headerEl.addEventListener("click", () => this.toggleAccordion());
    return this.contentEl;
  }
  toggleAccordion() {
    this.isOpen = !this.isOpen;
    this.contentEl.style.display = this.isOpen ? "block" : "none";
    this.updateToggleIcon();
    this.accordionEl.classList.toggle("gw-accordion-open", this.isOpen);
  }
  updateToggleIcon() {
    this.toggleIcon.empty();
    const iconText = document.createTextNode(this.isOpen ? "\u2796" : "\u2795");
    this.toggleIcon.appendChild(iconText);
  }
  createSettingItem(name, desc) {
    const setting = new import_obsidian14.Setting(this.contentEl);
    setting.setName(name).setDesc(desc);
    setting.settingEl.classList.add("gw-setting-item");
    return setting;
  }
};

// src/components/accordions/ModelHookupAccordion.ts
var ModelHookupAccordion = class extends BaseAccordion {
  constructor(app, containerEl, settingsService, aiService) {
    super(containerEl);
    this.app = app;
    this.settingsService = settingsService;
    this.aiService = aiService;
  }
  render() {
    const contentEl = this.createAccordion(
      "\u{1F50C} Model Hookup",
      "Configure AI providers and models."
    );
    this.createProviderDropdown(contentEl);
    this.settingsContainer = contentEl.createDiv({ cls: "provider-settings" });
    this.renderProviderSettings();
  }
  createProviderDropdown(containerEl) {
    const settings = this.settingsService.getSettings();
    new import_obsidian15.Setting(containerEl).setName("AI Provider").setDesc("Select the AI provider to use").addDropdown((dropdown) => {
      this.providerDropdown = dropdown;
      Object.values(AIProvider).forEach((provider) => {
        dropdown.addOption(provider, this.getFormattedProviderName(provider));
      });
      dropdown.setValue(settings.aiProvider.selected).onChange(async (value) => {
        await this.settingsService.updateNestedSetting("aiProvider", "selected", value);
        this.aiService.reinitialize();
        this.renderProviderSettings();
      });
    });
  }
  renderProviderSettings() {
    const provider = this.providerDropdown.getValue();
    this.settingsContainer.empty();
    if (provider === "lmstudio" /* LMStudio */) {
      this.renderLocalSettings();
    } else {
      this.renderCloudSettings(provider);
      this.createModelDropdown(this.settingsContainer, provider);
    }
    this.createTestButton(this.settingsContainer, provider);
  }
  renderCloudSettings(provider) {
    this.createProviderLink(this.settingsContainer, provider);
    this.createApiKeyInput(this.settingsContainer, provider);
  }
  renderLocalSettings() {
    this.createPortInput(this.settingsContainer);
    this.createModelNameInput(this.settingsContainer);
  }
  createApiKeyInput(containerEl, provider) {
    const settings = this.settingsService.getSettings();
    new import_obsidian15.Setting(containerEl).setName("API Key").setDesc(`Enter your API key for ${this.getFormattedProviderName(provider)}`).addText((text) => {
      text.setPlaceholder("Enter API Key").setValue(settings.aiProvider.apiKeys[provider] || "").onChange(async (value) => {
        const currentApiKeys = this.settingsService.getNestedSetting("aiProvider", "apiKeys");
        const updatedApiKeys = { ...currentApiKeys, [provider]: value };
        await this.settingsService.updateNestedSetting("aiProvider", "apiKeys", updatedApiKeys);
        this.aiService.reinitialize();
      });
    });
  }
  createPortInput(containerEl) {
    const settings = this.settingsService.getSettings();
    new import_obsidian15.Setting(containerEl).setName("LM Studio Port").setDesc("Enter the port number for your local LM Studio instance").addText((text) => {
      text.setPlaceholder("Enter port number").setValue(settings.localLMStudio.port.toString()).onChange(async (value) => {
        const port = parseInt(value, 10);
        if (!isNaN(port)) {
          await this.settingsService.updateNestedSetting("localLMStudio", "port", port);
          this.aiService.reinitialize();
        }
      });
    });
  }
  createModelNameInput(containerEl) {
    const settings = this.settingsService.getSettings();
    new import_obsidian15.Setting(containerEl).setName("Model Name").setDesc("Enter the name of the local model you want to use").addText((text) => {
      text.setPlaceholder("Enter model name").setValue(settings.localLMStudio.modelName).onChange(async (value) => {
        await this.settingsService.updateNestedSetting("localLMStudio", "modelName", value);
        await this.settingsService.updateNestedSetting("aiProvider", "selectedModels", {
          ...this.settingsService.getNestedSetting("aiProvider", "selectedModels"),
          ["lmstudio" /* LMStudio */]: value
        });
        this.aiService.reinitialize();
      });
    });
  }
  createModelDropdown(containerEl, provider) {
    const settings = this.settingsService.getSettings();
    const models = AIModelMap[provider];
    new import_obsidian15.Setting(containerEl).setName("Model").setDesc(`Select the AI model for ${this.getFormattedProviderName(provider)}`).addDropdown((dropdown) => {
      var _a;
      models.forEach((model) => {
        dropdown.addOption(model.apiName, model.name);
      });
      const currentModel = settings.aiProvider.selectedModels[provider] || (((_a = models[0]) == null ? void 0 : _a.apiName) || "");
      dropdown.setValue(currentModel).onChange(async (value) => {
        const currentSelectedModels = this.settingsService.getNestedSetting("aiProvider", "selectedModels");
        const updatedSelectedModels = { ...currentSelectedModels, [provider]: value };
        await this.settingsService.updateNestedSetting("aiProvider", "selectedModels", updatedSelectedModels);
      });
    });
  }
  createTestButton(containerEl, provider) {
    new import_obsidian15.Setting(containerEl).addButton((button) => {
      button.setButtonText("Test Connection").onClick(async () => {
        button.setDisabled(true);
        button.setButtonText("Testing...");
        const result = await this.aiService.testConnection(provider);
        button.setDisabled(false);
        button.setButtonText("Test Connection");
        if (result) {
          new import_obsidian15.Notice(`Successfully connected to ${this.getFormattedProviderName(provider)}`);
        } else {
          new import_obsidian15.Notice(`Failed to connect to ${this.getFormattedProviderName(provider)}. Please check your settings and try again.`);
        }
      });
    });
  }
  createProviderLink(containerEl, provider) {
    const websiteUrl = this.getProviderWebsite(provider);
    const linkText = provider === "lmstudio" /* LMStudio */ ? "LM Studio Documentation" : "Get API Key";
    const linkEl = containerEl.createEl("a", {
      text: linkText,
      href: websiteUrl,
      cls: "provider-link"
    });
    linkEl.setAttribute("target", "_blank");
    const providerLabel = containerEl.createEl("span", {
      text: ` for ${this.getFormattedProviderName(provider)}`,
      cls: "provider-label"
    });
  }
  getProviderWebsite(provider) {
    const websiteMap = {
      ["openai" /* OpenAI */]: "https://platform.openai.com/api-keys",
      ["anthropic" /* Anthropic */]: "https://console.anthropic.com/settings/keys",
      ["google" /* Google */]: "https://aistudio.google.com/apikey",
      ["groq" /* Groq */]: "https://console.groq.com/keys",
      ["openrouter" /* OpenRouter */]: "https://openrouter.ai/settings/keys",
      ["lmstudio" /* LMStudio */]: "https://lmstudio.ai/docs/basics/server"
    };
    return websiteMap[provider] || "#";
  }
  getFormattedProviderName(provider) {
    const formattedNames = {
      ["openai" /* OpenAI */]: "OpenAI",
      ["anthropic" /* Anthropic */]: "Anthropic",
      ["google" /* Google */]: "Google Gemini",
      ["groq" /* Groq */]: "Groq",
      ["openrouter" /* OpenRouter */]: "OpenRouter",
      ["lmstudio" /* LMStudio */]: "LM Studio"
    };
    return formattedNames[provider] || provider;
  }
};

// src/components/accordions/PropertyManagerAccordion.ts
var import_obsidian17 = require("obsidian");

// src/components/modals/EditPropertiesModal.ts
var import_obsidian16 = require("obsidian");
var EditPropertiesModal = class extends import_obsidian16.Modal {
  constructor(app, properties, onSubmit) {
    super(app);
    this.properties = [...properties];
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Edit Properties" });
    this.createSelectAllCheckbox(contentEl);
    this.propertyListEl = contentEl.createDiv({ cls: "gw-modal-property-list" });
    this.renderPropertyList();
    const buttonContainer = contentEl.createDiv({ cls: "gw-modal-button-container" });
    new import_obsidian16.Setting(buttonContainer).addButton((btn) => btn.setButtonText("Delete Selected").setWarning().onClick(() => this.deleteSelectedProperties())).addButton((btn) => btn.setButtonText("Save").setCta().onClick(() => {
      this.onSubmit(this.properties);
      this.close();
    })).addButton((btn) => btn.setButtonText("Cancel").onClick(() => this.close()));
  }
  createSelectAllCheckbox(containerEl) {
    const selectAllContainer = containerEl.createDiv({ cls: "gw-select-all-container" });
    this.selectAllCheckbox = selectAllContainer.createEl("input", { type: "checkbox" });
    selectAllContainer.createEl("span", { text: "Select All" });
    this.selectAllCheckbox.addEventListener("change", () => {
      const checkboxes = this.propertyListEl.querySelectorAll('input[type="checkbox"]');
      checkboxes.forEach((checkbox) => {
        checkbox.checked = this.selectAllCheckbox.checked;
      });
    });
  }
  renderPropertyList() {
    this.propertyListEl.empty();
    const table = this.propertyListEl.createEl("table", { cls: "gw-modal-property-table" });
    const headerRow = table.createEl("tr");
    headerRow.createEl("th", { text: "Drag" });
    headerRow.createEl("th", { text: "Name" });
    headerRow.createEl("th", { text: "Description" });
    headerRow.createEl("th", { text: "Type" });
    headerRow.createEl("th", { text: "Delete" });
    this.properties.forEach((property, index) => {
      const row = table.createEl("tr", { attr: { draggable: "true", "data-index": index.toString() } });
      row.addEventListener("dragstart", this.onDragStart.bind(this));
      row.addEventListener("dragover", this.onDragOver.bind(this));
      row.addEventListener("drop", this.onDrop.bind(this));
      row.createEl("td", { text: "\u2261", cls: "gw-drag-handle" });
      this.createEditableCell(row, property, "name", index);
      this.createEditableCell(row, property, "description", index);
      this.createTypeDropdown(row, property, index);
      const deleteCell = row.createEl("td");
      const deleteCheckbox = deleteCell.createEl("input", { type: "checkbox" });
      deleteCheckbox.dataset.index = index.toString();
      deleteCheckbox.addEventListener("change", () => this.updateSelectAllCheckbox());
    });
  }
  updateSelectAllCheckbox() {
    const checkboxes = this.propertyListEl.querySelectorAll('input[type="checkbox"]');
    const allChecked = Array.from(checkboxes).every((checkbox) => checkbox.checked);
    this.selectAllCheckbox.checked = allChecked;
  }
  createEditableCell(row, property, field, index) {
    const cell = row.createEl("td");
    const input = new import_obsidian16.TextComponent(cell);
    input.setValue(property[field]).onChange((value) => {
      this.properties[index][field] = value;
    });
  }
  createTypeDropdown(row, property, index) {
    const cell = row.createEl("td");
    const dropdown = new import_obsidian16.DropdownComponent(cell);
    const types = ["string", "number", "boolean", "array", "date"];
    types.forEach((type) => {
      dropdown.addOption(type, type);
    });
    dropdown.setValue(property.type).onChange((value) => {
      this.properties[index].type = value;
    });
  }
  deleteSelectedProperties() {
    const checkboxes = this.propertyListEl.querySelectorAll('input[type="checkbox"]:checked');
    const indicesToDelete = Array.from(checkboxes).map((cb) => parseInt(cb.dataset.index || "", 10)).sort((a, b) => b - a);
    indicesToDelete.forEach((index) => {
      this.properties.splice(index, 1);
    });
    this.renderPropertyList();
    this.updateSelectAllCheckbox();
  }
  onDragStart(e) {
    var _a;
    const target = e.target;
    (_a = e.dataTransfer) == null ? void 0 : _a.setData("text/plain", target.dataset.index || "");
  }
  onDragOver(e) {
    e.preventDefault();
  }
  onDrop(e) {
    var _a, _b;
    e.preventDefault();
    const fromIndex = parseInt(((_a = e.dataTransfer) == null ? void 0 : _a.getData("text/plain")) || "", 10);
    const toIndex = parseInt(((_b = e.target.closest("tr")) == null ? void 0 : _b.dataset.index) || "", 10);
    if (!isNaN(fromIndex) && !isNaN(toIndex)) {
      const [reorderedItem] = this.properties.splice(fromIndex, 1);
      this.properties.splice(toIndex, 0, reorderedItem);
      this.renderPropertyList();
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/components/accordions/PropertyManagerAccordion.ts
var PropertyManagerAccordion = class extends BaseAccordion {
  constructor(app, containerEl, settingsService, aiService) {
    super(containerEl);
    this.app = app;
    this.settingsService = settingsService;
    this.aiService = aiService;
  }
  render() {
    const contentEl = this.createAccordion(
      "\u{1F4CA} Property Management",
      "Create and manage custom properties for your notes."
    );
    this.createPropertyEditor(contentEl);
    this.createButtonRow(contentEl);
  }
  createPropertyEditor(containerEl) {
    const editorContainer = containerEl.createDiv({ cls: "gw-property-editor" });
    new import_obsidian17.Setting(editorContainer).setName("Property Name").addText((text) => {
      this.nameInput = text;
      text.setPlaceholder("Enter property name");
    });
    new import_obsidian17.Setting(editorContainer).setName("Property Description").addTextArea((textarea) => {
      this.descriptionInput = textarea;
      textarea.setPlaceholder("Enter property description");
    });
    new import_obsidian17.Setting(editorContainer).setName("Property Type").addDropdown((dropdown) => {
      this.typeDropdown = dropdown;
      dropdown.addOption("string", "String").addOption("number", "Number").addOption("boolean", "Boolean").addOption("array", "Array").addOption("date", "Date").setValue("string");
    });
  }
  createButtonRow(containerEl) {
    const buttonContainer = containerEl.createDiv({ cls: "gw-button-container" });
    new import_obsidian17.Setting(buttonContainer).addButton((button) => button.setButtonText("Edit Properties").onClick(() => this.openEditModal())).addButton((button) => button.setButtonText("Add Property").setCta().onClick(() => this.addProperty()));
  }
  addProperty() {
    const name = this.nameInput.getValue().trim();
    const description = this.descriptionInput.getValue().trim();
    const type = this.typeDropdown.getValue();
    if (!name) {
      new import_obsidian17.Notice("Property name cannot be empty.");
      return;
    }
    if (!description) {
      new import_obsidian17.Notice("Property description cannot be empty.");
      return;
    }
    const newProperty = {
      name,
      description,
      type,
      required: false,
      multipleValues: false
    };
    const settings = this.settingsService.getSettings();
    settings.frontMatter.customProperties.push(newProperty);
    this.settingsService.updateSettings(settings);
    new import_obsidian17.Notice(`Property "${name}" has been added.`);
    this.nameInput.setValue("");
    this.descriptionInput.setValue("");
    this.typeDropdown.setValue("string");
  }
  openEditModal() {
    const modal = new EditPropertiesModal(
      this.app,
      this.settingsService.getSettings().frontMatter.customProperties,
      (updatedProperties) => {
        const settings = this.settingsService.getSettings();
        settings.frontMatter.customProperties = updatedProperties;
        this.settingsService.updateSettings(settings);
      }
    );
    modal.open();
  }
};

// src/components/accordions/TagManagerAccordion.ts
var import_obsidian19 = require("obsidian");

// src/components/modals/EditTagsModal.ts
var import_obsidian18 = require("obsidian");
var EditTagsModal = class extends import_obsidian18.Modal {
  constructor(app, tags, onSubmit) {
    super(app);
    this.tags = [...tags];
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Edit Tags" });
    this.createSelectAllCheckbox(contentEl);
    this.tagListEl = contentEl.createDiv({ cls: "gw-modal-tag-list" });
    this.renderTagList();
    const buttonContainer = contentEl.createDiv({ cls: "gw-modal-button-container" });
    new import_obsidian18.Setting(buttonContainer).addButton((btn) => btn.setButtonText("Delete Selected").setWarning().onClick(() => this.deleteSelectedTags())).addButton((btn) => btn.setButtonText("Save").setCta().onClick(() => {
      this.onSubmit(this.tags);
      this.close();
    })).addButton((btn) => btn.setButtonText("Cancel").onClick(() => this.close()));
  }
  createSelectAllCheckbox(containerEl) {
    const selectAllContainer = containerEl.createDiv({ cls: "gw-select-all-container" });
    this.selectAllCheckbox = selectAllContainer.createEl("input", { type: "checkbox" });
    selectAllContainer.createEl("span", { text: "Select All" });
    this.selectAllCheckbox.addEventListener("change", () => {
      const checkboxes = this.tagListEl.querySelectorAll('input[type="checkbox"]');
      checkboxes.forEach((checkbox) => {
        checkbox.checked = this.selectAllCheckbox.checked;
      });
    });
  }
  renderTagList() {
    this.tagListEl.empty();
    const table = this.tagListEl.createEl("table", { cls: "gw-modal-tag-table" });
    const headerRow = table.createEl("tr");
    headerRow.createEl("th", { text: "Name" });
    headerRow.createEl("th", { text: "Description" });
    headerRow.createEl("th", { text: "Delete" });
    this.tags.forEach((tag, index) => {
      const row = table.createEl("tr");
      this.createEditableCell(row, tag, "name", index);
      this.createEditableCell(row, tag, "description", index);
      const deleteCell = row.createEl("td");
      const deleteCheckbox = deleteCell.createEl("input", { type: "checkbox" });
      deleteCheckbox.dataset.index = index.toString();
      deleteCheckbox.addEventListener("change", () => this.updateSelectAllCheckbox());
    });
  }
  updateSelectAllCheckbox() {
    const checkboxes = this.tagListEl.querySelectorAll('input[type="checkbox"]');
    const allChecked = Array.from(checkboxes).every((checkbox) => checkbox.checked);
    this.selectAllCheckbox.checked = allChecked;
  }
  createEditableCell(row, tag, field, index) {
    const cell = row.createEl("td");
    const input = field === "name" ? new import_obsidian18.TextComponent(cell) : new import_obsidian18.TextAreaComponent(cell);
    input.setValue(tag[field]).onChange((value) => {
      this.tags[index][field] = value;
    });
  }
  deleteSelectedTags() {
    const checkboxes = this.tagListEl.querySelectorAll('input[type="checkbox"]:checked');
    const indicesToDelete = Array.from(checkboxes).map((cb) => parseInt(cb.dataset.index || "", 10)).sort((a, b) => b - a);
    indicesToDelete.forEach((index) => {
      this.tags.splice(index, 1);
    });
    this.renderTagList();
    this.updateSelectAllCheckbox();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/components/accordions/TagManagerAccordion.ts
var TagManagerAccordion = class extends BaseAccordion {
  constructor(app, containerEl, settingsService, aiService) {
    super(containerEl);
    this.app = app;
    this.settingsService = settingsService;
    this.aiService = aiService;
  }
  render() {
    const contentEl = this.createAccordion(
      "\u{1F3F7}\uFE0F Tag Management",
      "Create and manage custom tags for your notes."
    );
    this.createTagEditor(contentEl);
    this.createButtonRow(contentEl);
  }
  createTagEditor(containerEl) {
    const editorContainer = containerEl.createDiv({ cls: "gw-tag-editor" });
    new import_obsidian19.Setting(editorContainer).setName("Tag Name").addText((text) => {
      this.nameInput = text;
      text.setPlaceholder("Enter tag name");
    });
    new import_obsidian19.Setting(editorContainer).setName("Tag Description").addTextArea((textarea) => {
      this.descriptionInput = textarea;
      textarea.setPlaceholder("Enter tag description");
    });
  }
  createButtonRow(containerEl) {
    const buttonContainer = containerEl.createDiv({ cls: "gw-button-container" });
    new import_obsidian19.Setting(buttonContainer).addButton((button) => button.setButtonText("Edit Tags").onClick(() => this.openEditModal())).addButton((button) => button.setButtonText("Add Tag").setCta().onClick(() => this.addTag()));
  }
  addTag() {
    const name = this.nameInput.getValue().trim();
    const description = this.descriptionInput.getValue().trim();
    if (!name) {
      new import_obsidian19.Notice("Tag name cannot be empty.");
      return;
    }
    const newTag = {
      name,
      description,
      type: "string",
      required: false,
      multipleValues: false
    };
    const settings = this.settingsService.getSettings();
    settings.tags.customTags.push(newTag);
    this.settingsService.updateSettings(settings);
    new import_obsidian19.Notice(`Tag "${name}" has been added.`);
    this.nameInput.setValue("");
    this.descriptionInput.setValue("");
  }
  openEditModal() {
    const modal = new EditTagsModal(
      this.app,
      this.settingsService.getSettings().tags.customTags,
      (updatedTags) => {
        const settings = this.settingsService.getSettings();
        settings.tags.customTags = updatedTags;
        this.settingsService.updateSettings(settings);
      }
    );
    modal.open();
  }
};

// src/components/accordions/OntologyGenerationAccordion.ts
var import_obsidian21 = require("obsidian");

// src/components/modals/OntologyGeneratorModal.ts
var import_obsidian20 = require("obsidian");
var OntologyGeneratorModal = class extends import_obsidian20.Modal {
  constructor(app, aiService, onGenerate) {
    super(app);
    this.aiService = aiService;
    this.onGenerate = onGenerate;
    this.vaultStats = { files: [], folders: [], tags: [] };
    this.availableModels = [];
  }
  async onOpen() {
    this.contentEl.empty();
    this.contentEl.addClass("ontology-generator-modal");
    this.loadingEl = this.contentEl.createDiv("loading-container");
    this.loadingEl.innerHTML = '<div class="spinner"></div><p>Retrieving vault statistics and available models...</p>';
    try {
      await this.loadVaultStats();
      this.availableModels = this.aiService.getAllAvailableModels();
      this.renderContent();
    } catch (error) {
      console.error("Error loading data:", error);
      this.showError("An error occurred while retrieving data.");
    }
  }
  async loadVaultStats() {
    this.vaultStats.files = this.app.vault.getMarkdownFiles();
    this.vaultStats.folders = this.app.vault.getAllLoadedFiles().filter((file) => file instanceof import_obsidian20.TFolder);
    this.vaultStats.tags = await this.getAllTags(this.vaultStats.files);
  }
  async getAllTags(files) {
    const tagSet = /* @__PURE__ */ new Set();
    for (const file of files) {
      const content = await this.app.vault.read(file);
      const tags = content.match(/#[\w-]+/g);
      if (tags) {
        tags.forEach((tag) => tagSet.add(tag));
      }
    }
    return Array.from(tagSet);
  }
  renderContent() {
    this.loadingEl.hide();
    this.contentEl.empty();
    this.contentEl.createEl("h2", { text: "Generate Ontology" });
    this.renderVaultStats();
    this.renderModelSelection();
    this.renderUserContextInput();
    this.renderGuidedQuestions();
    this.renderButtons();
  }
  renderVaultStats() {
    const statsEl = this.contentEl.createDiv("vault-stats");
    statsEl.createEl("h3", { text: "Vault Statistics" });
    const listEl = statsEl.createEl("ul");
    listEl.createEl("li", { text: `Files: ${this.vaultStats.files.length}` });
    listEl.createEl("li", { text: `Folders: ${this.vaultStats.folders.length}` });
    listEl.createEl("li", { text: `Tags: ${this.vaultStats.tags.length}` });
  }
  renderModelSelection() {
    const modelSetting = new import_obsidian20.Setting(this.contentEl).setName("AI Model").setDesc("Select the AI model to use for ontology generation");
    if (this.availableModels.length === 0) {
      modelSetting.setDesc("No AI models available. Please add API keys in the API Integration settings.");
      return;
    }
    modelSetting.addDropdown((dropdown) => {
      this.modelSelect = dropdown;
      this.availableModels.forEach(({ provider, model }) => {
        const optionText = `${provider} - ${model.name}`;
        dropdown.addOption(`${provider}:${model.apiName}`, optionText);
      });
      if (this.availableModels.length > 0) {
        const firstModel = this.availableModels[0];
        dropdown.setValue(`${firstModel.provider}:${firstModel.model.apiName}`);
      }
    });
  }
  renderUserContextInput() {
    const contextSetting = new import_obsidian20.Setting(this.contentEl).setName("Additional Context").setDesc("Provide any additional context or information about your knowledge base that might help in generating a more accurate ontology.").addTextArea((text) => {
      this.userContextInput = text;
      text.inputEl.rows = 4;
      text.inputEl.cols = 50;
      return text;
    });
  }
  renderGuidedQuestions() {
    const questionsEl = this.contentEl.createDiv("guided-questions");
    questionsEl.createEl("h4", { text: "Guided Questions" });
    questionsEl.createEl("p", { text: "Consider the following questions when providing additional context:" });
    const questionsList = questionsEl.createEl("ul");
    [
      "What are the main themes or topics in your knowledge base?",
      "Are there any specific hierarchies or relationships between concepts that you want to emphasize?",
      "What are your goals for organizing your knowledge base?"
    ].forEach((question) => {
      questionsList.createEl("li", { text: question });
    });
  }
  renderButtons() {
    const buttonContainer = this.contentEl.createDiv("button-container");
    this.generateButton = new import_obsidian20.ButtonComponent(buttonContainer).setButtonText("Generate Ontology").setCta().setDisabled(this.availableModels.length === 0).onClick(() => this.generateOntology());
    new import_obsidian20.ButtonComponent(buttonContainer).setButtonText("Cancel").onClick(() => this.close());
  }
  async generateOntology() {
    const modelValue = this.modelSelect.getValue();
    if (!modelValue) {
      new import_obsidian20.Notice("Please select an AI model first.");
      return;
    }
    const [provider, modelApiName] = modelValue.split(":");
    this.generateButton.setDisabled(true);
    const loadingNotice = new import_obsidian20.Notice("Generating ontology...", 0);
    try {
      const input = {
        ...this.vaultStats,
        provider,
        modelApiName,
        userContext: this.userContextInput.getValue()
      };
      const ontology = await this.aiService.generateOntology(input);
      await this.aiService.updateTags(ontology.suggestedTags);
      loadingNotice.hide();
      new import_obsidian20.Notice("Ontology generated and tags updated successfully!", 3e3);
      this.onGenerate(ontology);
      this.close();
    } catch (error) {
      console.error("Error generating ontology:", error);
      loadingNotice.hide();
      new import_obsidian20.Notice(`Failed to generate ontology: ${error.message}`, 5e3);
    } finally {
      this.generateButton.setDisabled(false);
    }
  }
  showError(message) {
    this.loadingEl.hide();
    this.contentEl.empty();
    this.contentEl.createEl("p", { text: message, cls: "error-message" });
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/components/accordions/OntologyGenerationAccordion.ts
var OntologyGenerationAccordion = class extends BaseAccordion {
  constructor(app, containerEl, settingsService, aiService) {
    super(containerEl);
    this.app = app;
    this.settingsService = settingsService;
    this.aiService = aiService;
  }
  render() {
    const contentEl = this.createAccordion(
      "\u{1F578} Ontology Generator",
      "Generate ontology tags for your knowledge base."
    );
    this.createDescription(contentEl);
    this.createGenerateButton(contentEl);
  }
  createDescription(containerEl) {
    const descEl = containerEl.createDiv({ cls: "ontology-description" });
    descEl.createEl("p", { text: "The Ontology Generator analyzes your vault's structure, including tags, file names, and folder names, to create a comprehensive set of suggested tags. This tool helps you:" });
    const listEl = descEl.createEl("ul");
    [
      "Discover new connections in your knowledge base",
      "Improve note categorization and searchability",
      "Save time on manual tagging",
      "Gain insights into your collected information"
    ].forEach((item) => {
      listEl.createEl("li", { text: item });
    });
  }
  createGenerateButton(containerEl) {
    new import_obsidian21.Setting(containerEl).addButton((button) => this.setupGenerateButton(button));
  }
  setupGenerateButton(button) {
    button.setButtonText("Generate Ontology").setCta().onClick(() => this.openGeneratorModal());
  }
  openGeneratorModal() {
    new OntologyGeneratorModal(
      this.app,
      this.aiService,
      this.handleGeneratedOntology.bind(this)
    ).open();
  }
  async handleGeneratedOntology(generatedOntology) {
    console.log("Ontology generated:", generatedOntology);
    const currentSettings = this.settingsService.getSettings();
    const updatedSettings = {
      ...currentSettings,
      ontology: {
        ...currentSettings.ontology,
        lastGenerated: JSON.stringify(generatedOntology)
      }
    };
    await this.settingsService.updateSettings(updatedSettings);
    new import_obsidian21.Notice("Ontology has been successfully generated and saved to your settings.");
  }
};

// src/components/accordions/BatchProcessorAccordion.ts
var import_obsidian23 = require("obsidian");

// src/components/modals/BatchProcessorModal.ts
var import_obsidian22 = require("obsidian");
var BatchProcessorModal = class extends import_obsidian22.Modal {
  constructor(app, aiService, settingsService) {
    super(app);
    this.aiService = aiService;
    this.settingsService = settingsService;
  }
  onOpen() {
    this.renderContent();
  }
  onClose() {
    this.contentEl.empty();
  }
  renderContent() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Select Files/Folders to Process" });
    const fileExplorer = contentEl.createDiv({ cls: "file-explorer" });
    this.renderVaultStructure(fileExplorer);
    this.createButtons(contentEl);
  }
  renderVaultStructure(containerEl) {
    const rootFolder = this.app.vault.getRoot();
    rootFolder.children.forEach((child) => {
      if (child instanceof import_obsidian22.TFolder) {
        this.renderFolder(containerEl, child);
      } else if (child instanceof import_obsidian22.TFile) {
        containerEl.appendChild(this.createFileElement(child));
      }
    });
  }
  renderFolder(containerEl, folder) {
    const folderEl = this.createFolderElement(folder);
    containerEl.appendChild(folderEl);
    const contentEl = folderEl.querySelector(".folder-content");
    folder.children.forEach((child) => {
      if (child instanceof import_obsidian22.TFolder) {
        this.renderFolder(contentEl, child);
      } else if (child instanceof import_obsidian22.TFile) {
        contentEl.appendChild(this.createFileElement(child));
      }
    });
  }
  createFolderElement(folder) {
    const folderEl = document.createElement("div");
    folderEl.className = "folder";
    const nameEl = folderEl.createDiv({ cls: "folder-name" });
    nameEl.createSpan({ cls: "icon folder-icon", text: "\u{1F4C1}" });
    const checkbox = nameEl.createEl("input", { type: "checkbox" });
    checkbox.className = "folder-checkbox";
    nameEl.createSpan({ text: folder.name });
    const contentEl = folderEl.createDiv({ cls: "folder-content" });
    folderEl.setAttribute("data-path", folder.path);
    nameEl.addEventListener("click", (e) => {
      if (e.target !== checkbox) {
        folderEl.classList.toggle("open");
      }
    });
    checkbox.addEventListener("change", () => this.handleFolderCheckboxChange(checkbox));
    return folderEl;
  }
  createFileElement(file) {
    const fileEl = document.createElement("div");
    fileEl.className = "file";
    fileEl.createSpan({ cls: "icon file-icon", text: "\u{1F4C4}" });
    const checkbox = fileEl.createEl("input", { type: "checkbox" });
    checkbox.className = "file-checkbox";
    fileEl.createSpan({ text: file.name });
    fileEl.setAttribute("data-path", file.path);
    checkbox.addEventListener("change", () => this.handleFileCheckboxChange(checkbox));
    return fileEl;
  }
  handleFolderCheckboxChange(checkbox) {
    const folderEl = checkbox.closest(".folder");
    if (!folderEl)
      return;
    const descendantCheckboxes = folderEl.querySelectorAll("input[type='checkbox']");
    descendantCheckboxes.forEach((childCheckbox) => {
      childCheckbox.checked = checkbox.checked;
      childCheckbox.indeterminate = false;
    });
    this.updateParentCheckboxes(checkbox);
  }
  handleFileCheckboxChange(checkbox) {
    this.updateParentCheckboxes(checkbox);
  }
  updateParentCheckboxes(checkbox) {
    var _a, _b, _c;
    let parentFolderEl = (_b = (_a = checkbox.closest(".folder")) == null ? void 0 : _a.parentElement) == null ? void 0 : _b.closest(".folder");
    while (parentFolderEl) {
      const parentCheckbox = parentFolderEl.querySelector(".folder-checkbox");
      const childCheckboxes = parentFolderEl.querySelectorAll(":scope > .folder-content .folder > .folder-name > .folder-checkbox, :scope > .folder-content .file > .file-checkbox");
      const allChecked = Array.from(childCheckboxes).every((cb) => cb.checked);
      const someChecked = Array.from(childCheckboxes).some((cb) => cb.checked);
      parentCheckbox.checked = allChecked;
      parentCheckbox.indeterminate = !allChecked && someChecked;
      parentFolderEl = (_c = parentFolderEl.parentElement) == null ? void 0 : _c.closest(".folder");
    }
  }
  createButtons(containerEl) {
    const buttonContainer = containerEl.createDiv({ cls: "button-container" });
    buttonContainer.createEl("button", { text: "Cancel", cls: "mod-cancel" }).addEventListener("click", () => this.close());
    buttonContainer.createEl("button", { text: "Confirm", cls: "mod-cta" }).addEventListener("click", () => this.confirmUpdate());
  }
  async confirmUpdate() {
    const selectedPaths = this.getSelectedPaths();
    if (selectedPaths.length === 0) {
      new import_obsidian22.Notice("No files selected for processing. Please select files or folders to update.");
      return;
    }
    this.close();
    await this.processSelectedFiles(selectedPaths);
  }
  getSelectedPaths() {
    const selectedPaths = [];
    const fileCheckboxes = this.contentEl.querySelectorAll(".file-checkbox:checked");
    fileCheckboxes.forEach((checkbox) => {
      const fileEl = checkbox.closest(".file");
      if (fileEl) {
        const path = fileEl.getAttribute("data-path");
        if (path) {
          selectedPaths.push(path);
        }
      }
    });
    return selectedPaths;
  }
  async processSelectedFiles(selectedPaths) {
    const totalFiles = selectedPaths.length;
    let updatedCount = 0;
    let errorCount = 0;
    const progressNotice = new import_obsidian22.Notice(`Processing 0/${totalFiles} files...`, 0);
    for (const path of selectedPaths) {
      try {
        const file = this.app.vault.getAbstractFileByPath(path);
        if (file instanceof import_obsidian22.TFile) {
          await this.updateFile(file);
          updatedCount++;
          progressNotice.setMessage(`Processing ${updatedCount}/${totalFiles} files...`);
        }
      } catch (error) {
        console.error(`Error updating file ${path}:`, error);
        errorCount++;
      }
    }
    progressNotice.hide();
    let message = `Updated ${updatedCount} file${updatedCount !== 1 ? "s" : ""} successfully.`;
    if (errorCount > 0) {
      message += ` Encountered errors in ${errorCount} file${errorCount !== 1 ? "s" : ""}.`;
    }
    new import_obsidian22.Notice(message, 5e3);
  }
  async updateFile(file) {
    const content = await this.app.vault.read(file);
    const updatedContent = await this.processContent(content);
    await this.app.vault.modify(file, updatedContent);
  }
  async processContent(content) {
    console.log("BatchProcessorModal: Starting content processing");
    let processedContent = content;
    console.log("BatchProcessorModal: Generating front matter");
    const frontMatter = await this.aiService.generateFrontMatter(processedContent);
    processedContent = this.addOrUpdateFrontMatter(processedContent, frontMatter);
    const settings = this.settingsService.getSettings();
    if (settings.advanced.generateWikilinks) {
      console.log("BatchProcessorModal: Generating wikilinks");
      processedContent = await this.aiService.generateWikilinks(processedContent);
    }
    return processedContent;
  }
  addOrUpdateFrontMatter(content, newFrontMatter) {
    const frontMatterRegex = /^---\n[\s\S]*?\n---\n*/;
    if (frontMatterRegex.test(content)) {
      return content.replace(frontMatterRegex, `${newFrontMatter}

`);
    } else {
      return `${newFrontMatter}

${content}`;
    }
  }
};

// src/components/accordions/BatchProcessorAccordion.ts
var BatchProcessorAccordion = class extends BaseAccordion {
  constructor(app, containerEl, settingsService, aiService) {
    super(containerEl);
    this.app = app;
    this.settingsService = settingsService;
    this.aiService = aiService;
  }
  render() {
    const contentEl = this.createAccordion(
      "\u{1F504} Batch Processor",
      "Process multiple files to generate front matter and wikilinks."
    );
    this.createAutoGenerateToggle(contentEl);
    this.createRunBatchProcessorButton(contentEl);
  }
  createAutoGenerateToggle(containerEl) {
    new import_obsidian23.Setting(containerEl).setName("Auto-generate Front Matter").setDesc("Automatically generate front matter for new or unprocessed notes when you open your vault.").addToggle((toggle) => this.setupAutoGenerateToggle(toggle));
  }
  setupAutoGenerateToggle(toggle) {
    const settings = this.settingsService.getSettings();
    toggle.setValue(settings.frontMatter.autoGenerate).onChange(async (value) => {
      await this.settingsService.updateNestedSetting("frontMatter", "autoGenerate", value);
    });
  }
  createRunBatchProcessorButton(containerEl) {
    new import_obsidian23.Setting(containerEl).setName("Run Batch Processor").setDesc("Manually process multiple files to generate front matter and wikilinks.").addButton((button) => this.setupRunBatchProcessorButton(button));
  }
  setupRunBatchProcessorButton(button) {
    button.setButtonText("Run Batch Processor").setCta().onClick(() => {
      const modal = new BatchProcessorModal(this.app, this.aiService, this.settingsService);
      modal.open();
    });
  }
};

// src/components/accordions/AdvancedAccordion.ts
var import_obsidian24 = require("obsidian");
var AdvancedAccordion = class extends BaseAccordion {
  constructor(app, containerEl, settingsService, aiService) {
    super(containerEl);
    this.app = app;
    this.settingsService = settingsService;
    this.aiService = aiService;
  }
  render() {
    const contentEl = this.createAccordion(
      "\u2699\uFE0F Advanced",
      "Configuration options for the plugin."
    );
    this.createWikilinksToggle(contentEl);
    this.createAIParameterOverrides(contentEl);
  }
  createWikilinksToggle(containerEl) {
    new import_obsidian24.Setting(containerEl).setName("Generate Wikilinks").addToggle((toggle) => this.setupWikilinksToggle(toggle));
  }
  createAIParameterOverrides(containerEl) {
    new import_obsidian24.Setting(containerEl).setName("Temperature").addText((text) => this.setupTemperatureOverride(text));
    new import_obsidian24.Setting(containerEl).setName("Max Tokens").addText((text) => this.setupMaxTokensOverride(text));
  }
  setupWikilinksToggle(toggle) {
    const settings = this.settingsService.getSettings();
    toggle.setValue(settings.advanced.generateWikilinks).onChange(async (value) => {
      await this.settingsService.updateNestedSetting("advanced", "generateWikilinks", value);
    });
  }
  setupTemperatureOverride(text) {
    const settings = this.settingsService.getSettings();
    text.setPlaceholder("0.0 - 1.0").setValue(settings.advanced.temperature.toString()).onChange(async (value) => {
      const temp = parseFloat(value);
      if (!isNaN(temp) && temp >= 0 && temp <= 1) {
        await this.settingsService.updateNestedSetting("advanced", "temperature", temp);
      }
    });
  }
  setupMaxTokensOverride(text) {
    const settings = this.settingsService.getSettings();
    text.setPlaceholder("Enter max tokens").setValue(settings.advanced.maxTokens.toString()).onChange(async (value) => {
      const tokens = parseInt(value);
      if (!isNaN(tokens) && tokens > 0) {
        await this.settingsService.updateNestedSetting("advanced", "maxTokens", tokens);
      }
    });
  }
};

// src/components/accordions/KnowledgeBloomAccordion.ts
var import_obsidian25 = require("obsidian");
var KnowledgeBloomAccordion = class extends BaseAccordion {
  constructor(app, containerEl, settingsService, aiService) {
    super(containerEl);
    this.app = app;
    this.settingsService = settingsService;
    this.aiService = aiService;
  }
  render() {
    const contentEl = this.createAccordion(
      "\u{1F33A} Knowledge Bloom",
      "Generate notes from wikilinks in your current note."
    );
    this.createDescription(contentEl);
    this.createModelSelector(contentEl);
    this.createUserPromptInput(contentEl);
    this.createGenerateButton(contentEl);
  }
  createDescription(containerEl) {
    const descEl = containerEl.createDiv({ cls: "knowledge-bloom-description" });
    descEl.createEl("p", { text: "Knowledge Bloom analyzes the current note, extracts wikilinks, and generates new notes for each link. This helps expand your knowledge base and create connections between ideas." });
    descEl.createEl("p", { text: "For best results, we recommend using Perplexity models as they can search online for up-to-date information." });
    const listEl = descEl.createEl("ul");
    [
      "Automatically creates notes for missing links",
      "Generates content based on the context of your note",
      "Helps build a more comprehensive knowledge graph",
      "Saves time on manual note creation and research"
    ].forEach((item) => {
      listEl.createEl("li", { text: item });
    });
  }
  createModelSelector(containerEl) {
    const selectorEl = containerEl.createDiv({ cls: "knowledge-bloom-model-selector" });
    new import_obsidian25.Setting(selectorEl).setName("AI Model").setDesc("Select the AI model to use for Knowledge Bloom").addDropdown((dropdown) => {
      this.modelSelector = dropdown;
      this.updateModelOptions();
      dropdown.onChange(async (value) => {
        await this.settingsService.updateKnowledgeBloomSetting("selectedModel", value);
        this.aiService.reinitialize();
      });
    });
  }
  updateModelOptions() {
    const currentProvider = this.aiService.getCurrentProvider();
    const models = this.aiService.getAvailableModels(currentProvider);
    const currentModel = this.settingsService.getKnowledgeBloomSettings().selectedModel;
    this.modelSelector.selectEl.innerHTML = "";
    models.forEach((model) => {
      this.modelSelector.addOption(model, model);
    });
    if (currentModel && models.includes(currentModel)) {
      this.modelSelector.setValue(currentModel);
    } else if (models.length > 0) {
      this.modelSelector.setValue(models[0]);
      this.settingsService.updateKnowledgeBloomSetting("selectedModel", models[0]);
    }
  }
  createUserPromptInput(containerEl) {
    const promptEl = containerEl.createDiv({ cls: "knowledge-bloom-prompt" });
    new import_obsidian25.Setting(promptEl).setName("Additional Context").setDesc("Provide any additional context or instructions for note generation (optional)").addTextArea((text) => {
      this.userPromptInput = text;
      text.inputEl.rows = 4;
      text.inputEl.cols = 50;
      return text;
    });
  }
  createGenerateButton(containerEl) {
    const buttonEl = containerEl.createDiv({ cls: "knowledge-bloom-generate-button" });
    new import_obsidian25.Setting(buttonEl).addButton((button) => {
      button.setButtonText("Generate Knowledge Bloom").setCta().onClick(() => this.handleGenerateKnowledgeBloom(button));
    });
  }
  async handleGenerateKnowledgeBloom(button) {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian25.Notice("No active file. Please open a file to generate Knowledge Bloom.");
      return;
    }
    button.setDisabled(true);
    button.setButtonText("Generating...");
    try {
      const userPrompt = this.userPromptInput.getValue();
      const result = await this.aiService.generateKnowledgeBloom(activeFile, userPrompt);
      if (result.generatedNotes.length > 0) {
        for (const note of result.generatedNotes) {
          const filePath = `${note.title}.md`;
          const existingFile = this.app.vault.getAbstractFileByPath(filePath);
          if (existingFile && existingFile instanceof import_obsidian25.TFile) {
            await this.app.vault.modify(existingFile, note.content);
          } else {
            await this.app.vault.create(filePath, note.content);
          }
        }
        new import_obsidian25.Notice(`Generated ${result.generatedNotes.length} new notes!`);
      } else {
        new import_obsidian25.Notice("No new notes were generated.");
      }
    } catch (error) {
      console.error("Error generating Knowledge Bloom:", error);
      new import_obsidian25.Notice(`Failed to generate Knowledge Bloom: ${error.message}`);
    } finally {
      button.setDisabled(false);
      button.setButtonText("Generate Knowledge Bloom");
    }
  }
};

// src/settings/GraphWeaverSettingTab.ts
var GraphWeaverSettingTab = class extends import_obsidian26.PluginSettingTab {
  // Replace with your actual plugin type
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "GraphWeaver Settings" });
    const modelHookupContainer = containerEl.createDiv();
    new ModelHookupAccordion(
      this.app,
      modelHookupContainer,
      this.plugin.settingsService,
      this.plugin.aiService
    ).render();
    const propertyManagerContainer = containerEl.createDiv();
    new PropertyManagerAccordion(
      this.app,
      propertyManagerContainer,
      this.plugin.settingsService,
      this.plugin.aiService
    ).render();
    const tagManagerContainer = containerEl.createDiv();
    new TagManagerAccordion(
      this.app,
      tagManagerContainer,
      this.plugin.settingsService,
      this.plugin.aiService
    ).render();
    const ontologyGenerationContainer = containerEl.createDiv();
    new OntologyGenerationAccordion(
      this.app,
      ontologyGenerationContainer,
      this.plugin.settingsService,
      this.plugin.aiService
    ).render();
    const batchProcessorContainer = containerEl.createDiv();
    new BatchProcessorAccordion(
      this.app,
      batchProcessorContainer,
      this.plugin.settingsService,
      this.plugin.aiService
    ).render();
    const advancedContainer = containerEl.createDiv();
    new AdvancedAccordion(
      this.app,
      advancedContainer,
      this.plugin.settingsService,
      this.plugin.aiService
    ).render();
    const knowledgeBloomContainer = containerEl.createDiv();
    new KnowledgeBloomAccordion(
      this.app,
      knowledgeBloomContainer,
      this.plugin.settingsService,
      this.plugin.aiService
    ).render();
  }
};

// main.ts
var GraphWeaverPlugin = class extends import_obsidian27.Plugin {
  constructor() {
    super(...arguments);
    this.statusBar = null;
    this.hasProcessedVaultStartup = false;
  }
  /**
   * Initialize plugin on load
   */
  async onload() {
    console.log("Loading GraphWeaver plugin");
    try {
      await this.initializeServices();
      await this.initializeUI();
      this.addPluginFunctionality();
      console.log("GraphWeaver plugin loaded successfully");
    } catch (error) {
      console.error("Error loading GraphWeaver plugin:", error);
      new import_obsidian27.Notice("Error loading GraphWeaver plugin. Check console for details.");
    }
  }
  /**
   * Initialize all plugin services
   */
  async initializeServices() {
    await this.loadSettings();
    this.settingsService = new SettingsService(this, this.settings);
    this.jsonValidationService = new JsonValidationService();
    this.databaseService = new DatabaseService();
    await this.databaseService.load(this.loadData.bind(this));
    this.aiService = new AIService(
      this.app,
      this.settingsService,
      this.jsonValidationService,
      this.databaseService
    );
    this.batchProcessor = new BatchProcessor(
      this.aiService.getCurrentAdapter(),
      this.settingsService,
      this.aiService.frontMatterGenerator,
      this.aiService.wikilinkGenerator,
      this.databaseService,
      this.app
    );
    this.autoGenerateService = new AutoGenerateService(
      this.app,
      this.app.vault,
      this.aiService,
      this.settingsService,
      this.databaseService
    );
  }
  /**
   * Initialize plugin UI components
   */
  async initializeUI() {
    const statusBarEl = this.addStatusBarItem();
    this.statusBar = new ProcessingStatusBar(
      this.app,
      statusBarEl,
      this.batchProcessor.eventEmitter,
      this.aiService,
      this.settingsService,
      this.databaseService
      // Add DatabaseService
    );
  }
  /**
   * Add plugin functionality
   */
  addPluginFunctionality() {
    this.addSettingTab(new GraphWeaverSettingTab(this.app, this));
    this.addRibbonIcon("brain-circuit", "GraphWeaver", this.showPluginMenu.bind(this));
    this.addCommands();
    this.registerEvents();
  }
  /**
   * Register plugin events
   */
  registerEvents() {
    this.registerEvent(
      this.app.workspace.on("layout-change", this.onLayoutChange.bind(this))
    );
  }
  /**
   * Add plugin commands
   */
  addCommands() {
    this.addCommand({
      id: "generate-frontmatter",
      name: "Generate Frontmatter",
      callback: this.generateFrontmatter.bind(this)
    });
    this.addCommand({
      id: "generate-wikilinks",
      name: "Generate Wikilinks",
      callback: this.generateWikilinks.bind(this)
    });
    this.addCommand({
      id: "generate-knowledge-bloom",
      name: "Generate Knowledge Bloom",
      callback: this.generateKnowledgeBloom.bind(this)
    });
    this.addCommand({
      id: "toggle-auto-generate",
      name: "Toggle Auto-Generate",
      callback: this.toggleAutoGenerate.bind(this)
    });
  }
  /**
   * Handle layout changes - only triggers vault startup processing once
   */
  onLayoutChange() {
    if (this.app.workspace.layoutReady && !this.hasProcessedVaultStartup) {
      this.onVaultOpen();
    }
  }
  /**
   * Handle vault opening - processes files only on initial startup
   */
  async onVaultOpen() {
    if (this.hasProcessedVaultStartup) {
      return;
    }
    if (this.settings.frontMatter.autoGenerate) {
      console.log("Processing vault on startup");
      await this.autoGenerateService.runAutoGenerate();
      this.hasProcessedVaultStartup = true;
    }
  }
  /**
   * Show plugin menu
   */
  showPluginMenu(evt) {
    const menu = new import_obsidian27.Menu();
    menu.addItem((item) => item.setTitle("Generate Frontmatter").setIcon("file-plus").onClick(this.generateFrontmatter.bind(this)));
    menu.addItem((item) => item.setTitle("Generate Wikilinks").setIcon("link").onClick(this.generateWikilinks.bind(this)));
    menu.addItem((item) => item.setTitle("Generate Knowledge Bloom").setIcon("flower").onClick(this.generateKnowledgeBloom.bind(this)));
    menu.addSeparator();
    menu.addItem((item) => item.setTitle(this.settings.frontMatter.autoGenerate ? "Disable Auto-Generate" : "Enable Auto-Generate").setIcon(this.settings.frontMatter.autoGenerate ? "toggle-right" : "toggle-left").onClick(this.toggleAutoGenerate.bind(this)));
    menu.showAtMouseEvent(evt);
  }
  /**
   * Toggle auto-generate functionality
   */
  async toggleAutoGenerate() {
    this.settings.frontMatter.autoGenerate = !this.settings.frontMatter.autoGenerate;
    await this.saveSettings();
    new import_obsidian27.Notice(
      this.settings.frontMatter.autoGenerate ? "Auto-generate enabled" : "Auto-generate disabled"
    );
    if (this.settings.frontMatter.autoGenerate && !this.hasProcessedVaultStartup) {
      await this.autoGenerateService.runAutoGenerate();
      this.hasProcessedVaultStartup = true;
    }
  }
  /**
   * Process a single file
   */
  async processFile(file, generateFrontMatter, generateWikilinks) {
    const result = await this.batchProcessor.generate({
      files: [file],
      generateFrontMatter,
      generateWikilinks
    });
    return result.fileResults[0];
  }
  /**
   * Generate front matter for active file
   */
  async generateFrontmatter() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian27.Notice("No active file. Please open a file to generate frontmatter.");
      return;
    }
    try {
      new import_obsidian27.Notice("Generating frontmatter...");
      const result = await this.processFile(activeFile, true, false);
      if (result.success) {
        new import_obsidian27.Notice("Frontmatter generated successfully!");
      } else if (result.error) {
        new import_obsidian27.Notice(`Error: ${result.error}`);
      }
    } catch (error) {
      console.error("Error generating frontmatter:", error);
      new import_obsidian27.Notice("Error generating frontmatter. Check console for details.");
    }
  }
  /**
   * Generate wikilinks for active file
   */
  async generateWikilinks() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian27.Notice("No active file. Please open a file to generate wikilinks.");
      return;
    }
    try {
      new import_obsidian27.Notice("Generating wikilinks...");
      const result = await this.processFile(activeFile, false, true);
      if (result.success) {
        new import_obsidian27.Notice("Wikilinks generated successfully!");
      } else if (result.error) {
        new import_obsidian27.Notice(`Error: ${result.error}`);
      }
    } catch (error) {
      console.error("Error generating wikilinks:", error);
      new import_obsidian27.Notice("Error generating wikilinks. Check console for details.");
    }
  }
  /**
   * Generate knowledge bloom for active file
   */
  async generateKnowledgeBloom() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian27.Notice("No active file. Please open a file to generate Knowledge Bloom.");
      return;
    }
    try {
      new import_obsidian27.Notice("Generating Knowledge Bloom...");
      const result = await this.aiService.generateKnowledgeBloom(activeFile);
      for (const note of result.generatedNotes) {
        await this.createOrUpdateNote(note.title, note.content);
      }
      new import_obsidian27.Notice(`Generated ${result.generatedNotes.length} new notes!`);
    } catch (error) {
      console.error("Error generating Knowledge Bloom:", error);
      new import_obsidian27.Notice("Error generating Knowledge Bloom. Check console for details.");
    }
  }
  /**
   * Create or update a note
   */
  async createOrUpdateNote(title, content) {
    const filePath = `${title}.md`;
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian27.TFile) {
      await this.app.vault.modify(file, content);
    } else {
      await this.app.vault.create(filePath, content);
    }
  }
  /**
   * Load plugin settings
   */
  async loadSettings() {
    const data = await this.loadData();
    this.settings = { ...DEFAULT_SETTINGS, ...data };
  }
  /**
   * Save plugin settings
   */
  async saveSettings() {
    await this.saveData(this.settings);
    await this.settingsService.updateSettings(this.settings);
  }
  /**
   * Clean up on plugin unload
   */
  async onunload() {
    console.log("Unloading GraphWeaver plugin");
    await this.databaseService.saveData(this.saveData.bind(this));
    if (this.autoGenerateService) {
      this.autoGenerateService.destroy();
    }
    if (this.statusBar) {
      this.statusBar.destroy();
    }
    this.hasProcessedVaultStartup = false;
  }
  // Public getters for plugin state
  getSettings() {
    return this.settings;
  }
  getSettingsService() {
    return this.settingsService;
  }
  getAIService() {
    return this.aiService;
  }
};
