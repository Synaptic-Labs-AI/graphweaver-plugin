
/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __reflectGet = Reflect.get;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __superGet = (cls, obj, key) => __reflectGet(__getProtoOf(cls), key, obj);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/tailwind-merge/dist/bundle-cjs.js
var require_bundle_cjs = __commonJS({
  "node_modules/tailwind-merge/dist/bundle-cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, {
      value: "Module"
    });
    var CLASS_PART_SEPARATOR = "-";
    var createClassGroupUtils = (config) => {
      const classMap = createClassMap(config);
      const {
        conflictingClassGroups,
        conflictingClassGroupModifiers
      } = config;
      const getClassGroupId = (className) => {
        const classParts = className.split(CLASS_PART_SEPARATOR);
        if (classParts[0] === "" && classParts.length !== 1) {
          classParts.shift();
        }
        return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
      };
      const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {
        const conflicts = conflictingClassGroups[classGroupId] || [];
        if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
          return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
        }
        return conflicts;
      };
      return {
        getClassGroupId,
        getConflictingClassGroupIds
      };
    };
    var getGroupRecursive = (classParts, classPartObject) => {
      var _a;
      if (classParts.length === 0) {
        return classPartObject.classGroupId;
      }
      const currentClassPart = classParts[0];
      const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
      const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
      if (classGroupFromNextClassPart) {
        return classGroupFromNextClassPart;
      }
      if (classPartObject.validators.length === 0) {
        return void 0;
      }
      const classRest = classParts.join(CLASS_PART_SEPARATOR);
      return (_a = classPartObject.validators.find(({
        validator
      }) => validator(classRest))) == null ? void 0 : _a.classGroupId;
    };
    var arbitraryPropertyRegex = /^\[(.+)\]$/;
    var getGroupIdForArbitraryProperty = (className) => {
      if (arbitraryPropertyRegex.test(className)) {
        const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
        const property = arbitraryPropertyClassName == null ? void 0 : arbitraryPropertyClassName.substring(0, arbitraryPropertyClassName.indexOf(":"));
        if (property) {
          return "arbitrary.." + property;
        }
      }
    };
    var createClassMap = (config) => {
      const {
        theme,
        prefix
      } = config;
      const classMap = {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      };
      const prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);
      prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {
        processClassesRecursively(classGroup, classMap, classGroupId, theme);
      });
      return classMap;
    };
    var processClassesRecursively = (classGroup, classPartObject, classGroupId, theme) => {
      classGroup.forEach((classDefinition) => {
        if (typeof classDefinition === "string") {
          const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
          classPartObjectToEdit.classGroupId = classGroupId;
          return;
        }
        if (typeof classDefinition === "function") {
          if (isThemeGetter(classDefinition)) {
            processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
            return;
          }
          classPartObject.validators.push({
            validator: classDefinition,
            classGroupId
          });
          return;
        }
        Object.entries(classDefinition).forEach(([key, classGroup2]) => {
          processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme);
        });
      });
    };
    var getPart = (classPartObject, path) => {
      let currentClassPartObject = classPartObject;
      path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
        if (!currentClassPartObject.nextPart.has(pathPart)) {
          currentClassPartObject.nextPart.set(pathPart, {
            nextPart: /* @__PURE__ */ new Map(),
            validators: []
          });
        }
        currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
      });
      return currentClassPartObject;
    };
    var isThemeGetter = (func) => func.isThemeGetter;
    var getPrefixedClassGroupEntries = (classGroupEntries, prefix) => {
      if (!prefix) {
        return classGroupEntries;
      }
      return classGroupEntries.map(([classGroupId, classGroup]) => {
        const prefixedClassGroup = classGroup.map((classDefinition) => {
          if (typeof classDefinition === "string") {
            return prefix + classDefinition;
          }
          if (typeof classDefinition === "object") {
            return Object.fromEntries(Object.entries(classDefinition).map(([key, value]) => [prefix + key, value]));
          }
          return classDefinition;
        });
        return [classGroupId, prefixedClassGroup];
      });
    };
    var createLruCache = (maxCacheSize) => {
      if (maxCacheSize < 1) {
        return {
          get: () => void 0,
          set: () => {
          }
        };
      }
      let cacheSize = 0;
      let cache = /* @__PURE__ */ new Map();
      let previousCache = /* @__PURE__ */ new Map();
      const update2 = (key, value) => {
        cache.set(key, value);
        cacheSize++;
        if (cacheSize > maxCacheSize) {
          cacheSize = 0;
          previousCache = cache;
          cache = /* @__PURE__ */ new Map();
        }
      };
      return {
        get(key) {
          let value = cache.get(key);
          if (value !== void 0) {
            return value;
          }
          if ((value = previousCache.get(key)) !== void 0) {
            update2(key, value);
            return value;
          }
        },
        set(key, value) {
          if (cache.has(key)) {
            cache.set(key, value);
          } else {
            update2(key, value);
          }
        }
      };
    };
    var IMPORTANT_MODIFIER = "!";
    var createParseClassName = (config) => {
      const {
        separator,
        experimentalParseClassName
      } = config;
      const isSeparatorSingleCharacter = separator.length === 1;
      const firstSeparatorCharacter = separator[0];
      const separatorLength = separator.length;
      const parseClassName = (className) => {
        const modifiers = [];
        let bracketDepth = 0;
        let modifierStart = 0;
        let postfixModifierPosition;
        for (let index = 0; index < className.length; index++) {
          let currentCharacter = className[index];
          if (bracketDepth === 0) {
            if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index, index + separatorLength) === separator)) {
              modifiers.push(className.slice(modifierStart, index));
              modifierStart = index + separatorLength;
              continue;
            }
            if (currentCharacter === "/") {
              postfixModifierPosition = index;
              continue;
            }
          }
          if (currentCharacter === "[") {
            bracketDepth++;
          } else if (currentCharacter === "]") {
            bracketDepth--;
          }
        }
        const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
        const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
        const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
        const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
        return {
          modifiers,
          hasImportantModifier,
          baseClassName,
          maybePostfixModifierPosition
        };
      };
      if (experimentalParseClassName) {
        return (className) => experimentalParseClassName({
          className,
          parseClassName
        });
      }
      return parseClassName;
    };
    var sortModifiers = (modifiers) => {
      if (modifiers.length <= 1) {
        return modifiers;
      }
      const sortedModifiers = [];
      let unsortedModifiers = [];
      modifiers.forEach((modifier) => {
        const isArbitraryVariant = modifier[0] === "[";
        if (isArbitraryVariant) {
          sortedModifiers.push(...unsortedModifiers.sort(), modifier);
          unsortedModifiers = [];
        } else {
          unsortedModifiers.push(modifier);
        }
      });
      sortedModifiers.push(...unsortedModifiers.sort());
      return sortedModifiers;
    };
    var createConfigUtils = (config) => __spreadValues({
      cache: createLruCache(config.cacheSize),
      parseClassName: createParseClassName(config)
    }, createClassGroupUtils(config));
    var SPLIT_CLASSES_REGEX = /\s+/;
    var mergeClassList = (classList, configUtils) => {
      const {
        parseClassName,
        getClassGroupId,
        getConflictingClassGroupIds
      } = configUtils;
      const classGroupsInConflict = [];
      const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
      let result = "";
      for (let index = classNames.length - 1; index >= 0; index -= 1) {
        const originalClassName = classNames[index];
        const {
          modifiers,
          hasImportantModifier,
          baseClassName,
          maybePostfixModifierPosition
        } = parseClassName(originalClassName);
        let hasPostfixModifier = Boolean(maybePostfixModifierPosition);
        let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
        if (!classGroupId) {
          if (!hasPostfixModifier) {
            result = originalClassName + (result.length > 0 ? " " + result : result);
            continue;
          }
          classGroupId = getClassGroupId(baseClassName);
          if (!classGroupId) {
            result = originalClassName + (result.length > 0 ? " " + result : result);
            continue;
          }
          hasPostfixModifier = false;
        }
        const variantModifier = sortModifiers(modifiers).join(":");
        const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
        const classId = modifierId + classGroupId;
        if (classGroupsInConflict.includes(classId)) {
          continue;
        }
        classGroupsInConflict.push(classId);
        const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
        for (let i = 0; i < conflictGroups.length; ++i) {
          const group = conflictGroups[i];
          classGroupsInConflict.push(modifierId + group);
        }
        result = originalClassName + (result.length > 0 ? " " + result : result);
      }
      return result;
    };
    function twJoin() {
      let index = 0;
      let argument;
      let resolvedValue;
      let string = "";
      while (index < arguments.length) {
        if (argument = arguments[index++]) {
          if (resolvedValue = toValue(argument)) {
            string && (string += " ");
            string += resolvedValue;
          }
        }
      }
      return string;
    }
    var toValue = (mix) => {
      if (typeof mix === "string") {
        return mix;
      }
      let resolvedValue;
      let string = "";
      for (let k = 0; k < mix.length; k++) {
        if (mix[k]) {
          if (resolvedValue = toValue(mix[k])) {
            string && (string += " ");
            string += resolvedValue;
          }
        }
      }
      return string;
    };
    function createTailwindMerge(createConfigFirst, ...createConfigRest) {
      let configUtils;
      let cacheGet;
      let cacheSet;
      let functionToCall = initTailwindMerge;
      function initTailwindMerge(classList) {
        const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
        configUtils = createConfigUtils(config);
        cacheGet = configUtils.cache.get;
        cacheSet = configUtils.cache.set;
        functionToCall = tailwindMerge;
        return tailwindMerge(classList);
      }
      function tailwindMerge(classList) {
        const cachedResult = cacheGet(classList);
        if (cachedResult) {
          return cachedResult;
        }
        const result = mergeClassList(classList, configUtils);
        cacheSet(classList, result);
        return result;
      }
      return function callTailwindMerge() {
        return functionToCall(twJoin.apply(null, arguments));
      };
    }
    var fromTheme = (key) => {
      const themeGetter = (theme) => theme[key] || [];
      themeGetter.isThemeGetter = true;
      return themeGetter;
    };
    var arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
    var fractionRegex = /^\d+\/\d+$/;
    var stringLengths = /* @__PURE__ */ new Set(["px", "full", "screen"]);
    var tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
    var lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
    var colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
    var shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
    var imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
    var isLength = (value) => isNumber(value) || stringLengths.has(value) || fractionRegex.test(value);
    var isArbitraryLength = (value) => getIsArbitraryValue(value, "length", isLengthOnly);
    var isNumber = (value) => Boolean(value) && !Number.isNaN(Number(value));
    var isArbitraryNumber = (value) => getIsArbitraryValue(value, "number", isNumber);
    var isInteger = (value) => Boolean(value) && Number.isInteger(Number(value));
    var isPercent = (value) => value.endsWith("%") && isNumber(value.slice(0, -1));
    var isArbitraryValue = (value) => arbitraryValueRegex.test(value);
    var isTshirtSize = (value) => tshirtUnitRegex.test(value);
    var sizeLabels = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
    var isArbitrarySize = (value) => getIsArbitraryValue(value, sizeLabels, isNever);
    var isArbitraryPosition = (value) => getIsArbitraryValue(value, "position", isNever);
    var imageLabels = /* @__PURE__ */ new Set(["image", "url"]);
    var isArbitraryImage = (value) => getIsArbitraryValue(value, imageLabels, isImage);
    var isArbitraryShadow = (value) => getIsArbitraryValue(value, "", isShadow);
    var isAny = () => true;
    var getIsArbitraryValue = (value, label, testValue) => {
      const result = arbitraryValueRegex.exec(value);
      if (result) {
        if (result[1]) {
          return typeof label === "string" ? result[1] === label : label.has(result[1]);
        }
        return testValue(result[2]);
      }
      return false;
    };
    var isLengthOnly = (value) => (
      // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
      // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
      // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
      lengthUnitRegex.test(value) && !colorFunctionRegex.test(value)
    );
    var isNever = () => false;
    var isShadow = (value) => shadowRegex.test(value);
    var isImage = (value) => imageRegex.test(value);
    var validators = /* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      isAny,
      isArbitraryImage,
      isArbitraryLength,
      isArbitraryNumber,
      isArbitraryPosition,
      isArbitraryShadow,
      isArbitrarySize,
      isArbitraryValue,
      isInteger,
      isLength,
      isNumber,
      isPercent,
      isTshirtSize
    }, Symbol.toStringTag, {
      value: "Module"
    });
    var getDefaultConfig = () => {
      const colors = fromTheme("colors");
      const spacing = fromTheme("spacing");
      const blur2 = fromTheme("blur");
      const brightness = fromTheme("brightness");
      const borderColor = fromTheme("borderColor");
      const borderRadius = fromTheme("borderRadius");
      const borderSpacing = fromTheme("borderSpacing");
      const borderWidth = fromTheme("borderWidth");
      const contrast = fromTheme("contrast");
      const grayscale = fromTheme("grayscale");
      const hueRotate = fromTheme("hueRotate");
      const invert = fromTheme("invert");
      const gap = fromTheme("gap");
      const gradientColorStops = fromTheme("gradientColorStops");
      const gradientColorStopPositions = fromTheme("gradientColorStopPositions");
      const inset = fromTheme("inset");
      const margin = fromTheme("margin");
      const opacity = fromTheme("opacity");
      const padding = fromTheme("padding");
      const saturate = fromTheme("saturate");
      const scale = fromTheme("scale");
      const sepia = fromTheme("sepia");
      const skew = fromTheme("skew");
      const space2 = fromTheme("space");
      const translate = fromTheme("translate");
      const getOverscroll = () => ["auto", "contain", "none"];
      const getOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
      const getSpacingWithAutoAndArbitrary = () => ["auto", isArbitraryValue, spacing];
      const getSpacingWithArbitrary = () => [isArbitraryValue, spacing];
      const getLengthWithEmptyAndArbitrary = () => ["", isLength, isArbitraryLength];
      const getNumberWithAutoAndArbitrary = () => ["auto", isNumber, isArbitraryValue];
      const getPositions = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
      const getLineStyles = () => ["solid", "dashed", "dotted", "double", "none"];
      const getBlendModes = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
      const getAlign = () => ["start", "end", "center", "between", "around", "evenly", "stretch"];
      const getZeroAndEmpty = () => ["", "0", isArbitraryValue];
      const getBreaks = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
      const getNumberAndArbitrary = () => [isNumber, isArbitraryValue];
      return {
        cacheSize: 500,
        separator: ":",
        theme: {
          colors: [isAny],
          spacing: [isLength, isArbitraryLength],
          blur: ["none", "", isTshirtSize, isArbitraryValue],
          brightness: getNumberAndArbitrary(),
          borderColor: [colors],
          borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
          borderSpacing: getSpacingWithArbitrary(),
          borderWidth: getLengthWithEmptyAndArbitrary(),
          contrast: getNumberAndArbitrary(),
          grayscale: getZeroAndEmpty(),
          hueRotate: getNumberAndArbitrary(),
          invert: getZeroAndEmpty(),
          gap: getSpacingWithArbitrary(),
          gradientColorStops: [colors],
          gradientColorStopPositions: [isPercent, isArbitraryLength],
          inset: getSpacingWithAutoAndArbitrary(),
          margin: getSpacingWithAutoAndArbitrary(),
          opacity: getNumberAndArbitrary(),
          padding: getSpacingWithArbitrary(),
          saturate: getNumberAndArbitrary(),
          scale: getNumberAndArbitrary(),
          sepia: getZeroAndEmpty(),
          skew: getNumberAndArbitrary(),
          space: getSpacingWithArbitrary(),
          translate: getSpacingWithArbitrary()
        },
        classGroups: {
          // Layout
          /**
           * Aspect Ratio
           * @see https://tailwindcss.com/docs/aspect-ratio
           */
          aspect: [{
            aspect: ["auto", "square", "video", isArbitraryValue]
          }],
          /**
           * Container
           * @see https://tailwindcss.com/docs/container
           */
          container: ["container"],
          /**
           * Columns
           * @see https://tailwindcss.com/docs/columns
           */
          columns: [{
            columns: [isTshirtSize]
          }],
          /**
           * Break After
           * @see https://tailwindcss.com/docs/break-after
           */
          "break-after": [{
            "break-after": getBreaks()
          }],
          /**
           * Break Before
           * @see https://tailwindcss.com/docs/break-before
           */
          "break-before": [{
            "break-before": getBreaks()
          }],
          /**
           * Break Inside
           * @see https://tailwindcss.com/docs/break-inside
           */
          "break-inside": [{
            "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
          }],
          /**
           * Box Decoration Break
           * @see https://tailwindcss.com/docs/box-decoration-break
           */
          "box-decoration": [{
            "box-decoration": ["slice", "clone"]
          }],
          /**
           * Box Sizing
           * @see https://tailwindcss.com/docs/box-sizing
           */
          box: [{
            box: ["border", "content"]
          }],
          /**
           * Display
           * @see https://tailwindcss.com/docs/display
           */
          display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
          /**
           * Floats
           * @see https://tailwindcss.com/docs/float
           */
          float: [{
            float: ["right", "left", "none", "start", "end"]
          }],
          /**
           * Clear
           * @see https://tailwindcss.com/docs/clear
           */
          clear: [{
            clear: ["left", "right", "both", "none", "start", "end"]
          }],
          /**
           * Isolation
           * @see https://tailwindcss.com/docs/isolation
           */
          isolation: ["isolate", "isolation-auto"],
          /**
           * Object Fit
           * @see https://tailwindcss.com/docs/object-fit
           */
          "object-fit": [{
            object: ["contain", "cover", "fill", "none", "scale-down"]
          }],
          /**
           * Object Position
           * @see https://tailwindcss.com/docs/object-position
           */
          "object-position": [{
            object: [...getPositions(), isArbitraryValue]
          }],
          /**
           * Overflow
           * @see https://tailwindcss.com/docs/overflow
           */
          overflow: [{
            overflow: getOverflow()
          }],
          /**
           * Overflow X
           * @see https://tailwindcss.com/docs/overflow
           */
          "overflow-x": [{
            "overflow-x": getOverflow()
          }],
          /**
           * Overflow Y
           * @see https://tailwindcss.com/docs/overflow
           */
          "overflow-y": [{
            "overflow-y": getOverflow()
          }],
          /**
           * Overscroll Behavior
           * @see https://tailwindcss.com/docs/overscroll-behavior
           */
          overscroll: [{
            overscroll: getOverscroll()
          }],
          /**
           * Overscroll Behavior X
           * @see https://tailwindcss.com/docs/overscroll-behavior
           */
          "overscroll-x": [{
            "overscroll-x": getOverscroll()
          }],
          /**
           * Overscroll Behavior Y
           * @see https://tailwindcss.com/docs/overscroll-behavior
           */
          "overscroll-y": [{
            "overscroll-y": getOverscroll()
          }],
          /**
           * Position
           * @see https://tailwindcss.com/docs/position
           */
          position: ["static", "fixed", "absolute", "relative", "sticky"],
          /**
           * Top / Right / Bottom / Left
           * @see https://tailwindcss.com/docs/top-right-bottom-left
           */
          inset: [{
            inset: [inset]
          }],
          /**
           * Right / Left
           * @see https://tailwindcss.com/docs/top-right-bottom-left
           */
          "inset-x": [{
            "inset-x": [inset]
          }],
          /**
           * Top / Bottom
           * @see https://tailwindcss.com/docs/top-right-bottom-left
           */
          "inset-y": [{
            "inset-y": [inset]
          }],
          /**
           * Start
           * @see https://tailwindcss.com/docs/top-right-bottom-left
           */
          start: [{
            start: [inset]
          }],
          /**
           * End
           * @see https://tailwindcss.com/docs/top-right-bottom-left
           */
          end: [{
            end: [inset]
          }],
          /**
           * Top
           * @see https://tailwindcss.com/docs/top-right-bottom-left
           */
          top: [{
            top: [inset]
          }],
          /**
           * Right
           * @see https://tailwindcss.com/docs/top-right-bottom-left
           */
          right: [{
            right: [inset]
          }],
          /**
           * Bottom
           * @see https://tailwindcss.com/docs/top-right-bottom-left
           */
          bottom: [{
            bottom: [inset]
          }],
          /**
           * Left
           * @see https://tailwindcss.com/docs/top-right-bottom-left
           */
          left: [{
            left: [inset]
          }],
          /**
           * Visibility
           * @see https://tailwindcss.com/docs/visibility
           */
          visibility: ["visible", "invisible", "collapse"],
          /**
           * Z-Index
           * @see https://tailwindcss.com/docs/z-index
           */
          z: [{
            z: ["auto", isInteger, isArbitraryValue]
          }],
          // Flexbox and Grid
          /**
           * Flex Basis
           * @see https://tailwindcss.com/docs/flex-basis
           */
          basis: [{
            basis: getSpacingWithAutoAndArbitrary()
          }],
          /**
           * Flex Direction
           * @see https://tailwindcss.com/docs/flex-direction
           */
          "flex-direction": [{
            flex: ["row", "row-reverse", "col", "col-reverse"]
          }],
          /**
           * Flex Wrap
           * @see https://tailwindcss.com/docs/flex-wrap
           */
          "flex-wrap": [{
            flex: ["wrap", "wrap-reverse", "nowrap"]
          }],
          /**
           * Flex
           * @see https://tailwindcss.com/docs/flex
           */
          flex: [{
            flex: ["1", "auto", "initial", "none", isArbitraryValue]
          }],
          /**
           * Flex Grow
           * @see https://tailwindcss.com/docs/flex-grow
           */
          grow: [{
            grow: getZeroAndEmpty()
          }],
          /**
           * Flex Shrink
           * @see https://tailwindcss.com/docs/flex-shrink
           */
          shrink: [{
            shrink: getZeroAndEmpty()
          }],
          /**
           * Order
           * @see https://tailwindcss.com/docs/order
           */
          order: [{
            order: ["first", "last", "none", isInteger, isArbitraryValue]
          }],
          /**
           * Grid Template Columns
           * @see https://tailwindcss.com/docs/grid-template-columns
           */
          "grid-cols": [{
            "grid-cols": [isAny]
          }],
          /**
           * Grid Column Start / End
           * @see https://tailwindcss.com/docs/grid-column
           */
          "col-start-end": [{
            col: ["auto", {
              span: ["full", isInteger, isArbitraryValue]
            }, isArbitraryValue]
          }],
          /**
           * Grid Column Start
           * @see https://tailwindcss.com/docs/grid-column
           */
          "col-start": [{
            "col-start": getNumberWithAutoAndArbitrary()
          }],
          /**
           * Grid Column End
           * @see https://tailwindcss.com/docs/grid-column
           */
          "col-end": [{
            "col-end": getNumberWithAutoAndArbitrary()
          }],
          /**
           * Grid Template Rows
           * @see https://tailwindcss.com/docs/grid-template-rows
           */
          "grid-rows": [{
            "grid-rows": [isAny]
          }],
          /**
           * Grid Row Start / End
           * @see https://tailwindcss.com/docs/grid-row
           */
          "row-start-end": [{
            row: ["auto", {
              span: [isInteger, isArbitraryValue]
            }, isArbitraryValue]
          }],
          /**
           * Grid Row Start
           * @see https://tailwindcss.com/docs/grid-row
           */
          "row-start": [{
            "row-start": getNumberWithAutoAndArbitrary()
          }],
          /**
           * Grid Row End
           * @see https://tailwindcss.com/docs/grid-row
           */
          "row-end": [{
            "row-end": getNumberWithAutoAndArbitrary()
          }],
          /**
           * Grid Auto Flow
           * @see https://tailwindcss.com/docs/grid-auto-flow
           */
          "grid-flow": [{
            "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
          }],
          /**
           * Grid Auto Columns
           * @see https://tailwindcss.com/docs/grid-auto-columns
           */
          "auto-cols": [{
            "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
          }],
          /**
           * Grid Auto Rows
           * @see https://tailwindcss.com/docs/grid-auto-rows
           */
          "auto-rows": [{
            "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
          }],
          /**
           * Gap
           * @see https://tailwindcss.com/docs/gap
           */
          gap: [{
            gap: [gap]
          }],
          /**
           * Gap X
           * @see https://tailwindcss.com/docs/gap
           */
          "gap-x": [{
            "gap-x": [gap]
          }],
          /**
           * Gap Y
           * @see https://tailwindcss.com/docs/gap
           */
          "gap-y": [{
            "gap-y": [gap]
          }],
          /**
           * Justify Content
           * @see https://tailwindcss.com/docs/justify-content
           */
          "justify-content": [{
            justify: ["normal", ...getAlign()]
          }],
          /**
           * Justify Items
           * @see https://tailwindcss.com/docs/justify-items
           */
          "justify-items": [{
            "justify-items": ["start", "end", "center", "stretch"]
          }],
          /**
           * Justify Self
           * @see https://tailwindcss.com/docs/justify-self
           */
          "justify-self": [{
            "justify-self": ["auto", "start", "end", "center", "stretch"]
          }],
          /**
           * Align Content
           * @see https://tailwindcss.com/docs/align-content
           */
          "align-content": [{
            content: ["normal", ...getAlign(), "baseline"]
          }],
          /**
           * Align Items
           * @see https://tailwindcss.com/docs/align-items
           */
          "align-items": [{
            items: ["start", "end", "center", "baseline", "stretch"]
          }],
          /**
           * Align Self
           * @see https://tailwindcss.com/docs/align-self
           */
          "align-self": [{
            self: ["auto", "start", "end", "center", "stretch", "baseline"]
          }],
          /**
           * Place Content
           * @see https://tailwindcss.com/docs/place-content
           */
          "place-content": [{
            "place-content": [...getAlign(), "baseline"]
          }],
          /**
           * Place Items
           * @see https://tailwindcss.com/docs/place-items
           */
          "place-items": [{
            "place-items": ["start", "end", "center", "baseline", "stretch"]
          }],
          /**
           * Place Self
           * @see https://tailwindcss.com/docs/place-self
           */
          "place-self": [{
            "place-self": ["auto", "start", "end", "center", "stretch"]
          }],
          // Spacing
          /**
           * Padding
           * @see https://tailwindcss.com/docs/padding
           */
          p: [{
            p: [padding]
          }],
          /**
           * Padding X
           * @see https://tailwindcss.com/docs/padding
           */
          px: [{
            px: [padding]
          }],
          /**
           * Padding Y
           * @see https://tailwindcss.com/docs/padding
           */
          py: [{
            py: [padding]
          }],
          /**
           * Padding Start
           * @see https://tailwindcss.com/docs/padding
           */
          ps: [{
            ps: [padding]
          }],
          /**
           * Padding End
           * @see https://tailwindcss.com/docs/padding
           */
          pe: [{
            pe: [padding]
          }],
          /**
           * Padding Top
           * @see https://tailwindcss.com/docs/padding
           */
          pt: [{
            pt: [padding]
          }],
          /**
           * Padding Right
           * @see https://tailwindcss.com/docs/padding
           */
          pr: [{
            pr: [padding]
          }],
          /**
           * Padding Bottom
           * @see https://tailwindcss.com/docs/padding
           */
          pb: [{
            pb: [padding]
          }],
          /**
           * Padding Left
           * @see https://tailwindcss.com/docs/padding
           */
          pl: [{
            pl: [padding]
          }],
          /**
           * Margin
           * @see https://tailwindcss.com/docs/margin
           */
          m: [{
            m: [margin]
          }],
          /**
           * Margin X
           * @see https://tailwindcss.com/docs/margin
           */
          mx: [{
            mx: [margin]
          }],
          /**
           * Margin Y
           * @see https://tailwindcss.com/docs/margin
           */
          my: [{
            my: [margin]
          }],
          /**
           * Margin Start
           * @see https://tailwindcss.com/docs/margin
           */
          ms: [{
            ms: [margin]
          }],
          /**
           * Margin End
           * @see https://tailwindcss.com/docs/margin
           */
          me: [{
            me: [margin]
          }],
          /**
           * Margin Top
           * @see https://tailwindcss.com/docs/margin
           */
          mt: [{
            mt: [margin]
          }],
          /**
           * Margin Right
           * @see https://tailwindcss.com/docs/margin
           */
          mr: [{
            mr: [margin]
          }],
          /**
           * Margin Bottom
           * @see https://tailwindcss.com/docs/margin
           */
          mb: [{
            mb: [margin]
          }],
          /**
           * Margin Left
           * @see https://tailwindcss.com/docs/margin
           */
          ml: [{
            ml: [margin]
          }],
          /**
           * Space Between X
           * @see https://tailwindcss.com/docs/space
           */
          "space-x": [{
            "space-x": [space2]
          }],
          /**
           * Space Between X Reverse
           * @see https://tailwindcss.com/docs/space
           */
          "space-x-reverse": ["space-x-reverse"],
          /**
           * Space Between Y
           * @see https://tailwindcss.com/docs/space
           */
          "space-y": [{
            "space-y": [space2]
          }],
          /**
           * Space Between Y Reverse
           * @see https://tailwindcss.com/docs/space
           */
          "space-y-reverse": ["space-y-reverse"],
          // Sizing
          /**
           * Width
           * @see https://tailwindcss.com/docs/width
           */
          w: [{
            w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", isArbitraryValue, spacing]
          }],
          /**
           * Min-Width
           * @see https://tailwindcss.com/docs/min-width
           */
          "min-w": [{
            "min-w": [isArbitraryValue, spacing, "min", "max", "fit"]
          }],
          /**
           * Max-Width
           * @see https://tailwindcss.com/docs/max-width
           */
          "max-w": [{
            "max-w": [isArbitraryValue, spacing, "none", "full", "min", "max", "fit", "prose", {
              screen: [isTshirtSize]
            }, isTshirtSize]
          }],
          /**
           * Height
           * @see https://tailwindcss.com/docs/height
           */
          h: [{
            h: [isArbitraryValue, spacing, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
          }],
          /**
           * Min-Height
           * @see https://tailwindcss.com/docs/min-height
           */
          "min-h": [{
            "min-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
          }],
          /**
           * Max-Height
           * @see https://tailwindcss.com/docs/max-height
           */
          "max-h": [{
            "max-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
          }],
          /**
           * Size
           * @see https://tailwindcss.com/docs/size
           */
          size: [{
            size: [isArbitraryValue, spacing, "auto", "min", "max", "fit"]
          }],
          // Typography
          /**
           * Font Size
           * @see https://tailwindcss.com/docs/font-size
           */
          "font-size": [{
            text: ["base", isTshirtSize, isArbitraryLength]
          }],
          /**
           * Font Smoothing
           * @see https://tailwindcss.com/docs/font-smoothing
           */
          "font-smoothing": ["antialiased", "subpixel-antialiased"],
          /**
           * Font Style
           * @see https://tailwindcss.com/docs/font-style
           */
          "font-style": ["italic", "not-italic"],
          /**
           * Font Weight
           * @see https://tailwindcss.com/docs/font-weight
           */
          "font-weight": [{
            font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
          }],
          /**
           * Font Family
           * @see https://tailwindcss.com/docs/font-family
           */
          "font-family": [{
            font: [isAny]
          }],
          /**
           * Font Variant Numeric
           * @see https://tailwindcss.com/docs/font-variant-numeric
           */
          "fvn-normal": ["normal-nums"],
          /**
           * Font Variant Numeric
           * @see https://tailwindcss.com/docs/font-variant-numeric
           */
          "fvn-ordinal": ["ordinal"],
          /**
           * Font Variant Numeric
           * @see https://tailwindcss.com/docs/font-variant-numeric
           */
          "fvn-slashed-zero": ["slashed-zero"],
          /**
           * Font Variant Numeric
           * @see https://tailwindcss.com/docs/font-variant-numeric
           */
          "fvn-figure": ["lining-nums", "oldstyle-nums"],
          /**
           * Font Variant Numeric
           * @see https://tailwindcss.com/docs/font-variant-numeric
           */
          "fvn-spacing": ["proportional-nums", "tabular-nums"],
          /**
           * Font Variant Numeric
           * @see https://tailwindcss.com/docs/font-variant-numeric
           */
          "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
          /**
           * Letter Spacing
           * @see https://tailwindcss.com/docs/letter-spacing
           */
          tracking: [{
            tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
          }],
          /**
           * Line Clamp
           * @see https://tailwindcss.com/docs/line-clamp
           */
          "line-clamp": [{
            "line-clamp": ["none", isNumber, isArbitraryNumber]
          }],
          /**
           * Line Height
           * @see https://tailwindcss.com/docs/line-height
           */
          leading: [{
            leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isLength, isArbitraryValue]
          }],
          /**
           * List Style Image
           * @see https://tailwindcss.com/docs/list-style-image
           */
          "list-image": [{
            "list-image": ["none", isArbitraryValue]
          }],
          /**
           * List Style Type
           * @see https://tailwindcss.com/docs/list-style-type
           */
          "list-style-type": [{
            list: ["none", "disc", "decimal", isArbitraryValue]
          }],
          /**
           * List Style Position
           * @see https://tailwindcss.com/docs/list-style-position
           */
          "list-style-position": [{
            list: ["inside", "outside"]
          }],
          /**
           * Placeholder Color
           * @deprecated since Tailwind CSS v3.0.0
           * @see https://tailwindcss.com/docs/placeholder-color
           */
          "placeholder-color": [{
            placeholder: [colors]
          }],
          /**
           * Placeholder Opacity
           * @see https://tailwindcss.com/docs/placeholder-opacity
           */
          "placeholder-opacity": [{
            "placeholder-opacity": [opacity]
          }],
          /**
           * Text Alignment
           * @see https://tailwindcss.com/docs/text-align
           */
          "text-alignment": [{
            text: ["left", "center", "right", "justify", "start", "end"]
          }],
          /**
           * Text Color
           * @see https://tailwindcss.com/docs/text-color
           */
          "text-color": [{
            text: [colors]
          }],
          /**
           * Text Opacity
           * @see https://tailwindcss.com/docs/text-opacity
           */
          "text-opacity": [{
            "text-opacity": [opacity]
          }],
          /**
           * Text Decoration
           * @see https://tailwindcss.com/docs/text-decoration
           */
          "text-decoration": ["underline", "overline", "line-through", "no-underline"],
          /**
           * Text Decoration Style
           * @see https://tailwindcss.com/docs/text-decoration-style
           */
          "text-decoration-style": [{
            decoration: [...getLineStyles(), "wavy"]
          }],
          /**
           * Text Decoration Thickness
           * @see https://tailwindcss.com/docs/text-decoration-thickness
           */
          "text-decoration-thickness": [{
            decoration: ["auto", "from-font", isLength, isArbitraryLength]
          }],
          /**
           * Text Underline Offset
           * @see https://tailwindcss.com/docs/text-underline-offset
           */
          "underline-offset": [{
            "underline-offset": ["auto", isLength, isArbitraryValue]
          }],
          /**
           * Text Decoration Color
           * @see https://tailwindcss.com/docs/text-decoration-color
           */
          "text-decoration-color": [{
            decoration: [colors]
          }],
          /**
           * Text Transform
           * @see https://tailwindcss.com/docs/text-transform
           */
          "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
          /**
           * Text Overflow
           * @see https://tailwindcss.com/docs/text-overflow
           */
          "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
          /**
           * Text Wrap
           * @see https://tailwindcss.com/docs/text-wrap
           */
          "text-wrap": [{
            text: ["wrap", "nowrap", "balance", "pretty"]
          }],
          /**
           * Text Indent
           * @see https://tailwindcss.com/docs/text-indent
           */
          indent: [{
            indent: getSpacingWithArbitrary()
          }],
          /**
           * Vertical Alignment
           * @see https://tailwindcss.com/docs/vertical-align
           */
          "vertical-align": [{
            align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
          }],
          /**
           * Whitespace
           * @see https://tailwindcss.com/docs/whitespace
           */
          whitespace: [{
            whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
          }],
          /**
           * Word Break
           * @see https://tailwindcss.com/docs/word-break
           */
          break: [{
            break: ["normal", "words", "all", "keep"]
          }],
          /**
           * Hyphens
           * @see https://tailwindcss.com/docs/hyphens
           */
          hyphens: [{
            hyphens: ["none", "manual", "auto"]
          }],
          /**
           * Content
           * @see https://tailwindcss.com/docs/content
           */
          content: [{
            content: ["none", isArbitraryValue]
          }],
          // Backgrounds
          /**
           * Background Attachment
           * @see https://tailwindcss.com/docs/background-attachment
           */
          "bg-attachment": [{
            bg: ["fixed", "local", "scroll"]
          }],
          /**
           * Background Clip
           * @see https://tailwindcss.com/docs/background-clip
           */
          "bg-clip": [{
            "bg-clip": ["border", "padding", "content", "text"]
          }],
          /**
           * Background Opacity
           * @deprecated since Tailwind CSS v3.0.0
           * @see https://tailwindcss.com/docs/background-opacity
           */
          "bg-opacity": [{
            "bg-opacity": [opacity]
          }],
          /**
           * Background Origin
           * @see https://tailwindcss.com/docs/background-origin
           */
          "bg-origin": [{
            "bg-origin": ["border", "padding", "content"]
          }],
          /**
           * Background Position
           * @see https://tailwindcss.com/docs/background-position
           */
          "bg-position": [{
            bg: [...getPositions(), isArbitraryPosition]
          }],
          /**
           * Background Repeat
           * @see https://tailwindcss.com/docs/background-repeat
           */
          "bg-repeat": [{
            bg: ["no-repeat", {
              repeat: ["", "x", "y", "round", "space"]
            }]
          }],
          /**
           * Background Size
           * @see https://tailwindcss.com/docs/background-size
           */
          "bg-size": [{
            bg: ["auto", "cover", "contain", isArbitrarySize]
          }],
          /**
           * Background Image
           * @see https://tailwindcss.com/docs/background-image
           */
          "bg-image": [{
            bg: ["none", {
              "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
            }, isArbitraryImage]
          }],
          /**
           * Background Color
           * @see https://tailwindcss.com/docs/background-color
           */
          "bg-color": [{
            bg: [colors]
          }],
          /**
           * Gradient Color Stops From Position
           * @see https://tailwindcss.com/docs/gradient-color-stops
           */
          "gradient-from-pos": [{
            from: [gradientColorStopPositions]
          }],
          /**
           * Gradient Color Stops Via Position
           * @see https://tailwindcss.com/docs/gradient-color-stops
           */
          "gradient-via-pos": [{
            via: [gradientColorStopPositions]
          }],
          /**
           * Gradient Color Stops To Position
           * @see https://tailwindcss.com/docs/gradient-color-stops
           */
          "gradient-to-pos": [{
            to: [gradientColorStopPositions]
          }],
          /**
           * Gradient Color Stops From
           * @see https://tailwindcss.com/docs/gradient-color-stops
           */
          "gradient-from": [{
            from: [gradientColorStops]
          }],
          /**
           * Gradient Color Stops Via
           * @see https://tailwindcss.com/docs/gradient-color-stops
           */
          "gradient-via": [{
            via: [gradientColorStops]
          }],
          /**
           * Gradient Color Stops To
           * @see https://tailwindcss.com/docs/gradient-color-stops
           */
          "gradient-to": [{
            to: [gradientColorStops]
          }],
          // Borders
          /**
           * Border Radius
           * @see https://tailwindcss.com/docs/border-radius
           */
          rounded: [{
            rounded: [borderRadius]
          }],
          /**
           * Border Radius Start
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-s": [{
            "rounded-s": [borderRadius]
          }],
          /**
           * Border Radius End
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-e": [{
            "rounded-e": [borderRadius]
          }],
          /**
           * Border Radius Top
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-t": [{
            "rounded-t": [borderRadius]
          }],
          /**
           * Border Radius Right
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-r": [{
            "rounded-r": [borderRadius]
          }],
          /**
           * Border Radius Bottom
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-b": [{
            "rounded-b": [borderRadius]
          }],
          /**
           * Border Radius Left
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-l": [{
            "rounded-l": [borderRadius]
          }],
          /**
           * Border Radius Start Start
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-ss": [{
            "rounded-ss": [borderRadius]
          }],
          /**
           * Border Radius Start End
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-se": [{
            "rounded-se": [borderRadius]
          }],
          /**
           * Border Radius End End
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-ee": [{
            "rounded-ee": [borderRadius]
          }],
          /**
           * Border Radius End Start
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-es": [{
            "rounded-es": [borderRadius]
          }],
          /**
           * Border Radius Top Left
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-tl": [{
            "rounded-tl": [borderRadius]
          }],
          /**
           * Border Radius Top Right
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-tr": [{
            "rounded-tr": [borderRadius]
          }],
          /**
           * Border Radius Bottom Right
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-br": [{
            "rounded-br": [borderRadius]
          }],
          /**
           * Border Radius Bottom Left
           * @see https://tailwindcss.com/docs/border-radius
           */
          "rounded-bl": [{
            "rounded-bl": [borderRadius]
          }],
          /**
           * Border Width
           * @see https://tailwindcss.com/docs/border-width
           */
          "border-w": [{
            border: [borderWidth]
          }],
          /**
           * Border Width X
           * @see https://tailwindcss.com/docs/border-width
           */
          "border-w-x": [{
            "border-x": [borderWidth]
          }],
          /**
           * Border Width Y
           * @see https://tailwindcss.com/docs/border-width
           */
          "border-w-y": [{
            "border-y": [borderWidth]
          }],
          /**
           * Border Width Start
           * @see https://tailwindcss.com/docs/border-width
           */
          "border-w-s": [{
            "border-s": [borderWidth]
          }],
          /**
           * Border Width End
           * @see https://tailwindcss.com/docs/border-width
           */
          "border-w-e": [{
            "border-e": [borderWidth]
          }],
          /**
           * Border Width Top
           * @see https://tailwindcss.com/docs/border-width
           */
          "border-w-t": [{
            "border-t": [borderWidth]
          }],
          /**
           * Border Width Right
           * @see https://tailwindcss.com/docs/border-width
           */
          "border-w-r": [{
            "border-r": [borderWidth]
          }],
          /**
           * Border Width Bottom
           * @see https://tailwindcss.com/docs/border-width
           */
          "border-w-b": [{
            "border-b": [borderWidth]
          }],
          /**
           * Border Width Left
           * @see https://tailwindcss.com/docs/border-width
           */
          "border-w-l": [{
            "border-l": [borderWidth]
          }],
          /**
           * Border Opacity
           * @see https://tailwindcss.com/docs/border-opacity
           */
          "border-opacity": [{
            "border-opacity": [opacity]
          }],
          /**
           * Border Style
           * @see https://tailwindcss.com/docs/border-style
           */
          "border-style": [{
            border: [...getLineStyles(), "hidden"]
          }],
          /**
           * Divide Width X
           * @see https://tailwindcss.com/docs/divide-width
           */
          "divide-x": [{
            "divide-x": [borderWidth]
          }],
          /**
           * Divide Width X Reverse
           * @see https://tailwindcss.com/docs/divide-width
           */
          "divide-x-reverse": ["divide-x-reverse"],
          /**
           * Divide Width Y
           * @see https://tailwindcss.com/docs/divide-width
           */
          "divide-y": [{
            "divide-y": [borderWidth]
          }],
          /**
           * Divide Width Y Reverse
           * @see https://tailwindcss.com/docs/divide-width
           */
          "divide-y-reverse": ["divide-y-reverse"],
          /**
           * Divide Opacity
           * @see https://tailwindcss.com/docs/divide-opacity
           */
          "divide-opacity": [{
            "divide-opacity": [opacity]
          }],
          /**
           * Divide Style
           * @see https://tailwindcss.com/docs/divide-style
           */
          "divide-style": [{
            divide: getLineStyles()
          }],
          /**
           * Border Color
           * @see https://tailwindcss.com/docs/border-color
           */
          "border-color": [{
            border: [borderColor]
          }],
          /**
           * Border Color X
           * @see https://tailwindcss.com/docs/border-color
           */
          "border-color-x": [{
            "border-x": [borderColor]
          }],
          /**
           * Border Color Y
           * @see https://tailwindcss.com/docs/border-color
           */
          "border-color-y": [{
            "border-y": [borderColor]
          }],
          /**
           * Border Color S
           * @see https://tailwindcss.com/docs/border-color
           */
          "border-color-s": [{
            "border-s": [borderColor]
          }],
          /**
           * Border Color E
           * @see https://tailwindcss.com/docs/border-color
           */
          "border-color-e": [{
            "border-e": [borderColor]
          }],
          /**
           * Border Color Top
           * @see https://tailwindcss.com/docs/border-color
           */
          "border-color-t": [{
            "border-t": [borderColor]
          }],
          /**
           * Border Color Right
           * @see https://tailwindcss.com/docs/border-color
           */
          "border-color-r": [{
            "border-r": [borderColor]
          }],
          /**
           * Border Color Bottom
           * @see https://tailwindcss.com/docs/border-color
           */
          "border-color-b": [{
            "border-b": [borderColor]
          }],
          /**
           * Border Color Left
           * @see https://tailwindcss.com/docs/border-color
           */
          "border-color-l": [{
            "border-l": [borderColor]
          }],
          /**
           * Divide Color
           * @see https://tailwindcss.com/docs/divide-color
           */
          "divide-color": [{
            divide: [borderColor]
          }],
          /**
           * Outline Style
           * @see https://tailwindcss.com/docs/outline-style
           */
          "outline-style": [{
            outline: ["", ...getLineStyles()]
          }],
          /**
           * Outline Offset
           * @see https://tailwindcss.com/docs/outline-offset
           */
          "outline-offset": [{
            "outline-offset": [isLength, isArbitraryValue]
          }],
          /**
           * Outline Width
           * @see https://tailwindcss.com/docs/outline-width
           */
          "outline-w": [{
            outline: [isLength, isArbitraryLength]
          }],
          /**
           * Outline Color
           * @see https://tailwindcss.com/docs/outline-color
           */
          "outline-color": [{
            outline: [colors]
          }],
          /**
           * Ring Width
           * @see https://tailwindcss.com/docs/ring-width
           */
          "ring-w": [{
            ring: getLengthWithEmptyAndArbitrary()
          }],
          /**
           * Ring Width Inset
           * @see https://tailwindcss.com/docs/ring-width
           */
          "ring-w-inset": ["ring-inset"],
          /**
           * Ring Color
           * @see https://tailwindcss.com/docs/ring-color
           */
          "ring-color": [{
            ring: [colors]
          }],
          /**
           * Ring Opacity
           * @see https://tailwindcss.com/docs/ring-opacity
           */
          "ring-opacity": [{
            "ring-opacity": [opacity]
          }],
          /**
           * Ring Offset Width
           * @see https://tailwindcss.com/docs/ring-offset-width
           */
          "ring-offset-w": [{
            "ring-offset": [isLength, isArbitraryLength]
          }],
          /**
           * Ring Offset Color
           * @see https://tailwindcss.com/docs/ring-offset-color
           */
          "ring-offset-color": [{
            "ring-offset": [colors]
          }],
          // Effects
          /**
           * Box Shadow
           * @see https://tailwindcss.com/docs/box-shadow
           */
          shadow: [{
            shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
          }],
          /**
           * Box Shadow Color
           * @see https://tailwindcss.com/docs/box-shadow-color
           */
          "shadow-color": [{
            shadow: [isAny]
          }],
          /**
           * Opacity
           * @see https://tailwindcss.com/docs/opacity
           */
          opacity: [{
            opacity: [opacity]
          }],
          /**
           * Mix Blend Mode
           * @see https://tailwindcss.com/docs/mix-blend-mode
           */
          "mix-blend": [{
            "mix-blend": [...getBlendModes(), "plus-lighter", "plus-darker"]
          }],
          /**
           * Background Blend Mode
           * @see https://tailwindcss.com/docs/background-blend-mode
           */
          "bg-blend": [{
            "bg-blend": getBlendModes()
          }],
          // Filters
          /**
           * Filter
           * @deprecated since Tailwind CSS v3.0.0
           * @see https://tailwindcss.com/docs/filter
           */
          filter: [{
            filter: ["", "none"]
          }],
          /**
           * Blur
           * @see https://tailwindcss.com/docs/blur
           */
          blur: [{
            blur: [blur2]
          }],
          /**
           * Brightness
           * @see https://tailwindcss.com/docs/brightness
           */
          brightness: [{
            brightness: [brightness]
          }],
          /**
           * Contrast
           * @see https://tailwindcss.com/docs/contrast
           */
          contrast: [{
            contrast: [contrast]
          }],
          /**
           * Drop Shadow
           * @see https://tailwindcss.com/docs/drop-shadow
           */
          "drop-shadow": [{
            "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
          }],
          /**
           * Grayscale
           * @see https://tailwindcss.com/docs/grayscale
           */
          grayscale: [{
            grayscale: [grayscale]
          }],
          /**
           * Hue Rotate
           * @see https://tailwindcss.com/docs/hue-rotate
           */
          "hue-rotate": [{
            "hue-rotate": [hueRotate]
          }],
          /**
           * Invert
           * @see https://tailwindcss.com/docs/invert
           */
          invert: [{
            invert: [invert]
          }],
          /**
           * Saturate
           * @see https://tailwindcss.com/docs/saturate
           */
          saturate: [{
            saturate: [saturate]
          }],
          /**
           * Sepia
           * @see https://tailwindcss.com/docs/sepia
           */
          sepia: [{
            sepia: [sepia]
          }],
          /**
           * Backdrop Filter
           * @deprecated since Tailwind CSS v3.0.0
           * @see https://tailwindcss.com/docs/backdrop-filter
           */
          "backdrop-filter": [{
            "backdrop-filter": ["", "none"]
          }],
          /**
           * Backdrop Blur
           * @see https://tailwindcss.com/docs/backdrop-blur
           */
          "backdrop-blur": [{
            "backdrop-blur": [blur2]
          }],
          /**
           * Backdrop Brightness
           * @see https://tailwindcss.com/docs/backdrop-brightness
           */
          "backdrop-brightness": [{
            "backdrop-brightness": [brightness]
          }],
          /**
           * Backdrop Contrast
           * @see https://tailwindcss.com/docs/backdrop-contrast
           */
          "backdrop-contrast": [{
            "backdrop-contrast": [contrast]
          }],
          /**
           * Backdrop Grayscale
           * @see https://tailwindcss.com/docs/backdrop-grayscale
           */
          "backdrop-grayscale": [{
            "backdrop-grayscale": [grayscale]
          }],
          /**
           * Backdrop Hue Rotate
           * @see https://tailwindcss.com/docs/backdrop-hue-rotate
           */
          "backdrop-hue-rotate": [{
            "backdrop-hue-rotate": [hueRotate]
          }],
          /**
           * Backdrop Invert
           * @see https://tailwindcss.com/docs/backdrop-invert
           */
          "backdrop-invert": [{
            "backdrop-invert": [invert]
          }],
          /**
           * Backdrop Opacity
           * @see https://tailwindcss.com/docs/backdrop-opacity
           */
          "backdrop-opacity": [{
            "backdrop-opacity": [opacity]
          }],
          /**
           * Backdrop Saturate
           * @see https://tailwindcss.com/docs/backdrop-saturate
           */
          "backdrop-saturate": [{
            "backdrop-saturate": [saturate]
          }],
          /**
           * Backdrop Sepia
           * @see https://tailwindcss.com/docs/backdrop-sepia
           */
          "backdrop-sepia": [{
            "backdrop-sepia": [sepia]
          }],
          // Tables
          /**
           * Border Collapse
           * @see https://tailwindcss.com/docs/border-collapse
           */
          "border-collapse": [{
            border: ["collapse", "separate"]
          }],
          /**
           * Border Spacing
           * @see https://tailwindcss.com/docs/border-spacing
           */
          "border-spacing": [{
            "border-spacing": [borderSpacing]
          }],
          /**
           * Border Spacing X
           * @see https://tailwindcss.com/docs/border-spacing
           */
          "border-spacing-x": [{
            "border-spacing-x": [borderSpacing]
          }],
          /**
           * Border Spacing Y
           * @see https://tailwindcss.com/docs/border-spacing
           */
          "border-spacing-y": [{
            "border-spacing-y": [borderSpacing]
          }],
          /**
           * Table Layout
           * @see https://tailwindcss.com/docs/table-layout
           */
          "table-layout": [{
            table: ["auto", "fixed"]
          }],
          /**
           * Caption Side
           * @see https://tailwindcss.com/docs/caption-side
           */
          caption: [{
            caption: ["top", "bottom"]
          }],
          // Transitions and Animation
          /**
           * Tranisition Property
           * @see https://tailwindcss.com/docs/transition-property
           */
          transition: [{
            transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
          }],
          /**
           * Transition Duration
           * @see https://tailwindcss.com/docs/transition-duration
           */
          duration: [{
            duration: getNumberAndArbitrary()
          }],
          /**
           * Transition Timing Function
           * @see https://tailwindcss.com/docs/transition-timing-function
           */
          ease: [{
            ease: ["linear", "in", "out", "in-out", isArbitraryValue]
          }],
          /**
           * Transition Delay
           * @see https://tailwindcss.com/docs/transition-delay
           */
          delay: [{
            delay: getNumberAndArbitrary()
          }],
          /**
           * Animation
           * @see https://tailwindcss.com/docs/animation
           */
          animate: [{
            animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
          }],
          // Transforms
          /**
           * Transform
           * @see https://tailwindcss.com/docs/transform
           */
          transform: [{
            transform: ["", "gpu", "none"]
          }],
          /**
           * Scale
           * @see https://tailwindcss.com/docs/scale
           */
          scale: [{
            scale: [scale]
          }],
          /**
           * Scale X
           * @see https://tailwindcss.com/docs/scale
           */
          "scale-x": [{
            "scale-x": [scale]
          }],
          /**
           * Scale Y
           * @see https://tailwindcss.com/docs/scale
           */
          "scale-y": [{
            "scale-y": [scale]
          }],
          /**
           * Rotate
           * @see https://tailwindcss.com/docs/rotate
           */
          rotate: [{
            rotate: [isInteger, isArbitraryValue]
          }],
          /**
           * Translate X
           * @see https://tailwindcss.com/docs/translate
           */
          "translate-x": [{
            "translate-x": [translate]
          }],
          /**
           * Translate Y
           * @see https://tailwindcss.com/docs/translate
           */
          "translate-y": [{
            "translate-y": [translate]
          }],
          /**
           * Skew X
           * @see https://tailwindcss.com/docs/skew
           */
          "skew-x": [{
            "skew-x": [skew]
          }],
          /**
           * Skew Y
           * @see https://tailwindcss.com/docs/skew
           */
          "skew-y": [{
            "skew-y": [skew]
          }],
          /**
           * Transform Origin
           * @see https://tailwindcss.com/docs/transform-origin
           */
          "transform-origin": [{
            origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
          }],
          // Interactivity
          /**
           * Accent Color
           * @see https://tailwindcss.com/docs/accent-color
           */
          accent: [{
            accent: ["auto", colors]
          }],
          /**
           * Appearance
           * @see https://tailwindcss.com/docs/appearance
           */
          appearance: [{
            appearance: ["none", "auto"]
          }],
          /**
           * Cursor
           * @see https://tailwindcss.com/docs/cursor
           */
          cursor: [{
            cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
          }],
          /**
           * Caret Color
           * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
           */
          "caret-color": [{
            caret: [colors]
          }],
          /**
           * Pointer Events
           * @see https://tailwindcss.com/docs/pointer-events
           */
          "pointer-events": [{
            "pointer-events": ["none", "auto"]
          }],
          /**
           * Resize
           * @see https://tailwindcss.com/docs/resize
           */
          resize: [{
            resize: ["none", "y", "x", ""]
          }],
          /**
           * Scroll Behavior
           * @see https://tailwindcss.com/docs/scroll-behavior
           */
          "scroll-behavior": [{
            scroll: ["auto", "smooth"]
          }],
          /**
           * Scroll Margin
           * @see https://tailwindcss.com/docs/scroll-margin
           */
          "scroll-m": [{
            "scroll-m": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Margin X
           * @see https://tailwindcss.com/docs/scroll-margin
           */
          "scroll-mx": [{
            "scroll-mx": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Margin Y
           * @see https://tailwindcss.com/docs/scroll-margin
           */
          "scroll-my": [{
            "scroll-my": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Margin Start
           * @see https://tailwindcss.com/docs/scroll-margin
           */
          "scroll-ms": [{
            "scroll-ms": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Margin End
           * @see https://tailwindcss.com/docs/scroll-margin
           */
          "scroll-me": [{
            "scroll-me": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Margin Top
           * @see https://tailwindcss.com/docs/scroll-margin
           */
          "scroll-mt": [{
            "scroll-mt": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Margin Right
           * @see https://tailwindcss.com/docs/scroll-margin
           */
          "scroll-mr": [{
            "scroll-mr": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Margin Bottom
           * @see https://tailwindcss.com/docs/scroll-margin
           */
          "scroll-mb": [{
            "scroll-mb": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Margin Left
           * @see https://tailwindcss.com/docs/scroll-margin
           */
          "scroll-ml": [{
            "scroll-ml": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Padding
           * @see https://tailwindcss.com/docs/scroll-padding
           */
          "scroll-p": [{
            "scroll-p": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Padding X
           * @see https://tailwindcss.com/docs/scroll-padding
           */
          "scroll-px": [{
            "scroll-px": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Padding Y
           * @see https://tailwindcss.com/docs/scroll-padding
           */
          "scroll-py": [{
            "scroll-py": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Padding Start
           * @see https://tailwindcss.com/docs/scroll-padding
           */
          "scroll-ps": [{
            "scroll-ps": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Padding End
           * @see https://tailwindcss.com/docs/scroll-padding
           */
          "scroll-pe": [{
            "scroll-pe": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Padding Top
           * @see https://tailwindcss.com/docs/scroll-padding
           */
          "scroll-pt": [{
            "scroll-pt": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Padding Right
           * @see https://tailwindcss.com/docs/scroll-padding
           */
          "scroll-pr": [{
            "scroll-pr": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Padding Bottom
           * @see https://tailwindcss.com/docs/scroll-padding
           */
          "scroll-pb": [{
            "scroll-pb": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Padding Left
           * @see https://tailwindcss.com/docs/scroll-padding
           */
          "scroll-pl": [{
            "scroll-pl": getSpacingWithArbitrary()
          }],
          /**
           * Scroll Snap Align
           * @see https://tailwindcss.com/docs/scroll-snap-align
           */
          "snap-align": [{
            snap: ["start", "end", "center", "align-none"]
          }],
          /**
           * Scroll Snap Stop
           * @see https://tailwindcss.com/docs/scroll-snap-stop
           */
          "snap-stop": [{
            snap: ["normal", "always"]
          }],
          /**
           * Scroll Snap Type
           * @see https://tailwindcss.com/docs/scroll-snap-type
           */
          "snap-type": [{
            snap: ["none", "x", "y", "both"]
          }],
          /**
           * Scroll Snap Type Strictness
           * @see https://tailwindcss.com/docs/scroll-snap-type
           */
          "snap-strictness": [{
            snap: ["mandatory", "proximity"]
          }],
          /**
           * Touch Action
           * @see https://tailwindcss.com/docs/touch-action
           */
          touch: [{
            touch: ["auto", "none", "manipulation"]
          }],
          /**
           * Touch Action X
           * @see https://tailwindcss.com/docs/touch-action
           */
          "touch-x": [{
            "touch-pan": ["x", "left", "right"]
          }],
          /**
           * Touch Action Y
           * @see https://tailwindcss.com/docs/touch-action
           */
          "touch-y": [{
            "touch-pan": ["y", "up", "down"]
          }],
          /**
           * Touch Action Pinch Zoom
           * @see https://tailwindcss.com/docs/touch-action
           */
          "touch-pz": ["touch-pinch-zoom"],
          /**
           * User Select
           * @see https://tailwindcss.com/docs/user-select
           */
          select: [{
            select: ["none", "text", "all", "auto"]
          }],
          /**
           * Will Change
           * @see https://tailwindcss.com/docs/will-change
           */
          "will-change": [{
            "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
          }],
          // SVG
          /**
           * Fill
           * @see https://tailwindcss.com/docs/fill
           */
          fill: [{
            fill: [colors, "none"]
          }],
          /**
           * Stroke Width
           * @see https://tailwindcss.com/docs/stroke-width
           */
          "stroke-w": [{
            stroke: [isLength, isArbitraryLength, isArbitraryNumber]
          }],
          /**
           * Stroke
           * @see https://tailwindcss.com/docs/stroke
           */
          stroke: [{
            stroke: [colors, "none"]
          }],
          // Accessibility
          /**
           * Screen Readers
           * @see https://tailwindcss.com/docs/screen-readers
           */
          sr: ["sr-only", "not-sr-only"],
          /**
           * Forced Color Adjust
           * @see https://tailwindcss.com/docs/forced-color-adjust
           */
          "forced-color-adjust": [{
            "forced-color-adjust": ["auto", "none"]
          }]
        },
        conflictingClassGroups: {
          overflow: ["overflow-x", "overflow-y"],
          overscroll: ["overscroll-x", "overscroll-y"],
          inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
          "inset-x": ["right", "left"],
          "inset-y": ["top", "bottom"],
          flex: ["basis", "grow", "shrink"],
          gap: ["gap-x", "gap-y"],
          p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
          px: ["pr", "pl"],
          py: ["pt", "pb"],
          m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
          mx: ["mr", "ml"],
          my: ["mt", "mb"],
          size: ["w", "h"],
          "font-size": ["leading"],
          "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
          "fvn-ordinal": ["fvn-normal"],
          "fvn-slashed-zero": ["fvn-normal"],
          "fvn-figure": ["fvn-normal"],
          "fvn-spacing": ["fvn-normal"],
          "fvn-fraction": ["fvn-normal"],
          "line-clamp": ["display", "overflow"],
          rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
          "rounded-s": ["rounded-ss", "rounded-es"],
          "rounded-e": ["rounded-se", "rounded-ee"],
          "rounded-t": ["rounded-tl", "rounded-tr"],
          "rounded-r": ["rounded-tr", "rounded-br"],
          "rounded-b": ["rounded-br", "rounded-bl"],
          "rounded-l": ["rounded-tl", "rounded-bl"],
          "border-spacing": ["border-spacing-x", "border-spacing-y"],
          "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
          "border-w-x": ["border-w-r", "border-w-l"],
          "border-w-y": ["border-w-t", "border-w-b"],
          "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
          "border-color-x": ["border-color-r", "border-color-l"],
          "border-color-y": ["border-color-t", "border-color-b"],
          "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
          "scroll-mx": ["scroll-mr", "scroll-ml"],
          "scroll-my": ["scroll-mt", "scroll-mb"],
          "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
          "scroll-px": ["scroll-pr", "scroll-pl"],
          "scroll-py": ["scroll-pt", "scroll-pb"],
          touch: ["touch-x", "touch-y", "touch-pz"],
          "touch-x": ["touch"],
          "touch-y": ["touch"],
          "touch-pz": ["touch"]
        },
        conflictingClassGroupModifiers: {
          "font-size": ["leading"]
        }
      };
    };
    var mergeConfigs = (baseConfig, {
      cacheSize,
      prefix,
      separator,
      experimentalParseClassName,
      extend = {},
      override = {}
    }) => {
      overrideProperty(baseConfig, "cacheSize", cacheSize);
      overrideProperty(baseConfig, "prefix", prefix);
      overrideProperty(baseConfig, "separator", separator);
      overrideProperty(baseConfig, "experimentalParseClassName", experimentalParseClassName);
      for (const configKey in override) {
        overrideConfigProperties(baseConfig[configKey], override[configKey]);
      }
      for (const key in extend) {
        mergeConfigProperties(baseConfig[key], extend[key]);
      }
      return baseConfig;
    };
    var overrideProperty = (baseObject, overrideKey, overrideValue) => {
      if (overrideValue !== void 0) {
        baseObject[overrideKey] = overrideValue;
      }
    };
    var overrideConfigProperties = (baseObject, overrideObject) => {
      if (overrideObject) {
        for (const key in overrideObject) {
          overrideProperty(baseObject, key, overrideObject[key]);
        }
      }
    };
    var mergeConfigProperties = (baseObject, mergeObject) => {
      if (mergeObject) {
        for (const key in mergeObject) {
          const mergeValue = mergeObject[key];
          if (mergeValue !== void 0) {
            baseObject[key] = (baseObject[key] || []).concat(mergeValue);
          }
        }
      }
    };
    var extendTailwindMerge = (configExtension, ...createConfig) => typeof configExtension === "function" ? createTailwindMerge(getDefaultConfig, configExtension, ...createConfig) : createTailwindMerge(() => mergeConfigs(getDefaultConfig(), configExtension), ...createConfig);
    var twMerge5 = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);
    exports.createTailwindMerge = createTailwindMerge;
    exports.extendTailwindMerge = extendTailwindMerge;
    exports.fromTheme = fromTheme;
    exports.getDefaultConfig = getDefaultConfig;
    exports.mergeConfigs = mergeConfigs;
    exports.twJoin = twJoin;
    exports.twMerge = twMerge5;
    exports.validators = validators;
  }
});

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports, module2) {
    (function() {
      var undefined2;
      var VERSION2 = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        // Latin Extended-A block.
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n2, iteratee) {
        var index = -1, result = Array(n2);
        while (++index < n2) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = function() {
          function object() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n2) {
          return shuffleSelf(copyArray(array), baseClamp(n2, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait2, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait2);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity2;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n2) {
          var length = array.length;
          if (!length) {
            return;
          }
          n2 += n2 < 0 ? length : 0;
          return isIndex(n2, length) ? array[n2] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity2];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n2) {
          var result2 = "";
          if (!string || n2 < 1 || n2 > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n2 % 2) {
              result2 += string;
            }
            n2 = nativeFloor(n2 / 2);
            if (n2) {
              string += string;
            }
          } while (n2);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity2), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n2) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n2, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity2 : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity2 : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity2, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity2;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop2 : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait2) {
          return root.setTimeout(func, wait2);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result2;
        }
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n2, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          return baseSlice(array, n2 < 0 ? 0 : n2, length);
        }
        function dropRight(array, n2, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          n2 = length - n2;
          return baseSlice(array, 0, n2 < 0 ? 0 : n2);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n2) {
          return array && array.length ? baseNth(array, toInteger(n2)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n2, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          return baseSlice(array, 0, n2 < 0 ? 0 : n2);
        }
        function takeRight(array, n2, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          n2 = length - n2;
          return baseSlice(array, n2 < 0 ? 0 : n2, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n2, guard) {
          if (guard ? isIterateeCall(collection, n2, guard) : n2 === undefined2) {
            n2 = 1;
          } else {
            n2 = toInteger(n2);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n2);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now2 = ctxNow || function() {
          return root.Date.now();
        };
        function after(n2, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n2 = toInteger(n2);
          return function() {
            if (--n2 < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n2, guard) {
          n2 = guard ? undefined2 : n2;
          n2 = func && n2 == null ? func.length : n2;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n2);
        }
        function before(n2, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n2 = toInteger(n2);
          return function() {
            if (--n2 > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n2 <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind2 = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind2));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce2(func, wait2, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait2 = toNumber(wait2) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait2) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait2);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait2 - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait2 || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now2();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush2() {
            return timerId === undefined2 ? result2 : trailingEdge(now2());
          }
          function debounced() {
            var time = now2(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait2);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait2);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush2;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay2 = baseRest(function(func, wait2, args) {
          return baseDelay(func, toNumber(wait2) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait2, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce2(func, wait2, {
            "leading": leading,
            "maxWait": wait2,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign2 = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity2));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index < length) {
            var value = object == null ? undefined2 : object[toKey(path[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update2(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape2(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n2, guard) {
          if (guard ? isIterateeCall(string, n2, guard) : n2 === undefined2) {
            n2 = 1;
          } else {
            n2 = toInteger(n2);
          }
          return baseRepeat(toString(string), n2);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind2(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity2(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop2() {
        }
        function nthArg(n2) {
          n2 = toInteger(n2);
          return baseRest(function(args) {
            return baseNth(args, n2);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n2, iteratee2) {
          n2 = toInteger(n2);
          if (n2 < 1 || n2 > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n2, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n2 -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n2) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity2, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity2);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity2, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity2) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign2;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind2;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce2;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay2;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update2;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape2;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity2;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop2;
        lodash.now = now2;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION2;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n2) {
            n2 = n2 === undefined2 ? 1 : nativeMax(toInteger(n2), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n2, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n2, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n2) {
            return this.reverse()[methodName](n2).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity2);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }).call(exports);
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GraphWeaverPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian24 = require("obsidian");

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
var identity = (x) => x;
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return (
    /** @type {T & S} */
    tar
  );
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    for (const callback of callbacks) {
      callback(void 0);
    }
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_) => value = _)();
  return value;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function exclude_internal_props(props) {
  const result = {};
  for (const k in props)
    if (k[0] !== "$")
      result[k] = props[k];
  return result;
}
function compute_rest_props(props, keys) {
  const rest = {};
  keys = new Set(keys);
  for (const k in props)
    if (!keys.has(k) && k[0] !== "$")
      rest[k] = props[k];
  return rest;
}
function compute_slots(slots) {
  const result = {};
  for (const key in slots) {
    result[key] = true;
  }
  return result;
}
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}
function split_css_unit(value) {
  const split = typeof value === "string" && value.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);
  return split ? [parseFloat(split[1]), split[2] || "px"] : [
    /** @type {number} */
    value,
    "px"
  ];
}

// node_modules/svelte/src/runtime/internal/environment.js
var is_client = typeof window !== "undefined";
var now = is_client ? () => window.performance.now() : () => Date.now();
var raf = is_client ? (cb) => requestAnimationFrame(cb) : noop;

// node_modules/svelte/src/runtime/internal/loop.js
var tasks = /* @__PURE__ */ new Set();
function run_tasks(now2) {
  tasks.forEach((task) => {
    if (!task.c(now2)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0)
    raf(run_tasks);
}
function loop(callback) {
  let task;
  if (tasks.size === 0)
    raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      tasks.delete(task);
    }
  };
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    var _a;
    return (_a = this._observer) != null ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) == null ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return node.ownerDocument;
}
function append_empty_stylesheet(node) {
  const style_element = element("style");
  style_element.textContent = "/* empty */";
  append_stylesheet(get_root_for_style(node), style_element);
  return style_element.sheet;
}
function append_stylesheet(node, style) {
  append(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
var always_set_through_set_attribute = ["width", "height"];
function set_attributes(node, attributes) {
  const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
  for (const key in attributes) {
    if (attributes[key] == null) {
      node.removeAttribute(key);
    } else if (key === "style") {
      node.style.cssText = attributes[key];
    } else if (key === "__value") {
      node.value = node[key] = attributes[key];
    } else if (descriptors[key] && descriptors[key].set && always_set_through_set_attribute.indexOf(key) === -1) {
      node[key] = attributes[key];
    } else {
      attr(node, key, attributes[key]);
    }
  }
}
function set_custom_element_data_map(node, data_map) {
  Object.keys(data_map).forEach((key) => {
    set_custom_element_data(node, key, data_map[key]);
  });
}
function set_custom_element_data(node, prop, value) {
  const lower = prop.toLowerCase();
  if (lower in node) {
    node[lower] = typeof node[lower] === "boolean" && value === "" ? true : value;
  } else if (prop in node) {
    node[prop] = typeof node[prop] === "boolean" && value === "" ? true : value;
  } else {
    attr(node, prop, value);
  }
}
function set_dynamic_element_data(tag) {
  return /-/.test(tag) ? set_custom_element_data_map : set_attributes;
}
function to_number(value) {
  return value === "" ? null : +value;
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = /** @type {string} */
  data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function select_option(select, value, mounting) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function select_value(select) {
  const selected_option = select.querySelector(":checked");
  return selected_option && selected_option.__value;
}
function toggle_class(element2, name, toggle) {
  element2.classList.toggle(name, !!toggle);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  return new CustomEvent(type, { detail, bubbles, cancelable });
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}
function construct_svelte_component(component, props) {
  return new component(props);
}

// node_modules/svelte/src/runtime/internal/style_manager.js
var managed_styles = /* @__PURE__ */ new Map();
var active = 0;
function hash(str) {
  let hash2 = 5381;
  let i = str.length;
  while (i--)
    hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);
  return hash2 >>> 0;
}
function create_style_information(doc, node) {
  const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
  managed_styles.set(doc, info);
  return info;
}
function create_rule(node, a, b, duration, delay2, ease, fn, uid = 0) {
  const step = 16.666 / duration;
  let keyframes = "{\n";
  for (let p = 0; p <= 1; p += step) {
    const t = a + (b - a) * ease(p);
    keyframes += p * 100 + `%{${fn(t, 1 - t)}}
`;
  }
  const rule = keyframes + `100% {${fn(b, 1 - b)}}
}`;
  const name = `__svelte_${hash(rule)}_${uid}`;
  const doc = get_root_for_style(node);
  const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
  if (!rules[name]) {
    rules[name] = true;
    stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
  }
  const animation = node.style.animation || "";
  node.style.animation = `${animation ? `${animation}, ` : ""}${name} ${duration}ms linear ${delay2}ms 1 both`;
  active += 1;
  return name;
}
function delete_rule(node, name) {
  const previous = (node.style.animation || "").split(", ");
  const next = previous.filter(
    name ? (anim) => anim.indexOf(name) < 0 : (anim) => anim.indexOf("__svelte") === -1
    // remove all Svelte animations
  );
  const deleted = previous.length - next.length;
  if (deleted) {
    node.style.animation = next.join(", ");
    active -= deleted;
    if (!active)
      clear_rules();
  }
}
function clear_rules() {
  raf(() => {
    if (active)
      return;
    managed_styles.forEach((info) => {
      const { ownerNode } = info.stylesheet;
      if (ownerNode)
        detach(ownerNode);
    });
    managed_styles.clear();
  });
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
  return context;
}
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var promise;
function wait() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(() => {
      promise = null;
    });
  }
  return promise;
}
function dispatch(node, direction, kind) {
  node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
}
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
var null_transition = { duration: 0 };
function create_bidirectional_transition(node, fn, params, intro) {
  const options = { direction: "both" };
  let config = fn(node, params, options);
  let t = intro ? 0 : 1;
  let running_program = null;
  let pending_program = null;
  let animation_name = null;
  let original_inert_value;
  function clear_animation() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function init2(program, duration) {
    const d = (
      /** @type {Program['d']} */
      program.b - t
    );
    duration *= Math.abs(d);
    return {
      a: t,
      b: program.b,
      d,
      duration,
      start: program.start,
      end: program.start + duration,
      group: program.group
    };
  }
  function go(b) {
    const {
      delay: delay2 = 0,
      duration = 300,
      easing = identity,
      tick: tick2 = noop,
      css
    } = config || null_transition;
    const program = {
      start: now() + delay2,
      b
    };
    if (!b) {
      program.group = outros;
      outros.r += 1;
    }
    if ("inert" in node) {
      if (b) {
        if (original_inert_value !== void 0) {
          node.inert = original_inert_value;
        }
      } else {
        original_inert_value = /** @type {HTMLElement} */
        node.inert;
        node.inert = true;
      }
    }
    if (running_program || pending_program) {
      pending_program = program;
    } else {
      if (css) {
        clear_animation();
        animation_name = create_rule(node, t, b, duration, delay2, easing, css);
      }
      if (b)
        tick2(0, 1);
      running_program = init2(program, duration);
      add_render_callback(() => dispatch(node, b, "start"));
      loop((now2) => {
        if (pending_program && now2 > pending_program.start) {
          running_program = init2(pending_program, duration);
          pending_program = null;
          dispatch(node, running_program.b, "start");
          if (css) {
            clear_animation();
            animation_name = create_rule(
              node,
              t,
              running_program.b,
              running_program.duration,
              0,
              easing,
              config.css
            );
          }
        }
        if (running_program) {
          if (now2 >= running_program.end) {
            tick2(t = running_program.b, 1 - t);
            dispatch(node, running_program.b, "end");
            if (!pending_program) {
              if (running_program.b) {
                clear_animation();
              } else {
                if (!--running_program.group.r)
                  run_all(running_program.group.c);
              }
            }
            running_program = null;
          } else if (now2 >= running_program.start) {
            const p = now2 - running_program.start;
            t = running_program.a + running_program.d * easing(p / running_program.duration);
            tick2(t, 1 - t);
          }
        }
        return !!(running_program || pending_program);
      });
    }
  }
  return {
    run(b) {
      if (is_function(config)) {
        wait().then(() => {
          const opts = { direction: b ? "in" : "out" };
          config = config(opts);
          go(b);
        });
      } else {
        go(b);
      }
    },
    end() {
      clear_animation();
      running_program = pending_program = null;
    }
  };
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
function destroy_block(block, lookup) {
  block.d(1);
  lookup.delete(block.key);
}
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block9, next, get_context) {
  let o = old_blocks.length;
  let n2 = list.length;
  let i = o;
  const old_indexes = {};
  while (i--)
    old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  const updates = [];
  i = n2;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block9(key, child_ctx);
      block.c();
    } else if (dynamic) {
      updates.push(() => block.p(child_ctx, dirty));
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n2--;
  }
  while (o && n2) {
    const new_block = new_blocks[n2 - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o--;
      n2--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key))
      destroy(old_block, lookup);
  }
  while (n2)
    insert2(new_blocks[n2 - 1]);
  run_all(updates);
  return new_blocks;
}

// node_modules/svelte/src/runtime/internal/spread.js
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n2 = updates[i];
    if (n2) {
      for (const key in o) {
        if (!(key in n2))
          to_null_out[key] = 1;
      }
      for (const key in n2) {
        if (!accounted_for[key]) {
          update2[key] = n2[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n2;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function bind(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance20, create_fragment20, not_equal, props, append_styles2 = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance20 ? instance20(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment20 ? create_fragment20($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    connectedCallback() {
      return __async(this, null, function* () {
        this.$$cn = true;
        if (!this.$$c) {
          let create_slot2 = function(name) {
            return () => {
              let node;
              const obj = {
                c: function create() {
                  node = element("slot");
                  if (name !== "default") {
                    attr(node, "name", name);
                  }
                },
                /**
                 * @param {HTMLElement} target
                 * @param {HTMLElement} [anchor]
                 */
                m: function mount(target, anchor) {
                  insert(target, node, anchor);
                },
                d: function destroy(detaching) {
                  if (detaching) {
                    detach(node);
                  }
                }
              };
              return obj;
            };
          };
          yield Promise.resolve();
          if (!this.$$cn || this.$$c) {
            return;
          }
          const $$slots = {};
          const existing_slots = get_custom_elements_slots(this);
          for (const name of this.$$s) {
            if (name in existing_slots) {
              $$slots[name] = [create_slot2(name)];
            }
          }
          for (const attribute of this.attributes) {
            const name = this.$$g_p(attribute.name);
            if (!(name in this.$$d)) {
              this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
            }
          }
          for (const key in this.$$p_d) {
            if (!(key in this.$$d) && this[key] !== void 0) {
              this.$$d[key] = this[key];
              delete this[key];
            }
          }
          this.$$c = new this.$$ctor({
            target: this.shadowRoot || this,
            props: __spreadProps(__spreadValues({}, this.$$d), {
              $$slots,
              $$scope: {
                ctx: []
              }
            })
          });
          const reflect_attributes = () => {
            this.$$r = true;
            for (const key in this.$$p_d) {
              this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
              if (this.$$p_d[key].reflect) {
                const attribute_value = get_custom_element_value(
                  key,
                  this.$$d[key],
                  this.$$p_d,
                  "toAttribute"
                );
                if (attribute_value == null) {
                  this.removeAttribute(this.$$p_d[key].attribute || key);
                } else {
                  this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
                }
              }
            }
            this.$$r = false;
          };
          this.$$c.$$.after_update.push(reflect_attributes);
          reflect_attributes();
          for (const type in this.$$l) {
            for (const listener of this.$$l[type]) {
              const unsub = this.$$c.$on(type, listener);
              this.$$l_u.set(listener, unsub);
            }
          }
          this.$$l = {};
        }
      });
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      var _a;
      if (this.$$r)
        return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      (_a = this.$$c) == null ? void 0 : _a.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn && this.$$c) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  var _a;
  const type = (_a = props_definition[prop]) == null ? void 0 : _a.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/store/index.js
var subscriber_queue = [];
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set, update2) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  if (!stores_array.every(Boolean)) {
    throw new Error("derived() expects stores as input, got a falsy value");
  }
  const auto = fn.length < 2;
  return readable(initial_value, (set, update2) => {
    let started = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set, update2);
      if (auto) {
        set(result);
      } else {
        cleanup = is_function(result) ? result : noop;
      }
    };
    const unsubscribers = stores_array.map(
      (store, i) => subscribe(
        store,
        (value) => {
          values[i] = value;
          pending &= ~(1 << i);
          if (started) {
            sync();
          }
        },
        () => {
          pending |= 1 << i;
        }
      )
    );
    started = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
      started = false;
    };
  });
}

// src/services/core/ServiceError.ts
var ServiceError = class extends Error {
  constructor(serviceId, message, details) {
    super(message);
    this.name = "ServiceError";
    this.serviceId = serviceId;
    this.details = details;
    Object.setPrototypeOf(this, ServiceError.prototype);
    if ((details == null ? void 0 : details.cause) instanceof Error) {
      this.cause = details.cause;
    }
  }
  /**
   * Create ServiceError from unknown error
   * @param serviceId Service identifier
   * @param error Original error
   * @param additionalDetails Additional error details
   */
  static from(serviceId, error, additionalDetails) {
    if (error instanceof ServiceError) {
      return error;
    }
    const details = __spreadProps(__spreadValues({}, additionalDetails), {
      cause: error instanceof Error ? error : void 0
    });
    const message = error instanceof Error ? error.message : String(error);
    return new ServiceError(serviceId, message, details);
  }
  /**
   * Get error details
   * @returns Structured error details
   */
  getDetails() {
    return {
      message: this.message,
      serviceId: this.serviceId,
      details: this.details,
      stack: this.stack,
      cause: this.cause
    };
  }
};

// src/stores/StoreUtils.ts
function createEnhancedStore(initialValue) {
  let currentValue = initialValue;
  const subscribers = [];
  return {
    subscribe(run2, invalidate) {
      subscribers.push(run2);
      run2(currentValue);
      return () => {
        const index = subscribers.indexOf(run2);
        if (index > -1) {
          subscribers.splice(index, 1);
        }
      };
    },
    set(value) {
      currentValue = value;
      subscribers.forEach((sub) => sub(currentValue));
    },
    update(updater) {
      this.set(updater(currentValue));
    },
    initialize(initialData) {
      currentValue = __spreadValues(__spreadValues({}, currentValue), initialData);
      this.set(currentValue);
    },
    reset() {
      currentValue = initialValue;
      this.set(currentValue);
    },
    getSnapshot() {
      return currentValue;
    }
  };
}
function createPersistedStore(key, initialState2, validator) {
  const loadPersistedData = () => {
    try {
      const stored = localStorage.getItem(key);
      if (!stored)
        return null;
      const parsed = JSON.parse(stored);
      if (validator && !validator(parsed)) {
        console.error("\u{1F987} Invalid persisted state:", parsed);
        return null;
      }
      return parsed;
    } catch (error) {
      console.error("\u{1F987} Error loading persisted state:", error);
      return null;
    }
  };
  const store = createEnhancedStore(
    __spreadValues(__spreadValues({}, initialState2), loadPersistedData() || {})
  );
  store.subscribe((state) => {
    try {
      localStorage.setItem(key, JSON.stringify(state));
    } catch (error) {
      console.error("\u{1F987} Error persisting state:", error);
    }
  });
  return store;
}
function updateNestedState(store, key, value) {
  store.update((state) => __spreadProps(__spreadValues({}, state), {
    [key]: typeof value === "function" ? value(state[key]) : value
  }));
}

// src/stores/BaseStore.ts
var BaseStore = class {
  constructor(serviceId, serviceName, initialState2) {
    this.unsubscribers = [];
    // Service state management
    this._serviceState = "uninitialized" /* Uninitialized */;
    this._error = null;
    this.serviceId = serviceId;
    this.serviceName = serviceName;
    this.store = createEnhancedStore(initialState2);
  }
  // IService implementation
  isReady() {
    return this._serviceState === "ready" /* Ready */;
  }
  initialize() {
    return __async(this, null, function* () {
      try {
        this._serviceState = "initializing" /* Initializing */;
        this._serviceState = "ready" /* Ready */;
        this._error = null;
      } catch (error) {
        this._serviceState = "error" /* Error */;
        this._error = new ServiceError(
          this.serviceId,
          `Failed to initialize ${this.serviceName}`,
          error instanceof Error ? error : void 0
        );
        throw this._error;
      }
    });
  }
  destroy() {
    return __async(this, null, function* () {
      try {
        this._serviceState = "destroying" /* Destroying */;
        this.unsubscribers.forEach((unsub) => unsub());
        this.unsubscribers = [];
        this._serviceState = "destroyed" /* Destroyed */;
        this._error = null;
      } catch (error) {
        this._serviceState = "error" /* Error */;
        this._error = new ServiceError(
          this.serviceId,
          `Failed to destroy ${this.serviceName}`,
          error instanceof Error ? error : void 0
        );
        throw this._error;
      }
    });
  }
  getState() {
    return {
      state: this._serviceState,
      error: this._error
    };
  }
  // Store methods
  subscribe(run2, invalidate) {
    if (this._serviceState !== "ready" /* Ready */) {
      throw new ServiceError(
        this.serviceId,
        `Cannot subscribe to ${this.serviceName} - service is not ready`
      );
    }
    const unsub = this.store.subscribe(run2, invalidate);
    this.unsubscribers.push(unsub);
    return () => {
      const index = this.unsubscribers.indexOf(unsub);
      if (index > -1) {
        this.unsubscribers.splice(index, 1);
      }
      unsub();
    };
  }
  set(value) {
    if (this._serviceState !== "ready" /* Ready */) {
      throw new ServiceError(
        this.serviceId,
        `Cannot set state of ${this.serviceName} - service is not ready`
      );
    }
    this.store.set(value);
  }
  update(updater) {
    if (this._serviceState !== "ready" /* Ready */) {
      throw new ServiceError(
        this.serviceId,
        `Cannot update state of ${this.serviceName} - service is not ready`
      );
    }
    this.store.update(updater);
  }
  reset() {
    if (this._serviceState !== "ready" /* Ready */) {
      throw new ServiceError(
        this.serviceId,
        `Cannot reset state of ${this.serviceName} - service is not ready`
      );
    }
    this.store.reset();
  }
  getSnapshot() {
    return this.store.getSnapshot();
  }
  // Helper method for type-safe nested updates
  updateState(key, value) {
    if (this._serviceState !== "ready" /* Ready */) {
      throw new ServiceError(
        this.serviceId,
        `Cannot update state of ${this.serviceName} - service is not ready`
      );
    }
    this.store.update((state) => __spreadProps(__spreadValues({}, state), {
      [key]: value
    }));
  }
  // Helper method to set error state
  setError(error) {
    this._serviceState = "error" /* Error */;
    this._error = new ServiceError(
      this.serviceId,
      typeof error === "string" ? error : error.message,
      error instanceof Error ? error : void 0
    );
  }
  // Helper method to clear error state
  clearError() {
    this._error = null;
    if (this._serviceState === "error" /* Error */) {
      this._serviceState = "ready" /* Ready */;
    }
  }
};

// src/types/operations.types.ts
var OperationType = /* @__PURE__ */ ((OperationType2) => {
  OperationType2["Generation"] = "generation";
  OperationType2["FrontMatter"] = "frontMatter";
  OperationType2["Wikilink"] = "wikilink";
  OperationType2["Ontology"] = "ontology";
  OperationType2["KnowledgeBloom"] = "knowledgeBloom";
  return OperationType2;
})(OperationType || {});

// src/settings/Settings.ts
var DEFAULT_SETTINGS = {
  aiProvider: {
    selected: "openai" /* OpenAI */,
    apiKeys: {},
    selectedModels: {
      ["openai" /* OpenAI */]: "gpt-4o-mini"
    }
  },
  frontMatter: {
    customProperties: [],
    // Initialize as PropertyTag[]
    autoGenerate: false
  },
  tags: {
    customTags: []
  },
  localLMStudio: {
    enabled: false,
    port: 1234,
    modelName: ""
  },
  advanced: {
    maxTokens: 4096,
    temperature: 0.3,
    generateWikilinks: false,
    minWordCount: 5,
    maxLinksPerNote: 10,
    batchSize: 10,
    delayBetweenChunks: 1e3,
    // Default value
    maxRetries: 3,
    // Default value
    maxConcurrentProcessing: 3
    // Default value
  },
  ontology: {
    lastGenerated: ""
  },
  knowledgeBloom: {
    selectedModel: "string",
    outputFolder: "",
    overwriteExisting: false,
    defaultPrompt: "Generate a comprehensive note about {LINK}. Include key concepts, definitions, and relevant examples if applicable."
  }
};

// src/generators/BaseGenerator.ts
var BaseGenerator = class {
  constructor(aiAdapter, settingsService) {
    this.aiAdapter = aiAdapter;
    this.settingsService = settingsService;
  }
  /**
   * Generate content based on input and settings.
   * @param input The input data for generation
   * @returns Promise resolving to the generated content
   */
  generate(input) {
    return __async(this, null, function* () {
      try {
        if (!this.validateInput(input)) {
          throw new Error("Invalid input provided");
        }
        const prompt = this.preparePrompt(input);
        const model = yield this.getCurrentModel();
        const aiResponse = yield this.aiAdapter.generateResponse(prompt, model);
        if (!aiResponse.success || !aiResponse.data) {
          throw new Error(aiResponse.error || "Failed to generate content");
        }
        return this.formatOutput(aiResponse.data, input);
      } catch (error) {
        return this.handleError(error);
      }
    });
  }
  /**
   * Initialize the generator.
   * Derived classes can override this method if specific initialization is needed.
   */
  initialize() {
    return __async(this, null, function* () {
    });
  }
  /**
   * Destroy the generator.
   * Derived classes can override this method to clean up resources.
   */
  destroy() {
    return __async(this, null, function* () {
    });
  }
  /**
   * Get the current model for this generator.
   * @returns The model identifier string
   */
  getCurrentModel() {
    return __async(this, null, function* () {
      const settings = this.getSettings();
      const selectedModel = this.getSelectedModel(settings);
      if (!selectedModel) {
        throw new Error(`No model selected for ${this.constructor.name}`);
      }
      return selectedModel;
    });
  }
  /**
   * Get the selected model from settings.
   * Can be overridden by subclasses to use specific model settings.
   */
  getSelectedModel(settings) {
    var _a, _b;
    const provider = this.aiAdapter.getProviderType();
    return (_b = (_a = settings.aiProvider) == null ? void 0 : _a.selectedModels) == null ? void 0 : _b[provider];
  }
  /**
   * Get the current settings for this generator.
   */
  getSettings() {
    return this.settingsService.getSettings();
  }
  /**
   * Validate the input before generation.
   * @param input The input to validate
   */
  validateInput(input) {
    return input !== null && input !== void 0;
  }
  /**
   * Handle errors that occur during generation.
   * @param error The error that occurred
   */
  handleError(error) {
    const errorMessage = `${this.constructor.name} error: ${error.message}`;
    console.error(errorMessage);
    throw new Error(errorMessage);
  }
  /**
   * Utility method to clean and format text content
   */
  cleanContent(content) {
    return content.trim().replace(/\n{3,}/g, "\n\n");
  }
  /**
   * Utility method to validate JSON data
   */
  isValidJson(data) {
    try {
      JSON.parse(JSON.stringify(data));
      return true;
    } catch (e) {
      return false;
    }
  }
};

// src/generators/FrontMatterGenerator.ts
var FrontMatterGenerator = class extends BaseGenerator {
  constructor(aiAdapter, settingsService, jsonSchemaGenerator) {
    super(aiAdapter, settingsService);
    this.jsonSchemaGenerator = jsonSchemaGenerator;
  }
  /**
   * Generates front matter for the provided content
   * @param input The input containing content and optional properties
   * @returns Promise resolving to content with front matter
   */
  generate(input) {
    return __async(this, null, function* () {
      try {
        const settings = this.getSettings();
        const completeInput = __spreadProps(__spreadValues({}, input), {
          customProperties: input.customProperties || settings.frontMatter.customProperties,
          customTags: input.customTags || settings.tags.customTags.map((tag) => tag.name)
        });
        const prompt = this.preparePrompt(completeInput);
        const model = yield this.getCurrentModel();
        const aiResponse = yield this.aiAdapter.generateResponse(prompt, model);
        if (!aiResponse.success || !aiResponse.data) {
          return { content: input.content };
        }
        return this.formatOutput(aiResponse.data, completeInput);
      } catch (error) {
        console.error("FrontMatterGenerator: Error during generation:", error);
        return { content: input.content };
      }
    });
  }
  /**
   * Prepares the AI prompt with schema and context
   * @param input The input containing content and properties
   * @returns Formatted prompt string
   */
  preparePrompt(input) {
    var _a, _b;
    const schema = this.jsonSchemaGenerator.generateBaseSchema();
    const propertyPrompt = ((_a = input.customProperties) == null ? void 0 : _a.map(
      (prop) => `${prop.name} (${prop.type}): ${prop.description}`
    ).join("\n")) || "";
    const tagPrompt = ((_b = input.customTags) == null ? void 0 : _b.join(", ")) || "";
    return `
# MISSION
Act as an expert analyzer and creator of metadata, with a specialization in ontological organization for Obsidian Vaults. Generate ONLY front matter fields based on the provided schema and available properties/tags.

# GUIDELINES
- You must ONLY use the properties provided in the schema
- Front matter fields will NOT include the note content itself
- Prioritize using available tags, but remain flexible in choosing additional relevant tags
- Return ONLY the formatted JSON object with front matter fields
- Do NOT include the content field in your response

## Custom Properties
${propertyPrompt}

## Available Tags
${tagPrompt}

## Note Content for Reference (OMIT FROM OUTPUT)
${input.content}

## JSON Schema for Front Matter Fields:
${JSON.stringify(schema, null, 2)}

Generate ONLY the front matter fields as JSON. Do not include any other text or the note content.
`;
  }
  /**
   * Formats AI response into proper front matter structure
   * @param aiResponse The AI response data
   * @param originalInput The original input parameters
   * @returns Formatted output with front matter
   */
  formatOutput(aiResponse, originalInput) {
    const parsedResponse = this.parseAIResponse(aiResponse);
    if (!parsedResponse) {
      console.error("FrontMatterGenerator: Failed to parse AI response");
      return { content: originalInput.content };
    }
    if ("content" in parsedResponse) {
      delete parsedResponse.content;
    }
    const frontMatter = this.convertToFrontMatter(parsedResponse);
    const finalContent = this.mergeFrontMatter(originalInput.content, frontMatter);
    return { content: finalContent };
  }
  /**
   * Parses and validates AI response
   */
  parseAIResponse(data) {
    if (typeof data === "object" && data !== null) {
      return data;
    }
    try {
      const parsed = JSON.parse(data);
      if (typeof parsed === "object" && parsed !== null) {
        return parsed;
      }
    } catch (error) {
      console.error("FrontMatterGenerator: Error parsing AI response as JSON:", error);
    }
    return null;
  }
  /**
   * Converts parsed response to YAML front matter format
   */
  convertToFrontMatter(data) {
    return Object.entries(data).map(([key, value]) => {
      if (Array.isArray(value)) {
        return `${key}:
${value.map((item) => `  - ${item}`).join("\n")}`;
      } else if (typeof value === "object" && value !== null) {
        return `${key}: ${JSON.stringify(value)}`;
      } else {
        return `${key}: ${value}`;
      }
    }).join("\n");
  }
  /**
   * Merges front matter with original content
   */
  mergeFrontMatter(content, frontMatter) {
    const hasFrontMatter = content.trim().startsWith("---");
    if (!hasFrontMatter) {
      return `---
${frontMatter}
---

${content.trim()}`;
    }
    const parts = content.split("---");
    if (parts.length >= 3) {
      const existingFrontMatter = parts[1].trim();
      const contentParts = parts.slice(2).join("---").trim();
      return `---
${frontMatter}
---
${contentParts}`;
    }
    return `---
${frontMatter}
---

${content.trim()}`;
  }
  /**
   * Validates input parameters
   */
  validateInput(input) {
    return typeof input.content === "string" && input.content.trim().length > 0;
  }
  /**
   * Gets the current AI model
   */
  getCurrentModel() {
    return __async(this, null, function* () {
      var _a, _b;
      const settings = this.getSettings();
      const providerType = this.aiAdapter.getProviderType();
      const modelApiName = (_b = (_a = settings.aiProvider) == null ? void 0 : _a.selectedModels) == null ? void 0 : _b[providerType];
      if (!modelApiName) {
        throw new Error(`No model selected for provider: ${providerType}`);
      }
      return modelApiName;
    });
  }
};

// src/services/core/CoreService.ts
var CoreService = class {
  constructor(serviceId, serviceName) {
    this.serviceId = serviceId;
    this.serviceName = serviceName;
    this.state = "uninitialized" /* Uninitialized */;
    this.error = null;
    this.isUnloading = false;
  }
  /**
   * Initialize the service
   * Manages state transitions and error handling
   */
  initialize() {
    return __async(this, null, function* () {
      if (this.isUnloading) {
        throw new ServiceError(this.serviceName, "Cannot initialize while unloading");
      }
      try {
        this.state = "initializing" /* Initializing */;
        yield this.initializeInternal();
        this.state = "ready" /* Ready */;
        this.error = null;
      } catch (error) {
        this.handleError("Initialization failed", error);
        this.state = "error" /* Error */;
        throw error;
      }
    });
  }
  /**
   * Check if service is ready for use
   */
  isReady() {
    return this.state === "ready" /* Ready */ && !this.isUnloading;
  }
  /**
   * Clean up service resources
   */
  destroy() {
    return __async(this, null, function* () {
      if (this.isUnloading)
        return;
      try {
        this.isUnloading = true;
        this.state = "destroying" /* Destroying */;
        yield this.destroyInternal();
        this.state = "destroyed" /* Destroyed */;
      } catch (error) {
        this.handleError("Destroy failed", error);
        throw error;
      }
    });
  }
  /**
   * Get current service state
   */
  getState() {
    return { state: this.state, error: this.error };
  }
  /**
   * Standard error handling
   */
  handleError(message, error) {
    const serviceError = ServiceError.from(this.serviceName, error, {
      state: this.state,
      isUnloading: this.isUnloading
    });
    console.error(`${this.serviceName} error:`, serviceError.getDetails());
    this.error = serviceError;
  }
};

// src/generators/utils/WikilinkPatterns.ts
var WikilinkPatterns = {
  WIKILINK_REGEX: /\[\[([^\[\]]*(?:\[\[[^\[\]]*\]\][^\[\]]*)*)\]\]/g,
  SIMPLE_WIKILINK_REGEX: /\[\[([^\]]+)\]\]/g,
  MALFORMED_REGEX: /\[\[[^\]\[]*(?:\](?!\])|$)|(?:\[\[)+[^\]\[]*\]\]/g,
  CODE_BLOCK_REGEX: /`[^`]*`|```[\s\S]*?```/g,
  INLINE_CODE_REGEX: /`[^`]+`/g,
  SPECIAL_CHARS_REGEX: /[!@#$%^&*(),.?":{}|<>]/g
};
var WikilinkConfig = {
  MAX_LINK_LENGTH: 100,
  MAX_NESTING_DEPTH: 5,
  CONTEXT_WINDOW_SIZE: 100,
  ALLOWED_SPECIAL_CHARS: ["'", "-", "_", "&", "."]
};
function isAllowedSpecialChar(char) {
  return WikilinkConfig.ALLOWED_SPECIAL_CHARS.includes(char);
}
var WikilinkUtils = class {
  /**
   * Escapes special regex characters in a string
   */
  static escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  /**
   * Calculates the nesting depth of a wikilink
   */
  static calculateNestingDepth(text2) {
    let maxDepth = 0;
    let currentDepth = 0;
    for (let i = 0; i < text2.length - 1; i++) {
      if (text2[i] === "[" && text2[i + 1] === "[") {
        currentDepth++;
        maxDepth = Math.max(maxDepth, currentDepth);
        i++;
      } else if (text2[i] === "]" && text2[i + 1] === "]") {
        currentDepth--;
        i++;
      }
    }
    return maxDepth;
  }
};

// src/services/WikilinkTextProcessor.ts
var WikilinkTextProcessor = class extends CoreService {
  constructor() {
    super("wikilink-processor", "Wikilink Text Processor");
  }
  initializeInternal() {
    return __async(this, null, function* () {
    });
  }
  destroyInternal() {
    return __async(this, null, function* () {
    });
  }
  /**
   * Add wikilinks to the content based on suggested links
   */
  addWikilinks(content, suggestedLinks, existingWikilinks) {
    const codeBlocks = /* @__PURE__ */ new Map();
    let processedContent = this.protectCodeBlocks(content, codeBlocks);
    suggestedLinks.filter((link) => this.isValidWikilinkText(link)).sort((a, b) => b.length - a.length).forEach((phrase) => {
      const normalizedLink = this.normalizeWikilinkText(phrase);
      if (!existingWikilinks.has(normalizedLink.toLowerCase())) {
        const escapedPhrase = WikilinkUtils.escapeRegExp(phrase);
        const regex = new RegExp(
          `(?<!\\[\\[.*?)\\b${escapedPhrase}\\b(?![^\\[]*\\]\\])`,
          "gi"
        );
        processedContent = processedContent.replace(regex, (match, offset) => {
          if (this.shouldSkipWikilink(processedContent, offset, match.length, existingWikilinks)) {
            return match;
          }
          return `[[${normalizedLink}]]`;
        });
      }
    });
    const finalContent = this.restoreCodeBlocks(processedContent, codeBlocks);
    return finalContent;
  }
  /**
   * Clean nested wikilinks while preserving structure
   */
  cleanNestedWikilinks(content) {
    const processedLinks = /* @__PURE__ */ new Set();
    let result = content;
    const matches = Array.from(content.matchAll(WikilinkPatterns.WIKILINK_REGEX)).map((match) => ({
      full: match[0],
      inner: match[1],
      index: match.index,
      length: match[0].length,
      depth: WikilinkUtils.calculateNestingDepth(match[0])
    })).filter((match) => match.depth <= WikilinkConfig.MAX_NESTING_DEPTH).sort((a, b) => b.length - a.length);
    const processedPositions = /* @__PURE__ */ new Set();
    for (const match of matches) {
      if (processedPositions.has(match.index))
        continue;
      if (match.inner.includes("[[")) {
        const cleaned = this.removeNestedDuplicates(match.inner);
        if (this.isValidWikilinkText(cleaned) && !processedLinks.has(cleaned.toLowerCase())) {
          processedLinks.add(cleaned.toLowerCase());
          result = this.safeReplace(
            result,
            match.index,
            match.length,
            `[[${this.normalizeWikilinkText(cleaned)}]]`
          );
          processedPositions.add(match.index);
        }
      } else {
        processedLinks.add(match.inner.toLowerCase());
      }
    }
    return result;
  }
  /**
   * Normalize text for wikilink usage
   */
  normalizeWikilinkText(text2) {
    const original = text2.trim();
    let normalized = original.replace(/\s+/g, " ");
    normalized = normalized.replace(
      WikilinkPatterns.SPECIAL_CHARS_REGEX,
      (char) => isAllowedSpecialChar(char) ? char : " "
    ).trim();
    return normalized.toLowerCase() === original.toLowerCase() ? original : normalized;
  }
  /**
   * Protected and utility methods
   */
  protectCodeBlocks(content, codeBlocks) {
    let processed = content;
    let counter = 0;
    const replaceWithPlaceholder = (match, type) => {
      const placeholder = `__${type}_${counter}__`;
      codeBlocks.set(placeholder, match);
      counter++;
      return placeholder;
    };
    processed = processed.replace(
      WikilinkPatterns.CODE_BLOCK_REGEX,
      (match) => replaceWithPlaceholder(match, "CODE_BLOCK")
    );
    processed = processed.replace(
      WikilinkPatterns.INLINE_CODE_REGEX,
      (match) => replaceWithPlaceholder(match, "INLINE_CODE")
    );
    return processed;
  }
  restoreCodeBlocks(content, codeBlocks) {
    let processed = content;
    for (const [placeholder, original] of codeBlocks.entries()) {
      processed = processed.replace(placeholder, original);
    }
    return processed;
  }
  isWithinExistingWikilink(content, offset, length, existingWikilinks) {
    const contextStart = Math.max(0, offset - WikilinkConfig.CONTEXT_WINDOW_SIZE);
    const contextEnd = Math.min(
      content.length,
      offset + length + WikilinkConfig.CONTEXT_WINDOW_SIZE
    );
    const context = content.slice(contextStart, contextEnd);
    let bracketCount = 0;
    for (let i = 0; i < offset - contextStart; i++) {
      if (context[i] === "[" && context[i + 1] === "[") {
        bracketCount++;
        i++;
      } else if (context[i] === "]" && context[i + 1] === "]") {
        bracketCount--;
        i++;
      }
    }
    if (bracketCount > 0)
      return true;
    return Array.from(existingWikilinks).some((wikilink) => {
      const index = context.indexOf(wikilink);
      if (index === -1)
        return false;
      const absStart = contextStart + index;
      const absEnd = absStart + wikilink.length;
      return offset >= absStart && offset + length <= absEnd;
    });
  }
  isWithinProtectedContext(content, offset) {
    return [WikilinkPatterns.CODE_BLOCK_REGEX, WikilinkPatterns.INLINE_CODE_REGEX].some((regex) => {
      const matches = Array.from(content.matchAll(regex));
      return matches.some(
        (match) => match.index !== void 0 && offset >= match.index && offset < match.index + match[0].length
      );
    });
  }
  extractExistingWikilinks(content) {
    const matches = content.match(WikilinkPatterns.SIMPLE_WIKILINK_REGEX) || [];
    return matches.map((match) => match.slice(2, -2).toLowerCase());
  }
  removeNestedDuplicates(text2) {
    return text2.replace(/\[\[([^\[\]]+)\]\]/g, "$1");
  }
  safeReplace(text2, start, length, replacement) {
    return text2.slice(0, start) + replacement + text2.slice(start + length);
  }
  /**
   * Determine if the wikilink should be skipped based on context
   */
  shouldSkipWikilink(content, offset, length, existingWikilinks) {
    if (this.isWithinExistingWikilink(content, offset, length, existingWikilinks)) {
      return true;
    }
    if (this.isWithinProtectedContext(content, offset)) {
      return true;
    }
    const contextStart = Math.max(0, offset - 4);
    const contextEnd = Math.min(content.length, offset + length + 4);
    const context = content.slice(contextStart, contextEnd);
    if (context.match(/\[\[.*?\]\]/)) {
      return true;
    }
    return false;
  }
  /**
   * Validate wikilink text
   */
  isValidWikilinkText(text2) {
    if (!text2 || typeof text2 !== "string")
      return false;
    const trimmed = text2.trim();
    if (trimmed.length === 0 || trimmed.length > WikilinkConfig.MAX_LINK_LENGTH) {
      return false;
    }
    const bracketCount = (trimmed.match(/[\[\]]/g) || []).length;
    if (bracketCount % 2 !== 0)
      return false;
    if (trimmed.match(WikilinkPatterns.MALFORMED_REGEX))
      return false;
    const validCharPattern = /^[a-zA-Z0-9\s\-_'&.]+$/;
    return validCharPattern.test(trimmed);
  }
};

// src/generators/WikilinkGenerator.ts
var WikilinkGenerator = class extends BaseGenerator {
  constructor(aiAdapter, settingsService) {
    super(aiAdapter, settingsService);
    this.textProcessor = new WikilinkTextProcessor();
  }
  /**
   * Initialize required services
   */
  initialize() {
    return __async(this, null, function* () {
      yield this.textProcessor.initialize();
    });
  }
  /**
   * Clean up resources
   */
  destroy() {
    return __async(this, null, function* () {
      this.textProcessor.destroy();
    });
  }
  /**
   * Generate wikilinks for the provided content
   */
  generate(input) {
    return __async(this, null, function* () {
      try {
        if (!this.validateInput(input)) {
          throw new Error("Invalid input for wikilink generation");
        }
        const prompt = this.preparePrompt(input);
        const model = yield this.getCurrentModel();
        const aiResponse = yield this.aiAdapter.generateResponse(prompt, model);
        let aiResponseValue;
        if (aiResponse && aiResponse.success && aiResponse.data && aiResponse.data.value) {
          aiResponseValue = aiResponse.data.value;
        } else {
          throw new Error("Invalid AI response format");
        }
        const output = this.formatOutput(aiResponseValue, input);
        return output;
      } catch (error) {
        console.error("WikilinkGenerator: Error during generation:", error);
        throw new ServiceError(
          "WikilinkGenerator",
          "Failed to generate wikilinks",
          error instanceof Error ? error : void 0
        );
      }
    });
  }
  /**
   * Prepare AI prompt with custom tags and context
   */
  preparePrompt(input) {
    const settings = this.getSettings();
    const customTags = settings.tags.customTags.map((tag) => tag.name).join(", ") || "";
    return `
# MISSION
Act as an expert in recommending wikilinks for potential future research notes.
Analyze the following content and suggest key phrases, proper nouns, people, places, events, and concepts that would make for a relevant and practical note.
Consider the existing pages in the vault and prioritize linking to them. Ignore all tags and front matter when generating.

# CONTENT
${input.content}

# EXISTING PAGES
${input.existingPages.join(", ")}

Provide your suggestions as a JSON array of strings, omitting all characters before or after, including backticks.
        `;
  }
  /**
   * Format AI response into wikilink output using text processor
   */
  formatOutput(aiResponse, originalInput) {
    const suggestedLinks = this.parseSuggestedLinks(aiResponse);
    const existingLinks = this.extractExistingWikilinks(originalInput.content);
    let processedContent = originalInput.content;
    processedContent = this.textProcessor.addWikilinks(
      processedContent,
      suggestedLinks,
      existingLinks
    );
    processedContent = this.textProcessor.cleanNestedWikilinks(processedContent);
    return { content: processedContent };
  }
  /**
   * Parse suggested links from AI response
   */
  parseSuggestedLinks(aiResponse) {
    if (aiResponse && Array.isArray(aiResponse.suggestions)) {
      return aiResponse.suggestions.filter((item) => typeof item === "string");
    }
    console.error("WikilinkGenerator: Unexpected AI response format:", aiResponse);
    return [];
  }
  /**
   * Validate input structure
   */
  validateInput(input) {
    return typeof input.content === "string" && input.content.trim().length > 0 && Array.isArray(input.existingPages) && input.existingPages.every((page) => typeof page === "string");
  }
  /**
   * Get current AI model based on settings
   */
  getCurrentModel() {
    return __async(this, null, function* () {
      var _a, _b;
      const settings = this.getSettings();
      const providerType = this.aiAdapter.getProviderType();
      const selectedModel = (_b = (_a = settings.aiProvider) == null ? void 0 : _a.selectedModels) == null ? void 0 : _b[providerType];
      if (!selectedModel) {
        throw new ServiceError(
          "WikilinkGenerator",
          `No model selected for provider type: ${providerType}`
        );
      }
      return selectedModel;
    });
  }
  /**
   * Extract existing wikilinks from content
   */
  extractExistingWikilinks(content) {
    const regex = /\[\[([^\]]+)\]\]/g;
    const existingLinks = /* @__PURE__ */ new Set();
    let match;
    while ((match = regex.exec(content)) !== null) {
      const link = match[1].split("|")[0].trim().toLowerCase();
      existingLinks.add(link);
    }
    return existingLinks;
  }
};

// src/generators/OntologyGenerator.ts
var OntologyGenerator = class extends BaseGenerator {
  constructor(aiAdapter, settingsService) {
    super(aiAdapter, settingsService);
  }
  /**
   * Main method to generate ontology.
   * @param input - Input parameters for ontology generation.
   * @returns Promise resolving to the generated ontology.
   */
  generate(input) {
    return __async(this, null, function* () {
      if (!this.validateInput(input)) {
        throw new Error("Invalid input for ontology generation");
      }
      try {
        const prompt = this.preparePrompt(input);
        const aiResponse = yield this.aiAdapter.generateResponse(prompt, input.modelApiName);
        return this.formatOutput(aiResponse.data);
      } catch (error) {
        this.handleError(error);
        throw error;
      }
    });
  }
  /**
   * Prepares the AI prompt based on the input.
   * @param input - Input parameters for ontology generation.
   * @returns Formatted prompt string.
   */
  preparePrompt(input) {
    const fileNames = input.files.map((file) => file.basename).join(", ");
    const folderNames = input.folders.map((folder) => folder.name).join(", ");
    const tags = input.tags.join(", ");
    return `
# MISSION
Act as an expert in Ontological Science, specializing in taking unstructured information from an Obsidian vault, and creating tags to create a means of connecting the information.
Analyze the following information about a knowledge base and synthesize an ontology.
Based on the overall structure and content, suggest a set of tags that would create a cohesive and useful ontology for this knowledge base.

**Files:**
${fileNames}

**Folders:** 
${folderNames}

**Existing Tags:** 
${tags}

${input.userContext ? `**Additional Context:** ${input.userContext}` : ""}

For each suggested tag in the ontology, provide:
{
    "Name": {
        "description": "a brief but robust instruction on what this tag represents, and when it should be applied",
    }
}

Consider the following when creating the ontology:
1. Identify overarching themes and concepts present in the knowledge base.
2. Suggest tags that would help categorize and connect information across different files and folders.
3. Build upon existing tags, either by refining them or suggesting complementary tags.
4. Aim for a balance between specificity and generality in the suggested tags.
5. Consider the hierarchical structure implied by the folder organization.
6. Omit all spaces from tags names (e.g. AlbertEinstein instead of Albert Einstein)

Provide your response as a JSON object where the keys are the tag names and the values are objects containing the description.
Suggest enough tags to form a comprehensive ontology for this knowledge base.
        `;
  }
  /**
   * Formats the AI response into the OntologyResult structure.
   * @param aiResponse - Raw AI response data.
   * @returns OntologyResult containing suggested tags.
   */
  formatOutput(aiResponse) {
    let parsedResponse;
    if (typeof aiResponse === "string") {
      try {
        const fixedJson = this.fixIncompleteJson(aiResponse);
        parsedResponse = JSON.parse(fixedJson);
      } catch (error) {
        console.error("Failed to parse AI response as JSON:", error);
        throw new Error("Invalid AI response: unable to parse as JSON");
      }
    } else if (typeof aiResponse === "object" && aiResponse !== null) {
      parsedResponse = aiResponse;
    } else {
      console.error("Unexpected AI response format:", aiResponse);
      throw new Error("Invalid AI response format: expected an object or valid JSON string");
    }
    if (typeof parsedResponse !== "object" || parsedResponse === null) {
      throw new Error("Invalid AI response format: expected an object after parsing");
    }
    const suggestedTags = Object.entries(parsedResponse).map(([name, value]) => {
      if (typeof value === "object" && value !== null && "description" in value) {
        return {
          name: String(name).trim(),
          description: String(value.description).trim(),
          type: value.type || "string",
          // Default to 'string' if type not provided
          required: value.required !== void 0 ? Boolean(value.required) : false,
          // Default to false
          multipleValues: value.multipleValues !== void 0 ? Boolean(value.multipleValues) : false
          // Default to false
        };
      } else {
        console.warn(`Unexpected format for tag ${name}:`, value);
        return null;
      }
    }).filter(
      (tag) => tag !== null && typeof tag.name === "string" && tag.name.length > 0 && typeof tag.description === "string" && tag.description.length > 0 && typeof tag.type === "string" && typeof tag.required === "boolean" && typeof tag.multipleValues === "boolean"
    );
    if (suggestedTags.length === 0) {
      throw new Error("No valid tags found in AI response");
    }
    return { suggestedTags };
  }
  /**
   * Attempts to fix incomplete JSON strings.
   * @param json - Raw JSON string.
   * @returns Fixed JSON string.
   */
  fixIncompleteJson(json) {
    let fixedJson = json.trim();
    if (!fixedJson.endsWith("}")) {
      fixedJson += "}}";
    }
    fixedJson = fixedJson.replace(/,\s*}$/, "}");
    return fixedJson;
  }
  /**
   * Validates the input parameters for ontology generation.
   * @param input - Input parameters.
   * @returns Boolean indicating validity.
   */
  validateInput(input) {
    return Array.isArray(input.files) && Array.isArray(input.folders) && Array.isArray(input.tags) && typeof input.provider === "string" && typeof input.modelApiName === "string" && typeof input.userContext === "string";
  }
  /**
   * Handles errors during ontology generation.
   * @param error - The error encountered.
   */
  handleError(error) {
    console.error(`Ontology generation error: ${error.message}`, error);
    throw new Error(`Ontology generation failed: ${error.message}`);
  }
};

// src/generators/JsonSchemaGenerator.ts
var JsonSchemaGenerator = class extends BaseGenerator {
  constructor(aiAdapter, settingsService) {
    super(aiAdapter, settingsService);
    this.settingsInitialized = false;
    this.cachedSchema = null;
  }
  /**
   * Generates a base JSON schema based on settings.
   * Handles lazy initialization of settings to avoid circular dependencies.
   */
  generateBaseSchema() {
    return __async(this, null, function* () {
      var _a, _b;
      const schema = {
        type: "object",
        properties: {},
        required: []
      };
      try {
        if (!this.settingsInitialized) {
          this.settingsInitialized = true;
          const settings = this.settingsService.getSettings();
          if ((_a = settings.frontMatter) == null ? void 0 : _a.customProperties) {
            settings.frontMatter.customProperties.forEach((property) => {
              schema.properties[property.name] = {
                type: this.getJsonSchemaType(property.type),
                description: `Create ${property.description}`
              };
              if (property.required) {
                schema.required.push(property.name);
              }
            });
          }
          if ((_b = settings.tags) == null ? void 0 : _b.customTags) {
            schema.properties.tags = {
              type: "array",
              items: {
                type: "string",
                enum: settings.tags.customTags.map((tag) => tag.name)
              },
              description: "Select appropriate tags from the provided list"
            };
          }
        }
      } catch (error) {
        console.warn("JsonSchemaGenerator: Settings not yet available, using basic schema");
      }
      schema.additionalProperties = false;
      return schema;
    });
  }
  /**
   * Determines the JSON schema type based on the provided property type.
   * @param propertyType The type of the property (e.g., 'number', 'boolean', 'array')
   * @returns The corresponding JSON schema type as a string
   */
  getJsonSchemaType(propertyType) {
    switch (propertyType) {
      case "number":
        return "number";
      case "boolean":
        return "boolean";
      case "array":
        return "array";
      default:
        return "string";
    }
  }
  /**
   * Resets the cached schema and settings initialization flag.
   * Useful for scenarios where settings have changed and the schema needs to be regenerated.
   */
  resetCache() {
    this.cachedSchema = null;
    this.settingsInitialized = false;
  }
  /**
   * Overrides the preparePrompt method.
   * Not used in JsonSchemaGenerator, returns an empty string.
   */
  preparePrompt(_input) {
    return "";
  }
  /**
   * Overrides the formatOutput method.
   * Not used in JsonSchemaGenerator, returns an empty object.
   */
  formatOutput(_aiResponse, _originalInput) {
    return {};
  }
};

// src/generators/KnowledgeBloomGenerator.ts
var import_obsidian = require("obsidian");
var KnowledgeBloomGenerator = class extends BaseGenerator {
  constructor(aiAdapter, settingsService, app, frontMatterGenerator, wikilinkProcessor) {
    super(aiAdapter, settingsService);
    this.app = app;
    this.currentInput = null;
    this.frontMatterGenerator = frontMatterGenerator;
    this.wikilinkProcessor = wikilinkProcessor;
  }
  /**
   * Generate new notes from wikilinks in the source document
   * @param input The input parameters for generation
   * @returns Promise resolving to generated notes
   */
  generate(input) {
    return __async(this, null, function* () {
      this.currentInput = input;
      try {
        if (!this.validateInput(input)) {
          throw new Error("Invalid input for Knowledge Bloom generation");
        }
        const wikilinks = yield this.extractWikilinks(input.sourceFile);
        if (wikilinks.length === 0) {
          throw new Error("No wikilinks found in the source file.");
        }
        const folderPath = this.getFolderPath(input.sourceFile);
        const output = { generatedNotes: [] };
        const generationPromises = wikilinks.map(
          (link) => this.processWikilink(link, folderPath, input, output)
        );
        yield Promise.allSettled(generationPromises);
        return output;
      } catch (error) {
        return this.handleError(error);
      } finally {
        this.currentInput = null;
      }
    });
  }
  /**
   * Extract and generate wikilinks from a file
   */
  extractWikilinks(file) {
    return __async(this, null, function* () {
      try {
        const content = yield this.app.vault.read(file);
        const existingWikilinks = /* @__PURE__ */ new Set();
        const suggestedLinks = yield this.generateSuggestedLinks(content);
        const processedContent = this.wikilinkProcessor.addWikilinks(
          content,
          suggestedLinks,
          existingWikilinks
        );
        const links = this.wikilinkProcessor.extractExistingWikilinks(processedContent);
        yield this.app.vault.modify(file, processedContent);
        return Array.from(new Set(links));
      } catch (error) {
        console.error("\u274C Error extracting wikilinks:", error);
        throw new Error(`Failed to extract wikilinks: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    });
  }
  /**
   * Generate suggested links using AI
   */
  generateSuggestedLinks(content) {
    return __async(this, null, function* () {
      try {
        const prompt = `
Analyze the following content and identify key phrases, proper nouns, concepts, and terms that would make good wiki links. 
Focus on important concepts, technical terms, proper nouns, and significant phrases.
Return them as a simple array of strings.

Content:
${content}

Return ONLY the array of strings, nothing else.
`;
        const model = yield this.getCurrentModel();
        const response = yield this.aiAdapter.generateResponse(prompt, model);
        if (!response.success || !response.data) {
          throw new Error("Failed to generate suggested links");
        }
        let suggestions = [];
        if (Array.isArray(response.data)) {
          suggestions = response.data.filter((item) => typeof item === "string");
        } else if (typeof response.data === "object" && response.data !== null) {
          suggestions = Object.values(response.data).filter((item) => typeof item === "string");
        }
        return suggestions;
      } catch (error) {
        console.error("\u274C Error generating suggested links:", error);
        return [];
      }
    });
  }
  /**
   * Process a single wikilink to generate a new note
   */
  processWikilink(link, folderPath, input, output) {
    return __async(this, null, function* () {
      try {
        if (this.doesNoteExist(link, folderPath)) {
          return;
        }
        const markdownContent = yield this.generateMarkdownContent(link, input);
        const finalContent = yield this.addFrontMatter(markdownContent);
        const newFilePath = `${folderPath}/${link}.md`;
        yield this.app.vault.create(newFilePath, finalContent);
        output.generatedNotes.push({ title: link, content: finalContent });
      } catch (error) {
        console.error(`\u274C Error processing wikilink "${link}":`, error);
        new import_obsidian.Notice(`Failed to generate note for "${link}": ${error.message}`);
      }
    });
  }
  /**
   * Generate markdown content for a single wikilink
   */
  generateMarkdownContent(link, input) {
    return __async(this, null, function* () {
      const prompt = this.preparePrompt(__spreadProps(__spreadValues({}, input), {
        currentWikilink: link,
        currentNoteTitle: input.sourceFile.basename
      }));
      const model = yield this.getCurrentModel();
      const options = { rawResponse: true };
      const response = yield this.aiAdapter.generateResponse(prompt, model, options);
      if (!response.success || !response.data) {
        throw new Error(`Failed to generate content for "${link}": ${response.error || "Unknown error"}`);
      }
      let content = response.data;
      if (typeof content === "object" && content !== null) {
        const contentObj = content;
        if ("content" in contentObj && typeof contentObj.content === "string") {
          content = contentObj.content;
        } else if ("response" in contentObj && typeof contentObj.response === "string") {
          content = contentObj.response;
        } else {
          content = JSON.stringify(content);
        }
      }
      const contentString = String(content).trim();
      return contentString.replace(/^---\n[\s\S]*?\n---\n*/g, "");
    });
  }
  /**
   * Add front matter to the generated content
   */
  addFrontMatter(content) {
    return __async(this, null, function* () {
      const frontMatterInput = {
        content,
        customProperties: this.extractCustomProperties(content),
        customTags: this.extractCustomTags(content)
      };
      const frontMatterResult = yield this.frontMatterGenerator.generate(frontMatterInput);
      return frontMatterResult.content;
    });
  }
  /**
   * Extract custom properties from content
   */
  extractCustomProperties(content) {
    try {
      return this.settingsService.getSettings().frontMatter.customProperties;
    } catch (error) {
      console.error("\u274C Error extracting custom properties:", error);
      return [];
    }
  }
  /**
   * Extract custom tags from content
   */
  extractCustomTags(content) {
    try {
      return this.settingsService.getSettings().tags.customTags.map((tag) => tag.name);
    } catch (error) {
      console.error("\u274C Error extracting custom tags:", error);
      return [];
    }
  }
  /**
   * Prepare the AI prompt for content generation
   */
  preparePrompt(input) {
    if (!input.currentWikilink || !input.currentNoteTitle) {
      throw new Error("Missing required wikilink or note title");
    }
    return `
# MISSION
Act as an expert Research Assistant that specializes in writing structured notes that are accessible and practical based on a provided topic.

# GUIDELINES
- Write the note in Markdown format.
- Do NOT include any JSON objects or front matter.
- Ensure the content is well-structured and comprehensive.
- Include relevant wikilinks to other concepts where appropriate.
- Omit any words before or after the Markdown content.

# TOPIC
Write a detailed note about "${input.currentWikilink}" in relation to "${input.currentNoteTitle}".

${input.userPrompt ? `## Additional Context:
${input.userPrompt}` : ""}
`;
  }
  /**
   * Check if a note exists at the given path
   */
  doesNoteExist(title, folderPath) {
    const filePath = `${folderPath}/${title}.md`;
    const file = this.app.vault.getAbstractFileByPath(filePath);
    return file instanceof import_obsidian.TFile;
  }
  /**
   * Get the folder path for the new note
   */
  getFolderPath(file) {
    const pathSegments = file.path.split("/");
    pathSegments.pop();
    return pathSegments.join("/");
  }
  /**
   * Validate the input parameters
   */
  validateInput(input) {
    const isValid = (input == null ? void 0 : input.sourceFile) instanceof import_obsidian.TFile;
    return isValid;
  }
  /**
   * Get the current AI model
   */
  getCurrentModel() {
    return __async(this, null, function* () {
      var _a;
      const settings = this.getSettings();
      const selectedModel = (_a = settings.knowledgeBloom) == null ? void 0 : _a.selectedModel;
      if (!selectedModel) {
        throw new Error("No model selected for Knowledge Bloom.");
      }
      return selectedModel;
    });
  }
  /**
   * Handle generation errors
   */
  handleError(error) {
    console.error(`\u274C KnowledgeBloomGenerator: Knowledge Bloom generation error: ${error.message}`, error);
    new import_obsidian.Notice(`Knowledge Bloom generation failed: ${error.message}`);
    throw error;
  }
  /**
   * Format output (not used in this implementation)
   */
  formatOutput(_aiResponse, _originalInput) {
    throw new Error("Method not implemented - using custom generate method");
  }
};

// src/stores/AIStore.ts
function createAIStore(initialState2 = {
  isInitialized: false,
  isConnected: false,
  currentModel: "",
  isProcessing: false,
  provider: "openai" /* OpenAI */,
  // Use enum member instead of string
  availableModels: [],
  performanceMetrics: {
    // Initialize all required properties
    responseTime: {
      average: 0,
      min: Infinity,
      max: 0,
      samples: 0
    },
    successRate: {
      total: 0,
      successful: 0,
      rate: 0
    },
    errorRate: {
      total: 0,
      errors: 0,
      rate: 0
    },
    operationMetrics: {
      generation: { count: 0, averageTime: 0, errorCount: 0 },
      frontMatter: { count: 0, averageTime: 0, errorCount: 0 },
      wikilink: { count: 0, averageTime: 0, errorCount: 0 },
      ontology: { count: 0, averageTime: 0, errorCount: 0 },
      knowledgeBloom: { count: 0, averageTime: 0, errorCount: 0 }
    }
  }
}) {
  const store = createEnhancedStore(initialState2);
  return __spreadProps(__spreadValues({}, store), {
    setProvider: (provider) => {
      updateNestedState(store, "provider", provider);
    },
    updateConnection: (isConnected) => {
      updateNestedState(store, "isConnected", isConnected);
    },
    setModel: (model) => {
      updateNestedState(store, "currentModel", model);
    },
    setInitialized: (isInitialized) => {
      updateNestedState(store, "isInitialized", isInitialized);
    },
    setProcessing: (isProcessing) => {
      updateNestedState(store, "isProcessing", isProcessing);
    },
    setAvailableModels: (models) => {
      updateNestedState(store, "availableModels", models);
    },
    setError: (error) => {
      updateNestedState(store, "error", error);
    },
    setLastResponse: (response) => {
      updateNestedState(store, "lastResponse", response);
    },
    updateMetrics: (metrics) => {
      store.update((state) => __spreadProps(__spreadValues({}, state), {
        performanceMetrics: __spreadProps(__spreadValues(__spreadValues({}, state.performanceMetrics), metrics), {
          // Ensure nested objects are also merged properly
          responseTime: __spreadValues(__spreadValues({}, state.performanceMetrics.responseTime), metrics.responseTime),
          successRate: __spreadValues(__spreadValues({}, state.performanceMetrics.successRate), metrics.successRate),
          errorRate: __spreadValues(__spreadValues({}, state.performanceMetrics.errorRate), metrics.errorRate),
          operationMetrics: __spreadValues(__spreadValues({}, state.performanceMetrics.operationMetrics), metrics.operationMetrics)
        })
      }));
    },
    updateOperation: (operation) => {
      if (operation && !operation.type) {
        throw new Error("Operation type is required when updating OperationStatus");
      }
      store.update((state) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
        return __spreadProps(__spreadValues({}, state), {
          currentOperation: operation ? __spreadProps(__spreadValues(__spreadValues({}, state.currentOperation), operation), {
            type: operation.type,
            startTime: (_c = (_b = operation.startTime) != null ? _b : (_a = state.currentOperation) == null ? void 0 : _a.startTime) != null ? _c : 0,
            endTime: (_f = (_e = operation.endTime) != null ? _e : (_d = state.currentOperation) == null ? void 0 : _d.endTime) != null ? _f : 0,
            duration: (_i = (_h = operation.duration) != null ? _h : (_g = state.currentOperation) == null ? void 0 : _g.duration) != null ? _i : 0,
            success: (_l = (_k = operation.success) != null ? _k : (_j = state.currentOperation) == null ? void 0 : _j.success) != null ? _l : false,
            error: (_o = (_n = operation.error) != null ? _n : (_m = state.currentOperation) == null ? void 0 : _m.error) != null ? _o : "",
            metadata: (_r = (_q = operation.metadata) != null ? _q : (_p = state.currentOperation) == null ? void 0 : _p.metadata) != null ? _r : {}
          }) : null
        });
      });
    }
  });
}
var aiStore = createAIStore();
var aiStatus = derived(aiStore, ($store) => ({
  isInitialized: $store.isInitialized,
  isConnected: $store.isConnected,
  currentModel: $store.currentModel,
  isProcessing: $store.isProcessing,
  provider: $store.provider,
  availableModels: $store.availableModels,
  hasError: !!$store.error
}));

// src/services/ai/GeneratorFactory.ts
var GeneratorType = /* @__PURE__ */ ((GeneratorType2) => {
  GeneratorType2["JsonSchema"] = "jsonSchema";
  GeneratorType2["FrontMatter"] = "frontMatter";
  GeneratorType2["Wikilink"] = "wikilink";
  GeneratorType2["Ontology"] = "ontology";
  GeneratorType2["KnowledgeBloom"] = "knowledgeBloom";
  return GeneratorType2;
})(GeneratorType || {});
var GeneratorFactory = class {
  constructor(app, settingsService, adapterRegistry, wikilinkProcessor) {
    this.app = app;
    this.settingsService = settingsService;
    this.adapterRegistry = adapterRegistry;
    // IService implementation
    this.serviceId = "generator-factory";
    this.serviceName = "Generator Factory Service";
    this.serviceState = "uninitialized" /* Uninitialized */;
    this.serviceError = null;
    this.isUnloading = false;
    // Generator factory properties
    this.instances = /* @__PURE__ */ new Map();
    this.states = /* @__PURE__ */ new Map();
    this.lastRun = /* @__PURE__ */ new Map();
    this.wikilinkProcessor = wikilinkProcessor;
    this.initializeStates();
  }
  /**
   * Initialize service and all essential generators
   */
  initialize() {
    return __async(this, null, function* () {
      if (this.isUnloading) {
        throw new ServiceError(this.serviceName, "Cannot initialize while unloading");
      }
      try {
        this.serviceState = "initializing" /* Initializing */;
        yield this.initializeEssentialGenerators();
        this.serviceState = "ready" /* Ready */;
      } catch (error) {
        this.serviceState = "error" /* Error */;
        this.serviceError = ServiceError.from(
          this.serviceName,
          error,
          { context: "Service initialization failed" }
        );
        console.error("GeneratorFactory: Initialization failed:", error);
        throw this.serviceError;
      }
    });
  }
  /**
   * Initialize essential generators needed for basic functionality
   */
  initializeEssentialGenerators() {
    return __async(this, null, function* () {
      try {
        const jsonSchemaGen = this.createJsonSchemaGenerator();
        this.instances.set("jsonSchema" /* JsonSchema */, jsonSchemaGen);
        yield jsonSchemaGen.initialize();
        this.updateState("jsonSchema" /* JsonSchema */, "ready" /* Ready */);
        const frontMatterGen = new FrontMatterGenerator(
          this.adapterRegistry.getCurrentAdapter(),
          this.settingsService,
          jsonSchemaGen
        );
        this.instances.set("frontMatter" /* FrontMatter */, frontMatterGen);
        yield frontMatterGen.initialize();
        this.updateState("frontMatter" /* FrontMatter */, "ready" /* Ready */);
      } catch (error) {
        throw new ServiceError(
          this.serviceName,
          "Failed to initialize essential generators",
          error instanceof Error ? error : void 0
        );
      }
    });
  }
  /**
   * Check if service is ready
   */
  isReady() {
    return this.serviceState === "ready" /* Ready */ && !this.isUnloading;
  }
  /**
   * Clean up service resources
   */
  destroy() {
    return __async(this, null, function* () {
      if (this.isUnloading)
        return;
      try {
        this.isUnloading = true;
        this.serviceState = "destroying" /* Destroying */;
        yield this.cleanup();
        this.serviceState = "destroyed" /* Destroyed */;
      } catch (error) {
        this.serviceState = "error" /* Error */;
        this.serviceError = ServiceError.from(
          this.serviceName,
          error,
          { context: "Service destroy failed" }
        );
        throw this.serviceError;
      }
    });
  }
  /**
   * Internal cleanup method
   */
  cleanup() {
    return __async(this, null, function* () {
      yield this.resetAll();
      this.instances.clear();
      this.states.clear();
      this.lastRun.clear();
    });
  }
  /**
   * Initialize generator states
   */
  initializeStates() {
    Object.values(GeneratorType).forEach((type) => {
      this.states.set(type, "not_initialized" /* NotInitialized */);
    });
  }
  getState() {
    return {
      state: this.serviceState,
      error: this.serviceError
    };
  }
  /**
   * Get a specific type of generator with proper typing
   */
  getTypedGenerator(type) {
    return __async(this, null, function* () {
      const generator = yield this.getGenerator(type);
      return generator;
    });
  }
  /**
   * Get generator for FrontMatter
   */
  getFrontMatterGenerator() {
    return __async(this, null, function* () {
      return this.getTypedGenerator("frontMatter" /* FrontMatter */);
    });
  }
  /**
   * Get generator for Wikilinks
   */
  getWikilinkGenerator() {
    return __async(this, null, function* () {
      return this.getTypedGenerator("wikilink" /* Wikilink */);
    });
  }
  /**
   * Get a generator by type with lifecycle management
   */
  getGenerator(type) {
    return __async(this, null, function* () {
      if (!this.isReady()) {
        throw new ServiceError(this.serviceName, "Service not ready");
      }
      try {
        this.updateState(type, "creating" /* Creating */);
        let generator = this.instances.get(type);
        if (generator) {
          return generator;
        }
        generator = yield this.createGenerator(type);
        this.instances.set(type, generator);
        this.lastRun.set(type, new Date());
        this.updateState(type, "ready" /* Ready */);
        return generator;
      } catch (error) {
        this.updateState(type, "error" /* Error */, error instanceof Error ? error.message : "Unknown error");
        console.error(`GeneratorFactory: Error creating generator of type ${type}:`, error);
        throw error;
      }
    });
  }
  /**
   * Create a generator of specific type
   */
  createGenerator(type) {
    return __async(this, null, function* () {
      switch (type) {
        case "frontMatter" /* FrontMatter */:
          return this.createFrontMatterGenerator();
        case "wikilink" /* Wikilink */:
          return this.createWikilinkGenerator();
        case "ontology" /* Ontology */:
          return this.createOntologyGenerator();
        case "knowledgeBloom" /* KnowledgeBloom */:
          return this.createKnowledgeBloomGenerator();
        case "jsonSchema" /* JsonSchema */:
          return this.createJsonSchemaGenerator();
        default:
          throw new Error(`Unknown GeneratorType: ${type}`);
      }
    });
  }
  /**
   * Create FrontMatter Generator
   */
  createFrontMatterGenerator() {
    return __async(this, null, function* () {
      const jsonSchemaGen = this.instances.get("jsonSchema" /* JsonSchema */);
      if (!jsonSchemaGen) {
        throw new ServiceError(
          this.serviceName,
          "JsonSchemaGenerator instance not found"
        );
      }
      const frontMatterGen = new FrontMatterGenerator(
        this.adapterRegistry.getCurrentAdapter(),
        this.settingsService,
        jsonSchemaGen
      );
      yield frontMatterGen.initialize();
      return frontMatterGen;
    });
  }
  /**
   * Create Wikilink Generator
   */
  createWikilinkGenerator() {
    return __async(this, null, function* () {
      const wikilinkGen = new WikilinkGenerator(
        this.adapterRegistry.getCurrentAdapter(),
        this.settingsService
      );
      yield wikilinkGen.initialize();
      return wikilinkGen;
    });
  }
  /**
   * Create Ontology Generator
   */
  createOntologyGenerator() {
    return __async(this, null, function* () {
      const ontologyGen = new OntologyGenerator(
        this.adapterRegistry.getCurrentAdapter(),
        this.settingsService
      );
      yield ontologyGen.initialize();
      return ontologyGen;
    });
  }
  /**
   * Create KnowledgeBloom Generator
   */
  createKnowledgeBloomGenerator() {
    return __async(this, null, function* () {
      const frontMatterGen = this.instances.get("frontMatter" /* FrontMatter */);
      if (!frontMatterGen) {
        throw new ServiceError(
          this.serviceName,
          "FrontMatterGenerator instance not found"
        );
      }
      const knowledgeBloomGen = new KnowledgeBloomGenerator(
        this.adapterRegistry.getCurrentAdapter(),
        this.settingsService,
        this.app,
        frontMatterGen,
        this.wikilinkProcessor
      );
      yield knowledgeBloomGen.initialize();
      return knowledgeBloomGen;
    });
  }
  /**
   * Create JsonSchema Generator
   */
  createJsonSchemaGenerator() {
    return new JsonSchemaGenerator(
      this.adapterRegistry.getCurrentAdapter(),
      this.settingsService
    );
  }
  /**
   * Update generator state and notify store
   */
  updateState(type, state, error) {
    if (this.isUnloading)
      return;
    this.states.set(type, state);
    this.updateStore(type, error);
  }
  /**
   * Update AI store with current generator status
   */
  updateStore(updatedType, error) {
    if (this.isUnloading)
      return;
    const generatorStatuses = {};
    Object.values(GeneratorType).forEach((type) => {
      const state = this.states.get(type) || "not_initialized" /* NotInitialized */;
      generatorStatuses[type] = {
        isInitialized: state === "ready" /* Ready */,
        lastRun: this.lastRun.get(type) || null,
        statusMessage: state === "ready" /* Ready */ ? "Ready" : state === "creating" /* Creating */ ? "Creating..." : state === "error" /* Error */ ? error || "Error" : "Not Initialized"
      };
    });
    aiStore.update((state) => __spreadProps(__spreadValues({}, state), {
      generators: generatorStatuses
    }));
  }
  /**
   * Reset a specific generator
   */
  resetGenerator(type) {
    return __async(this, null, function* () {
      if (this.isUnloading)
        return;
      const instance20 = this.instances.get(type);
      if (instance20) {
        if ("reset" in instance20 && typeof instance20.reset === "function") {
          yield instance20.reset();
        }
        this.instances.delete(type);
        this.lastRun.delete(type);
        this.states.set(type, "not_initialized" /* NotInitialized */);
        this.updateStore(type);
      }
    });
  }
  /**
   * Reset all generators
   */
  resetAll() {
    return __async(this, null, function* () {
      if (this.isUnloading)
        return;
      for (const type of this.instances.keys()) {
        yield this.resetGenerator(type);
      }
    });
  }
  /**
   * Get generator state
   */
  getGeneratorState(type) {
    return this.states.get(type) || "not_initialized" /* NotInitialized */;
  }
  /**
   * Check if a specific generator is ready
   */
  isGeneratorReady(type) {
    return this.states.get(type) === "ready" /* Ready */;
  }
  /**
   * Get service state information
   */
  getServiceState() {
    return {
      state: this.serviceState,
      error: this.serviceError
    };
  }
};

// src/types/store.types.ts
var DEFAULT_PLUGIN_STATE = {
  plugin: null,
  settings: DEFAULT_SETTINGS,
  processing: {
    isProcessing: false,
    currentFile: null,
    queue: [],
    progress: 0,
    state: "idle" /* IDLE */,
    filesQueued: 0,
    filesProcessed: 0,
    filesRemaining: 0,
    errors: [],
    error: null,
    startTime: null,
    estimatedTimeRemaining: null
  },
  ai: {
    isInitialized: false,
    isConnected: false,
    currentModel: "",
    isProcessing: false,
    provider: "openai" /* OpenAI */,
    availableModels: [],
    generators: Object.values(GeneratorType).reduce(
      (acc, type) => __spreadProps(__spreadValues({}, acc), {
        [type]: {
          isInitialized: false,
          lastRun: null,
          statusMessage: "Not Initialized"
        }
      }),
      {}
    ),
    error: void 0,
    lastResponse: void 0,
    lastError: void 0,
    operationMetrics: Object.values(OperationType).reduce(
      (acc, type) => __spreadProps(__spreadValues({}, acc), {
        [type]: {
          totalOperations: 0,
          successfulOperations: 0,
          failedOperations: 0,
          averageDuration: 0,
          lastOperation: void 0
        }
      }),
      {}
    ),
    performanceMetrics: {
      responseTime: {
        average: 0,
        min: Infinity,
        max: 0,
        samples: 0
      },
      successRate: {
        total: 0,
        successful: 0,
        rate: 0
      },
      errorRate: {
        total: 0,
        errors: 0,
        rate: 0
      },
      operationMetrics: Object.values(OperationType).reduce(
        (acc, type) => __spreadProps(__spreadValues({}, acc), {
          [type]: {
            count: 0,
            averageTime: 0,
            errorCount: 0
          }
        }),
        {}
      )
    },
    currentOperation: null,
    queueLength: 0,
    lastOperation: void 0
  },
  ui: {
    darkMode: false,
    activeAccordion: null,
    notifications: [],
    lastInteraction: Date.now(),
    modalStack: []
  },
  files: {
    processedFiles: [],
    lastProcessed: void 0,
    stats: {
      totalProcessed: 0,
      successCount: 0,
      errorCount: 0,
      averageProcessingTime: 0
    },
    activeFilters: [],
    sortOrder: "asc",
    searchQuery: ""
  }
};

// src/stores/PluginStore.ts
var _PluginStore = class extends BaseStore {
  constructor() {
    if (_PluginStore.instance) {
      return _PluginStore.instance;
    }
    super(
      "plugin-store",
      "Plugin Store Service",
      JSON.parse(JSON.stringify(DEFAULT_PLUGIN_STATE))
    );
    _PluginStore.instance = this;
  }
  initialize() {
    return __async(this, null, function* () {
      try {
        yield __superGet(_PluginStore.prototype, this, "initialize").call(this);
        const savedState = this.loadSavedState();
        if (savedState) {
          this.set(this.resetVolatileState(savedState));
        }
      } catch (error) {
        this.handleError("Failed to initialize Plugin Store", error);
        throw error;
      }
    });
  }
  updateSection(section, update2) {
    try {
      if (!this.isReady()) {
        throw new Error("Plugin Store is not ready");
      }
      this.update((state) => {
        const newState = __spreadProps(__spreadValues({}, state), {
          [section]: typeof update2 === "function" ? update2(state[section]) : __spreadValues(__spreadValues({}, state[section]), update2)
        });
        this.saveState(newState);
        return newState;
      });
    } catch (error) {
      this.handleError(`Failed to update section: ${String(section)}`, error);
    }
  }
  // Private helpers
  loadSavedState() {
    try {
      const saved = localStorage.getItem(_PluginStore.STORAGE_KEY);
      return saved ? JSON.parse(saved) : null;
    } catch (error) {
      console.warn("\u{1F987} Failed to load saved state:", error);
      return null;
    }
  }
  saveState(state) {
    try {
      const persistedState = this.resetVolatileState(state);
      localStorage.setItem(_PluginStore.STORAGE_KEY, JSON.stringify(persistedState));
    } catch (error) {
      console.warn("\u{1F987} Failed to save state:", error);
    }
  }
  resetVolatileState(state) {
    return __spreadProps(__spreadValues(__spreadValues({}, DEFAULT_PLUGIN_STATE), state), {
      // Merge saved state
      // Reset volatile state
      processing: __spreadProps(__spreadValues(__spreadValues({}, DEFAULT_PLUGIN_STATE.processing), state.processing), {
        isProcessing: false,
        currentFile: null,
        progress: 0
      }),
      ai: __spreadProps(__spreadValues(__spreadValues({}, DEFAULT_PLUGIN_STATE.ai), state.ai), {
        isProcessing: false,
        currentOperation: null
      }),
      ui: __spreadProps(__spreadValues(__spreadValues({}, DEFAULT_PLUGIN_STATE.ui), state.ui), {
        notifications: []
      }),
      files: __spreadValues(__spreadValues({}, DEFAULT_PLUGIN_STATE.files), state.files)
    });
  }
  handleError(message, error) {
    console.error(`\u{1F987} ${message}:`, error);
    this.setError(error instanceof Error ? error : new Error(message));
  }
};
var PluginStore = _PluginStore;
PluginStore.STORAGE_KEY = "graphweaver-plugin-state";
PluginStore.instance = null;
function createPluginStore() {
  return new PluginStore();
}
var pluginStore = createPluginStore();
var settingsState = derived(pluginStore, ($store) => $store.settings);
var processingState = derived(pluginStore, ($store) => $store.processing);
var aiState = derived(pluginStore, ($store) => $store.ai);
var uiState = derived(pluginStore, ($store) => $store.ui);
var filesState = derived(pluginStore, ($store) => $store.files);
var pluginStatus = derived(pluginStore, ($store) => ({
  isInitialized: $store.ai.isInitialized,
  isProcessing: $store.processing.isProcessing,
  hasErrors: $store.processing.errors.length > 0 || !!$store.ai.error,
  activeSection: $store.ui.activeAccordion,
  serviceState: pluginStore.getState().state
}));

// src/stores/SettingStore.ts
function createSettingsStore(settingsService) {
  const store = createPersistedStore(
    "graphweaver-settings",
    DEFAULT_SETTINGS,
    validateSettings
  );
  return __spreadProps(__spreadValues({}, store), {
    /**
     * Initialize the store with persisted settings
     * @param persistedSettings Partial settings data
     */
    initialize: (persistedSettings) => {
      store.update((settings) => __spreadValues(__spreadValues(__spreadValues({}, DEFAULT_SETTINGS), settings), persistedSettings));
    },
    /**
     * Save new settings and persist them
     * @param newSettings Complete settings data
     */
    save: (newSettings) => __async(this, null, function* () {
      if (!validateSettings(newSettings)) {
        throw new Error("Invalid settings configuration");
      }
      yield settingsService.updateSettings(newSettings);
      store.set(newSettings);
    }),
    /**
     * Update a specific setting
     * @param key Setting key
     * @param value New value for the setting
     */
    updateSetting: (key, value) => {
      updateNestedState(store, key, value);
    },
    /**
     * Validate settings structure and values
     * @param settings Partial settings data
     * @returns Boolean indicating validity
     */
    validateSettings: (settings) => {
      return validateSettings(settings);
    },
    /**
     * Reset settings to default values
     */
    reset: () => {
      store.set(DEFAULT_SETTINGS);
      void settingsService.updateSettings(DEFAULT_SETTINGS);
    },
    /**
     * Get a snapshot of the current settings
     * @returns Current settings data
     */
    getSnapshot: () => store.getSnapshot()
  });
}
var settingsStore;
function initializeSettingsStore(settingsService) {
  settingsStore = createSettingsStore(settingsService);
}
var aiSettings;
var frontMatterSettings;
var advancedSettings;
var knowledgeBloomSettings;
var settingsStatus;
function initializeDerivedStores() {
  if (!settingsStore) {
    throw new Error("Settings store not initialized");
  }
  aiSettings = derived(
    settingsStore,
    ($settings) => $settings.aiProvider
  );
  frontMatterSettings = derived(
    settingsStore,
    ($settings) => $settings.frontMatter
  );
  advancedSettings = derived(
    settingsStore,
    ($settings) => $settings.advanced
  );
  knowledgeBloomSettings = derived(
    settingsStore,
    ($settings) => $settings.knowledgeBloom
  );
  settingsStatus = derived(settingsStore, ($settings) => ({
    isValid: validateSettings($settings),
    hasApiKey: !!$settings.aiProvider.apiKeys[$settings.aiProvider.selected],
    isConfigured: validateSettings($settings) && !!$settings.aiProvider.apiKeys[$settings.aiProvider.selected],
    provider: $settings.aiProvider.selected
  }));
}
function validateSettings(settings) {
  var _a;
  const requiredSections = [
    "aiProvider",
    "frontMatter",
    "tags",
    "localLMStudio",
    "advanced",
    "ontology",
    "knowledgeBloom"
  ];
  const hasRequiredSections = requiredSections.every(
    (section) => section in settings
  );
  if (!hasRequiredSections)
    return false;
  const aiProvider = settings.aiProvider;
  if (!(aiProvider == null ? void 0 : aiProvider.selected) || !aiProvider.apiKeys || !aiProvider.selectedModels) {
    return false;
  }
  if ((_a = settings.frontMatter) == null ? void 0 : _a.customProperties) {
    const isValidCustomProperties = settings.frontMatter.customProperties.every(
      (prop) => typeof prop.name === "string" && typeof prop.description === "string" && typeof prop.type === "string" && typeof prop.required === "boolean" && (prop.defaultValue === void 0 || true) && // Adjust as needed
      (prop.options === void 0 || Array.isArray(prop.options)) && typeof prop.multipleValues === "boolean"
    );
    if (!isValidCustomProperties)
      return false;
  }
  return true;
}

// src/stores/ProcessingStore.ts
var initialState = {
  isProcessing: false,
  currentFile: null,
  queue: [],
  progress: 0,
  state: "idle" /* IDLE */,
  filesQueued: 0,
  filesProcessed: 0,
  filesRemaining: 0,
  errors: [],
  error: null,
  startTime: null,
  estimatedTimeRemaining: null
};
var _ProcessingStore = class extends CoreService {
  constructor() {
    super("processing-store", "Processing Store Service");
    this.store = createEnhancedStore(initialState);
  }
  static getInstance() {
    if (!_ProcessingStore.instance) {
      _ProcessingStore.instance = new _ProcessingStore();
    }
    return _ProcessingStore.instance;
  }
  /**
   * Initialize the service
   */
  initializeInternal() {
    return __async(this, null, function* () {
      try {
        this.set(initialState);
      } catch (error) {
        throw new ServiceError(
          this.serviceName,
          "Failed to initialize processing store",
          error instanceof Error ? error : void 0
        );
      }
    });
  }
  /**
   * Clean up resources
   */
  destroyInternal() {
    return __async(this, null, function* () {
      this.set(initialState);
    });
  }
  // Implement Writable interface
  set(value) {
    this.store.set(value);
  }
  update(updater) {
    this.store.update(updater);
  }
  subscribe(run2) {
    return this.store.subscribe(run2);
  }
  /**
   * Start processing a file
   */
  startProcessing(file) {
    if (!this.isReady()) {
      throw new ServiceError(this.serviceName, "Store not ready");
    }
    this.update((state) => __spreadProps(__spreadValues({}, state), {
      isProcessing: true,
      currentFile: file,
      progress: 0,
      state: "running" /* RUNNING */,
      startTime: Date.now(),
      filesQueued: state.queue.length,
      filesRemaining: state.queue.length
    }));
  }
  /**
   * Complete file processing
   */
  completeFile(file) {
    if (!this.isReady()) {
      throw new ServiceError(this.serviceName, "Store not ready");
    }
    this.store.update((state) => {
      const filesProcessed = state.filesProcessed + 1;
      const filesRemaining = state.filesQueued - filesProcessed;
      const elapsedTime = Date.now() - (state.startTime || Date.now());
      const averageTimePerFile = elapsedTime / filesProcessed;
      const estimatedTimeRemaining = averageTimePerFile * filesRemaining;
      return __spreadProps(__spreadValues({}, state), {
        isProcessing: filesRemaining > 0,
        currentFile: null,
        progress: filesProcessed / state.filesQueued * 100,
        state: filesRemaining > 0 ? "running" /* RUNNING */ : "idle" /* IDLE */,
        filesProcessed,
        filesRemaining,
        estimatedTimeRemaining
      });
    });
  }
  /**
   * Set error state
   */
  setError(error) {
    if (!this.isReady()) {
      throw new ServiceError(this.serviceName, "Store not ready");
    }
    this.store.update((state) => {
      const newError = error ? {
        filePath: state.currentFile || "unknown",
        error,
        timestamp: Date.now(),
        retryCount: 0
      } : void 0;
      return __spreadProps(__spreadValues({}, state), {
        state: error ? "error" /* ERROR */ : state.state,
        errors: newError ? [...state.errors, newError] : state.errors
      });
    });
  }
  /**
   * Clear error state
   */
  clearError() {
    if (!this.isReady()) {
      throw new ServiceError(this.serviceName, "Store not ready");
    }
    this.store.update((state) => __spreadProps(__spreadValues({}, state), {
      state: state.isProcessing ? "running" /* RUNNING */ : "idle" /* IDLE */,
      errors: []
    }));
  }
  /**
   * Update progress
   */
  updateProgress(progress) {
    if (!this.isReady()) {
      throw new ServiceError(this.serviceName, "Store not ready");
    }
    this.store.update((state) => __spreadProps(__spreadValues({}, state), {
      progress: Math.min(Math.max(progress, 0), 100)
    }));
  }
  /**
   * Update queue
   */
  updateQueue(files) {
    if (!this.isReady()) {
      throw new ServiceError(this.serviceName, "Store not ready");
    }
    this.store.update((state) => __spreadProps(__spreadValues({}, state), {
      queue: files,
      filesQueued: files.length,
      filesRemaining: files.length
    }));
  }
  /**
   * Get current state snapshot
   */
  getSnapshot() {
    let currentState;
    this.store.subscribe((state) => {
      currentState = state;
    })();
    return currentState;
  }
};
var ProcessingStore = _ProcessingStore;
ProcessingStore.instance = null;
var processingStore = ProcessingStore.getInstance();
var processingStatus = derived(processingStore, ($store) => ({
  isProcessing: $store.isProcessing,
  currentFile: $store.currentFile,
  progress: $store.progress,
  state: $store.state,
  filesQueued: $store.filesQueued,
  filesProcessed: $store.filesProcessed,
  filesRemaining: $store.filesRemaining,
  hasErrors: $store.errors.length > 0
}));
var processingErrors = derived(
  processingStore,
  ($store) => $store.errors
);
var processingProgress = derived(processingStore, ($store) => ({
  progress: $store.progress,
  estimatedTimeRemaining: $store.estimatedTimeRemaining
}));

// src/stores/UIStore.ts
var _UIStore = class extends CoreService {
  constructor() {
    super("ui-store", "UI Store Service");
    this.store = createEnhancedStore({
      darkMode: false,
      activeAccordion: null,
      notifications: [],
      modalStack: [],
      lastInteraction: Date.now()
    });
    this.subscribe = this.store.subscribe;
    this.set = this.store.set;
    this.update = this.store.update;
  }
  static getInstance() {
    if (!_UIStore.instance) {
      _UIStore.instance = new _UIStore();
    }
    return _UIStore.instance;
  }
  /**
   * Initialize the service and load persisted state
   */
  initializeInternal() {
    return __async(this, null, function* () {
      try {
        const savedState = localStorage.getItem(_UIStore.STORAGE_KEY);
        if (savedState) {
          try {
            const parsedState = JSON.parse(savedState);
            if (this.validateState(parsedState)) {
              this.store.set(__spreadProps(__spreadValues(__spreadValues({}, this.getSnapshot()), parsedState), {
                notifications: [],
                // Reset notifications on initialization
                lastInteraction: Date.now()
              }));
            }
          } catch (error) {
            console.warn("\u{1F987} Failed to parse saved UI state:", error);
            localStorage.removeItem(_UIStore.STORAGE_KEY);
          }
        }
      } catch (error) {
        throw new ServiceError(
          this.serviceName,
          "Failed to initialize UI Store",
          error instanceof Error ? error : void 0
        );
      }
    });
  }
  /**
   * Clean up service resources
   */
  destroyInternal() {
    return __async(this, null, function* () {
      try {
        yield this.persistState();
        this.store.set({
          darkMode: false,
          activeAccordion: null,
          notifications: [],
          modalStack: [],
          lastInteraction: Date.now()
        });
      } catch (error) {
        throw new ServiceError(
          this.serviceName,
          "Failed to destroy UI Store",
          error instanceof Error ? error : void 0
        );
      }
    });
  }
  /**
   * Set dark mode state
   */
  setDarkMode(isDark) {
    this.ensureReady();
    this.store.update((state) => __spreadProps(__spreadValues({}, state), {
      darkMode: isDark
    }));
    void this.persistState();
  }
  /**
   * Set active accordion
   */
  setActiveAccordion(accordionId) {
    this.ensureReady();
    this.store.update((state) => __spreadProps(__spreadValues({}, state), {
      activeAccordion: accordionId
    }));
    void this.persistState();
  }
  /**
   * Add notification
   */
  addNotification(notification) {
    this.ensureReady();
    this.store.update((state) => __spreadProps(__spreadValues({}, state), {
      notifications: [...state.notifications, __spreadProps(__spreadValues({}, notification), {
        timestamp: Date.now()
      })]
    }));
  }
  /**
   * Remove notification
   */
  removeNotification(id) {
    this.ensureReady();
    this.store.update((state) => __spreadProps(__spreadValues({}, state), {
      notifications: state.notifications.filter((n2) => n2.id !== id)
    }));
  }
  /**
   * Push modal to stack
   */
  pushModal(modalId) {
    this.ensureReady();
    this.store.update((state) => __spreadProps(__spreadValues({}, state), {
      modalStack: [...state.modalStack, modalId],
      lastInteraction: Date.now()
    }));
    void this.persistState();
  }
  /**
   * Pop modal from stack
   */
  popModal() {
    this.ensureReady();
    this.store.update((state) => __spreadProps(__spreadValues({}, state), {
      modalStack: state.modalStack.slice(0, -1),
      lastInteraction: Date.now()
    }));
    void this.persistState();
  }
  /**
   * Get current state snapshot
   */
  getSnapshot() {
    let currentState;
    this.store.subscribe((state) => {
      currentState = state;
    })();
    return currentState;
  }
  /**
   * Persist state to localStorage
   */
  persistState() {
    return __async(this, null, function* () {
      if (!this.isReady())
        return;
      try {
        const state = this.getSnapshot();
        const persistedState = {
          darkMode: state.darkMode,
          activeAccordion: state.activeAccordion,
          modalStack: state.modalStack,
          lastInteraction: Date.now()
        };
        localStorage.setItem(_UIStore.STORAGE_KEY, JSON.stringify(persistedState));
      } catch (error) {
        console.warn("\u{1F987} Failed to persist UI state:", error);
      }
    });
  }
  /**
   * Validate state structure
   */
  validateState(state) {
    if (typeof state !== "object" || state === null)
      return false;
    const validState = state;
    return (validState.darkMode === void 0 || typeof validState.darkMode === "boolean") && (validState.activeAccordion === void 0 || typeof validState.activeAccordion === "string" || validState.activeAccordion === null) && (validState.modalStack === void 0 || Array.isArray(validState.modalStack));
  }
  /**
   * Ensure store is ready for operations
   */
  ensureReady() {
    if (!this.isReady()) {
      throw new ServiceError(this.serviceName, "Store not ready");
    }
  }
  /**
   * Reset store to initial state
   */
  reset() {
    this.ensureReady();
    this.store.set({
      darkMode: false,
      activeAccordion: null,
      notifications: [],
      modalStack: [],
      lastInteraction: Date.now()
    });
    try {
      localStorage.removeItem(_UIStore.STORAGE_KEY);
    } catch (error) {
      console.warn("\u{1F987} Failed to clear persisted UI state:", error);
    }
    console.log("\u{1F987} UI Store reset to initial state");
  }
};
var UIStore = _UIStore;
UIStore.STORAGE_KEY = "graphweaver-ui-state";
UIStore.instance = null;
var uiStore = UIStore.getInstance();
var isDarkMode = derived(uiStore, ($store) => $store.darkMode);
var activeModal = derived(
  uiStore,
  ($store) => $store.modalStack[$store.modalStack.length - 1] || null
);
var activeAccordion = derived(uiStore, ($store) => $store.activeAccordion);
var notifications = derived(uiStore, ($store) => $store.notifications);

// src/stores/ErrorStore.ts
var ErrorStoreService = class extends BaseStore {
  constructor() {
    super("errorStore", "Error Store Service", {
      active: false,
      message: "",
      timestamp: Date.now(),
      source: void 0
    });
  }
  reportError({ message, source }) {
    this.set({
      active: true,
      message,
      source,
      timestamp: Date.now()
    });
  }
  clearError() {
    this.set({
      active: false,
      message: "",
      timestamp: Date.now(),
      source: void 0
    });
  }
  hasError() {
    return this.getSnapshot().active;
  }
};
var errorStore = new ErrorStoreService();
var errorStatus = derived(errorStore, ($store) => ({
  hasError: $store.active,
  message: $store.message,
  timestamp: $store.timestamp,
  source: $store.source
}));

// src/registrations/ServiceRegistrations.ts
var ServiceRegistry = class {
  constructor() {
    this.services = /* @__PURE__ */ new Map();
    this.initializedServices = /* @__PURE__ */ new Set();
    this.isInitialized = false;
  }
  static getInstance() {
    if (!ServiceRegistry.instance) {
      console.log("\u{1F987} [ServiceRegistry] Creating new instance");
      ServiceRegistry.instance = new ServiceRegistry();
    }
    return ServiceRegistry.instance;
  }
  getRegisteredServices() {
    console.log("\u{1F987} [ServiceRegistry] Getting registered services");
    return Array.from(this.services.entries()).map(([id, service]) => ({
      id,
      service: service.instance,
      name: service.instance.serviceName || id,
      initialize: () => service.instance.initialize(),
      destroy: () => service.instance.destroy()
    }));
  }
  hasRegisteredServices() {
    return this.services.size > 0;
  }
  getServiceState(id) {
    const service = this.services.get(id);
    if (!service) {
      return {
        registered: false,
        status: "NOT_REGISTERED" /* NotRegistered */,
        dependencies: []
      };
    }
    return {
      registered: true,
      status: this.initializedServices.has(id) ? "INITIALIZED" /* Initialized */ : "REGISTERED" /* Registered */,
      dependencies: service.dependencies,
      error: service.error
    };
  }
  getInitializationStatus() {
    const failedServices = [];
    const pendingServices = [];
    this.services.forEach((service, id) => {
      if (service.error) {
        failedServices.push({ id, error: service.error });
      } else if (!this.initializedServices.has(id)) {
        pendingServices.push(id);
      }
    });
    return {
      totalServices: this.services.size,
      initializedServices: this.initializedServices.size,
      pendingServices,
      failedServices,
      timestamp: Date.now()
    };
  }
  getService(id) {
    console.log(`\u{1F987} [ServiceRegistry] Getting service: ${id}`);
    if (!this.isInitialized) {
      throw new ServiceError(
        "ServiceRegistry",
        "Registry not initialized. Call initializeRegistry() first.",
        "REGISTRY_NOT_INITIALIZED"
      );
    }
    const service = this.services.get(id);
    if (!service) {
      const available = Array.from(this.services.keys()).join(", ");
      throw new ServiceError(
        "ServiceRegistry",
        `Service ${id} not found. Available: ${available}`,
        "SERVICE_NOT_FOUND"
      );
    }
    return service.instance;
  }
  getDependencies(serviceId) {
    const service = this.services.get(serviceId);
    return service ? service.dependencies : [];
  }
  hasService(serviceId) {
    return this.services.has(serviceId);
  }
  getAllServiceIds() {
    return Array.from(this.services.keys());
  }
  initializeRegistry() {
    return __async(this, null, function* () {
      console.log("\u{1F987} [ServiceRegistry] Initializing registry");
      this.isInitialized = true;
    });
  }
  registerService(_0, _1) {
    return __async(this, arguments, function* (id, instance20, dependencies = []) {
      console.log(`\u{1F987} [ServiceRegistry] Registering service: ${id}`);
      if (this.services.has(id)) {
        throw new ServiceError(
          "ServiceRegistry",
          `Service ${id} already registered`,
          "SERVICE_ALREADY_REGISTERED"
        );
      }
      this.services.set(id, {
        instance: instance20,
        dependencies,
        error: void 0
      });
      if (dependencies.length === 0) {
        this.initializedServices.add(id);
      }
      console.log(`\u{1F987} [ServiceRegistry] Available services: ${Array.from(this.services.keys()).join(", ")}`);
    });
  }
  initializeAll() {
    return __async(this, null, function* () {
      console.log("\u{1F987} [ServiceRegistry] Initializing all services");
      for (const [id, service] of this.services) {
        if (!this.initializedServices.has(id)) {
          try {
            yield service.instance.initialize();
            this.initializedServices.add(id);
          } catch (error) {
            service.error = error instanceof ServiceError ? error : new ServiceError(`Failed to initialize ${id}`, "INITIALIZATION_FAILED");
            throw service.error;
          }
        }
      }
    });
  }
  destroyAll() {
    return __async(this, null, function* () {
      console.log("\u{1F987} [ServiceRegistry] Destroying all services");
      const services = Array.from(this.services.entries()).reverse();
      for (const [id, service] of services) {
        try {
          yield service.instance.destroy();
          this.initializedServices.delete(id);
        } catch (error) {
          console.error(`\u{1F987} [ServiceRegistry] Error destroying ${id}:`, error);
        }
      }
      this.services.clear();
      this.isInitialized = false;
    });
  }
};

// src/registrations/StoreRegistrations.ts
function hasStoreInterface(store) {
  return typeof store.initialize === "function" && typeof store.destroy === "function" && typeof store.update === "function";
}
function checkDependencies(store, dependencies) {
  return dependencies.every((depId) => {
    const depStore = getStore(depId);
    return !("isReady" in depStore) || depStore.isReady();
  });
}
function initializeStores(config) {
  return __async(this, null, function* () {
    var _a, _b;
    try {
      console.log("\u{1F987} [StoreRegistrations] Initializing plugin store...");
      yield pluginStore.initialize();
      pluginStore.update((state) => __spreadProps(__spreadValues({}, state), {
        plugin: config.plugin
      }));
      console.log("\u{1F987} [StoreRegistrations] Initializing settings store...");
      const settingsService = ServiceRegistry.getInstance().getService("settingsService");
      if (!settingsService) {
        throw new ServiceError(
          "StoreRegistrations",
          "SettingsService not found in ServiceRegistry"
        );
      }
      initializeSettingsStore(settingsService);
      settingsStore.initialize((_b = (_a = config.data) == null ? void 0 : _a.settings) != null ? _b : {});
      initializeDerivedStores();
      console.log("\u{1F987} [StoreRegistrations] Settings store initialized");
      const initSequence = [
        {
          store: processingStore,
          id: "processing",
          dependencies: ["plugin"]
        },
        {
          store: uiStore,
          id: "ui",
          dependencies: []
        },
        {
          store: errorStore,
          id: "error",
          dependencies: []
        }
        // Add other stores as needed
      ];
      for (const { store, id, dependencies } of initSequence) {
        try {
          if (!hasStoreInterface(store)) {
            throw new Error(`Store ${id} does not implement required interface`);
          }
          if (!checkDependencies(store, dependencies)) {
            throw new Error(
              `Cannot initialize ${id} store. Dependencies not ready.`
            );
          }
          console.log(`\u{1F987} [StoreRegistrations] Initializing ${id} store...`);
          yield store.initialize();
          console.log(`\u{1F987} [StoreRegistrations] Initialized ${id} store`);
        } catch (error) {
          console.error(`\u{1F987} [StoreRegistrations] Failed to initialize ${id} store:`, error);
          throw new ServiceError(
            "StoreRegistrations",
            `Failed to initialize ${id} store`,
            error instanceof Error ? error : void 0
          );
        }
      }
      console.log("\u{1F987} [StoreRegistrations] All stores initialized successfully");
    } catch (error) {
      console.error("\u{1F987} [StoreRegistrations] Failed to initialize stores:", error);
      throw error;
    }
  });
}
function getStore(id) {
  const stores = {
    plugin: pluginStore,
    settings: settingsStore,
    processing: processingStore,
    ui: uiStore,
    error: errorStore
  };
  const store = stores[id];
  if (!store) {
    throw new ServiceError("StoreRegistrations", `Unknown store: ${id}`);
  }
  return store;
}

// src/services/core/TypedEventEmitter.ts
var import_events = require("events");
var TypedEventEmitter = class extends import_events.EventEmitter {
  /**
   * Register an event handler with type checking
   * @param event The event name
   * @param listener The event handler function
   */
  on(event, listener) {
    return super.on(event, listener);
  }
  /**
   * Remove an event handler with type checking
   * @param event The event name
   * @param listener The event handler function to remove
   */
  off(event, listener) {
    return super.off(event, listener);
  }
  /**
   * Emit an event with type-safe arguments
   * @param event The event name
   * @param args The arguments to pass to handlers
   */
  emit(event, ...args) {
    return super.emit(event, ...args);
  }
};

// src/managers/SettingsStateManager.ts
var SettingsStateManager = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.settings = __spreadValues({}, DEFAULT_SETTINGS);
    this.eventEmitter = new TypedEventEmitter();
  }
  initialize() {
    return __async(this, null, function* () {
      const loadedData = yield this.plugin.loadData();
      if (loadedData) {
        this.settings = __spreadValues(__spreadValues({}, DEFAULT_SETTINGS), loadedData);
        this.emit("settingsChanged", this.settings);
      } else {
        this.settings = __spreadValues({}, DEFAULT_SETTINGS);
      }
    });
  }
  getSettings() {
    return __spreadValues({}, this.settings);
  }
  getSettingSection(section) {
    return __spreadValues({}, this.settings[section]);
  }
  getNestedSetting(section, key) {
    return this.settings[section][key];
  }
  updateNestedSetting(section, key, value) {
    return __async(this, null, function* () {
      this.settings[section] = __spreadProps(__spreadValues({}, this.settings[section]), {
        [key]: value
      });
      yield this.saveSettings();
      this.emit("settingsChanged", { [section]: this.settings[section] });
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      try {
        yield this.plugin.saveData(this.settings);
      } catch (error) {
        const serviceError = error instanceof Error ? error : new Error("Unknown error");
        this.emit("persistenceError", serviceError);
        throw serviceError;
      }
    });
  }
  on(event, listener) {
    this.eventEmitter.on(event, listener);
  }
  emit(event, ...args) {
    this.eventEmitter.emit(event, ...args);
  }
  resetToDefault() {
    return __async(this, null, function* () {
      this.settings = __spreadValues({}, DEFAULT_SETTINGS);
      yield this.saveSettings();
      this.emit("settingsReset");
    });
  }
  destroy() {
    return __async(this, null, function* () {
      this.eventEmitter.removeAllListeners();
    });
  }
};

// src/services/SettingsService.ts
var SettingsService = class extends CoreService {
  constructor(plugin) {
    super("settings-service", "Settings Service");
    this.stateManager = new SettingsStateManager(plugin);
  }
  initializeInternal() {
    return __async(this, null, function* () {
      try {
        yield this.stateManager.initialize();
      } catch (error) {
        throw new ServiceError(
          this.serviceName,
          "Failed to initialize settings",
          error instanceof Error ? error : void 0
        );
      }
    });
  }
  destroyInternal() {
    return __async(this, null, function* () {
      yield this.stateManager.destroy();
    });
  }
  getSettings() {
    return this.stateManager.getSettings();
  }
  getSettingSection(section) {
    return this.stateManager.getSettingSection(section);
  }
  getNestedSetting(section, key) {
    return this.stateManager.getNestedSetting(section, key);
  }
  updateNestedSetting(section, key, value) {
    return __async(this, null, function* () {
      yield this.stateManager.updateNestedSetting(section, key, value);
    });
  }
  /**
   * Update specific Knowledge Bloom settings
   */
  updateKnowledgeBloomSettings(settings) {
    return __async(this, null, function* () {
      const currentSettings = this.getSettings();
      const updatedSettings = __spreadProps(__spreadValues({}, currentSettings), {
        knowledgeBloom: __spreadValues(__spreadValues({}, currentSettings.knowledgeBloom), settings)
      });
      yield this.stateManager.saveSettings;
    });
  }
  /**
   * Update plugin settings
   */
  updateSettings(settings) {
    return __async(this, null, function* () {
      const currentSettings = this.getSettings();
      const updatedSettings = __spreadValues(__spreadValues({}, currentSettings), settings);
      yield this.stateManager.saveSettings;
    });
  }
  on(event, listener) {
    this.stateManager.on(event, listener);
  }
};

// src/services/DatabaseService.ts
var _DatabaseService = class extends CoreService {
  constructor(plugin) {
    super("database-service", "Database Service");
    this.plugin = plugin;
    this.MONTH_IN_MS = 30 * 24 * 60 * 60 * 1e3;
    this.config = {
      maxHistoryLength: 100,
      pruneThreshold: 1e3,
      processingCooldown: 5e3
    };
    this.processedFiles = /* @__PURE__ */ new Set();
    this.recentlyProcessed = /* @__PURE__ */ new Map();
    this.processingQueue = /* @__PURE__ */ new Set();
    if (_DatabaseService.instance) {
      return _DatabaseService.instance;
    }
    _DatabaseService.instance = this;
  }
  /**
   * Initialize database service
   */
  initializeInternal() {
    return __async(this, null, function* () {
      try {
        const savedData = yield this.plugin.loadData();
        if (savedData) {
          yield this.loadSavedData(savedData);
        }
        yield this.updateProcessingStore();
      } catch (error) {
        this.handleError("Failed to initialize database", error);
      }
    });
  }
  /**
   * Clean up resources
   */
  destroyInternal() {
    return __async(this, null, function* () {
      this.recentlyProcessed.clear();
      this.processingQueue.clear();
      processingStore.update((state) => __spreadProps(__spreadValues({}, state), {
        databaseReady: false
      }));
    });
  }
  /**
   * Configure service settings
   */
  configure(config) {
    return __async(this, null, function* () {
      this.config = __spreadValues(__spreadValues({}, this.config), config);
    });
  }
  /**
   * Track file processing
   */
  trackFileProcessing(filePath) {
    this.recentlyProcessed.set(filePath, Date.now());
    this.processingQueue.add(filePath);
    processingStore.update((state) => __spreadProps(__spreadValues({}, state), {
      currentFile: filePath
    }));
    setTimeout(() => {
      this.recentlyProcessed.delete(filePath);
      this.processingQueue.delete(filePath);
    }, this.config.processingCooldown);
  }
  /**
   * Check if file needs processing
   */
  needsProcessing(file) {
    if (this.processingQueue.has(file.path)) {
      return false;
    }
    const lastProcessTime = this.recentlyProcessed.get(file.path);
    if (lastProcessTime && Date.now() - lastProcessTime < this.config.processingCooldown) {
      return false;
    }
    return !this.processedFiles.has(file.path);
  }
  /**
   * Mark file as processed
   */
  markFileAsProcessed(file, result) {
    return __async(this, null, function* () {
      this.processedFiles.add(file.path);
      this.trackFileProcessing(file.path);
      yield this.saveData();
    });
  }
  /**
   * Load saved data
   */
  loadSavedData(savedData) {
    return __async(this, null, function* () {
      if (savedData.processedFiles) {
        this.processedFiles = new Set(savedData.processedFiles);
      }
    });
  }
  /**
   * Save current state
   */
  saveData() {
    return __async(this, null, function* () {
      try {
        const data = {
          processedFiles: Array.from(this.processedFiles),
          lastUpdated: Date.now()
        };
        yield this.plugin.saveData(data);
        yield this.updateProcessingStore();
      } catch (error) {
        this.handleError("Failed to save data", error);
      }
    });
  }
  /**
   * Update processing store state
   */
  updateProcessingStore() {
    return __async(this, null, function* () {
      processingStore.update((state) => __spreadProps(__spreadValues({}, state), {
        databaseReady: true,
        totalProcessed: this.processedFiles.size,
        filesProcessing: Array.from(this.processingQueue)
      }));
    });
  }
  /**
   * Get singleton instance
   */
  static getInstance(plugin) {
    if (!_DatabaseService.instance) {
      _DatabaseService.instance = new _DatabaseService(plugin);
    }
    return _DatabaseService.instance;
  }
};
var DatabaseService = _DatabaseService;
DatabaseService.instance = null;

// src/services/file/FileScannerService.ts
var import_events2 = require("events");
var FileScannerService = class extends CoreService {
  constructor(vault, config = {}) {
    super("file-scanner", "File Scanner Service");
    this.vault = vault;
    this.scanTimeout = null;
    this.lastProgressUpdate = 0;
    this.scanErrors = [];
    this.config = __spreadValues({
      batchSize: 100,
      progressInterval: 1e3,
      // 1 second
      scanTimeoutMs: 3e4,
      // 30 seconds
      debug: false
    }, config);
    this.eventEmitter = new import_events2.EventEmitter();
  }
  /**
   * Initialize scanner service
   */
  initializeInternal() {
    return __async(this, null, function* () {
      if (this.config.debug) {
      }
    });
  }
  /**
   * Clean up resources
   */
  destroyInternal() {
    return __async(this, null, function* () {
      this.eventEmitter.removeAllListeners();
      if (this.scanTimeout) {
        clearTimeout(this.scanTimeout);
        this.scanTimeout = null;
      }
    });
  }
  /**
   * Configure scanner options
   */
  configure(config) {
    return __async(this, null, function* () {
      this.config = __spreadValues(__spreadValues({}, this.config), config);
    });
  }
  /**
   * Get all files missing front matter with progress tracking
   */
  getFilesMissingFrontMatter() {
    return __async(this, null, function* () {
      try {
        const startTime = Date.now();
        const files = this.vault.getMarkdownFiles();
        const filesMissingFM = [];
        this.scanErrors = [];
        this.emit("scanStart", files.length);
        for (let i = 0; i < files.length; i += this.config.batchSize) {
          const batch = files.slice(i, i + this.config.batchSize);
          yield this.processBatch(batch, filesMissingFM, startTime, i, files.length);
        }
        const result = {
          filesMissingFrontMatter: filesMissingFM,
          totalScanned: files.length,
          scanDuration: Date.now() - startTime,
          errors: this.scanErrors
        };
        this.emit("scanComplete", result);
        return result;
      } catch (error) {
        const serviceError = new ServiceError(
          this.serviceName,
          "Failed to scan files",
          error instanceof Error ? error : void 0
        );
        this.emit("scanError", serviceError);
        throw serviceError;
      }
    });
  }
  /**
   * Process a batch of files
   */
  processBatch(batch, filesMissingFM, startTime, processedCount, totalFiles) {
    return __async(this, null, function* () {
      yield Promise.all(
        batch.map((file) => __async(this, null, function* () {
          try {
            if (!(yield this.hasFrontMatter(file))) {
              filesMissingFM.push(file);
            }
          } catch (error) {
            this.scanErrors.push({
              path: file.path,
              error: error instanceof Error ? error.message : "Unknown error"
            });
          }
        }))
      );
      yield this.emitProgress(
        processedCount + batch.length,
        totalFiles,
        batch[batch.length - 1].path,
        filesMissingFM.length,
        startTime
      );
    });
  }
  /**
   * Check if file has front matter
   */
  hasFrontMatter(file) {
    return __async(this, null, function* () {
      try {
        const startTime = Date.now();
        const content = yield this.vault.read(file);
        const timeoutPromise = new Promise((_, reject) => {
          this.scanTimeout = setTimeout(() => {
            reject(new Error(`Timeout reading file ${file.path}`));
          }, this.config.scanTimeoutMs);
        });
        const result = content.startsWith("---\n");
        if (this.scanTimeout) {
          clearTimeout(this.scanTimeout);
          this.scanTimeout = null;
        }
        return result;
      } catch (error) {
        throw new ServiceError(
          this.serviceName,
          `Failed to check front matter for ${file.path}`,
          error instanceof Error ? error : void 0
        );
      }
    });
  }
  /**
   * Emit progress update if interval elapsed
   */
  emitProgress(scannedFiles, totalFiles, currentFile, missingCount, startTime) {
    return __async(this, null, function* () {
      const now2 = Date.now();
      if (now2 - this.lastProgressUpdate >= this.config.progressInterval) {
        this.lastProgressUpdate = now2;
        const progress = {
          scannedFiles,
          totalFiles,
          currentFile,
          missingFrontMatter: missingCount,
          elapsedTime: now2 - startTime
        };
        this.emit("scanProgress", progress);
      }
    });
  }
  /**
   * Subscribe to scanner events
   */
  on(event, callback) {
    this.eventEmitter.on(event, callback);
  }
  /**
   * Remove event subscription
   */
  off(event, callback) {
    this.eventEmitter.off(event, callback);
  }
  /**
   * Emit scanner event
   */
  emit(event, ...args) {
    this.eventEmitter.emit(event, ...args);
  }
};

// src/services/JsonValidationService.ts
var JsonValidationService = class extends CoreService {
  constructor(config = {}) {
    super("json-validation", "JSON Validation Service");
    this.config = __spreadValues({
      notifyOnError: true,
      strictMode: false,
      maxDepth: 100,
      allowComments: false,
      fixMalformed: true,
      debug: false
    }, config);
  }
  /**
   * Initialize validation service
   */
  initializeInternal() {
    return __async(this, null, function* () {
      if (this.config.debug) {
      }
    });
  }
  /**
   * Clean up resources
   */
  destroyInternal() {
    return __async(this, null, function* () {
      if (this.config.debug) {
      }
    });
  }
  /**
   * Configure validation options
   */
  configure(config) {
    return __async(this, null, function* () {
      this.config = __spreadValues(__spreadValues({}, this.config), config);
    });
  }
  /**
   * Validate JSON data with type safety
   */
  validate(data) {
    try {
      if (this.isValidJsonObject(data)) {
        return {
          valid: true,
          value: data
        };
      }
      if (typeof data === "string") {
        const parsed = JSON.parse(data);
        if (this.isValidJsonObject(parsed)) {
          return {
            valid: true,
            value: parsed
          };
        }
      }
      throw new Error("Invalid JSON data type");
    } catch (error) {
      const serviceError = new ServiceError(
        this.serviceName,
        "JSON validation failed",
        error instanceof Error ? error : void 0
      );
      if (this.config.debug) {
        console.error(serviceError.getDetails());
      }
      return {
        valid: false,
        error: serviceError.message
      };
    }
  }
  /**
   * Clean and validate JSON string with enhanced error handling
   */
  validateAndCleanJson(jsonString) {
    try {
      const cleaned = this.cleanJsonString(jsonString);
      const fixes = [];
      try {
        const parsed = JSON.parse(cleaned);
        return {
          valid: true,
          value: parsed,
          fixes: fixes.length > 0 ? fixes : void 0
        };
      } catch (parseError) {
        if (this.config.fixMalformed) {
          const fixResult = this.fixAndParseJson(cleaned);
          if (fixResult.valid) {
            return fixResult;
          }
        }
        throw parseError;
      }
    } catch (error) {
      const serviceError = new ServiceError(
        this.serviceName,
        "JSON validation and cleaning failed",
        error instanceof Error ? error : void 0
      );
      if (this.config.debug) {
        console.error(serviceError.getDetails());
      }
      if (this.config.notifyOnError) {
      }
      return {
        valid: false,
        error: serviceError.message
      };
    }
  }
  /**
   * Fix and parse potentially malformed JSON
   */
  fixAndParseJson(str) {
    const fixes = [];
    try {
      return {
        valid: true,
        value: JSON.parse(str)
      };
    } catch (initialError) {
      if (this.config.debug) {
      }
      try {
        let fixed = str;
        const unquotedKeysFix = fixed.replace(/(\w+)(?=\s*:)/g, '"$1"');
        if (unquotedKeysFix !== fixed) {
          fixes.push("Added quotes to keys");
          fixed = unquotedKeysFix;
        }
        const singleQuotesFix = fixed.replace(/'/g, '"');
        if (singleQuotesFix !== fixed) {
          fixes.push("Converted single quotes to double quotes");
          fixed = singleQuotesFix;
        }
        const trailingCommasFix = fixed.replace(/,\s*([\]}])/g, "$1");
        if (trailingCommasFix !== fixed) {
          fixes.push("Removed trailing commas");
          fixed = trailingCommasFix;
        }
        const fixedJson = JSON.parse(fixed);
        return {
          valid: true,
          value: fixedJson,
          fixes
        };
      } catch (fixError) {
        const serviceError = new ServiceError(
          this.serviceName,
          "Failed to fix malformed JSON",
          {
            originalError: fixError instanceof Error ? fixError : void 0,
            context: { original: str }
          }
        );
        if (this.config.debug) {
          console.error(serviceError.getDetails());
        }
        return {
          valid: false,
          error: serviceError.message,
          fixes
        };
      }
    }
  }
  /**
   * Clean JSON string by removing whitespace and markdown
   */
  cleanJsonString(str) {
    let cleaned = str.trim();
    cleaned = cleaned.replace(/^```json?\s*|\s*```$/g, "");
    if (!this.config.allowComments) {
      cleaned = cleaned.replace(/\/\*[\s\S]*?\*\//g, "").replace(/\/\/.*/g, "");
    }
    return cleaned;
  }
  /**
   * Check if value is a valid JSON object
   */
  isValidJsonObject(value) {
    return typeof value === "object" && value !== null && !Array.isArray(value);
  }
  /**
   * Validate object against max depth constraint
   */
  validateDepth(obj, currentDepth = 0) {
    if (currentDepth > this.config.maxDepth) {
      return false;
    }
    if (typeof obj !== "object" || obj === null) {
      return true;
    }
    for (const value of Object.values(obj)) {
      if (!this.validateDepth(value, currentDepth + 1)) {
        return false;
      }
    }
    return true;
  }
};

// src/registrations/CoreRegistrations.ts
var CORE_SERVICES = [
  {
    id: "settingsService",
    name: "Settings Service",
    factory: (plugin) => new SettingsService(plugin)
  },
  {
    id: "jsonValidationService",
    name: "JSON Validation Service",
    factory: (plugin) => new JsonValidationService()
  },
  {
    id: "databaseService",
    name: "Database Service",
    factory: (plugin) => new DatabaseService(plugin),
    dependencies: ["settingsService"]
  },
  {
    id: "wikilinkProcessor",
    name: "Wikilink Processor",
    factory: (plugin) => new WikilinkTextProcessor()
  },
  {
    id: "fileScanner",
    name: "File Scanner",
    factory: (plugin) => new FileScannerService(plugin.app.vault),
    dependencies: ["settingsService"]
  }
];
function reportError(message, source, error) {
  console.error(`\u{1F987} [CoreRegistrations] ${message}:`, error);
  errorStore.reportError({
    message: error ? `${message}: ${error.message}` : message,
    source
  });
}
function initializeCoreServices(plugin) {
  return __async(this, null, function* () {
    console.log("\u{1F987} [CoreRegistrations] Starting initialization sequence");
    const registry = ServiceRegistry.getInstance();
    yield registry.initializeRegistry();
    const registeredServices = [];
    try {
      console.log("\u{1F987} [CoreRegistrations] Phase 1: Registering services");
      for (const config of CORE_SERVICES) {
        yield registerService(config, plugin, registry, registeredServices);
      }
      console.log("\u{1F987} [CoreRegistrations] Phase 2: Validating dependencies");
      yield validateServiceDependencies(registry);
      console.log("\u{1F987} [CoreRegistrations] Phase 3: Initializing services");
      yield initializeServices(registeredServices);
      console.log("\u{1F987} [CoreRegistrations] All services initialized successfully");
    } catch (error) {
      console.error("\u{1F987} [CoreRegistrations] Initialization failed:", error);
      yield performCleanup(registeredServices);
      throw error instanceof ServiceError ? error : new ServiceError("CoreRegistrations", "Service initialization failed", error);
    }
  });
}
function registerService(config, plugin, registry, registeredServices) {
  return __async(this, null, function* () {
    console.log(`\u{1F987} [CoreRegistrations] Registering ${config.name}`);
    try {
      const service = config.factory(plugin);
      yield registry.registerService(config.id, service, config.dependencies);
      registeredServices.push({
        id: config.id,
        service,
        name: config.name,
        initialize: service.initialize.bind(service),
        destroy: service.destroy.bind(service)
      });
      console.log(`\u{1F987} [CoreRegistrations] Registered ${config.name} successfully`);
    } catch (error) {
      throw new ServiceError(
        "CoreRegistrations",
        `Failed to register ${config.name}`,
        error
      );
    }
  });
}
function validateServiceDependencies(registry) {
  return __async(this, null, function* () {
    console.log("\u{1F987} [CoreRegistrations] Validating service dependencies");
    const serviceIds = registry.getAllServiceIds();
    for (const id of serviceIds) {
      const deps = registry.getDependencies(id);
      const missingDeps = deps.filter((dep) => !registry.hasService(dep));
      if (missingDeps.length > 0) {
        throw new ServiceError(
          "CoreRegistrations",
          `Service ${id} missing dependencies: ${missingDeps.join(", ")}`
        );
      }
    }
  });
}
function initializeServices(services) {
  return __async(this, null, function* () {
    for (const { name, initialize } of services) {
      try {
        console.log(`\u{1F987} [CoreRegistrations] Initializing ${name}`);
        yield initialize();
        console.log(`\u{1F987} [CoreRegistrations] Initialized ${name} successfully`);
      } catch (error) {
        throw new ServiceError(
          "CoreRegistrations",
          `Failed to initialize ${name}`,
          error
        );
      }
    }
  });
}
function performCleanup(services) {
  return __async(this, null, function* () {
    console.log("\u{1F987} [CoreRegistrations] Starting cleanup sequence");
    const reversedServices = [...services].reverse();
    for (const { name, destroy } of reversedServices) {
      try {
        yield destroy();
        console.log(`\u{1F987} [CoreRegistrations] Cleaned up ${name}`);
      } catch (error) {
        reportError(
          `Cleanup failed for ${name}`,
          "ServiceCleanup",
          error
        );
      }
    }
  });
}
function destroyCoreServices(services) {
  return __async(this, null, function* () {
    if (!(services == null ? void 0 : services.length))
      return;
    yield performCleanup(services);
  });
}

// src/services/ai/MetricsTracker.ts
var MetricsTracker = class {
  constructor() {
    this.serviceId = "metrics-tracker";
    this.serviceName = "Metrics Tracker";
    this.state = "uninitialized" /* Uninitialized */;
    this.error = null;
    this.metrics = {};
    this.operationHistory = [];
    this.MAX_HISTORY_SIZE = 50;
  }
  initialize() {
    return __async(this, null, function* () {
      try {
        this.state = "initializing" /* Initializing */;
        this.initializeMetrics();
        this.state = "ready" /* Ready */;
      } catch (error) {
        this.state = "error" /* Error */;
        this.error = error instanceof ServiceError ? error : new ServiceError(this.serviceName, "Initialization failed");
        throw this.error;
      }
    });
  }
  isReady() {
    return this.state === "ready" /* Ready */;
  }
  destroy() {
    return __async(this, null, function* () {
      try {
        this.state = "destroying" /* Destroying */;
        this.clearHistory();
        this.resetMetrics();
        this.state = "destroyed" /* Destroyed */;
      } catch (error) {
        this.state = "error" /* Error */;
        this.error = error instanceof ServiceError ? error : new ServiceError(this.serviceName, "Destroy failed");
        throw this.error;
      }
    });
  }
  getState() {
    return { state: this.state, error: this.error };
  }
  // Rest of existing MetricsTracker implementation...
  initializeMetrics() {
    Object.values(OperationType).forEach((type) => {
      this.metrics[type] = {
        totalOperations: 0,
        successfulOperations: 0,
        failedOperations: 0,
        averageDuration: 0,
        lastOperation: void 0
      };
    });
  }
  trackOperation(status) {
    this.updateMetrics(status);
    this.operationHistory.unshift(status);
    if (this.operationHistory.length > this.MAX_HISTORY_SIZE) {
      this.operationHistory.pop();
    }
  }
  updateMetrics(status) {
    const metrics = this.metrics[status.type];
    const duration = (status.endTime || Date.now()) - status.startTime;
    metrics.totalOperations++;
    if (status.success) {
      metrics.successfulOperations++;
    } else {
      metrics.failedOperations++;
    }
    metrics.averageDuration = (metrics.averageDuration * (metrics.totalOperations - 1) + duration) / metrics.totalOperations;
    metrics.lastOperation = status;
  }
  getMetrics(type) {
    return __spreadValues({}, this.metrics[type]);
  }
  getAllMetrics() {
    return __spreadValues({}, this.metrics);
  }
  getHistory() {
    return [...this.operationHistory];
  }
  clearHistory() {
    this.operationHistory = [];
  }
  resetMetrics() {
    this.initializeMetrics();
  }
};

// src/services/ai/OperationEventEmitter.ts
var OperationEventEmitter = class extends TypedEventEmitter {
  constructor() {
    super();
    this.serviceId = "operation-emitter";
    this.serviceName = "Operation Event Emitter";
    this.state = "uninitialized" /* Uninitialized */;
    this.error = null;
  }
  initialize() {
    return __async(this, null, function* () {
      this.state = "ready" /* Ready */;
    });
  }
  isReady() {
    return this.state === "ready" /* Ready */;
  }
  destroy() {
    return __async(this, null, function* () {
      this.removeAllListeners();
      this.state = "destroyed" /* Destroyed */;
    });
  }
  getState() {
    return { state: this.state, error: this.error };
  }
  // Existing event emitter methods...
  emitOperationStart(status) {
    this.emit("operationStart", status);
  }
  emitOperationComplete(status) {
    this.emit("operationComplete", status);
  }
  emitOperationError(error, status) {
    this.emit("operationError", error, status);
  }
  emitOperationProgress(progress) {
    this.emit("operationProgress", progress);
  }
  emitQueueUpdate(queueLength) {
    this.emit("queueUpdate", queueLength);
  }
  emitStateChange(status) {
    this.emit("stateChange", status);
  }
  emitMetricsUpdate(metrics) {
    this.emit("metricsUpdate", metrics);
  }
};

// src/types/aiModels.ts
var OpenAIModels = [
  {
    name: "GPT 4o mini",
    apiName: "gpt-4o-mini",
    capabilities: {
      maxTokens: 128e3,
      supportsFunctions: true,
      supportsStreaming: true
    }
  },
  {
    name: "GPT 4o",
    apiName: "gpt-4o",
    capabilities: {
      maxTokens: 128e3,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsVision: true
    }
  },
  {
    name: "GPT o1 Preview",
    apiName: "o1-preview",
    capabilities: {
      maxTokens: 128e3,
      supportsFunctions: true,
      supportsStreaming: true
    }
  },
  {
    name: "GPT o1 Mini",
    apiName: "o1-mini",
    capabilities: {
      maxTokens: 128e3,
      supportsFunctions: true,
      supportsStreaming: true
    }
  }
];
var AnthropicModels = [
  {
    name: "Claude 3 Haiku",
    apiName: "claude-3-haiku-20240307",
    capabilities: {
      maxTokens: 2e5,
      supportsFunctions: true,
      supportsStreaming: true
    }
  },
  {
    name: "Claude 3 Sonnet",
    apiName: "claude-3-sonnet-20240229",
    capabilities: {
      maxTokens: 2e5,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsVision: true
    }
  },
  {
    name: "Claude 3 Opus",
    apiName: "claude-3-opus-20240229",
    capabilities: {
      maxTokens: 2e5,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsVision: true
    }
  },
  {
    name: "Claude 3.5 Sonnet",
    apiName: "claude-3-5-sonnet-20240620",
    capabilities: {
      maxTokens: 2e5,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsVision: true
    }
  }
];
var GoogleModels = [
  {
    name: "Gemini 1.5 Flash",
    apiName: "gemini-1.5-flash",
    capabilities: {
      maxTokens: 32e3,
      supportsStreaming: true
    }
  },
  {
    name: "Gemini 1.5 Flash 8B",
    apiName: "gemini-1.5-flash-8b",
    capabilities: {
      maxTokens: 32e3,
      supportsStreaming: true
    }
  },
  {
    name: "Gemini 1.5 Pro",
    apiName: "gemini-1.5-pro",
    capabilities: {
      maxTokens: 32e3,
      supportsStreaming: true,
      supportsVision: true
    }
  }
];
var GroqModels = [
  {
    name: "Llama 3.1 70B",
    apiName: "llama-3.1-70b-versatile",
    capabilities: {
      maxTokens: 32e3,
      supportsStreaming: true
    }
  },
  {
    name: "Llama 3.1 8B",
    apiName: "llama-3.1-8b-instant",
    capabilities: {
      maxTokens: 32e3,
      supportsStreaming: true
    }
  },
  {
    name: "Llama 3.2 1B (Preview)",
    apiName: "llama-3.2-1b-preview",
    capabilities: {
      maxTokens: 32e3,
      supportsStreaming: true
    }
  },
  {
    name: "Llama 3.2 3B (Preview)",
    apiName: "llama-3.2-3b-preview",
    capabilities: {
      maxTokens: 32e3,
      supportsStreaming: true
    }
  }
];
var OpenRouterModels = [
  {
    name: "Anthropic Claude 3 Opus",
    apiName: "anthropic/claude-3-opus",
    capabilities: {
      maxTokens: 2e5,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsVision: true
    }
  },
  {
    name: "Anthropic Claude 3.5 Sonnet",
    apiName: "anthropic/claude-3.5-sonnet",
    capabilities: {
      maxTokens: 2e5,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsVision: true
    }
  },
  {
    name: "Google Gemini Flash 1.5",
    apiName: "google/gemini-flash-1.5",
    capabilities: {
      maxTokens: 32e3,
      supportsStreaming: true
    }
  },
  {
    name: "Google Gemini Flash 1.5 8B",
    apiName: "google/gemini-flash-1.5-8b",
    capabilities: {
      maxTokens: 32e3,
      supportsStreaming: true
    }
  },
  {
    name: "Google Gemini Pro 1.5",
    apiName: "google/gemini-pro-1.5",
    capabilities: {
      maxTokens: 32e3,
      supportsStreaming: true,
      supportsVision: true
    }
  },
  {
    name: "Mistralai Mistral Large",
    apiName: "mistralai/mistral-large",
    capabilities: {
      maxTokens: 32e3,
      supportsStreaming: true
    }
  },
  {
    name: "Mistralai Mistral Nemo",
    apiName: "mistralai/mistral-nemo",
    capabilities: {
      maxTokens: 32e3,
      supportsStreaming: true
    }
  },
  {
    name: "OpenAI GPT 4o",
    apiName: "openai/gpt-4o",
    capabilities: {
      maxTokens: 128e3,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsVision: true
    }
  },
  {
    name: "OpenAI GPT 4o Mini",
    apiName: "openai/gpt-4o-mini",
    capabilities: {
      maxTokens: 128e3,
      supportsFunctions: true,
      supportsStreaming: true
    }
  },
  {
    name: "OpenAI o1 Mini",
    apiName: "openai/o1-mini",
    capabilities: {
      maxTokens: 128e3,
      supportsFunctions: true,
      supportsStreaming: true
    }
  },
  {
    name: "OpenAI o1 Preview",
    apiName: "openai/o1-preview",
    capabilities: {
      maxTokens: 128e3,
      supportsFunctions: true,
      supportsStreaming: true
    }
  }
];
var LMStudioModels = [
  {
    name: "Custom",
    apiName: "custom",
    capabilities: {
      supportsStreaming: false
    }
  }
];
var AIModelMap = {
  ["openai" /* OpenAI */]: OpenAIModels,
  ["anthropic" /* Anthropic */]: AnthropicModels,
  ["google" /* Google */]: GoogleModels,
  ["groq" /* Groq */]: GroqModels,
  ["openrouter" /* OpenRouter */]: OpenRouterModels,
  ["lmstudio" /* LMStudio */]: LMStudioModels
};
var AIModelUtils = {
  /**
   * Get a model by its API name
   * @param apiName The API name to look up
   * @returns The matching model or undefined
   */
  getModelByApiName(apiName) {
    for (const models of Object.values(AIModelMap)) {
      const model = models.find((m) => m.apiName === apiName);
      if (model)
        return model;
    }
    return void 0;
  },
  /**
   * Get all models for a specific provider
   * @param provider The provider to get models for
   * @returns Array of models for the provider
   */
  getModelsForProvider(provider) {
    return AIModelMap[provider] || [];
  },
  /**
   * Check if a model supports a specific capability
   * @param model The model to check
   * @param capability The capability to check for
   * @returns Whether the model supports the capability
   */
  modelSupportsCapability(model, capability) {
    var _a;
    return !!((_a = model.capabilities) == null ? void 0 : _a[capability]);
  },
  /**
   * Get all models that support a specific capability
   * @param capability The capability to filter by
   * @returns Array of models that support the capability
   */
  getModelsByCapability(capability) {
    const supportedModels = [];
    for (const models of Object.values(AIModelMap)) {
      supportedModels.push(...models.filter((m) => this.modelSupportsCapability(m, capability)));
    }
    return supportedModels;
  },
  /**
   * Get models by provider and capability
   * @param provider The provider to filter by
   * @param capability The capability to filter by
   * @returns Array of matching models
   */
  getModelsByProviderAndCapability(provider, capability) {
    return this.getModelsForProvider(provider).filter((m) => this.modelSupportsCapability(m, capability));
  }
};

// src/adapters/OpenAIAdapter.ts
var import_obsidian2 = require("obsidian");
var OpenAIAdapter = class {
  constructor(settingsService, jsonValidationService) {
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    const aiProviderSettings = this.settingsService.getSettingSection("aiProvider");
    this.apiKey = aiProviderSettings.apiKeys["openai" /* OpenAI */] || "";
    this.models = AIModelMap["openai" /* OpenAI */];
  }
  /**
   * Generate a response using the OpenAI API
   */
  generateResponse(prompt, modelApiName, options) {
    return __async(this, null, function* () {
      try {
        const apiModel = this.getApiModelName(modelApiName);
        if (!apiModel) {
          throw new Error(`No valid model found for ${this.getProviderType()}`);
        }
        if (!this.apiKey) {
          throw new Error("OpenAI API key is not set");
        }
        const settings = this.settingsService.getSettings();
        const temperature = this.getTemperature(settings);
        const maxTokens = (options == null ? void 0 : options.maxTokens) || this.getMaxTokens(settings);
        const response = yield this.makeApiRequest({
          model: apiModel,
          prompt,
          temperature,
          maxTokens,
          rawResponse: options == null ? void 0 : options.rawResponse
        });
        const content = this.extractContentFromResponse(response);
        if (options == null ? void 0 : options.rawResponse) {
          return { success: true, data: content };
        }
        const validatedContent = yield this.jsonValidationService.validateAndCleanJson(content);
        return { success: true, data: validatedContent };
      } catch (error) {
        return this.handleError(error);
      }
    });
  }
  /**
   * Test connection to OpenAI API
   */
  testConnection(prompt, modelApiName) {
    return __async(this, null, function* () {
      try {
        if (!this.apiKey) {
          return false;
        }
        const response = yield this.generateResponse(
          prompt || "Return the word 'OK'.",
          modelApiName,
          { rawResponse: true }
        );
        if (!response.success || typeof response.data !== "string") {
          return false;
        }
        return response.data.toLowerCase().includes("ok");
      } catch (error) {
        console.error("Error in OpenAI test connection:", error);
        return false;
      }
    });
  }
  /**
   * Make a request to the OpenAI API
   */
  makeApiRequest(params) {
    return __async(this, null, function* () {
      var _a;
      const response = yield (0, import_obsidian2.requestUrl)({
        url: "https://api.openai.com/v1/chat/completions",
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.apiKey}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          model: params.model,
          messages: [
            {
              role: "system",
              content: params.rawResponse ? "You are a helpful assistant." : "You are a helpful assistant that responds in JSON format."
            },
            { role: "user", content: params.prompt }
          ],
          temperature: params.temperature,
          max_tokens: params.maxTokens,
          n: 1,
          stream: false,
          response_format: params.rawResponse ? void 0 : { type: "json_object" }
        })
      });
      if (response.status !== 200) {
        const errorBody = response.json;
        throw new Error(
          `API request failed with status ${response.status}: ${((_a = errorBody == null ? void 0 : errorBody.error) == null ? void 0 : _a.message) || "Unknown error"}`
        );
      }
      return response;
    });
  }
  /**
   * Extract content from API response
   */
  extractContentFromResponse(response) {
    var _a, _b, _c, _d;
    if (!((_d = (_c = (_b = (_a = response.json) == null ? void 0 : _a.choices) == null ? void 0 : _b[0]) == null ? void 0 : _c.message) == null ? void 0 : _d.content)) {
      throw new Error("Invalid response format from OpenAI API");
    }
    return response.json.choices[0].message.content;
  }
  /**
   * Get temperature setting
   */
  getTemperature(settings) {
    var _a, _b;
    return ((_a = settings.advanced) == null ? void 0 : _a.temperature) >= 0 && ((_b = settings.advanced) == null ? void 0 : _b.temperature) <= 1 ? settings.advanced.temperature : 0.7;
  }
  /**
   * Get max tokens setting
   */
  getMaxTokens(settings) {
    var _a;
    return ((_a = settings.advanced) == null ? void 0 : _a.maxTokens) > 0 ? settings.advanced.maxTokens : 1e3;
  }
  /**
   * Handle errors in API calls
   */
  handleError(error) {
    console.error("Error in OpenAI API call:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    new import_obsidian2.Notice(`OpenAI API Error: ${errorMessage}`);
    return { success: false, error: errorMessage };
  }
  /**
   * Validate API key
   */
  validateApiKey() {
    return __async(this, null, function* () {
      try {
        if (!this.apiKey) {
          throw new Error("OpenAI API key is not set");
        }
        if (this.models.length === 0) {
          throw new Error("No models available for OpenAI");
        }
        const isValid = yield this.testConnection(
          "Return the word 'OK'.",
          this.models[0].apiName
        );
        if (isValid) {
          new import_obsidian2.Notice("OpenAI API key validated successfully");
          return true;
        } else {
          throw new Error("Failed to validate API key");
        }
      } catch (error) {
        console.error("Error validating OpenAI API key:", error);
        new import_obsidian2.Notice(`Failed to validate OpenAI API key: ${error instanceof Error ? error.message : "Unknown error occurred"}`);
        return false;
      }
    });
  }
  /**
   * Get available models
   */
  getAvailableModels() {
    return this.models.map((model) => model.apiName);
  }
  /**
   * Get provider type
   */
  getProviderType() {
    return "openai" /* OpenAI */;
  }
  /**
   * Set API key
   */
  setApiKey(apiKey) {
    this.apiKey = apiKey;
  }
  /**
   * Get API key
   */
  getApiKey() {
    return this.apiKey;
  }
  /**
   * Configure the adapter
   */
  configure(config) {
    if (config == null ? void 0 : config.apiKey) {
      this.setApiKey(config.apiKey);
    }
  }
  /**
   * Check if adapter is ready
   */
  isReady() {
    return !!this.apiKey && this.models.length > 0;
  }
  /**
   * Get API model name
   */
  getApiModelName(modelApiName) {
    var _a;
    const model = this.models.find((m) => m.apiName === modelApiName);
    if (!model) {
      console.warn(`Model ${modelApiName} not found for ${this.getProviderType()}. Using first available model.`);
      return ((_a = this.models[0]) == null ? void 0 : _a.apiName) || modelApiName;
    }
    return model.apiName;
  }
};

// src/adapters/AnthropicAdapter.ts
var import_obsidian3 = require("obsidian");
var AnthropicAdapter = class {
  constructor(settingsService, jsonValidationService) {
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    const aiProviderSettings = this.settingsService.getSettingSection("aiProvider");
    this.apiKey = aiProviderSettings.apiKeys["anthropic" /* Anthropic */] || "";
    this.models = AIModelMap["anthropic" /* Anthropic */];
  }
  generateResponse(prompt, modelApiName, options) {
    return __async(this, null, function* () {
      try {
        const apiModel = this.getApiModelName(modelApiName);
        if (!apiModel) {
          throw new Error(`Invalid model: ${modelApiName} for ${this.getProviderType()}`);
        }
        if (!this.apiKey) {
          throw new Error("Anthropic API key is not set");
        }
        const settings = this.settingsService.getSettings();
        const temperature = this.getTemperature(settings);
        const maxTokens = (options == null ? void 0 : options.maxTokens) || this.getMaxTokens(settings);
        const response = yield this.makeApiRequest(apiModel, prompt, temperature, maxTokens);
        const content = this.extractContentFromResponse(response);
        if (options == null ? void 0 : options.rawResponse) {
          return { success: true, data: content };
        }
        const validatedContent = yield this.jsonValidationService.validateAndCleanJson(content);
        return { success: true, data: validatedContent };
      } catch (error) {
        return this.handleError(error);
      }
    });
  }
  testConnection(prompt, modelApiName) {
    return __async(this, null, function* () {
      try {
        if (!this.apiKey) {
          throw new Error("Anthropic API key is not set");
        }
        const apiModel = this.getApiModelName(modelApiName);
        const response = yield this.makeApiRequest(apiModel, prompt, 0.7, 50);
        const content = this.extractContentFromResponse(response);
        return content.toLowerCase().includes("ok");
      } catch (error) {
        console.error("Error in Anthropic test connection:", error);
        return false;
      }
    });
  }
  getTemperature(settings) {
    return settings.advanced.temperature >= 0 && settings.advanced.temperature <= 1 ? settings.advanced.temperature : 0.7;
  }
  getMaxTokens(settings) {
    return settings.advanced.maxTokens > 0 ? settings.advanced.maxTokens : 1e3;
  }
  makeApiRequest(apiModel, prompt, temperature, maxTokens) {
    return __async(this, null, function* () {
      const requestBody = {
        model: apiModel,
        messages: [{ role: "user", content: prompt }],
        max_tokens: maxTokens,
        temperature
      };
      const response = yield (0, import_obsidian3.requestUrl)({
        url: "https://api.anthropic.com/v1/messages",
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-api-key": this.apiKey,
          "anthropic-version": "2023-06-01"
        },
        body: JSON.stringify(requestBody)
      });
      if (response.status !== 200) {
        throw new Error(`API request failed with status ${response.status}: ${response.text}`);
      }
      return response;
    });
  }
  extractContentFromResponse(response) {
    return response.json.content[0].text;
  }
  handleError(error) {
    console.error("Error in Anthropic API call:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    new import_obsidian3.Notice(`Anthropic API Error: ${errorMessage}`);
    return { success: false, error: errorMessage };
  }
  validateApiKey() {
    return __async(this, null, function* () {
      try {
        if (!this.apiKey) {
          throw new Error("Anthropic API key is not set");
        }
        const response = yield this.testConnection("Return the word 'OK'.", this.models[0].apiName);
        if (response) {
          new import_obsidian3.Notice("Anthropic API key validated successfully");
          return true;
        } else {
          throw new Error("Failed to validate API key");
        }
      } catch (error) {
        console.error("Error validating Anthropic API key:", error);
        new import_obsidian3.Notice(`Failed to validate Anthropic API key: ${error instanceof Error ? error.message : "Unknown error occurred"}`);
        return false;
      }
    });
  }
  getAvailableModels() {
    return this.models.map((model) => model.apiName);
  }
  getProviderType() {
    return "anthropic" /* Anthropic */;
  }
  setApiKey(apiKey) {
    this.apiKey = apiKey;
  }
  getApiKey() {
    return this.apiKey;
  }
  configure(config) {
  }
  isReady() {
    return !!this.apiKey;
  }
  getApiModelName(modelApiName) {
    const model = this.models.find((m) => m.apiName === modelApiName);
    if (!model) {
      throw new Error(`Model ${modelApiName} not found for ${this.getProviderType()}`);
    }
    return model.apiName;
  }
};

// src/adapters/GeminiAdapter.ts
var import_obsidian4 = require("obsidian");
var GeminiAdapter = class {
  constructor(settingsService, jsonValidationService) {
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    const aiProviderSettings = this.settingsService.getSettingSection("aiProvider");
    this.apiKey = aiProviderSettings.apiKeys["google" /* Google */] || "";
    this.models = AIModelMap["google" /* Google */];
  }
  /**
   * Generate a response using the Gemini API
   */
  generateResponse(prompt, modelApiName, options) {
    return __async(this, null, function* () {
      try {
        const apiModel = this.getApiModelName(modelApiName);
        if (!apiModel) {
          throw new Error(`No valid model found for ${this.getProviderType()}`);
        }
        if (!this.apiKey) {
          throw new Error("Google API key is not set");
        }
        const settings = this.settingsService.getSettings();
        const temperature = this.getTemperature(settings);
        const maxTokens = (options == null ? void 0 : options.maxTokens) || this.getMaxTokens(settings);
        const response = yield this.makeApiRequest({
          model: apiModel,
          prompt,
          temperature,
          maxTokens,
          rawResponse: options == null ? void 0 : options.rawResponse
        });
        const content = this.extractContentFromResponse(response);
        if (options == null ? void 0 : options.rawResponse) {
          return { success: true, data: content };
        }
        try {
          const validatedContent = yield this.jsonValidationService.validateAndCleanJson(content);
          return { success: true, data: validatedContent };
        } catch (jsonError) {
          return {
            success: true,
            data: { response: content }
          };
        }
      } catch (error) {
        return this.handleError(error);
      }
    });
  }
  /**
   * Test connection to Gemini API
   */
  testConnection(prompt, modelApiName) {
    return __async(this, null, function* () {
      try {
        if (!this.apiKey) {
          return false;
        }
        const response = yield this.generateResponse(
          prompt || "Return the word 'OK'.",
          modelApiName,
          { rawResponse: true }
        );
        if (!response.success || typeof response.data !== "string") {
          return false;
        }
        return response.data.toLowerCase().includes("ok");
      } catch (error) {
        console.error("Error in Gemini test connection:", error);
        return false;
      }
    });
  }
  /**
   * Make a request to the Gemini API
   */
  makeApiRequest(params) {
    return __async(this, null, function* () {
      var _a;
      const systemPrompt = params.rawResponse ? "You are a helpful assistant." : "You are a helpful assistant that responds in JSON format. Your response should be valid JSON with a 'response' field containing your answer.";
      const requestBody = {
        contents: [
          {
            parts: [
              { text: systemPrompt },
              { text: params.prompt }
            ]
          }
        ],
        generationConfig: {
          temperature: params.temperature,
          maxOutputTokens: params.maxTokens,
          topK: 40,
          topP: 0.95
        }
      };
      const response = yield (0, import_obsidian4.requestUrl)({
        url: `https://generativelanguage.googleapis.com/v1/models/${params.model}:generateContent`,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-goog-api-key": this.apiKey
        },
        body: JSON.stringify(requestBody)
      });
      if (response.status !== 200) {
        const errorBody = response.json;
        throw new Error(
          `API request failed with status ${response.status}: ${((_a = errorBody == null ? void 0 : errorBody.error) == null ? void 0 : _a.message) || response.text}`
        );
      }
      return response;
    });
  }
  /**
   * Extract content from Gemini API response
   */
  extractContentFromResponse(response) {
    var _a, _b, _c, _d, _e, _f;
    if (!((_f = (_e = (_d = (_c = (_b = (_a = response.json) == null ? void 0 : _a.candidates) == null ? void 0 : _b[0]) == null ? void 0 : _c.content) == null ? void 0 : _d.parts) == null ? void 0 : _e[0]) == null ? void 0 : _f.text)) {
      throw new Error("Invalid response format from Gemini API");
    }
    const content = response.json.candidates[0].content;
    return content.parts[0].text;
  }
  /**
   * Get temperature setting
   */
  getTemperature(settings) {
    var _a, _b;
    return ((_a = settings.advanced) == null ? void 0 : _a.temperature) >= 0 && ((_b = settings.advanced) == null ? void 0 : _b.temperature) <= 1 ? settings.advanced.temperature : 0.7;
  }
  /**
   * Get max tokens setting
   */
  getMaxTokens(settings) {
    var _a;
    return ((_a = settings.advanced) == null ? void 0 : _a.maxTokens) > 0 ? settings.advanced.maxTokens : 1e3;
  }
  /**
   * Handle errors in API calls
   */
  handleError(error) {
    console.error("Error in Gemini API call:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    new import_obsidian4.Notice(`Gemini API Error: ${errorMessage}`);
    return { success: false, error: errorMessage };
  }
  /**
   * Validate API key
   */
  validateApiKey() {
    return __async(this, null, function* () {
      try {
        if (!this.apiKey) {
          throw new Error("Google API key is not set");
        }
        if (this.models.length === 0) {
          throw new Error("No models available for Gemini");
        }
        const isValid = yield this.testConnection(
          "Return the word 'OK'.",
          this.models[0].apiName
        );
        if (isValid) {
          new import_obsidian4.Notice("Gemini API key validated successfully");
          return true;
        } else {
          throw new Error("Failed to validate API key");
        }
      } catch (error) {
        console.error("Error validating Gemini API key:", error);
        new import_obsidian4.Notice(`Failed to validate Gemini API key: ${error instanceof Error ? error.message : "Unknown error occurred"}`);
        return false;
      }
    });
  }
  /**
   * Get available models
   */
  getAvailableModels() {
    return this.models.map((model) => model.apiName);
  }
  /**
   * Get provider type
   */
  getProviderType() {
    return "google" /* Google */;
  }
  /**
   * Set API key
   */
  setApiKey(apiKey) {
    this.apiKey = apiKey;
  }
  /**
   * Get API key
   */
  getApiKey() {
    return this.apiKey;
  }
  /**
   * Configure the adapter
   */
  configure(config) {
    if (config == null ? void 0 : config.apiKey) {
      this.setApiKey(config.apiKey);
    }
  }
  /**
   * Check if adapter is ready
   */
  isReady() {
    return !!this.apiKey && this.models.length > 0;
  }
  /**
   * Get API model name
   */
  getApiModelName(modelApiName) {
    var _a;
    const model = this.models.find((m) => m.apiName === modelApiName);
    if (!model) {
      console.warn(`Model ${modelApiName} not found for ${this.getProviderType()}. Using first available model.`);
      return ((_a = this.models[0]) == null ? void 0 : _a.apiName) || modelApiName;
    }
    return model.apiName;
  }
};

// src/adapters/GroqAdapter.ts
var import_obsidian5 = require("obsidian");
var GroqAdapter = class {
  constructor(settingsService, jsonValidationService) {
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    const aiProviderSettings = this.settingsService.getSettingSection("aiProvider");
    this.apiKey = aiProviderSettings.apiKeys["groq" /* Groq */] || "";
    this.models = AIModelMap["groq" /* Groq */];
  }
  /**
   * Generate a response using the Groq API
   */
  generateResponse(prompt, modelApiName, options) {
    return __async(this, null, function* () {
      try {
        const apiModel = this.getApiModelName(modelApiName);
        if (!apiModel) {
          throw new Error(`No valid model found for ${this.getProviderType()}`);
        }
        if (!this.apiKey) {
          throw new Error("Groq API key is not set");
        }
        const settings = this.settingsService.getSettings();
        const temperature = this.getTemperature(settings);
        const maxTokens = (options == null ? void 0 : options.maxTokens) || this.getMaxTokens(settings);
        const response = yield this.makeApiRequest({
          model: apiModel,
          prompt,
          temperature,
          maxTokens,
          rawResponse: options == null ? void 0 : options.rawResponse
        });
        const content = this.extractContentFromResponse(response);
        if (options == null ? void 0 : options.rawResponse) {
          return { success: true, data: content };
        }
        const validatedContent = yield this.jsonValidationService.validateAndCleanJson(content);
        return { success: true, data: validatedContent };
      } catch (error) {
        return this.handleError(error);
      }
    });
  }
  /**
   * Test connection to Groq API
   */
  testConnection(prompt, modelApiName) {
    return __async(this, null, function* () {
      try {
        if (!this.apiKey) {
          throw new Error("Groq API key is not set");
        }
        const response = yield this.generateResponse(
          prompt || "Return the word 'OK'.",
          modelApiName,
          { rawResponse: true }
        );
        if (!response.success || typeof response.data !== "string") {
          return false;
        }
        return response.data.toLowerCase().includes("ok");
      } catch (error) {
        console.error("Error in Groq test connection:", error);
        return false;
      }
    });
  }
  /**
   * Make a request to the Groq API
   */
  makeApiRequest(params) {
    return __async(this, null, function* () {
      var _a;
      const response = yield (0, import_obsidian5.requestUrl)({
        url: "https://api.groq.com/openai/v1/chat/completions",
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.apiKey}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          model: params.model,
          messages: [
            {
              role: "system",
              content: params.rawResponse ? "You are a helpful assistant." : "You are a helpful assistant that responds in JSON format."
            },
            { role: "user", content: params.prompt }
          ],
          temperature: params.temperature,
          max_tokens: params.maxTokens,
          response_format: params.rawResponse ? void 0 : { type: "json_object" }
        })
      });
      if (response.status !== 200) {
        const errorBody = response.json;
        throw new Error(
          `API request failed with status ${response.status}: ${((_a = errorBody == null ? void 0 : errorBody.error) == null ? void 0 : _a.message) || "Unknown error"}`
        );
      }
      return response;
    });
  }
  /**
   * Extract content from API response
   */
  extractContentFromResponse(response) {
    var _a, _b, _c, _d;
    if (!((_d = (_c = (_b = (_a = response.json) == null ? void 0 : _a.choices) == null ? void 0 : _b[0]) == null ? void 0 : _c.message) == null ? void 0 : _d.content)) {
      throw new Error("Invalid response format from Groq API");
    }
    return response.json.choices[0].message.content;
  }
  /**
   * Get temperature setting
   */
  getTemperature(settings) {
    var _a, _b;
    return ((_a = settings.advanced) == null ? void 0 : _a.temperature) >= 0 && ((_b = settings.advanced) == null ? void 0 : _b.temperature) <= 1 ? settings.advanced.temperature : 0.7;
  }
  /**
   * Get max tokens setting
   */
  getMaxTokens(settings) {
    var _a;
    return ((_a = settings.advanced) == null ? void 0 : _a.maxTokens) > 0 ? settings.advanced.maxTokens : 1e3;
  }
  /**
   * Handle errors in API calls
   */
  handleError(error) {
    console.error("Error in Groq API call:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    new import_obsidian5.Notice(`Groq API Error: ${errorMessage}`);
    return { success: false, error: errorMessage };
  }
  /**
   * Validate API key
   */
  validateApiKey() {
    return __async(this, null, function* () {
      try {
        if (!this.apiKey) {
          throw new Error("Groq API key is not set");
        }
        if (this.models.length === 0) {
          throw new Error("No models available for Groq");
        }
        const isValid = yield this.testConnection(
          "Return the word 'OK'.",
          this.models[0].apiName
        );
        if (isValid) {
          new import_obsidian5.Notice("Groq API key validated successfully");
          return true;
        } else {
          throw new Error("Failed to validate API key");
        }
      } catch (error) {
        console.error("Error validating Groq API key:", error);
        new import_obsidian5.Notice(`Failed to validate Groq API key: ${error instanceof Error ? error.message : "Unknown error occurred"}`);
        return false;
      }
    });
  }
  /**
   * Get available models
   */
  getAvailableModels() {
    return this.models.map((model) => model.apiName);
  }
  /**
   * Get provider type
   */
  getProviderType() {
    return "groq" /* Groq */;
  }
  /**
   * Set API key
   */
  setApiKey(apiKey) {
    this.apiKey = apiKey;
  }
  /**
   * Get API key
   */
  getApiKey() {
    return this.apiKey;
  }
  /**
   * Configure the adapter
   */
  configure(config) {
    if (config == null ? void 0 : config.apiKey) {
      this.setApiKey(config.apiKey);
    }
  }
  /**
   * Check if adapter is ready
   */
  isReady() {
    return !!this.apiKey && this.models.length > 0;
  }
  /**
   * Get API model name
   */
  getApiModelName(modelApiName) {
    var _a;
    const model = this.models.find((m) => m.apiName === modelApiName);
    if (!model) {
      console.warn(`Model ${modelApiName} not found for ${this.getProviderType()}. Using first available model.`);
      return ((_a = this.models[0]) == null ? void 0 : _a.apiName) || modelApiName;
    }
    return model.apiName;
  }
};

// src/adapters/OpenRouterAdapter.ts
var import_obsidian6 = require("obsidian");
var OpenRouterAdapter = class {
  constructor(settingsService, jsonValidationService) {
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    const aiProviderSettings = this.settingsService.getSettingSection("aiProvider");
    this.apiKey = aiProviderSettings.apiKeys["openrouter" /* OpenRouter */] || "";
    this.models = AIModelMap["openrouter" /* OpenRouter */];
  }
  /**
   * Generate a response using the OpenRouter API
   */
  generateResponse(prompt, modelApiName, options) {
    return __async(this, null, function* () {
      try {
        const apiModel = this.getApiModelName(modelApiName);
        if (!apiModel) {
          throw new Error(`No valid model found for ${this.getProviderType()}`);
        }
        if (!this.apiKey) {
          throw new Error("OpenRouter API key is not set");
        }
        const settings = this.settingsService.getSettings();
        const temperature = this.getTemperature(settings);
        const maxTokens = (options == null ? void 0 : options.maxTokens) || this.getMaxTokens(settings);
        console.log(`OpenRouterAdapter: Sending prompt to AI: ${prompt}`);
        const response = yield this.makeApiRequest(
          apiModel,
          prompt,
          temperature,
          maxTokens,
          options == null ? void 0 : options.rawResponse
        );
        const content = this.extractContentFromResponse(response);
        console.log(`OpenRouterAdapter: Received response from AI: ${content}`);
        if (options == null ? void 0 : options.rawResponse) {
          return { success: true, data: content };
        }
        const validatedContent = yield this.jsonValidationService.validateAndCleanJson(content);
        console.log(`OpenRouterAdapter: Validated JSON content:`, validatedContent);
        return { success: true, data: validatedContent };
      } catch (error) {
        return this.handleError(error);
      }
    });
  }
  /**
   * Test connection to OpenRouter API
   */
  testConnection(prompt, modelApiName) {
    return __async(this, null, function* () {
      try {
        if (!this.apiKey) {
          return false;
        }
        const response = yield this.generateResponse(
          prompt || "Return the word 'OK'.",
          modelApiName,
          { rawResponse: true }
        );
        if (!response.success || typeof response.data !== "string") {
          return false;
        }
        return response.data.toLowerCase().includes("ok");
      } catch (error) {
        console.error("Error in OpenRouter test connection:", error);
        return false;
      }
    });
  }
  /**
   * Make a request to the OpenRouter API
   */
  makeApiRequest(apiModel, prompt, temperature, maxTokens, rawResponse) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d;
      const headers = {
        "Authorization": `Bearer ${this.apiKey}`,
        "Content-Type": "application/json",
        "HTTP-Referer": window.location.href,
        // Dynamic referrer
        "X-Title": "Obsidian GraphWeaver Plugin"
      };
      try {
        const response = yield (0, import_obsidian6.requestUrl)({
          url: "https://openrouter.ai/api/v1/chat/completions",
          method: "POST",
          headers,
          body: JSON.stringify({
            model: apiModel,
            messages: [
              {
                role: "system",
                content: rawResponse ? "You are a helpful assistant." : "You are a helpful assistant that responds in JSON format."
              },
              { role: "user", content: prompt }
            ],
            temperature,
            max_tokens: maxTokens,
            response_format: rawResponse ? void 0 : { type: "json_object" }
          })
        });
        if (!((_d = (_c = (_b = (_a = response.json) == null ? void 0 : _a.choices) == null ? void 0 : _b[0]) == null ? void 0 : _c.message) == null ? void 0 : _d.content)) {
          throw new Error("Invalid response format from OpenRouter API");
        }
        return response;
      } catch (error) {
        if (error.status === 401) {
          throw new Error("OpenRouter API authentication failed. Please check your API key.");
        }
        throw error;
      }
    });
  }
  /**
   * Extract content from API response
   */
  extractContentFromResponse(response) {
    var _a, _b, _c, _d;
    if (!((_d = (_c = (_b = (_a = response.json) == null ? void 0 : _a.choices) == null ? void 0 : _b[0]) == null ? void 0 : _c.message) == null ? void 0 : _d.content)) {
      throw new Error("Invalid response format from OpenRouter API");
    }
    return response.json.choices[0].message.content;
  }
  /**
   * Get temperature setting
   */
  getTemperature(settings) {
    var _a, _b;
    return ((_a = settings.advanced) == null ? void 0 : _a.temperature) >= 0 && ((_b = settings.advanced) == null ? void 0 : _b.temperature) <= 1 ? settings.advanced.temperature : 0.7;
  }
  /**
   * Get max tokens setting
   */
  getMaxTokens(settings) {
    var _a;
    return ((_a = settings.advanced) == null ? void 0 : _a.maxTokens) > 0 ? settings.advanced.maxTokens : 1e3;
  }
  /**
   * Handle errors in API calls
   */
  handleError(error) {
    console.error("Error in OpenRouter API call:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    new import_obsidian6.Notice(`OpenRouter API Error: ${errorMessage}`);
    return { success: false, error: errorMessage };
  }
  /**
   * Validate API key
   */
  validateApiKey() {
    return __async(this, null, function* () {
      try {
        if (!this.apiKey) {
          throw new Error("OpenRouter API key is not set");
        }
        if (this.models.length === 0) {
          throw new Error("No models available for OpenRouter");
        }
        const isValid = yield this.testConnection(
          "Return the word 'OK'.",
          this.models[0].apiName
        );
        if (isValid) {
          new import_obsidian6.Notice("OpenRouter API key validated successfully");
          return true;
        } else {
          throw new Error("Failed to validate API key");
        }
      } catch (error) {
        console.error("Error validating OpenRouter API key:", error);
        new import_obsidian6.Notice(`Failed to validate OpenRouter API key: ${error instanceof Error ? error.message : "Unknown error occurred"}`);
        return false;
      }
    });
  }
  /**
   * Get available models
   */
  getAvailableModels() {
    return this.models.map((model) => model.apiName);
  }
  /**
   * Get provider type
   */
  getProviderType() {
    return "openrouter" /* OpenRouter */;
  }
  /**
   * Set API key
   */
  setApiKey(apiKey) {
    this.apiKey = apiKey;
  }
  /**
   * Get API key
   */
  getApiKey() {
    return this.apiKey;
  }
  /**
   * Configure the adapter
   */
  configure(config) {
    if (config == null ? void 0 : config.apiKey) {
      this.setApiKey(config.apiKey);
    }
  }
  /**
   * Check if adapter is ready
   */
  isReady() {
    return !!this.apiKey && this.models.length > 0;
  }
  /**
   * Get API model name
   */
  getApiModelName(modelApiName) {
    var _a;
    const model = this.models.find((m) => m.apiName === modelApiName);
    if (!model) {
      console.warn(`Model ${modelApiName} not found for ${this.getProviderType()}. Using first available model.`);
      return ((_a = this.models[0]) == null ? void 0 : _a.apiName) || modelApiName;
    }
    return model.apiName;
  }
};

// src/adapters/LMStudioAdapter.ts
var import_obsidian7 = require("obsidian");
var LMStudioAdapter = class {
  constructor(settingsService, jsonValidationService) {
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    this.model = "";
    this.port = "";
    this.updateSettings();
  }
  generateResponse(prompt, model = "default", options) {
    return __async(this, null, function* () {
      try {
        if (!this.isReady()) {
          throw new Error("LM Studio settings are not properly configured");
        }
        const response = yield (0, import_obsidian7.requestUrl)({
          url: `http://localhost:${this.port}/v1/chat/completions`,
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            model: this.model,
            messages: [
              {
                role: "system",
                content: (options == null ? void 0 : options.rawResponse) ? "You are a helpful assistant." : "You are a helpful assistant that responds in JSON format."
              },
              {
                role: "user",
                content: prompt
              }
            ],
            response_format: (options == null ? void 0 : options.rawResponse) ? void 0 : {
              type: "json_schema",
              json_schema: this.createJsonSchema()
            },
            temperature: 0.7,
            max_tokens: (options == null ? void 0 : options.maxTokens) || 1e3,
            stream: false
          })
        });
        if (response.status !== 200) {
          throw new Error(`API request failed with status ${response.status}`);
        }
        const content = response.json.choices[0].message.content;
        if (options == null ? void 0 : options.rawResponse) {
          return {
            success: true,
            data: content
          };
        }
        const validatedContent = yield this.jsonValidationService.validateAndCleanJson(content);
        return {
          success: true,
          data: validatedContent
        };
      } catch (error) {
        console.error("Error in LM Studio API call:", error);
        new import_obsidian7.Notice(`LM Studio API Error: ${error instanceof Error ? error.message : "Unknown error occurred"}`);
        return {
          success: false,
          error: error instanceof Error ? error.message : "Unknown error occurred"
        };
      }
    });
  }
  createJsonSchema() {
    return {
      name: "assistant_response",
      strict: "true",
      schema: {
        type: "object",
        properties: {
          response: {
            type: "string"
          }
        },
        required: ["response"]
      }
    };
  }
  testConnection(prompt, model = "default") {
    return __async(this, null, function* () {
      try {
        if (!this.isReady()) {
          return false;
        }
        const response = yield this.generateResponse("Return the word 'OK'.", model);
        if (!response.success || !response.data) {
          return false;
        }
        if (typeof response.data === "object" && response.data !== null && "response" in response.data && typeof response.data.response === "string") {
          return response.data.response.toLowerCase().includes("ok");
        }
        return false;
      } catch (error) {
        console.error("Error in LM Studio test connection:", error);
        return false;
      }
    });
  }
  validateApiKey() {
    return __async(this, null, function* () {
      return this.isReady();
    });
  }
  getAvailableModels() {
    return [this.model];
  }
  getProviderType() {
    return "lmstudio" /* LMStudio */;
  }
  setApiKey(apiKey) {
  }
  getApiKey() {
    return "";
  }
  configure(config) {
    if (config.model) {
      this.model = config.model;
    }
    if (config.port) {
      this.port = config.port.toString();
    }
    this.settingsService.updateNestedSetting("localLMStudio", "modelName", this.model);
    this.settingsService.updateNestedSetting("localLMStudio", "port", parseInt(this.port, 10));
  }
  isReady() {
    return !!this.model && !!this.port;
  }
  getApiModelName(modelName) {
    return modelName;
  }
  updateSettings() {
    const localLMStudioSettings = this.settingsService.getSettingSection("localLMStudio");
    this.model = localLMStudioSettings.modelName;
    this.port = localLMStudioSettings.port.toString();
  }
};

// src/services/ai/AdapterRegistry.ts
var AdapterRegistry = class {
  constructor(settingsService, jsonValidationService) {
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    // IService implementation
    this.serviceId = "adapter-registry";
    this.serviceName = "Adapter Registry";
    this.serviceState = "uninitialized" /* Uninitialized */;
    this.serviceError = null;
    this.unsubscribers = [];
    this.isUnloading = false;
    this.adapters = /* @__PURE__ */ new Map();
    this.adapterStatus = /* @__PURE__ */ new Map();
    const settings = get_store_value(settingsStore);
    this.currentProvider = settings.aiProvider.selected;
  }
  /**
   * Get current service state
   */
  getState() {
    return {
      state: this.serviceState,
      error: this.serviceError
    };
  }
  /**
   * Initialize the service and adapters
   */
  initialize() {
    return __async(this, null, function* () {
      try {
        this.serviceState = "initializing" /* Initializing */;
        yield this.initializeAdapters();
        this.setupSubscriptions();
        this.serviceState = "ready" /* Ready */;
      } catch (error) {
        this.serviceState = "error" /* Error */;
        this.serviceError = error instanceof ServiceError ? error : new ServiceError(this.serviceName, "Failed to initialize adapters");
        throw this.serviceError;
      }
    });
  }
  /**
   * Check if service is ready
   */
  isReady() {
    return this.serviceState === "ready" /* Ready */ && !this.isUnloading;
  }
  /**
   * Clean up resources and destroy adapters
   */
  destroy() {
    return __async(this, null, function* () {
      if (this.isUnloading)
        return;
      try {
        this.isUnloading = true;
        this.serviceState = "destroying" /* Destroying */;
        this.unsubscribers.forEach((unsubscribe) => unsubscribe());
        this.unsubscribers = [];
        const cleanupPromises = Array.from(this.adapters.values()).map((adapter) => __async(this, null, function* () {
          if ("destroy" in adapter && adapter.destroy && typeof adapter.destroy === "function") {
            try {
              yield adapter.destroy();
            } catch (error) {
              console.warn(
                `Failed to destroy adapter for ${adapter.getProviderType()}: ${error instanceof Error ? error.message : "Unknown error"}`
              );
            }
          }
        }));
        yield Promise.all(cleanupPromises);
        this.adapters.clear();
        this.adapterStatus.clear();
        this.updateAIStore();
        this.serviceState = "destroyed" /* Destroyed */;
      } catch (error) {
        this.serviceState = "error" /* Error */;
        this.serviceError = error instanceof ServiceError ? error : new ServiceError(this.serviceName, "Failed to destroy adapters");
        throw this.serviceError;
      }
    });
  }
  /**
   * Set up store subscriptions
   */
  setupSubscriptions() {
    const settingsUnsub = settingsStore.subscribe((settings) => {
      if (!this.isUnloading && settings.aiProvider.selected !== this.currentProvider) {
        void this.handleProviderChange(settings.aiProvider.selected);
      }
    });
    this.unsubscribers.push(settingsUnsub);
  }
  /**
   * Initialize all supported adapters
   */
  initializeAdapters() {
    return __async(this, null, function* () {
      const adapterInitializers = /* @__PURE__ */ new Map([
        ["openai" /* OpenAI */, () => new OpenAIAdapter(this.settingsService, this.jsonValidationService)],
        ["anthropic" /* Anthropic */, () => new AnthropicAdapter(this.settingsService, this.jsonValidationService)],
        ["google" /* Google */, () => new GeminiAdapter(this.settingsService, this.jsonValidationService)],
        ["groq" /* Groq */, () => new GroqAdapter(this.settingsService, this.jsonValidationService)],
        ["openrouter" /* OpenRouter */, () => new OpenRouterAdapter(this.settingsService, this.jsonValidationService)],
        ["lmstudio" /* LMStudio */, () => new LMStudioAdapter(this.settingsService, this.jsonValidationService)]
      ]);
      for (const [provider, initializer] of adapterInitializers) {
        try {
          this.adapters.set(provider, initializer());
          this.adapterStatus.set(provider, {
            isInitialized: true,
            isConnected: false
          });
        } catch (error) {
          console.error(`Failed to initialize adapter for ${provider}:`, error);
          this.updateAdapterStatus(provider, {
            isInitialized: false,
            isConnected: false,
            lastError: error instanceof Error ? error.message : "Unknown error"
          });
        }
      }
      this.updateAIStore();
    });
  }
  /**
   * Handle provider changes
   */
  handleProviderChange(newProvider) {
    return __async(this, null, function* () {
      if (this.isUnloading)
        return;
      try {
        const adapter = this.getAdapter(newProvider);
        if (!adapter) {
          throw new Error(`No adapter available for provider: ${newProvider}`);
        }
        const isValid = yield this.validateAdapter(newProvider);
        if (!isValid) {
          throw new Error(`Failed to validate adapter for provider: ${newProvider}`);
        }
        this.currentProvider = newProvider;
        this.updateAIStore();
      } catch (error) {
        this.handleError(error);
        if (!this.isUnloading) {
          settingsStore.update((settings) => __spreadProps(__spreadValues({}, settings), {
            aiProvider: __spreadProps(__spreadValues({}, settings.aiProvider), {
              selected: this.currentProvider
            })
          }));
        }
      }
    });
  }
  getAdapter(provider) {
    return this.adapters.get(provider);
  }
  getCurrentAdapter() {
    if (this.isUnloading) {
      throw new Error("Service is being unloaded");
    }
    const adapter = this.getAdapter(this.currentProvider);
    if (!adapter) {
      throw new Error(`No adapter available for current provider: ${this.currentProvider}`);
    }
    return adapter;
  }
  validateAdapter(provider) {
    return __async(this, null, function* () {
      if (this.isUnloading)
        return false;
      const adapter = this.getAdapter(provider);
      if (!adapter)
        return false;
      try {
        const isValid = yield adapter.validateApiKey();
        this.updateAdapterStatus(provider, {
          isConnected: isValid,
          lastValidated: Date.now()
        });
        return isValid;
      } catch (error) {
        this.updateAdapterStatus(provider, {
          isConnected: false,
          lastError: error instanceof Error ? error.message : "Unknown error",
          lastValidated: Date.now()
        });
        return false;
      }
    });
  }
  testConnection(provider) {
    return __async(this, null, function* () {
      if (this.isUnloading)
        return false;
      const adapter = this.getAdapter(provider);
      if (!adapter) {
        this.handleError(new Error(`No adapter available for provider: ${provider}`));
        return false;
      }
      try {
        const models = AIModelMap[provider] || [];
        if (models.length === 0) {
          throw new Error(`No models available for provider: ${provider}`);
        }
        const testModel = models[0].apiName;
        const testPrompt = "Return the word 'OK'.";
        const isConnected = yield adapter.testConnection(testPrompt, testModel);
        this.updateAdapterStatus(provider, {
          isConnected,
          lastConnected: isConnected ? Date.now() : void 0,
          lastError: isConnected ? void 0 : "Connection test failed"
        });
        return isConnected;
      } catch (error) {
        this.updateAdapterStatus(provider, {
          isConnected: false,
          lastError: error instanceof Error ? error.message : "Unknown error during connection test"
        });
        this.handleError(error instanceof Error ? error : new Error("Connection test failed"));
        return false;
      }
    });
  }
  updateAdapterStatus(provider, status) {
    if (this.isUnloading)
      return;
    const currentStatus = this.adapterStatus.get(provider) || {
      isInitialized: false,
      isConnected: false
    };
    this.adapterStatus.set(provider, __spreadValues(__spreadValues({}, currentStatus), status));
    this.updateAIStore();
  }
  updateAIStore() {
    if (this.isUnloading)
      return;
    const currentAdapter = this.adapters.get(this.currentProvider);
    const currentStatus = this.adapterStatus.get(this.currentProvider);
    if (currentAdapter && currentStatus) {
      aiStore.update((state) => __spreadProps(__spreadValues({}, state), {
        isConnected: currentStatus.isConnected,
        currentModel: currentAdapter.getApiKey() ? AIModelMap[this.currentProvider][0].apiName : "",
        isProcessing: false,
        provider: this.currentProvider,
        availableModels: AIModelMap[this.currentProvider] || [],
        error: currentStatus.lastError
      }));
    }
  }
  handleError(error) {
    if (this.isUnloading)
      return;
    console.error("AdapterRegistry error:", error);
    this.serviceError = new ServiceError(this.serviceName, error.message);
    aiStore.update((state) => __spreadProps(__spreadValues({}, state), {
      error: error.message,
      lastError: {
        message: error.message,
        timestamp: Date.now()
      },
      isConnected: false,
      isProcessing: false
    }));
  }
  // Utility methods
  getAdapterStatus(provider) {
    return this.adapterStatus.get(provider);
  }
  getAllAdapterStatus() {
    return new Map(this.adapterStatus);
  }
  isAdapterHealthy(provider) {
    const status = this.adapterStatus.get(provider);
    return !!((status == null ? void 0 : status.isInitialized) && (status == null ? void 0 : status.isConnected));
  }
  getHealthyAdapters() {
    return Array.from(this.adapterStatus.entries()).filter(([_, status]) => status.isInitialized && status.isConnected).map(([provider]) => provider);
  }
  getAllAvailableModels() {
    const allModels = [];
    for (const provider of this.adapters.keys()) {
      allModels.push(...AIModelMap[provider] || []);
    }
    return allModels;
  }
};

// src/services/ai/QueueManagerService.ts
var QueueManagerService = class extends CoreService {
  constructor(processOperation) {
    super("queue-manager", "Queue Manager Service");
    this.processOperation = processOperation;
    this.operationQueue = [];
    this.isProcessing = false;
    this.MAX_QUEUE_SIZE = 100;
    this.QUEUE_PROCESS_INTERVAL = 100;
  }
  initializeInternal() {
    return __async(this, null, function* () {
      this.startQueueProcessor();
    });
  }
  destroyInternal() {
    return __async(this, null, function* () {
      if (this.queueProcessorInterval) {
        clearInterval(this.queueProcessorInterval);
        this.queueProcessorInterval = void 0;
      }
    });
  }
  /**
   * Add operation to queue
   */
  enqueueOperation(operation) {
    if (this.operationQueue.length >= this.MAX_QUEUE_SIZE) {
      throw new Error("Operation queue is full");
    }
    this.operationQueue.push(operation);
    this.sortQueue();
  }
  /**
   * Sort queue by priority
   */
  sortQueue() {
    this.operationQueue.sort((a, b) => b.priority - a.priority);
  }
  /**
   * Get priority for operation type
   */
  getOperationPriority(type) {
    const priorities = {
      ["generation" /* Generation */]: 1,
      ["frontMatter" /* FrontMatter */]: 2,
      ["wikilink" /* Wikilink */]: 2,
      ["ontology" /* Ontology */]: 3,
      ["knowledgeBloom" /* KnowledgeBloom */]: 4
    };
    return priorities[type] || 1;
  }
  /**
   * Start queue processor
   */
  startQueueProcessor() {
    if (this.queueProcessorInterval) {
      clearInterval(this.queueProcessorInterval);
    }
    this.queueProcessorInterval = setInterval(
      () => this.processQueue(),
      this.QUEUE_PROCESS_INTERVAL
    );
  }
  /**
   * Process queued operations
   */
  processQueue() {
    return __async(this, null, function* () {
      if (this.isProcessing || this.operationQueue.length === 0) {
        return;
      }
      this.isProcessing = true;
      try {
        const operation = this.operationQueue[0];
        yield this.processOperation(operation);
        this.operationQueue = this.operationQueue.filter((op) => op.id !== operation.id);
      } finally {
        this.isProcessing = false;
      }
    });
  }
  /**
   * Get operation by ID
   */
  getOperation(operationId) {
    return this.operationQueue.find((op) => op.id === operationId);
  }
  /**
   * Get queue length
   */
  getQueueLength() {
    return this.operationQueue.length;
  }
  /**
   * Check if queue is processing
   */
  isQueueProcessing() {
    return this.isProcessing;
  }
  /**
   * Clear the queue
   */
  clearQueue() {
    this.operationQueue = [];
  }
};

// src/services/ai/OperationExecutor.ts
var OperationExecutor = class {
  constructor(metricsTracker, eventEmitter, queueManager) {
    this.metricsTracker = metricsTracker;
    this.eventEmitter = eventEmitter;
    this.queueManager = queueManager;
    this.currentOperation = null;
  }
  /**
   * Execute operation with tracking
   */
  execute(type, operation, metadata, config) {
    return __async(this, null, function* () {
      var _a;
      const operationId = this.generateOperationId();
      const queuedOperation = {
        id: operationId,
        type,
        priority: (_a = config == null ? void 0 : config.priority) != null ? _a : this.queueManager.getOperationPriority(type),
        startTime: Date.now(),
        execute: () => __async(this, null, function* () {
          const result = yield this.executeWithTracking(type, operation, metadata);
          return result.data;
        }),
        metadata
      };
      this.queueManager.enqueueOperation(queuedOperation);
      return this.waitForOperation(operationId);
    });
  }
  /**
   * Execute operation with tracking
   */
  executeWithTracking(type, operation, metadata) {
    return __async(this, null, function* () {
      const startTime = Date.now();
      const status = {
        type,
        startTime,
        metadata
      };
      try {
        this.currentOperation = status;
        this.eventEmitter.emitOperationStart(status);
        const result = yield operation();
        const endTime = Date.now();
        status.endTime = endTime;
        status.duration = endTime - startTime;
        status.success = true;
        this.eventEmitter.emitOperationComplete(status);
        return {
          success: true,
          data: result,
          duration: status.duration,
          metadata
        };
      } catch (error) {
        const endTime = Date.now();
        status.endTime = endTime;
        status.duration = endTime - startTime;
        status.success = false;
        status.error = error instanceof Error ? error.message : "Unknown error";
        this.eventEmitter.emitOperationError(
          error instanceof Error ? error : new Error(String(error)),
          status
        );
        return {
          success: false,
          error: status.error,
          duration: status.duration,
          metadata
        };
      } finally {
        this.currentOperation = null;
      }
    });
  }
  /**
   * Wait for operation completion with type-safe metrics
   */
  waitForOperation(operationId) {
    return __async(this, null, function* () {
      return new Promise((resolve, reject) => {
        const checkInterval = setInterval(() => {
          var _a, _b;
          const operation = this.queueManager.getOperation(operationId);
          if (!operation) {
            clearInterval(checkInterval);
            const metrics = this.metricsTracker.getAllMetrics();
            const defaultOperation = (_a = metrics["generation" /* Generation */]) == null ? void 0 : _a.lastOperation;
            const operationResult = (_b = defaultOperation == null ? void 0 : defaultOperation.metadata) == null ? void 0 : _b.result;
            if ((defaultOperation == null ? void 0 : defaultOperation.success) && operationResult !== void 0) {
              resolve(operationResult);
            } else {
              reject(new Error((defaultOperation == null ? void 0 : defaultOperation.error) || "Operation failed"));
            }
          }
        }, 50);
      });
    });
  }
  /**
   * Generate unique operation ID
   */
  generateOperationId() {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  /**
   * Get current operation
   */
  getCurrentOperation() {
    return this.currentOperation;
  }
};

// src/services/ai/AIOperationManager.ts
var AIOperationManager = class {
  constructor(adapterRegistry, generatorFactory) {
    this.adapterRegistry = adapterRegistry;
    this.generatorFactory = generatorFactory;
    // IService implementation
    this.serviceId = "ai-operation-manager";
    this.serviceName = "AI Operation Manager";
    this.serviceState = "uninitialized" /* Uninitialized */;
    this.serviceError = null;
    this.unsubscribers = [];
    // Public access methods for metrics and history
    this.getMetrics = () => this.metricsTracker.getAllMetrics();
    this.getHistory = () => this.metricsTracker.getHistory();
    this.clearHistory = () => this.metricsTracker.clearHistory();
    this.resetMetrics = () => this.metricsTracker.resetMetrics();
    this.eventEmitter = new OperationEventEmitter();
    this.metricsTracker = new MetricsTracker();
    this.queueManager = new QueueManagerService(this.processOperation.bind(this));
    this.operationExecutor = new OperationExecutor(
      this.metricsTracker,
      this.eventEmitter,
      this.queueManager
    );
  }
  /**
   * Initialize service and components
   */
  initialize() {
    return __async(this, null, function* () {
      try {
        this.serviceState = "initializing" /* Initializing */;
        yield this.metricsTracker.initialize();
        yield this.queueManager.initialize();
        this.setupEventListeners();
        this.serviceState = "ready" /* Ready */;
      } catch (error) {
        this.serviceState = "error" /* Error */;
        this.serviceError = ServiceError.from(this.serviceName, error);
        throw this.serviceError;
      }
    });
  }
  /**
   * Process a single operation
   */
  processOperation(operation) {
    return __async(this, null, function* () {
      yield operation.execute();
    });
  }
  /**
   * Set up event listeners
   */
  setupEventListeners() {
    this.eventEmitter.on("operationComplete", (status) => {
      this.metricsTracker.trackOperation(status);
      this.updateAIStore();
    });
    this.eventEmitter.on("operationError", (error, status) => {
      console.error(`Operation error (${status.type}):`, error);
      this.updateAIStore();
    });
    const aiStoreUnsub = aiStore.subscribe(() => {
    });
    this.unsubscribers.push(aiStoreUnsub);
  }
  /**
   * Check if service is ready
   */
  isReady() {
    return this.serviceState === "ready" /* Ready */;
  }
  /**
   * Get service state
   */
  getState() {
    return {
      state: this.serviceState,
      error: this.serviceError
    };
  }
  /**
   * Get the OperationExecutor instance
   */
  getOperationExecutor() {
    return this.operationExecutor;
  }
  /**
   * Clean up resources
   */
  destroy() {
    return __async(this, null, function* () {
      try {
        this.serviceState = "destroying" /* Destroying */;
        this.unsubscribers.forEach((unsub) => unsub());
        this.unsubscribers = [];
        yield this.queueManager.destroy();
        yield this.metricsTracker.destroy();
        this.eventEmitter.removeAllListeners();
        this.serviceState = "destroyed" /* Destroyed */;
      } catch (error) {
        this.serviceError = ServiceError.from(this.serviceName, error);
        throw this.serviceError;
      }
    });
  }
  /**
   * Generate AI response
   */
  generateResponse(prompt, config) {
    return __async(this, null, function* () {
      if (!this.isReady()) {
        throw new Error("AIOperationManager not ready");
      }
      return this.operationExecutor.execute(
        "generation" /* Generation */,
        () => __async(this, null, function* () {
          const adapter = this.adapterRegistry.getCurrentAdapter();
          const aiState2 = get_store_value(aiStore);
          return adapter.generateResponse(prompt, aiState2.currentModel);
        }),
        { prompt },
        config
      );
    });
  }
  /**
   * Generate front matter
   */
  generateFrontMatter(content, config) {
    return __async(this, null, function* () {
      if (!this.isReady()) {
        throw new Error("AIOperationManager not ready");
      }
      return this.operationExecutor.execute(
        "frontMatter" /* FrontMatter */,
        () => __async(this, null, function* () {
          const generator = yield this.generatorFactory.getGenerator("frontMatter" /* FrontMatter */);
          const result = yield generator.generate({ content });
          return result.content;
        }),
        { contentLength: content.length },
        config
      );
    });
  }
  /**
   * Update AI store state
   */
  updateAIStore() {
    aiStore.update((state) => {
      var _a;
      return __spreadProps(__spreadValues({}, state), {
        currentOperation: this.operationExecutor.getCurrentOperation(),
        queueLength: this.queueManager.getQueueLength(),
        operationMetrics: this.metricsTracker.getAllMetrics(),
        error: ((_a = this.serviceError) == null ? void 0 : _a.message) || state.error
      });
    });
  }
};

// src/services/ai/AIService.ts
var import_obsidian8 = require("obsidian");

// src/services/ai/AIServiceError.ts
var AIServiceError = class extends Error {
  constructor(message, originalError, context) {
    super(message);
    this.name = "AIServiceError";
    if (originalError instanceof Error) {
      this.originalError = originalError;
      this.stack = `${this.stack}
Caused by: ${originalError.stack}`;
    }
    if (context) {
      this.context = context;
    }
    Object.setPrototypeOf(this, AIServiceError.prototype);
  }
  /**
   * Get full error details including context
   */
  getDetails() {
    var _a;
    return {
      message: this.message,
      originalError: (_a = this.originalError) == null ? void 0 : _a.message,
      context: this.context,
      stack: this.stack
    };
  }
  /**
   * Create error from unknown error
   */
  static from(error, context) {
    if (error instanceof AIServiceError) {
      return error;
    }
    const message = error instanceof Error ? error.message : "Unknown error occurred";
    return new AIServiceError(message, error, context);
  }
};

// src/services/ai/AIGenerationService.ts
var AIGenerationService = class {
  constructor(generatorFactory) {
    this.generatorFactory = generatorFactory;
  }
  /**
   * Generate front matter content
   */
  generateFrontMatter(content) {
    return __async(this, null, function* () {
      try {
        const generator = yield this.generatorFactory.getGenerator("frontMatter" /* FrontMatter */);
        const result = yield generator.generate({ content });
        return result.content;
      } catch (error) {
        throw new AIServiceError("Failed to generate front matter", error);
      }
    });
  }
  /**
   * Generate wikilinks for content
   */
  generateWikilinks(content, existingPages) {
    return __async(this, null, function* () {
      try {
        const generator = yield this.generatorFactory.getGenerator("wikilink" /* Wikilink */);
        const result = yield generator.generate({ content, existingPages });
        return result.content;
      } catch (error) {
        throw new AIServiceError("Failed to generate wikilinks", error);
      }
    });
  }
  /**
   * Generate Knowledge Bloom content
   */
  generateKnowledgeBloom(sourceFile, userPrompt) {
    return __async(this, null, function* () {
      try {
        const generator = yield this.generatorFactory.getGenerator("knowledgeBloom" /* KnowledgeBloom */);
        return yield generator.generate({ sourceFile, userPrompt });
      } catch (error) {
        throw new AIServiceError("Failed to generate Knowledge Bloom", error);
      }
    });
  }
  /**
   * Generate ontology
   */
  generateOntology(input) {
    return __async(this, null, function* () {
      try {
        const generator = yield this.generatorFactory.getGenerator("ontology" /* Ontology */);
        return yield generator.generate(input);
      } catch (error) {
        throw new AIServiceError("Failed to generate ontology", error);
      }
    });
  }
};

// src/services/ai/AIService.ts
var AIService = class extends CoreService {
  constructor(app, operationManager, settingsService, jsonValidationService, databaseService, wikilinkProcessor, config = {}) {
    super("ai-service", "AI Service");
    this.app = app;
    this.operationManager = operationManager;
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    this.databaseService = databaseService;
    this.wikilinkProcessor = wikilinkProcessor;
    this.unsubscribers = [];
    this.config = __spreadValues({
      defaultProvider: "openai" /* OpenAI */,
      enableNotifications: true,
      debug: false
    }, config);
    this.adapterRegistry = new AdapterRegistry(
      settingsService,
      jsonValidationService
    );
    this.generatorFactory = new GeneratorFactory(
      app,
      settingsService,
      this.adapterRegistry,
      wikilinkProcessor
    );
  }
  /**
   * Initialize core components and services
   */
  initializeInternal() {
    return __async(this, null, function* () {
      try {
        yield this.adapterRegistry.initialize();
        yield this.generatorFactory.initialize();
        this.generationService = new AIGenerationService(this.generatorFactory);
        this.setupSubscriptions();
        aiStore.update((state) => __spreadProps(__spreadValues({}, state), {
          isInitialized: true
        }));
      } catch (error) {
        throw new ServiceError(
          this.serviceName,
          "Failed to initialize AI service",
          error instanceof Error ? error : void 0
        );
      }
    });
  }
  /**
   * Initialize core components
   */
  initializeComponents() {
    this.adapterRegistry = new AdapterRegistry(
      this.settingsService,
      this.jsonValidationService
    );
    this.generatorFactory = new GeneratorFactory(
      this.app,
      // App
      this.settingsService,
      // SettingsService
      this.adapterRegistry,
      // AdapterRegistry
      this.wikilinkProcessor
      // WikilinkTextProcessor
    );
  }
  /**
   * Set up store subscriptions
   */
  setupSubscriptions() {
    const settingsUnsub = settingsStore.subscribe((settings) => {
      if (this.config.debug) {
        console.log("\u{1F987} AI Service settings update:", settings);
      }
    });
    const aiStoreUnsub = aiStore.subscribe((state) => {
      if (this.config.debug) {
        console.log("\u{1F987} AI Service state update:", state);
      }
    });
    this.unsubscribers.push(settingsUnsub, aiStoreUnsub);
  }
  /**
   * Clean up resources
   */
  destroyInternal() {
    return __async(this, null, function* () {
      var _a, _b;
      try {
        this.unsubscribers.forEach((unsub) => unsub());
        this.unsubscribers = [];
        yield (_a = this.generatorFactory) == null ? void 0 : _a.resetAll();
        yield (_b = this.adapterRegistry) == null ? void 0 : _b.destroy();
        aiStore.update((state) => __spreadProps(__spreadValues({}, state), {
          isInitialized: false
        }));
      } catch (error) {
        throw new ServiceError(
          this.serviceName,
          "Failed to clean up AI service",
          error instanceof Error ? error : void 0
        );
      }
    });
  }
  /**
   * Configure the service
   */
  configure(config) {
    return __async(this, null, function* () {
      this.config = __spreadValues(__spreadValues({}, this.config), config);
      if (config.defaultProvider) {
        const currentProvider = this.getProviderFromStore();
        if (currentProvider !== config.defaultProvider) {
          yield this.adapterRegistry.testConnection(config.defaultProvider);
          this.updateAIStore({ provider: config.defaultProvider });
        }
      }
      if (this.config.debug) {
        console.log("\u{1F987} AI Service configured:", this.config);
      }
    });
  }
  /**
   * Get current provider from store
   */
  getProviderFromStore() {
    const state = get_store_value(aiStore);
    return state.provider;
  }
  /**
   * Reinitialize the service
   */
  reinitialize() {
    return __async(this, null, function* () {
      if (!this.isReady()) {
        throw new ServiceError(this.serviceName, "Cannot reinitialize when not ready");
      }
      try {
        yield this.destroy();
        this.initializeComponents();
        yield this.initialize();
        if (this.config.enableNotifications) {
          new import_obsidian8.Notice("AI Service reinitialized successfully");
        }
      } catch (error) {
        throw new ServiceError(
          this.serviceName,
          "Failed to reinitialize AI service",
          error instanceof Error ? error : void 0
        );
      }
    });
  }
  /**
   * Update AI store state
   */
  updateAIStore(update2) {
    aiStore.update((state) => __spreadValues(__spreadValues({}, state), update2));
  }
  /**
   * Get the current AI adapter
   */
  getCurrentAdapter() {
    return this.adapterRegistry.getCurrentAdapter();
  }
  /**
   * Get the current provider
   */
  getCurrentProvider() {
    return this.getProviderFromStore();
  }
  /**
   * Get the adapter registry
   */
  getAdapterRegistry() {
    if (!this.adapterRegistry) {
      throw new ServiceError(this.serviceName, "AdapterRegistry not initialized");
    }
    return this.adapterRegistry;
  }
  /**
   * Get the generator factory
   */
  getGeneratorFactory() {
    if (!this.generatorFactory) {
      throw new ServiceError(this.serviceName, "GeneratorFactory not initialized");
    }
    return this.generatorFactory;
  }
  /**
   * Get the generation service
   */
  getGenerationService() {
    if (!this.generationService) {
      this.generationService = new AIGenerationService(this.generatorFactory);
    }
    return this.generationService;
  }
  /**
   * Test connection to provider
   */
  testConnection(provider) {
    return __async(this, null, function* () {
      if (!this.isReady()) {
        yield this.initialize();
      }
      try {
        const result = yield this.adapterRegistry.testConnection(provider);
        if (this.config.enableNotifications) {
          new import_obsidian8.Notice(
            result ? `Successfully connected to ${provider}` : `Failed to connect to ${provider}`
          );
        }
        return result;
      } catch (error) {
        this.handleError("Failed to test connection", error);
        return false;
      }
    });
  }
};

// src/registrations/AIRegistrations.ts
var AI_SERVICES = [
  {
    id: "metricsTracker",
    name: "Metrics Tracker",
    factory: () => new MetricsTracker()
  },
  {
    id: "operationEventEmitter",
    name: "Operation Event Emitter",
    factory: () => new OperationEventEmitter()
  },
  {
    id: "adapterRegistry",
    name: "AI Adapter Registry",
    factory: ({ registry }) => new AdapterRegistry(
      registry.getService("settingsService"),
      registry.getService("jsonValidationService")
    ),
    dependencies: ["settingsService", "jsonValidationService"]
  },
  {
    id: "generatorFactory",
    name: "Generator Factory",
    factory: ({ app, registry }) => new GeneratorFactory(
      app,
      registry.getService("settingsService"),
      registry.getService("adapterRegistry"),
      registry.getService("wikilinkProcessor")
    ),
    dependencies: ["settingsService", "adapterRegistry", "wikilinkProcessor"]
  },
  {
    id: "queueManager",
    name: "Queue Manager",
    factory: () => new QueueManagerService((operation) => __async(void 0, null, function* () {
      console.log("\u{1F987} Processing operation:", operation);
      yield operation.execute();
    }))
  },
  {
    id: "aiOperationManager",
    name: "AI Operation Manager",
    factory: ({ registry }) => new AIOperationManager(
      registry.getService("adapterRegistry"),
      registry.getService("generatorFactory")
    ),
    dependencies: ["adapterRegistry", "generatorFactory"]
  },
  {
    id: "aiService",
    name: "AI Service",
    factory: ({ app, registry }) => new AIService(
      app,
      registry.getService("aiOperationManager"),
      registry.getService("settingsService"),
      registry.getService("jsonValidationService"),
      registry.getService("databaseService"),
      registry.getService("wikilinkProcessor"),
      {
        defaultProvider: "openai" /* OpenAI */,
        enableNotifications: true,
        debug: false
      }
    ),
    dependencies: [
      "aiOperationManager",
      "settingsService",
      "jsonValidationService",
      "databaseService",
      "wikilinkProcessor"
    ]
  }
];
function reportError2(message, error) {
  console.error(`\u{1F987} ${message}:`, error);
  errorStore.reportError({
    message: error ? `${message}: ${error.message}` : message,
    source: "AI Services Registration"
  });
}
function validateDependencies(dependencies, registry) {
  return __async(this, null, function* () {
    for (const depId of dependencies) {
      try {
        const service = registry.getService(depId);
        if (!service) {
          throw new Error(`Required dependency '${depId}' not found`);
        }
      } catch (error) {
        throw new ServiceError(
          "AIRegistrations",
          `Dependency validation failed for '${depId}'`,
          error instanceof Error ? error : void 0
        );
      }
    }
  });
}
function registerService2(config, context) {
  return __async(this, null, function* () {
    var _a;
    console.log(`\u{1F987} Registering ${config.name}...`);
    try {
      if ((_a = config.dependencies) == null ? void 0 : _a.length) {
        yield validateDependencies(config.dependencies, context.registry);
      }
      const service = config.factory(context);
      yield context.registry.registerService(config.id, service);
      if (typeof service.initialize === "function") {
        yield service.initialize();
      }
      console.log(`\u{1F987} Initialized ${config.name}`);
    } catch (error) {
      reportError2(`Failed to register ${config.name}`, error instanceof Error ? error : void 0);
      throw error;
    }
  });
}
function registerAIServices(app, plugin) {
  return __async(this, null, function* () {
    console.log("\u{1F987} Starting AI services registration");
    const registry = ServiceRegistry.getInstance();
    const context = { app, plugin, registry };
    try {
      for (const serviceConfig of AI_SERVICES) {
        yield registerService2(serviceConfig, context);
      }
      console.log("\u{1F987} AI Services registered successfully");
    } catch (error) {
      reportError2("Failed to register AI services", error instanceof Error ? error : void 0);
      throw error instanceof ServiceError ? error : new ServiceError("AIRegistrations", "AI services registration failed");
    }
  });
}

// src/services/file/FileProcessorService.ts
var import_obsidian10 = require("obsidian");

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// src/components/modals/BatchProcessorModal.svelte
var import_obsidian9 = require("obsidian");
function add_css(target) {
  append_styles(target, "svelte-95zn0x", '.batch-processor-modal.svelte-95zn0x.svelte-95zn0x{padding:var(--size-4);max-width:600px;width:100%}.modal-content.svelte-95zn0x.svelte-95zn0x{display:flex;flex-direction:column;gap:var(--size-4)}.modal-header.svelte-95zn0x.svelte-95zn0x{border-bottom:1px solid var(--background-modifier-border);padding-bottom:var(--size-4)}.modal-header.svelte-95zn0x h2.svelte-95zn0x{margin:0;color:var(--text-normal);font-size:var(--font-ui-large)}.modal-scrollable-content.svelte-95zn0x.svelte-95zn0x{max-height:400px;overflow-y:auto;padding:var(--size-2)}.file-tree-item.svelte-95zn0x.svelte-95zn0x{padding:var(--size-2) 0}.folder-header.svelte-95zn0x.svelte-95zn0x{display:flex;align-items:center;gap:var(--size-2)}.folder-toggle.svelte-95zn0x.svelte-95zn0x{cursor:pointer;transition:transform 0.2s ease;width:20px;height:20px;display:flex;align-items:center;justify-content:center}.folder-toggle.expanded.svelte-95zn0x.svelte-95zn0x{transform:rotate(90deg)}label.svelte-95zn0x.svelte-95zn0x{display:flex;align-items:center;gap:var(--size-2);cursor:pointer}input[type="checkbox"].svelte-95zn0x.svelte-95zn0x{cursor:pointer}.modal-footer.svelte-95zn0x.svelte-95zn0x{display:flex;justify-content:flex-end;gap:var(--size-4);padding-top:var(--size-4);border-top:1px solid var(--background-modifier-border)}button.svelte-95zn0x.svelte-95zn0x{padding:var(--size-2) var(--size-4);border-radius:var(--radius-s);border:none;cursor:pointer;font-weight:var(--font-bold)}button.mod-cta.svelte-95zn0x.svelte-95zn0x{background-color:var(--interactive-accent);color:var(--text-on-accent)}button.mod-cta.svelte-95zn0x.svelte-95zn0x:hover:not(:disabled){background-color:var(--interactive-accent-hover)}button.mod-cancel.svelte-95zn0x.svelte-95zn0x{background-color:var(--background-modifier-border);color:var(--text-normal)}button.mod-cancel.svelte-95zn0x.svelte-95zn0x:hover{background-color:var(--background-modifier-border-hover)}button.svelte-95zn0x.svelte-95zn0x:disabled{opacity:0.5;cursor:not-allowed}');
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  child_ctx[20] = list;
  child_ctx[21] = i;
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i];
  child_ctx[23] = list;
  child_ctx[24] = i;
  return child_ctx;
}
function create_else_block(ctx) {
  let label;
  let input;
  let input_aria_label_value;
  let t0;
  let t1_value = (
    /*node*/
    ctx[19].name + ""
  );
  let t1;
  let mounted;
  let dispose;
  function input_change_handler_2() {
    ctx[14].call(
      input,
      /*each_value*/
      ctx[20],
      /*node_index*/
      ctx[21]
    );
  }
  function change_handler_2(...args) {
    return (
      /*change_handler_2*/
      ctx[15](
        /*node*/
        ctx[19],
        ...args
      )
    );
  }
  return {
    c() {
      label = element("label");
      input = element("input");
      t0 = space();
      t1 = text(t1_value);
      attr(input, "type", "checkbox");
      attr(input, "aria-label", input_aria_label_value = `Select file ${/*node*/
      ctx[19].name}`);
      attr(input, "class", "svelte-95zn0x");
      attr(label, "class", "svelte-95zn0x");
    },
    m(target, anchor) {
      insert(target, label, anchor);
      append(label, input);
      input.checked = /*node*/
      ctx[19].selected;
      append(label, t0);
      append(label, t1);
      if (!mounted) {
        dispose = [
          listen(input, "change", input_change_handler_2),
          listen(input, "change", change_handler_2)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*vaultStructure*/
      2 && input_aria_label_value !== (input_aria_label_value = `Select file ${/*node*/
      ctx[19].name}`)) {
        attr(input, "aria-label", input_aria_label_value);
      }
      if (dirty & /*vaultStructure*/
      2) {
        input.checked = /*node*/
        ctx[19].selected;
      }
      if (dirty & /*vaultStructure*/
      2 && t1_value !== (t1_value = /*node*/
      ctx[19].name + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(label);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block(ctx) {
  let div1;
  let div0;
  let t1;
  let label;
  let input;
  let input_aria_label_value;
  let t2;
  let t3_value = (
    /*node*/
    ctx[19].name + ""
  );
  let t3;
  let div1_aria_expanded_value;
  let t4;
  let if_block_anchor;
  let mounted;
  let dispose;
  function input_change_handler() {
    ctx[8].call(
      input,
      /*each_value*/
      ctx[20],
      /*node_index*/
      ctx[21]
    );
  }
  function change_handler(...args) {
    return (
      /*change_handler*/
      ctx[9](
        /*node*/
        ctx[19],
        ...args
      )
    );
  }
  function click_handler(...args) {
    return (
      /*click_handler*/
      ctx[10](
        /*node*/
        ctx[19],
        ...args
      )
    );
  }
  function keydown_handler(...args) {
    return (
      /*keydown_handler*/
      ctx[11](
        /*node*/
        ctx[19],
        ...args
      )
    );
  }
  let if_block = (
    /*node*/
    ctx[19].expanded && /*node*/
    ctx[19].children && create_if_block_1(ctx)
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      div0.textContent = "\u25B6";
      t1 = space();
      label = element("label");
      input = element("input");
      t2 = space();
      t3 = text(t3_value);
      t4 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(div0, "class", "folder-toggle svelte-95zn0x");
      attr(div0, "aria-hidden", "true");
      toggle_class(
        div0,
        "expanded",
        /*node*/
        ctx[19].expanded
      );
      attr(input, "type", "checkbox");
      attr(input, "aria-label", input_aria_label_value = `Select folder ${/*node*/
      ctx[19].name}`);
      attr(input, "class", "svelte-95zn0x");
      attr(label, "class", "folder-label svelte-95zn0x");
      attr(div1, "class", "folder-header svelte-95zn0x");
      attr(div1, "role", "button");
      attr(div1, "tabindex", "0");
      attr(div1, "aria-expanded", div1_aria_expanded_value = /*node*/
      ctx[19].expanded);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div1, t1);
      append(div1, label);
      append(label, input);
      input.checked = /*node*/
      ctx[19].selected;
      append(label, t2);
      append(label, t3);
      insert(target, t4, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      if (!mounted) {
        dispose = [
          listen(input, "change", input_change_handler),
          listen(input, "change", change_handler),
          listen(div1, "click", click_handler),
          listen(div1, "keydown", keydown_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*vaultStructure*/
      2) {
        toggle_class(
          div0,
          "expanded",
          /*node*/
          ctx[19].expanded
        );
      }
      if (dirty & /*vaultStructure*/
      2 && input_aria_label_value !== (input_aria_label_value = `Select folder ${/*node*/
      ctx[19].name}`)) {
        attr(input, "aria-label", input_aria_label_value);
      }
      if (dirty & /*vaultStructure*/
      2) {
        input.checked = /*node*/
        ctx[19].selected;
      }
      if (dirty & /*vaultStructure*/
      2 && t3_value !== (t3_value = /*node*/
      ctx[19].name + ""))
        set_data(t3, t3_value);
      if (dirty & /*vaultStructure*/
      2 && div1_aria_expanded_value !== (div1_aria_expanded_value = /*node*/
      ctx[19].expanded)) {
        attr(div1, "aria-expanded", div1_aria_expanded_value);
      }
      if (
        /*node*/
        ctx[19].expanded && /*node*/
        ctx[19].children
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_1(ctx);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
        detach(t4);
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1(ctx) {
  let div;
  let div_aria_label_value;
  let each_value_1 = ensure_array_like(
    /*node*/
    ctx[19].children
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "folder-content");
      attr(div, "role", "group");
      attr(div, "aria-label", div_aria_label_value = `Contents of ${/*node*/
      ctx[19].name}`);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*vaultStructure, toggleSelection*/
      10) {
        each_value_1 = ensure_array_like(
          /*node*/
          ctx2[19].children
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty & /*vaultStructure*/
      2 && div_aria_label_value !== (div_aria_label_value = `Contents of ${/*node*/
      ctx2[19].name}`)) {
        attr(div, "aria-label", div_aria_label_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_1(ctx) {
  let div;
  let label;
  let input;
  let input_aria_label_value;
  let t0;
  let t1_value = (
    /*childNode*/
    ctx[22].name + ""
  );
  let t1;
  let t2;
  let mounted;
  let dispose;
  function input_change_handler_1() {
    ctx[12].call(
      input,
      /*each_value_1*/
      ctx[23],
      /*childNode_index*/
      ctx[24]
    );
  }
  function change_handler_1(...args) {
    return (
      /*change_handler_1*/
      ctx[13](
        /*childNode*/
        ctx[22],
        ...args
      )
    );
  }
  return {
    c() {
      div = element("div");
      label = element("label");
      input = element("input");
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      attr(input, "type", "checkbox");
      attr(input, "aria-label", input_aria_label_value = `Select ${/*childNode*/
      ctx[22].type} ${/*childNode*/
      ctx[22].name}`);
      attr(input, "class", "svelte-95zn0x");
      attr(label, "class", "svelte-95zn0x");
      attr(div, "class", "file-tree-item svelte-95zn0x");
      set_style(div, "margin-left", "20px");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(label, input);
      input.checked = /*childNode*/
      ctx[22].selected;
      append(label, t0);
      append(label, t1);
      append(div, t2);
      if (!mounted) {
        dispose = [
          listen(input, "change", input_change_handler_1),
          listen(input, "change", change_handler_1)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*vaultStructure*/
      2 && input_aria_label_value !== (input_aria_label_value = `Select ${/*childNode*/
      ctx[22].type} ${/*childNode*/
      ctx[22].name}`)) {
        attr(input, "aria-label", input_aria_label_value);
      }
      if (dirty & /*vaultStructure*/
      2) {
        input.checked = /*childNode*/
        ctx[22].selected;
      }
      if (dirty & /*vaultStructure*/
      2 && t1_value !== (t1_value = /*childNode*/
      ctx[22].name + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block(ctx) {
  let div;
  let t;
  function select_block_type(ctx2, dirty) {
    if (
      /*node*/
      ctx2[19].type === "folder"
    )
      return create_if_block;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      t = space();
      attr(div, "class", "file-tree-item svelte-95zn0x");
      set_style(
        div,
        "margin-left",
        /*node*/
        ctx[19].type === "folder" ? "0" : "20px"
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_block.m(div, null);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, t);
        }
      }
      if (dirty & /*vaultStructure*/
      2) {
        set_style(
          div,
          "margin-left",
          /*node*/
          ctx2[19].type === "folder" ? "0" : "20px"
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_block.d();
    }
  };
}
function create_fragment(ctx) {
  let div3;
  let div2;
  let header;
  let t1;
  let div0;
  let t2;
  let div1;
  let button0;
  let t3;
  let button0_disabled_value;
  let t4;
  let button1;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*vaultStructure*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      header = element("header");
      header.innerHTML = `<h2 class="svelte-95zn0x">Select Files/Folders to Process</h2>`;
      t1 = space();
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      div1 = element("div");
      button0 = element("button");
      t3 = text("Process Selected");
      t4 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      attr(header, "class", "modal-header svelte-95zn0x");
      attr(div0, "class", "modal-scrollable-content svelte-95zn0x");
      attr(button0, "class", "mod-cta svelte-95zn0x");
      button0.disabled = button0_disabled_value = /*selectedPaths*/
      ctx[2].size === 0;
      attr(button1, "class", "mod-cancel svelte-95zn0x");
      attr(div1, "class", "modal-footer svelte-95zn0x");
      attr(div2, "class", "modal-content svelte-95zn0x");
      attr(div3, "class", "batch-processor-modal svelte-95zn0x");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, header);
      append(div2, t1);
      append(div2, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      append(div2, t2);
      append(div2, div1);
      append(div1, button0);
      append(button0, t3);
      append(div1, t4);
      append(div1, button1);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*handleProcess*/
            ctx[4]
          ),
          listen(button1, "click", function() {
            if (is_function(
              /*onClose*/
              ctx[0]
            ))
              ctx[0].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*vaultStructure, toggleSelection, toggleFolder*/
      10) {
        each_value = ensure_array_like(
          /*vaultStructure*/
          ctx[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div0, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*selectedPaths*/
      4 && button0_disabled_value !== (button0_disabled_value = /*selectedPaths*/
      ctx[2].size === 0)) {
        button0.disabled = button0_disabled_value;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function toggleFolder(node, event) {
  if (event instanceof KeyboardEvent && event.key !== "Enter" && event.key !== " ") {
    return;
  }
  event.preventDefault();
  node.expanded = !node.expanded;
}
function instance($$self, $$props, $$invalidate) {
  var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  let { app } = $$props;
  let { aiService } = $$props;
  let { settingsService } = $$props;
  let { onClose } = $$props;
  let vaultStructure = [];
  let selectedPaths = /* @__PURE__ */ new Set();
  onMount(() => {
    buildVaultStructure();
  });
  function buildVaultStructure() {
    const rootFolder = app.vault.getRoot();
    $$invalidate(1, vaultStructure = rootFolder.children.filter((child) => child instanceof import_obsidian9.TFolder || child instanceof import_obsidian9.TFile).map((child) => createNode(child)));
  }
  function createNode(item) {
    if (item instanceof import_obsidian9.TFile) {
      return {
        name: item.name,
        path: item.path,
        type: "file",
        selected: false
      };
    } else {
      return {
        name: item.name,
        path: item.path,
        type: "folder",
        children: item.children.filter((child) => child instanceof import_obsidian9.TFolder || child instanceof import_obsidian9.TFile).map((child) => createNode(child)),
        selected: false,
        expanded: false
      };
    }
  }
  function toggleSelection(node, selected) {
    node.selected = selected;
    if (selected) {
      selectedPaths.add(node.path);
    } else {
      selectedPaths.delete(node.path);
    }
    $$invalidate(2, selectedPaths);
    if (node.type === "folder" && node.children) {
      node.children.forEach((child) => toggleSelection(child, selected));
    }
  }
  function handleProcess() {
    return __awaiter(this, void 0, void 0, function* () {
      if (selectedPaths.size === 0) {
        new import_obsidian9.Notice("No files or folders selected.");
        return;
      }
      try {
        new import_obsidian9.Notice("Processing started...");
        new import_obsidian9.Notice("Batch processing completed.");
        onClose();
      } catch (error) {
        console.error("Error processing files:", error);
        new import_obsidian9.Notice(`Error processing files: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    });
  }
  function input_change_handler(each_value, node_index) {
    each_value[node_index].selected = this.checked;
    $$invalidate(1, vaultStructure);
  }
  const change_handler = (node, e) => toggleSelection(node, e.currentTarget.checked);
  const click_handler = (node, e) => toggleFolder(node, e);
  const keydown_handler = (node, e) => toggleFolder(node, e);
  function input_change_handler_1(each_value_1, childNode_index) {
    each_value_1[childNode_index].selected = this.checked;
    $$invalidate(1, vaultStructure);
  }
  const change_handler_1 = (childNode, e) => toggleSelection(childNode, e.currentTarget.checked);
  function input_change_handler_2(each_value, node_index) {
    each_value[node_index].selected = this.checked;
    $$invalidate(1, vaultStructure);
  }
  const change_handler_2 = (node, e) => toggleSelection(node, e.currentTarget.checked);
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(5, app = $$props2.app);
    if ("aiService" in $$props2)
      $$invalidate(6, aiService = $$props2.aiService);
    if ("settingsService" in $$props2)
      $$invalidate(7, settingsService = $$props2.settingsService);
    if ("onClose" in $$props2)
      $$invalidate(0, onClose = $$props2.onClose);
  };
  return [
    onClose,
    vaultStructure,
    selectedPaths,
    toggleSelection,
    handleProcess,
    app,
    aiService,
    settingsService,
    input_change_handler,
    change_handler,
    click_handler,
    keydown_handler,
    input_change_handler_1,
    change_handler_1,
    input_change_handler_2,
    change_handler_2
  ];
}
var BatchProcessorModal = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        app: 5,
        aiService: 6,
        settingsService: 7,
        onClose: 0
      },
      add_css
    );
  }
};
var BatchProcessorModal_default = BatchProcessorModal;

// src/services/file/FileProcessorService.ts
var FileProcessorService = class extends CoreService {
  constructor(app, aiService, settingsService, databaseService, fileScanner, generatorFactory, store) {
    super("file-processor", "File Processor Service");
    this.app = app;
    this.aiService = aiService;
    this.settingsService = settingsService;
    this.databaseService = databaseService;
    this.fileScanner = fileScanner;
    this.generatorFactory = generatorFactory;
    this.store = store;
    this.batchHandler = null;
  }
  /**
   * Initialize the service
   */
  initializeInternal() {
    return __async(this, null, function* () {
      try {
        if (!this.fileScanner || !this.generatorFactory) {
          throw new Error("Required services not available");
        }
      } catch (error) {
        throw new ServiceError(
          this.serviceName,
          "Failed to initialize file processor",
          error instanceof Error ? error : void 0
        );
      }
    });
  }
  /**
   * Clean up resources
   */
  destroyInternal() {
    return __async(this, null, function* () {
      var _a;
      (_a = this.batchHandler) == null ? void 0 : _a.close();
      this.batchHandler = null;
    });
  }
  /**
   * Process a single file with specified options
   */
  processSingleFile(file, options) {
    return __async(this, null, function* () {
      var _a, _b;
      if (!this.isReady()) {
        throw new ServiceError(this.serviceName, "Service not ready");
      }
      const startTime = Date.now();
      let frontMatterGenerated = false;
      let wikilinksGenerated = false;
      try {
        const settings = this.settingsService.getSettings();
        const generateFM = (_a = options == null ? void 0 : options.generateFrontMatter) != null ? _a : settings.frontMatter.autoGenerate;
        const generateWL = (_b = options == null ? void 0 : options.generateWikilinks) != null ? _b : settings.advanced.generateWikilinks;
        if (generateFM) {
          const hasFM = yield this.fileScanner.hasFrontMatter(file);
          if (!hasFM) {
            yield this.generateFrontMatter(file);
            frontMatterGenerated = true;
          }
        }
        if (generateWL) {
          const wikilinkResult = yield this.generateWikilinks(file);
          wikilinksGenerated = wikilinkResult.success;
        }
        const processingTime = Date.now() - startTime;
        const result = {
          success: true,
          path: file.path,
          frontMatterGenerated,
          wikilinksGenerated,
          processingTime
        };
        yield this.handleSuccess(file, result);
        return result;
      } catch (error) {
        const processingTime = Date.now() - startTime;
        this.handleProcessingError("Failed to process file", error);
        return {
          success: false,
          path: file.path,
          frontMatterGenerated,
          wikilinksGenerated,
          processingTime,
          error: error instanceof Error ? error.message : "Unknown error"
        };
      }
    });
  }
  /**
   * Generate front matter for a file
   */
  generateFrontMatter(file) {
    return __async(this, null, function* () {
      const frontMatter = `---
title: ${file.basename}
created: ${new Date().toISOString()}
---
`;
      const content = yield this.app.vault.read(file);
      yield this.app.vault.modify(file, frontMatter + content);
    });
  }
  /**
   * Generate wikilinks using WikilinkGenerator
   */
  generateWikilinks(file) {
    return __async(this, null, function* () {
      try {
        const content = yield this.app.vault.read(file);
        const existingPages = this.getExistingPageNames();
        const existingWikilinks = this.extractExistingWikilinks(content);
        const wikilinkGenerator = yield this.generatorFactory.getWikilinkGenerator();
        yield wikilinkGenerator.initialize();
        const result = yield wikilinkGenerator.generate({
          content,
          existingPages
        });
        yield this.app.vault.modify(file, result.content);
        return { success: true };
      } catch (error) {
        console.error(`Failed to generate wikilinks for ${file.path}:`, error);
        throw error;
      }
    });
  }
  /**
   * Extract existing wikilinks from content
   */
  extractExistingWikilinks(content) {
    const regex = /\[\[([^\]]+)\]\]/g;
    const existingLinks = /* @__PURE__ */ new Set();
    let match;
    while ((match = regex.exec(content)) !== null) {
      const link = match[1].split("|")[0].trim().toLowerCase();
      existingLinks.add(link);
    }
    return existingLinks;
  }
  /**
   * Get existing page names in the vault
   */
  getExistingPageNames() {
    return this.app.vault.getMarkdownFiles().map((file) => file.basename);
  }
  /**
   * Handle successful processing
   */
  handleSuccess(file, result) {
    return __async(this, null, function* () {
      yield this.databaseService.markFileAsProcessed(file, result);
      this.store.update((state) => __spreadProps(__spreadValues({}, state), {
        isProcessing: false,
        currentFile: null,
        // Changed from undefined to null
        progress: 100,
        error: null,
        // Changed from undefined to null
        queue: [],
        state: "idle" /* IDLE */,
        filesQueued: 0,
        filesProcessed: 0,
        filesRemaining: 0,
        errors: [],
        startTime: null,
        // Changed from undefined to null
        estimatedTimeRemaining: null
        // Changed from undefined to null
      }));
      new import_obsidian10.Notice(`Successfully processed ${file.basename}`);
    });
  }
  handleProcessingError(message, error, file) {
    console.error("Processing error:", error);
    if (file) {
      new import_obsidian10.Notice(`Error processing file ${file.path}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
    this.store.update((state) => __spreadProps(__spreadValues({}, state), {
      isProcessing: false,
      currentFile: null,
      // Changed from undefined to null
      progress: 0,
      error: error instanceof Error ? error.message : "Unknown error",
      queue: [],
      state: "error" /* ERROR */,
      filesQueued: 0,
      filesProcessed: 0,
      filesRemaining: 0,
      errors: [
        ...state.errors,
        {
          filePath: (file == null ? void 0 : file.path) || "unknown",
          error: error instanceof Error ? error.message : "Unknown error",
          timestamp: Date.now(),
          retryCount: 0
        }
      ],
      startTime: null,
      estimatedTimeRemaining: null
    }));
  }
  /**
   * Open the batch processor modal
   */
  openBatchProcessor() {
    if (!this.isReady()) {
      throw new ServiceError(this.serviceName, "Service not ready");
    }
    this.batchHandler = new BatchProcessorModal_default({
      target: this.app.workspace.containerEl,
      props: {
        app: this.app,
        aiService: this.aiService,
        settingsService: this.settingsService,
        onClose: () => {
          this.batchHandler = null;
        }
      }
    });
  }
};

// src/generators/BatchProcessor.ts
var import_obsidian11 = require("obsidian");
var import_events3 = require("events");

// src/services/file/BatchHandler.ts
var BatchHandler = class {
  constructor(processFile, options, maxRetries, retryDelay) {
    this.processFile = processFile;
    this.options = options;
    this.maxRetries = maxRetries;
    this.retryDelay = retryDelay;
  }
  processBatches(batches) {
    return __async(this, null, function* () {
      for (const batch of batches) {
        yield Promise.all(
          batch.map(
            (file) => this.processFile(file)
          )
        );
        if (this.options.delayBetweenChunks > 0) {
          yield delay(this.options.delayBetweenChunks);
        }
      }
    });
  }
  createBatches(files) {
    const batches = [];
    const batchSize = this.options.chunkSize;
    for (let i = 0; i < files.length; i += batchSize) {
      batches.push(files.slice(i, i + batchSize));
    }
    return batches;
  }
};
function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// src/types/constants.ts
var DEFAULT_PROCESSING_OPTIONS = {
  chunkSize: 10,
  delayBetweenChunks: 1e3,
  maxRetries: 3,
  generateFrontMatter: true,
  generateWikilinks: false,
  maxConcurrentProcessing: 3
};
var CACHE_DURATIONS = {
  MODEL_LIST: 24 * 60 * 60 * 1e3,
  // 24 hours
  FILE_SCAN: 5 * 60 * 1e3,
  // 5 minutes
  API_KEY: 12 * 60 * 60 * 1e3
  // 12 hours
};
var VALIDATION_LIMITS = {
  MAX_FILE_SIZE: 1024 * 1024 * 10,
  // 10MB
  MAX_BATCH_SIZE: 50,
  MAX_CONCURRENT_REQUESTS: 5,
  MIN_CHUNK_SIZE: 1,
  MAX_CHUNK_SIZE: 100
};

// src/generators/BatchProcessor.ts
var BatchProcessor = class extends import_events3.EventEmitter {
  constructor(app, coreService, statusBar) {
    super();
    this.app = app;
    this.coreService = coreService;
    this.statusBar = statusBar;
    const defaultState = this.createInitialProcessingState();
    this.state = {
      status: {
        state: defaultState,
        filesQueued: 0,
        filesProcessed: 0,
        filesRemaining: 0,
        currentFile: void 0,
        // Changed from null to undefined
        startTime: 0,
        errors: []
      },
      options: __spreadValues({}, DEFAULT_PROCESSING_OPTIONS),
      isProcessing: false,
      isPaused: false,
      results: [],
      startTime: 0,
      batchHandler: null
    };
  }
  //  Public API Methods
  process(input) {
    return __async(this, null, function* () {
      this.validateInput(input);
      this.initializeProcessing(input);
      try {
        const tfiles = this.getValidFiles(input.files);
        yield this.initializeBatchHandler(tfiles, input);
        yield this.processBatches(this.state.batchHandler.createBatches(tfiles));
        return this.generateStats();
      } catch (error) {
        this.handleError(this.normalizeError(error));
        throw error;
      } finally {
        this.cleanup();
      }
    });
  }
  pause() {
    this.state.isPaused = true;
    this.updateStatusAndEmit("paused" /* PAUSED */);
  }
  resume() {
    this.state.isPaused = false;
    this.updateStatusAndEmit("running" /* RUNNING */);
  }
  //  Private Processing Methods
  processBatches(batches) {
    return __async(this, null, function* () {
      for (const [index, batch] of batches.entries()) {
        yield this.processSingleBatch(batch, index, batches.length);
      }
    });
  }
  processSingleBatch(batch, index, total) {
    return __async(this, null, function* () {
      if (this.state.isPaused) {
        yield this.waitForResume();
      }
      const batchInfo = {
        files: batch.map((f) => f.path),
        index,
        size: batch.length
      };
      this.emit("chunkStart", batchInfo);
      yield this.state.batchHandler.processBatches([batch]);
      this.emit("chunkComplete", batchInfo);
    });
  }
  processFile(file, input) {
    return __async(this, null, function* () {
      this.emit("fileStart", { file: file.path });
      try {
        const result = yield this.executeFileProcessing(file, input);
        this.updateFileProgress(file.path, result);
        this.emit("fileComplete", { result });
      } catch (error) {
        this.handleFileError(file.path, this.normalizeError(error));
      }
    });
  }
  //  State Management Methods
  updateStatusAndEmit(newState) {
    this.updateStatus({
      state: this.createProcessingState(newState)
    });
  }
  //  Create initial processing state without dependencies
  createInitialProcessingState() {
    return {
      isProcessing: false,
      currentFile: null,
      queue: [],
      progress: 0,
      state: "idle" /* IDLE */,
      filesQueued: 0,
      filesProcessed: 0,
      filesRemaining: 0,
      errors: [],
      error: null,
      startTime: null,
      estimatedTimeRemaining: null
    };
  }
  createProcessingState(state) {
    if (!this.state) {
      return this.createInitialProcessingState();
    }
    const { status, isProcessing, startTime } = this.state;
    return {
      isProcessing,
      currentFile: status.currentFile || null,
      // Ensures null when undefined
      queue: [],
      progress: this.calculateProgress(),
      state,
      filesQueued: status.filesQueued,
      filesProcessed: status.filesProcessed,
      filesRemaining: status.filesRemaining,
      errors: status.errors,
      error: null,
      startTime: startTime || null,
      estimatedTimeRemaining: this.calculateETA()
    };
  }
  updateStatus(update2) {
    this.state.status = __spreadValues(__spreadValues({}, this.state.status), update2);
    this.emit("stateChanged", {
      state: this.state.status.state,
      currentFile: this.state.status.currentFile,
      progress: this.calculateProgress(),
      status: this.state.status
    });
  }
  //  Utility Methods
  calculateProgress() {
    const { filesProcessed, filesQueued } = this.state.status;
    return filesQueued === 0 ? 0 : filesProcessed / filesQueued * 100;
  }
  calculateETA() {
    const { filesProcessed, filesRemaining } = this.state.status;
    if (filesProcessed === 0)
      return null;
    const elapsed = Date.now() - this.state.startTime;
    const averageTimePerFile = elapsed / filesProcessed;
    return averageTimePerFile * filesRemaining;
  }
  calculateAverageProcessingTime() {
    const { results } = this.state;
    if (results.length === 0)
      return 0;
    const totalTime = results.reduce((sum, r) => sum + r.processingTime, 0);
    return totalTime / results.length;
  }
  //  Initialization Methods
  initializeStatus() {
    const defaultState = this.createProcessingState("idle" /* IDLE */);
    return {
      state: defaultState,
      filesQueued: 0,
      filesProcessed: 0,
      filesRemaining: 0,
      currentFile: void 0,
      // Changed from null to undefined
      startTime: 0,
      errors: []
    };
  }
  initializeProcessing(input) {
    Object.assign(this.state, {
      isProcessing: true,
      startTime: Date.now(),
      results: [],
      options: __spreadValues(__spreadValues({}, this.state.options), input.options)
    });
    this.updateStatus({
      state: this.createProcessingState("running" /* RUNNING */),
      filesQueued: input.files.length,
      filesProcessed: 0,
      filesRemaining: input.files.length,
      startTime: this.state.startTime,
      errors: []
    });
    this.emit("start", { status: this.state.status });
  }
  initializeBatchHandler(files, input) {
    return __async(this, null, function* () {
      this.state.batchHandler = new BatchHandler(
        (file) => __async(this, null, function* () {
          return this.processFile(file, input);
        }),
        this.state.options,
        this.state.options.maxRetries,
        this.state.options.delayBetweenChunks
      );
    });
  }
  //  Helper Methods
  executeFileProcessing(file, input) {
    return __async(this, null, function* () {
      const startTime = Date.now();
      yield this.state.batchHandler.processBatches([[file]]);
      return {
        success: true,
        path: file.path,
        frontMatterGenerated: input.generateFrontMatter,
        wikilinksGenerated: input.generateWikilinks,
        processingTime: Date.now() - startTime
      };
    });
  }
  updateFileProgress(filePath, result) {
    this.state.results.push(result);
    this.state.status.filesProcessed++;
    this.state.status.filesRemaining--;
    this.statusBar.updateFromState({
      currentFile: filePath,
      progress: this.calculateProgress(),
      status: this.state.status
    });
  }
  getValidFiles(filePaths) {
    return filePaths.map((path) => this.app.vault.getAbstractFileByPath(path)).filter((file) => file instanceof import_obsidian11.TFile);
  }
  validateInput(input) {
    if (!Array.isArray(input.files) || input.files.length === 0 || typeof input.generateFrontMatter !== "boolean" || typeof input.generateWikilinks !== "boolean") {
      throw new Error("Invalid batch input");
    }
  }
  //  Error Handling Methods
  normalizeError(error) {
    return error instanceof Error ? error : new Error(String(error));
  }
  handleError(error) {
    this.updateStatus({
      state: this.createProcessingState("error" /* ERROR */)
    });
    this.emit("error", {
      filePath: this.state.status.currentFile || "",
      error: error.message,
      timestamp: Date.now(),
      retryCount: 0
    });
  }
  handleFileError(filePath, error) {
    const newError = {
      filePath,
      error: error.message,
      timestamp: Date.now(),
      retryCount: 0
    };
    this.state.status.errors.push(newError);
    this.emit("error", newError);
  }
  //  Cleanup and Management Methods
  cleanup() {
    this.state.isProcessing = false;
    this.updateStatus({
      state: this.createProcessingState("idle" /* IDLE */)
    });
  }
  waitForResume() {
    return __async(this, null, function* () {
      return new Promise((resolve) => {
        const resumeHandler = () => {
          this.off("resume", resumeHandler);
          resolve();
        };
        this.on("resume", resumeHandler);
      });
    });
  }
  generateStats() {
    const endTime = Date.now();
    return {
      totalFiles: this.state.status.filesQueued,
      processedFiles: this.state.status.filesProcessed,
      skippedFiles: 0,
      errorFiles: this.state.status.errors.length,
      startTime: this.state.startTime,
      endTime,
      averageProcessingTime: this.calculateAverageProcessingTime(),
      timestamp: endTime
    };
  }
};

// src/registrations/FileRegistrations.ts
var BatchProcessorService = class {
  constructor(app, fileProcessor, operationExecutor) {
    this.serviceId = "batchProcessor";
    this.serviceName = "Batch Processor Service";
    this.batchProcessor = new BatchProcessor(
      app,
      fileProcessor,
      operationExecutor
    );
  }
  initialize() {
    return __async(this, null, function* () {
      return Promise.resolve();
    });
  }
  isReady() {
    return true;
  }
  destroy() {
    return __async(this, null, function* () {
      return Promise.resolve();
    });
  }
  getState() {
    return {};
  }
  // Expose the underlying batch processor methods
  getBatchProcessor() {
    return this.batchProcessor;
  }
};
function registerFileServices(app) {
  return __async(this, null, function* () {
    const registry = ServiceRegistry.getInstance();
    try {
      const aiService = registry.getService("aiService");
      const settingsService = registry.getService("settingsService");
      const databaseService = registry.getService("databaseService");
      const fileScannerService = registry.getService("fileScanner");
      const generatorFactory = registry.getService("generatorFactory");
      const operationManager = registry.getService("aiOperationManager");
      yield registry.registerService(
        "fileProcessorService",
        new FileProcessorService(
          app,
          aiService,
          settingsService,
          databaseService,
          fileScannerService,
          generatorFactory,
          processingStore
        )
      );
      yield registry.registerService(
        "batchProcessor",
        new BatchProcessorService(
          app,
          registry.getService("fileProcessorService"),
          operationManager.getOperationExecutor()
        ),
        ["fileProcessorService", "aiOperationManager", "generatorFactory"]
        // Dependencies array
      );
      console.log("\u{1F987} File services registered successfully");
    } catch (error) {
      console.error("\u{1F987} Failed to register file services:", error);
      throw error;
    }
  });
}

// src/settings/GraphWeaverSettingTab.ts
var import_obsidian23 = require("obsidian");

// node_modules/flowbite-svelte/dist/utils/Frame.svelte
var import_tailwind_merge = __toESM(require_bundle_cjs());
function create_dynamic_element(ctx) {
  let svelte_element;
  let use_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  let svelte_element_levels = [
    { role: (
      /*role*/
      ctx[4]
    ) },
    /*$$restProps*/
    ctx[6],
    { class: (
      /*divClass*/
      ctx[5]
    ) }
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  return {
    c() {
      svelte_element = element(
        /*tag*/
        ctx[1]
      );
      if (default_slot)
        default_slot.c();
      set_dynamic_element_data(
        /*tag*/
        ctx[1]
      )(svelte_element, svelte_element_data);
    },
    m(target, anchor) {
      insert(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      ctx[18](svelte_element);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(use_action = /*use*/
          ctx[2].call(
            null,
            svelte_element,
            /*options*/
            ctx[3]
          )),
          listen(
            svelte_element,
            "click",
            /*click_handler*/
            ctx[13]
          ),
          listen(
            svelte_element,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[14]
          ),
          listen(
            svelte_element,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[15]
          ),
          listen(
            svelte_element,
            "focusin",
            /*focusin_handler*/
            ctx[16]
          ),
          listen(
            svelte_element,
            "focusout",
            /*focusout_handler*/
            ctx[17]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_dynamic_element_data(
        /*tag*/
        ctx2[1]
      )(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty & /*role*/
        16) && { role: (
          /*role*/
          ctx2[4]
        ) },
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6],
        (!current || dirty & /*divClass*/
        32) && { class: (
          /*divClass*/
          ctx2[5]
        ) }
      ]));
      if (use_action && is_function(use_action.update) && dirty & /*options*/
      8)
        use_action.update.call(
          null,
          /*options*/
          ctx2[3]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[18](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment2(ctx) {
  let previous_tag = (
    /*tag*/
    ctx[1]
  );
  let svelte_element_anchor;
  let current;
  let svelte_element = (
    /*tag*/
    ctx[1] && create_dynamic_element(ctx)
  );
  return {
    c() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    m(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert(target, svelte_element_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*tag*/
        ctx2[1]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*tag*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*tag*/
          ctx2[1]
        )) {
          svelte_element.d(1);
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*tag*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*tag*/
        ctx2[1];
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(svelte_element, local);
      current = true;
    },
    o(local) {
      transition_out(svelte_element, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element_anchor);
      }
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  const omit_props_names = ["tag", "color", "rounded", "border", "shadow", "node", "use", "options", "role"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const noop2 = () => {
  };
  setContext("background", true);
  let { tag = $$restProps.href ? "a" : "div" } = $$props;
  let { color = "default" } = $$props;
  let { rounded = false } = $$props;
  let { border = false } = $$props;
  let { shadow = false } = $$props;
  let { node = void 0 } = $$props;
  let { use = noop2 } = $$props;
  let { options = {} } = $$props;
  let { role = void 0 } = $$props;
  const bgColors = {
    gray: "bg-gray-50 dark:bg-gray-800",
    red: "bg-red-50 dark:bg-gray-800",
    yellow: "bg-yellow-50 dark:bg-gray-800 ",
    green: "bg-green-50 dark:bg-gray-800 ",
    indigo: "bg-indigo-50 dark:bg-gray-800 ",
    purple: "bg-purple-50 dark:bg-gray-800 ",
    pink: "bg-pink-50 dark:bg-gray-800 ",
    blue: "bg-blue-50 dark:bg-gray-800 ",
    light: "bg-gray-50 dark:bg-gray-700",
    dark: "bg-gray-50 dark:bg-gray-800",
    default: "bg-white dark:bg-gray-800",
    dropdown: "bg-white dark:bg-gray-700",
    navbar: "bg-white dark:bg-gray-900",
    navbarUl: "bg-gray-50 dark:bg-gray-800",
    form: "bg-gray-50 dark:bg-gray-700",
    primary: "bg-primary-50 dark:bg-gray-800 ",
    orange: "bg-orange-50 dark:bg-orange-800",
    none: ""
  };
  const textColors = {
    gray: "text-gray-800 dark:text-gray-300",
    red: "text-red-800 dark:text-red-400",
    yellow: "text-yellow-800 dark:text-yellow-300",
    green: "text-green-800 dark:text-green-400",
    indigo: "text-indigo-800 dark:text-indigo-400",
    purple: "text-purple-800 dark:text-purple-400",
    pink: "text-pink-800 dark:text-pink-400",
    blue: "text-blue-800 dark:text-blue-400",
    light: "text-gray-700 dark:text-gray-300",
    dark: "text-gray-700 dark:text-gray-300",
    default: "text-gray-500 dark:text-gray-400",
    dropdown: "text-gray-700 dark:text-gray-200",
    navbar: "text-gray-700 dark:text-gray-200",
    navbarUl: "text-gray-700 dark:text-gray-400",
    form: "text-gray-900 dark:text-white",
    primary: "text-primary-800 dark:text-primary-400",
    orange: "text-orange-800 dark:text-orange-400",
    none: ""
  };
  const borderColors = {
    gray: "border-gray-300 dark:border-gray-800 divide-gray-300 dark:divide-gray-800",
    red: "border-red-300 dark:border-red-800 divide-red-300 dark:divide-red-800",
    yellow: "border-yellow-300 dark:border-yellow-800 divide-yellow-300 dark:divide-yellow-800",
    green: "border-green-300 dark:border-green-800 divide-green-300 dark:divide-green-800",
    indigo: "border-indigo-300 dark:border-indigo-800 divide-indigo-300 dark:divide-indigo-800",
    purple: "border-purple-300 dark:border-purple-800 divide-purple-300 dark:divide-purple-800",
    pink: "border-pink-300 dark:border-pink-800 divide-pink-300 dark:divide-pink-800",
    blue: "border-blue-300 dark:border-blue-800 divide-blue-300 dark:divide-blue-800",
    light: "border-gray-500 divide-gray-500",
    dark: "border-gray-500 divide-gray-500",
    default: "border-gray-200 dark:border-gray-700 divide-gray-200 dark:divide-gray-700",
    dropdown: "border-gray-100 dark:border-gray-600 divide-gray-100 dark:divide-gray-600",
    navbar: "border-gray-100 dark:border-gray-700 divide-gray-100 dark:divide-gray-700",
    navbarUl: "border-gray-100 dark:border-gray-700 divide-gray-100 dark:divide-gray-700",
    form: "border-gray-300 dark:border-gray-700 divide-gray-300 dark:divide-gray-700",
    primary: "border-primary-500 dark:border-primary-200  divide-primary-500 dark:divide-primary-200 ",
    orange: "border-orange-300 dark:border-orange-800 divide-orange-300 dark:divide-orange-800",
    none: ""
  };
  let divClass;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focusin_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focusout_handler(event) {
    bubble.call(this, $$self, event);
  }
  function svelte_element_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      node = $$value;
      $$invalidate(0, node);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(23, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("tag" in $$new_props)
      $$invalidate(1, tag = $$new_props.tag);
    if ("color" in $$new_props)
      $$invalidate(7, color = $$new_props.color);
    if ("rounded" in $$new_props)
      $$invalidate(8, rounded = $$new_props.rounded);
    if ("border" in $$new_props)
      $$invalidate(9, border = $$new_props.border);
    if ("shadow" in $$new_props)
      $$invalidate(10, shadow = $$new_props.shadow);
    if ("node" in $$new_props)
      $$invalidate(0, node = $$new_props.node);
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("options" in $$new_props)
      $$invalidate(3, options = $$new_props.options);
    if ("role" in $$new_props)
      $$invalidate(4, role = $$new_props.role);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*color*/
    128) {
      $:
        $$invalidate(7, color = color != null ? color : "default");
    }
    if ($$self.$$.dirty & /*color*/
    128) {
      $:
        setContext("color", color);
    }
    $:
      $$invalidate(5, divClass = (0, import_tailwind_merge.twMerge)(bgColors[color], textColors[color], rounded && "rounded-lg", border && "border", borderColors[color], shadow && "shadow-md", $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    node,
    tag,
    use,
    options,
    role,
    divClass,
    $$restProps,
    color,
    rounded,
    border,
    shadow,
    $$scope,
    slots,
    click_handler,
    mouseenter_handler,
    mouseleave_handler,
    focusin_handler,
    focusout_handler,
    svelte_element_binding
  ];
}
var Frame = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      tag: 1,
      color: 7,
      rounded: 8,
      border: 9,
      shadow: 10,
      node: 0,
      use: 2,
      options: 3,
      role: 4
    });
  }
};
var Frame_default = Frame;

// node_modules/flowbite-svelte/dist/accordion/Accordion.svelte
var import_tailwind_merge2 = __toESM(require_bundle_cjs());
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment3(ctx) {
  let frame;
  let current;
  const frame_spread_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*frameClass*/
      ctx[0]
    ) },
    { color: "none" }
  ];
  let frame_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < frame_spread_levels.length; i += 1) {
    frame_props = assign(frame_props, frame_spread_levels[i]);
  }
  frame = new Frame_default({ props: frame_props });
  return {
    c() {
      create_component(frame.$$.fragment);
    },
    m(target, anchor) {
      mount_component(frame, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const frame_changes = dirty & /*$$restProps, frameClass*/
      3 ? get_spread_update(frame_spread_levels, [
        dirty & /*$$restProps*/
        2 && get_spread_object(
          /*$$restProps*/
          ctx2[1]
        ),
        dirty & /*frameClass*/
        1 && { class: (
          /*frameClass*/
          ctx2[0]
        ) },
        frame_spread_levels[2]
      ]) : {};
      if (dirty & /*$$scope*/
      256) {
        frame_changes.$$scope = { dirty, ctx: ctx2 };
      }
      frame.$set(frame_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(frame.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(frame.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(frame, detaching);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  const omit_props_names = ["multiple", "flush", "activeClass", "inactiveClass", "defaultClass"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { multiple = false } = $$props;
  let { flush: flush2 = false } = $$props;
  let { activeClass = "bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-white focus:ring-4 focus:ring-gray-200 dark:focus:ring-gray-800" } = $$props;
  let { inactiveClass = "text-gray-500 dark:text-gray-400 hover:bg-gray-100 hover:dark:bg-gray-800" } = $$props;
  let { defaultClass = "text-gray-500 dark:text-gray-400" } = $$props;
  const ctx = {
    flush: flush2,
    activeClass: (0, import_tailwind_merge2.twMerge)(activeClass, $$props.classActive),
    inactiveClass: (0, import_tailwind_merge2.twMerge)(inactiveClass, $$props.classInactive),
    selected: multiple ? void 0 : writable()
  };
  setContext("ctx", ctx);
  let frameClass;
  $$self.$$set = ($$new_props) => {
    $$invalidate(10, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("multiple" in $$new_props)
      $$invalidate(2, multiple = $$new_props.multiple);
    if ("flush" in $$new_props)
      $$invalidate(3, flush2 = $$new_props.flush);
    if ("activeClass" in $$new_props)
      $$invalidate(4, activeClass = $$new_props.activeClass);
    if ("inactiveClass" in $$new_props)
      $$invalidate(5, inactiveClass = $$new_props.inactiveClass);
    if ("defaultClass" in $$new_props)
      $$invalidate(6, defaultClass = $$new_props.defaultClass);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $:
      $$invalidate(0, frameClass = (0, import_tailwind_merge2.twMerge)(defaultClass, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    frameClass,
    $$restProps,
    multiple,
    flush2,
    activeClass,
    inactiveClass,
    defaultClass,
    slots,
    $$scope
  ];
}
var Accordion = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      multiple: 2,
      flush: 3,
      activeClass: 4,
      inactiveClass: 5,
      defaultClass: 6
    });
  }
};
var Accordion_default = Accordion;

// node_modules/flowbite-svelte/dist/accordion/AccordionItem.svelte
var import_tailwind_merge3 = __toESM(require_bundle_cjs());

// node_modules/svelte/src/runtime/easing/index.js
function cubicInOut(t) {
  return t < 0.5 ? 4 * t * t * t : 0.5 * Math.pow(2 * t - 2, 3) + 1;
}
function cubicOut(t) {
  const f = t - 1;
  return f * f * f + 1;
}

// node_modules/svelte/src/runtime/transition/index.js
function blur(node, { delay: delay2 = 0, duration = 400, easing = cubicInOut, amount = 5, opacity = 0 } = {}) {
  const style = getComputedStyle(node);
  const target_opacity = +style.opacity;
  const f = style.filter === "none" ? "" : style.filter;
  const od = target_opacity * (1 - opacity);
  const [value, unit] = split_css_unit(amount);
  return {
    delay: delay2,
    duration,
    easing,
    css: (_t, u) => `opacity: ${target_opacity - od * u}; filter: ${f} blur(${u * value}${unit});`
  };
}
function fade(node, { delay: delay2 = 0, duration = 400, easing = identity } = {}) {
  const o = +getComputedStyle(node).opacity;
  return {
    delay: delay2,
    duration,
    easing,
    css: (t) => `opacity: ${t * o}`
  };
}
function fly(node, { delay: delay2 = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 } = {}) {
  const style = getComputedStyle(node);
  const target_opacity = +style.opacity;
  const transform = style.transform === "none" ? "" : style.transform;
  const od = target_opacity * (1 - opacity);
  const [xValue, xUnit] = split_css_unit(x);
  const [yValue, yUnit] = split_css_unit(y);
  return {
    delay: delay2,
    duration,
    easing,
    css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * xValue}${xUnit}, ${(1 - t) * yValue}${yUnit});
			opacity: ${target_opacity - od * u}`
  };
}
function slide(node, { delay: delay2 = 0, duration = 400, easing = cubicOut, axis = "y" } = {}) {
  const style = getComputedStyle(node);
  const opacity = +style.opacity;
  const primary_property = axis === "y" ? "height" : "width";
  const primary_property_value = parseFloat(style[primary_property]);
  const secondary_properties = axis === "y" ? ["top", "bottom"] : ["left", "right"];
  const capitalized_secondary_properties = secondary_properties.map(
    (e) => `${e[0].toUpperCase()}${e.slice(1)}`
  );
  const padding_start_value = parseFloat(style[`padding${capitalized_secondary_properties[0]}`]);
  const padding_end_value = parseFloat(style[`padding${capitalized_secondary_properties[1]}`]);
  const margin_start_value = parseFloat(style[`margin${capitalized_secondary_properties[0]}`]);
  const margin_end_value = parseFloat(style[`margin${capitalized_secondary_properties[1]}`]);
  const border_width_start_value = parseFloat(
    style[`border${capitalized_secondary_properties[0]}Width`]
  );
  const border_width_end_value = parseFloat(
    style[`border${capitalized_secondary_properties[1]}Width`]
  );
  return {
    delay: delay2,
    duration,
    easing,
    css: (t) => `overflow: hidden;opacity: ${Math.min(t * 20, 1) * opacity};${primary_property}: ${t * primary_property_value}px;padding-${secondary_properties[0]}: ${t * padding_start_value}px;padding-${secondary_properties[1]}: ${t * padding_end_value}px;margin-${secondary_properties[0]}: ${t * margin_start_value}px;margin-${secondary_properties[1]}: ${t * margin_end_value}px;border-${secondary_properties[0]}-width: ${t * border_width_start_value}px;border-${secondary_properties[1]}-width: ${t * border_width_end_value}px;`
  };
}

// node_modules/flowbite-svelte/dist/accordion/AccordionItem.svelte
var get_arrowdown_slot_changes = (dirty) => ({});
var get_arrowdown_slot_context = (ctx) => ({});
var get_arrowup_slot_changes = (dirty) => ({});
var get_arrowup_slot_context = (ctx) => ({});
var get_header_slot_changes = (dirty) => ({});
var get_header_slot_context = (ctx) => ({});
function create_else_block_1(ctx) {
  let current;
  const arrowdown_slot_template = (
    /*#slots*/
    ctx[22].arrowdown
  );
  const arrowdown_slot = create_slot(
    arrowdown_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    get_arrowdown_slot_context
  );
  const arrowdown_slot_or_fallback = arrowdown_slot || fallback_block_1(ctx);
  return {
    c() {
      if (arrowdown_slot_or_fallback)
        arrowdown_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (arrowdown_slot_or_fallback) {
        arrowdown_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (arrowdown_slot) {
        if (arrowdown_slot.p && (!current || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            arrowdown_slot,
            arrowdown_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              arrowdown_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              get_arrowdown_slot_changes
            ),
            get_arrowdown_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(arrowdown_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(arrowdown_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (arrowdown_slot_or_fallback)
        arrowdown_slot_or_fallback.d(detaching);
    }
  };
}
function create_if_block_12(ctx) {
  let current;
  const arrowup_slot_template = (
    /*#slots*/
    ctx[22].arrowup
  );
  const arrowup_slot = create_slot(
    arrowup_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    get_arrowup_slot_context
  );
  const arrowup_slot_or_fallback = arrowup_slot || fallback_block(ctx);
  return {
    c() {
      if (arrowup_slot_or_fallback)
        arrowup_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (arrowup_slot_or_fallback) {
        arrowup_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (arrowup_slot) {
        if (arrowup_slot.p && (!current || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            arrowup_slot,
            arrowup_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              arrowup_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              get_arrowup_slot_changes
            ),
            get_arrowup_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(arrowup_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(arrowup_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (arrowup_slot_or_fallback)
        arrowup_slot_or_fallback.d(detaching);
    }
  };
}
function fallback_block_1(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "stroke", "currentColor");
      attr(path, "stroke-linecap", "round");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "2");
      attr(path, "d", "m1 1 4 4 4-4");
      attr(svg, "class", "w-3 h-3 text-gray-800 dark:text-white");
      attr(svg, "aria-hidden", "true");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 10 6");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function fallback_block(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "stroke", "currentColor");
      attr(path, "stroke-linecap", "round");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "2");
      attr(path, "d", "M9 5 5 1 1 5");
      attr(svg, "class", "w-3 h-3 text-gray-800 dark:text-white");
      attr(svg, "aria-hidden", "true");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 10 6");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_else_block2(ctx) {
  let div1;
  let div0;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[22].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    null
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr(
        div0,
        "class",
        /*contentClass*/
        ctx[3]
      );
      attr(div1, "class", "hidden");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*contentClass*/
      8) {
        attr(
          div0,
          "class",
          /*contentClass*/
          ctx2[3]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_if_block2(ctx) {
  let div1;
  let div0;
  let div1_transition;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[22].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    null
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr(
        div0,
        "class",
        /*contentClass*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[21],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*contentClass*/
      8) {
        attr(
          div0,
          "class",
          /*contentClass*/
          ctx[3]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div1_transition)
            div1_transition = create_bidirectional_transition(
              div1,
              /*multiple*/
              ctx[4],
              /*transitionParams*/
              ctx[1],
              true
            );
          div1_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      if (local) {
        if (!div1_transition)
          div1_transition = create_bidirectional_transition(
            div1,
            /*multiple*/
            ctx[4],
            /*transitionParams*/
            ctx[1],
            false
          );
        div1_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && div1_transition)
        div1_transition.end();
    }
  };
}
function create_fragment4(ctx) {
  let h2;
  let button;
  let t0;
  let current_block_type_index;
  let if_block0;
  let t1;
  let current_block_type_index_1;
  let if_block1;
  let if_block1_anchor;
  let current;
  let mounted;
  let dispose;
  const header_slot_template = (
    /*#slots*/
    ctx[22].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    get_header_slot_context
  );
  const if_block_creators = [create_if_block_12, create_else_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*open*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const if_block_creators_1 = [create_if_block2, create_else_block2];
  const if_blocks_1 = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*open*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index_1 = select_block_type_1(ctx, -1);
  if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
  return {
    c() {
      h2 = element("h2");
      button = element("button");
      if (header_slot)
        header_slot.c();
      t0 = space();
      if_block0.c();
      t1 = space();
      if_block1.c();
      if_block1_anchor = empty();
      attr(button, "type", "button");
      attr(
        button,
        "class",
        /*buttonClass*/
        ctx[2]
      );
      attr(
        button,
        "aria-expanded",
        /*open*/
        ctx[0]
      );
      attr(h2, "class", "group");
    },
    m(target, anchor) {
      insert(target, h2, anchor);
      append(h2, button);
      if (header_slot) {
        header_slot.m(button, null);
      }
      append(button, t0);
      if_blocks[current_block_type_index].m(button, null);
      insert(target, t1, anchor);
      if_blocks_1[current_block_type_index_1].m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*handleToggle*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              get_header_slot_changes
            ),
            get_header_slot_context
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(button, null);
      }
      if (!current || dirty & /*buttonClass*/
      4) {
        attr(
          button,
          "class",
          /*buttonClass*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*open*/
      1) {
        attr(
          button,
          "aria-expanded",
          /*open*/
          ctx2[0]
        );
      }
      let previous_block_index_1 = current_block_type_index_1;
      current_block_type_index_1 = select_block_type_1(ctx2, dirty);
      if (current_block_type_index_1 === previous_block_index_1) {
        if_blocks_1[current_block_type_index_1].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
          if_blocks_1[previous_block_index_1] = null;
        });
        check_outros();
        if_block1 = if_blocks_1[current_block_type_index_1];
        if (!if_block1) {
          if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(header_slot, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h2);
        detach(t1);
        detach(if_block1_anchor);
      }
      if (header_slot)
        header_slot.d(detaching);
      if_blocks[current_block_type_index].d();
      if_blocks_1[current_block_type_index_1].d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  var _a, _b;
  let contentClass;
  let $selected;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { open = false } = $$props;
  let { activeClass = void 0 } = $$props;
  let { inactiveClass = void 0 } = $$props;
  let { defaultClass = "flex items-center justify-between w-full font-medium text-left group-first:rounded-t-xl border-gray-200 dark:border-gray-700" } = $$props;
  let { transitionType = "slide" } = $$props;
  let { transitionParams = {} } = $$props;
  let { paddingFlush = "py-5" } = $$props;
  let { paddingDefault = "p-5" } = $$props;
  let { textFlushOpen = "text-gray-900 dark:text-white" } = $$props;
  let { textFlushDefault = "text-gray-500 dark:text-gray-400" } = $$props;
  let { borderClass = "border-s border-e group-first:border-t" } = $$props;
  let { borderOpenClass = "border-s border-e" } = $$props;
  let { borderBottomClass = "border-b" } = $$props;
  let { borderSharedClass = "border-gray-200 dark:border-gray-700" } = $$props;
  let { classActive = void 0 } = $$props;
  let { classInactive = void 0 } = $$props;
  let activeCls = (0, import_tailwind_merge3.twMerge)(activeClass, classActive);
  let inactiveCls = (0, import_tailwind_merge3.twMerge)(inactiveClass, classInactive);
  const multiple = (node, params) => {
    switch (transitionType) {
      case "blur":
        return blur(node, params);
      case "fly":
        return fly(node, params);
      case "fade":
        return fade(node, params);
      default:
        return slide(node, params);
    }
  };
  const ctx = (_a = getContext("ctx")) != null ? _a : {};
  const self2 = {};
  const selected = (_b = ctx.selected) != null ? _b : writable();
  component_subscribe($$self, selected, (value) => $$invalidate(23, $selected = value));
  let _open = open;
  open = false;
  onMount(() => {
    if (_open)
      set_store_value(selected, $selected = self2, $selected);
    return selected.subscribe((x) => $$invalidate(0, open = x === self2));
  });
  const handleToggle = (_) => selected.set(open ? {} : self2);
  let buttonClass;
  $$self.$$set = ($$new_props) => {
    $$invalidate(29, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("open" in $$new_props)
      $$invalidate(0, open = $$new_props.open);
    if ("activeClass" in $$new_props)
      $$invalidate(7, activeClass = $$new_props.activeClass);
    if ("inactiveClass" in $$new_props)
      $$invalidate(8, inactiveClass = $$new_props.inactiveClass);
    if ("defaultClass" in $$new_props)
      $$invalidate(9, defaultClass = $$new_props.defaultClass);
    if ("transitionType" in $$new_props)
      $$invalidate(10, transitionType = $$new_props.transitionType);
    if ("transitionParams" in $$new_props)
      $$invalidate(1, transitionParams = $$new_props.transitionParams);
    if ("paddingFlush" in $$new_props)
      $$invalidate(11, paddingFlush = $$new_props.paddingFlush);
    if ("paddingDefault" in $$new_props)
      $$invalidate(12, paddingDefault = $$new_props.paddingDefault);
    if ("textFlushOpen" in $$new_props)
      $$invalidate(13, textFlushOpen = $$new_props.textFlushOpen);
    if ("textFlushDefault" in $$new_props)
      $$invalidate(14, textFlushDefault = $$new_props.textFlushDefault);
    if ("borderClass" in $$new_props)
      $$invalidate(15, borderClass = $$new_props.borderClass);
    if ("borderOpenClass" in $$new_props)
      $$invalidate(16, borderOpenClass = $$new_props.borderOpenClass);
    if ("borderBottomClass" in $$new_props)
      $$invalidate(17, borderBottomClass = $$new_props.borderBottomClass);
    if ("borderSharedClass" in $$new_props)
      $$invalidate(18, borderSharedClass = $$new_props.borderSharedClass);
    if ("classActive" in $$new_props)
      $$invalidate(19, classActive = $$new_props.classActive);
    if ("classInactive" in $$new_props)
      $$invalidate(20, classInactive = $$new_props.classInactive);
    if ("$$scope" in $$new_props)
      $$invalidate(21, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $:
      $$invalidate(2, buttonClass = (0, import_tailwind_merge3.twMerge)([
        defaultClass,
        ctx.flush || borderClass,
        borderBottomClass,
        borderSharedClass,
        ctx.flush ? paddingFlush : paddingDefault,
        open && (ctx.flush ? textFlushOpen : activeCls || ctx.activeClass),
        !open && (ctx.flush ? textFlushDefault : inactiveCls || ctx.inactiveClass),
        $$props.class
      ]));
    if ($$self.$$.dirty & /*paddingFlush, paddingDefault, borderOpenClass, borderBottomClass, borderSharedClass*/
    464896) {
      $:
        $$invalidate(3, contentClass = (0, import_tailwind_merge3.twMerge)([
          ctx.flush ? paddingFlush : paddingDefault,
          ctx.flush ? "" : borderOpenClass,
          borderBottomClass,
          borderSharedClass
        ]));
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    open,
    transitionParams,
    buttonClass,
    contentClass,
    multiple,
    selected,
    handleToggle,
    activeClass,
    inactiveClass,
    defaultClass,
    transitionType,
    paddingFlush,
    paddingDefault,
    textFlushOpen,
    textFlushDefault,
    borderClass,
    borderOpenClass,
    borderBottomClass,
    borderSharedClass,
    classActive,
    classInactive,
    $$scope,
    slots
  ];
}
var AccordionItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, {
      open: 0,
      activeClass: 7,
      inactiveClass: 8,
      defaultClass: 9,
      transitionType: 10,
      transitionParams: 1,
      paddingFlush: 11,
      paddingDefault: 12,
      textFlushOpen: 13,
      textFlushDefault: 14,
      borderClass: 15,
      borderOpenClass: 16,
      borderBottomClass: 17,
      borderSharedClass: 18,
      classActive: 19,
      classInactive: 20
    });
  }
};
var AccordionItem_default = AccordionItem;

// node_modules/flowbite-svelte/dist/darkmode/DarkMode.svelte
var { document: document_1 } = globals;

// node_modules/flowbite-svelte/dist/utils/Wrapper.svelte
function create_else_block3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_if_block3(ctx) {
  let previous_tag = (
    /*tag*/
    ctx[0]
  );
  let svelte_element_anchor;
  let current;
  let svelte_element = (
    /*tag*/
    ctx[0] && create_dynamic_element2(ctx)
  );
  return {
    c() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    m(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert(target, svelte_element_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*tag*/
        ctx2[0]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element2(ctx2);
          previous_tag = /*tag*/
          ctx2[0];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*tag*/
          ctx2[0]
        )) {
          svelte_element.d(1);
          svelte_element = create_dynamic_element2(ctx2);
          previous_tag = /*tag*/
          ctx2[0];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*tag*/
        ctx2[0];
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(svelte_element, local);
      current = true;
    },
    o(local) {
      transition_out(svelte_element, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element_anchor);
      }
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
}
function create_dynamic_element2(ctx) {
  let svelte_element;
  let use_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let svelte_element_levels = [
    /*$$restProps*/
    ctx[3]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  return {
    c() {
      svelte_element = element(
        /*tag*/
        ctx[0]
      );
      if (default_slot)
        default_slot.c();
      set_dynamic_element_data(
        /*tag*/
        ctx[0]
      )(svelte_element, svelte_element_data);
    },
    m(target, anchor) {
      insert(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(use_action = /*use*/
        ctx[2].call(null, svelte_element));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_dynamic_element_data(
        /*tag*/
        ctx2[0]
      )(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [dirty & /*$$restProps*/
      8 && /*$$restProps*/
      ctx2[3]]));
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment5(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block3, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*show*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  const omit_props_names = ["tag", "show", "use"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { tag = "div" } = $$props;
  let { show } = $$props;
  let { use = () => {
  } } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("tag" in $$new_props)
      $$invalidate(0, tag = $$new_props.tag);
    if ("show" in $$new_props)
      $$invalidate(1, show = $$new_props.show);
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  return [tag, show, use, $$restProps, $$scope, slots];
}
var Wrapper = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, { tag: 0, show: 1, use: 2 });
  }
};
var Wrapper_default = Wrapper;

// node_modules/flowbite-svelte/dist/forms/Input.svelte
var import_tailwind_merge4 = __toESM(require_bundle_cjs());
var get_right_slot_changes = (dirty) => ({});
var get_right_slot_context = (ctx) => ({});
var get_default_slot_changes = (dirty) => ({
  props: dirty[0] & /*$$restProps, inputClass*/
  72
});
var get_default_slot_context = (ctx) => ({
  props: __spreadProps(__spreadValues(
    {},
    /*$$restProps*/
    ctx[6]
  ), {
    class: (
      /*inputClass*/
      ctx[3]
    )
  })
});
var get_left_slot_changes = (dirty) => ({});
var get_left_slot_context = (ctx) => ({});
function create_if_block_13(ctx) {
  let div;
  let div_class_value;
  let current;
  const left_slot_template = (
    /*#slots*/
    ctx[11].left
  );
  const left_slot = create_slot(
    left_slot_template,
    ctx,
    /*$$scope*/
    ctx[26],
    get_left_slot_context
  );
  return {
    c() {
      div = element("div");
      if (left_slot)
        left_slot.c();
      attr(div, "class", div_class_value = (0, import_tailwind_merge4.twMerge)(
        /*floatClass*/
        ctx[2],
        /*$$props*/
        ctx[4].classLeft
      ) + " start-0 ps-2.5 pointer-events-none");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (left_slot) {
        left_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (left_slot) {
        if (left_slot.p && (!current || dirty[0] & /*$$scope*/
        67108864)) {
          update_slot_base(
            left_slot,
            left_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[26],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[26]
            ) : get_slot_changes(
              left_slot_template,
              /*$$scope*/
              ctx2[26],
              dirty,
              get_left_slot_changes
            ),
            get_left_slot_context
          );
        }
      }
      if (!current || dirty[0] & /*floatClass, $$props*/
      20 && div_class_value !== (div_class_value = (0, import_tailwind_merge4.twMerge)(
        /*floatClass*/
        ctx2[2],
        /*$$props*/
        ctx2[4].classLeft
      ) + " start-0 ps-2.5 pointer-events-none")) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(left_slot, local);
      current = true;
    },
    o(local) {
      transition_out(left_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (left_slot)
        left_slot.d(detaching);
    }
  };
}
function fallback_block2(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[6],
    { type: (
      /*type*/
      ctx[1]
    ) },
    { class: (
      /*inputClass*/
      ctx[3]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  return {
    c() {
      input = element("input");
      set_attributes(input, input_data);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[25]
          ),
          listen(
            input,
            "blur",
            /*blur_handler*/
            ctx[12]
          ),
          listen(
            input,
            "change",
            /*change_handler*/
            ctx[13]
          ),
          listen(
            input,
            "click",
            /*click_handler*/
            ctx[14]
          ),
          listen(
            input,
            "contextmenu",
            /*contextmenu_handler*/
            ctx[15]
          ),
          listen(
            input,
            "focus",
            /*focus_handler*/
            ctx[16]
          ),
          listen(
            input,
            "keydown",
            /*keydown_handler*/
            ctx[17]
          ),
          listen(
            input,
            "keypress",
            /*keypress_handler*/
            ctx[18]
          ),
          listen(
            input,
            "keyup",
            /*keyup_handler*/
            ctx[19]
          ),
          listen(
            input,
            "mouseover",
            /*mouseover_handler*/
            ctx[20]
          ),
          listen(
            input,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[21]
          ),
          listen(
            input,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[22]
          ),
          listen(
            input,
            "paste",
            /*paste_handler*/
            ctx[23]
          ),
          listen(
            input,
            "input",
            /*input_handler*/
            ctx[24]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6],
        dirty[0] & /*type*/
        2 && { type: (
          /*type*/
          ctx2[1]
        ) },
        dirty[0] & /*inputClass*/
        8 && { class: (
          /*inputClass*/
          ctx2[3]
        ) }
      ]));
      if (dirty[0] & /*value*/
      1 && input.value !== /*value*/
      ctx2[0]) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block4(ctx) {
  let div;
  let div_class_value;
  let current;
  const right_slot_template = (
    /*#slots*/
    ctx[11].right
  );
  const right_slot = create_slot(
    right_slot_template,
    ctx,
    /*$$scope*/
    ctx[26],
    get_right_slot_context
  );
  return {
    c() {
      div = element("div");
      if (right_slot)
        right_slot.c();
      attr(div, "class", div_class_value = (0, import_tailwind_merge4.twMerge)(
        /*floatClass*/
        ctx[2],
        /*$$props*/
        ctx[4].classRight
      ) + " end-0 pe-2.5");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (right_slot) {
        right_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (right_slot) {
        if (right_slot.p && (!current || dirty[0] & /*$$scope*/
        67108864)) {
          update_slot_base(
            right_slot,
            right_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[26],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[26]
            ) : get_slot_changes(
              right_slot_template,
              /*$$scope*/
              ctx2[26],
              dirty,
              get_right_slot_changes
            ),
            get_right_slot_context
          );
        }
      }
      if (!current || dirty[0] & /*floatClass, $$props*/
      20 && div_class_value !== (div_class_value = (0, import_tailwind_merge4.twMerge)(
        /*floatClass*/
        ctx2[2],
        /*$$props*/
        ctx2[4].classRight
      ) + " end-0 pe-2.5")) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(right_slot, local);
      current = true;
    },
    o(local) {
      transition_out(right_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (right_slot)
        right_slot.d(detaching);
    }
  };
}
function create_default_slot2(ctx) {
  let t0;
  let t1;
  let if_block1_anchor;
  let current;
  let if_block0 = (
    /*$$slots*/
    ctx[5].left && create_if_block_13(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[26],
    get_default_slot_context
  );
  const default_slot_or_fallback = default_slot || fallback_block2(ctx);
  let if_block1 = (
    /*$$slots*/
    ctx[5].right && create_if_block4(ctx)
  );
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t0, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[5].left
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*$$slots*/
          32) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_13(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope, $$restProps, inputClass*/
        67108936)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[26],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[26]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[26],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & /*$$restProps, type, inputClass, value*/
        75)) {
          default_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (
        /*$$slots*/
        ctx2[5].right
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*$$slots*/
          32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block4(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(default_slot_or_fallback, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(default_slot_or_fallback, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(if_block1_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
    }
  };
}
function create_fragment6(ctx) {
  let wrapper;
  let current;
  wrapper = new Wrapper_default({
    props: {
      class: "relative w-full",
      show: (
        /*$$slots*/
        ctx[5].left || /*$$slots*/
        ctx[5].right
      ),
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(wrapper.$$.fragment);
    },
    m(target, anchor) {
      mount_component(wrapper, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const wrapper_changes = {};
      if (dirty[0] & /*$$slots*/
      32)
        wrapper_changes.show = /*$$slots*/
        ctx2[5].left || /*$$slots*/
        ctx2[5].right;
      if (dirty[0] & /*$$scope, floatClass, $$props, $$slots, $$restProps, type, inputClass, value*/
      67108991) {
        wrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      wrapper.$set(wrapper_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(wrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(wrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(wrapper, detaching);
    }
  };
}
function clampSize(s) {
  return s && s === "xs" ? "sm" : s === "xl" ? "lg" : s;
}
function instance6($$self, $$props, $$invalidate) {
  let _size;
  const omit_props_names = ["type", "value", "size", "defaultClass", "color", "floatClass"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { type = "text" } = $$props;
  let { value = void 0 } = $$props;
  let { size = void 0 } = $$props;
  let { defaultClass = "block w-full disabled:cursor-not-allowed disabled:opacity-50 rtl:text-right" } = $$props;
  let { color = "base" } = $$props;
  let { floatClass = "flex absolute inset-y-0 items-center text-gray-500 dark:text-gray-400" } = $$props;
  const borderClasses = {
    base: "border-gray-300 dark:border-gray-600",
    tinted: "border-gray-300 dark:border-gray-500",
    green: "border-green-500 dark:border-green-400",
    red: "border-red-500 dark:border-red-400"
  };
  const ringClasses = {
    base: "focus:border-primary-500 focus:ring-primary-500 dark:focus:border-primary-500 dark:focus:ring-primary-500",
    green: "focus:ring-green-500 focus:border-green-500 dark:focus:border-green-500 dark:focus:ring-green-500",
    red: "focus:ring-red-500 focus:border-red-500 dark:focus:ring-red-500 dark:focus:border-red-500"
  };
  const colorClasses = {
    base: "bg-gray-50 text-gray-900 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400",
    tinted: "bg-gray-50 text-gray-900 dark:bg-gray-600 dark:text-white dark:placeholder-gray-400",
    green: "bg-green-50 text-green-900 placeholder-green-700 dark:text-green-400 dark:placeholder-green-500 dark:bg-gray-700",
    red: "bg-red-50 text-red-900 placeholder-red-700 dark:text-red-500 dark:placeholder-red-500 dark:bg-gray-700"
  };
  let background = getContext("background");
  let group = getContext("group");
  const textSizes = {
    sm: "sm:text-xs",
    md: "text-sm",
    lg: "sm:text-base"
  };
  const leftPadding = { sm: "ps-9", md: "ps-10", lg: "ps-11" };
  const rightPadding = { sm: "pe-9", md: "pe-10", lg: "pe-11" };
  const inputPadding = { sm: "p-2", md: "p-2.5", lg: "p-3" };
  let inputClass2;
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function contextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function paste_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("type" in $$new_props)
      $$invalidate(1, type = $$new_props.type);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("size" in $$new_props)
      $$invalidate(7, size = $$new_props.size);
    if ("defaultClass" in $$new_props)
      $$invalidate(8, defaultClass = $$new_props.defaultClass);
    if ("color" in $$new_props)
      $$invalidate(9, color = $$new_props.color);
    if ("floatClass" in $$new_props)
      $$invalidate(2, floatClass = $$new_props.floatClass);
    if ("$$scope" in $$new_props)
      $$invalidate(26, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*size*/
    128) {
      $:
        $$invalidate(10, _size = size || clampSize(group == null ? void 0 : group.size) || "md");
    }
    $: {
      const _color = color === "base" && background ? "tinted" : color;
      $$invalidate(3, inputClass2 = (0, import_tailwind_merge4.twMerge)([
        defaultClass,
        inputPadding[_size],
        $$slots.left && leftPadding[_size] || $$slots.right && rightPadding[_size],
        ringClasses[color],
        colorClasses[_color],
        borderClasses[_color],
        textSizes[_size],
        group || "rounded-lg",
        group && "first:rounded-s-lg last:rounded-e-lg",
        group && "border-s-0 first:border-s last:border-e",
        $$props.class
      ]));
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    value,
    type,
    floatClass,
    inputClass2,
    $$props,
    $$slots,
    $$restProps,
    size,
    defaultClass,
    color,
    _size,
    slots,
    blur_handler,
    change_handler,
    click_handler,
    contextmenu_handler,
    focus_handler,
    keydown_handler,
    keypress_handler,
    keyup_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    paste_handler,
    input_handler,
    input_input_handler,
    $$scope
  ];
}
var Input = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance6,
      create_fragment6,
      safe_not_equal,
      {
        type: 1,
        value: 0,
        size: 7,
        defaultClass: 8,
        color: 9,
        floatClass: 2
      },
      null,
      [-1, -1]
    );
  }
};
var Input_default = Input;

// node_modules/flowbite-svelte/dist/utils/generateId.js
var n = Date.now();

// node_modules/flowbite-svelte/dist/forms/Search.svelte
function create_left_slot(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "fill-rule", "evenodd");
      attr(path, "d", "M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z");
      attr(path, "clip-rule", "evenodd");
      attr(svg, "slot", "left");
      attr(svg, "class", svg_class_value = /*sizes*/
      ctx[3][
        /*size*/
        ctx[1]
      ]);
      attr(svg, "fill", "currentColor");
      attr(svg, "viewBox", "0 0 20 20");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, dirty) {
      if (dirty & /*size*/
      2 && svg_class_value !== (svg_class_value = /*sizes*/
      ctx2[3][
        /*size*/
        ctx2[1]
      ])) {
        attr(svg, "class", svg_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_if_block5(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "flex absolute inset-y-0 end-0 items-center text-gray-500 dark:text-gray-400");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_default_slot3(ctx) {
  let input;
  let updating_value;
  let t;
  let if_block_anchor;
  let current;
  const input_spread_levels = [
    { type: "search" },
    { placeholder: (
      /*placeholder*/
      ctx[2]
    ) },
    { size: (
      /*size*/
      ctx[1]
    ) },
    /*$$restProps*/
    ctx[5],
    { class: (
      /*$$props*/
      ctx[6].class
    ) }
  ];
  function input_value_binding(value) {
    ctx[8](value);
  }
  let input_props = {
    $$slots: { left: [create_left_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < input_spread_levels.length; i += 1) {
    input_props = assign(input_props, input_spread_levels[i]);
  }
  if (
    /*value*/
    ctx[0] !== void 0
  ) {
    input_props.value = /*value*/
    ctx[0];
  }
  input = new Input_default({ props: input_props });
  binding_callbacks.push(() => bind(input, "value", input_value_binding));
  input.$on(
    "blur",
    /*blur_handler*/
    ctx[9]
  );
  input.$on(
    "change",
    /*change_handler*/
    ctx[10]
  );
  input.$on(
    "input",
    /*input_handler*/
    ctx[11]
  );
  input.$on(
    "click",
    /*click_handler*/
    ctx[12]
  );
  input.$on(
    "focus",
    /*focus_handler*/
    ctx[13]
  );
  input.$on(
    "keydown",
    /*keydown_handler*/
    ctx[14]
  );
  input.$on(
    "keypress",
    /*keypress_handler*/
    ctx[15]
  );
  input.$on(
    "keyup",
    /*keyup_handler*/
    ctx[16]
  );
  input.$on(
    "mouseenter",
    /*mouseenter_handler*/
    ctx[17]
  );
  input.$on(
    "mouseleave",
    /*mouseleave_handler*/
    ctx[18]
  );
  input.$on(
    "mouseover",
    /*mouseover_handler*/
    ctx[19]
  );
  input.$on(
    "paste",
    /*paste_handler*/
    ctx[20]
  );
  let if_block = (
    /*$$slots*/
    ctx[4].default && create_if_block5(ctx)
  );
  return {
    c() {
      create_component(input.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(input, target, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const input_changes = dirty & /*placeholder, size, $$restProps, $$props*/
      102 ? get_spread_update(input_spread_levels, [
        input_spread_levels[0],
        dirty & /*placeholder*/
        4 && { placeholder: (
          /*placeholder*/
          ctx2[2]
        ) },
        dirty & /*size*/
        2 && { size: (
          /*size*/
          ctx2[1]
        ) },
        dirty & /*$$restProps*/
        32 && get_spread_object(
          /*$$restProps*/
          ctx2[5]
        ),
        dirty & /*$$props*/
        64 && { class: (
          /*$$props*/
          ctx2[6].class
        ) }
      ]) : {};
      if (dirty & /*$$scope, size*/
      2097154) {
        input_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_value && dirty & /*value*/
      1) {
        updating_value = true;
        input_changes.value = /*value*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      input.$set(input_changes);
      if (
        /*$$slots*/
        ctx2[4].default
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(input.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(input.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
        detach(if_block_anchor);
      }
      destroy_component(input, detaching);
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment7(ctx) {
  let wrapper;
  let current;
  wrapper = new Wrapper_default({
    props: {
      class: "relative w-full",
      show: (
        /*$$slots*/
        ctx[4].default
      ),
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(wrapper.$$.fragment);
    },
    m(target, anchor) {
      mount_component(wrapper, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const wrapper_changes = {};
      if (dirty & /*$$slots*/
      16)
        wrapper_changes.show = /*$$slots*/
        ctx2[4].default;
      if (dirty & /*$$scope, $$slots, placeholder, size, $$restProps, $$props, value*/
      2097271) {
        wrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      wrapper.$set(wrapper_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(wrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(wrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(wrapper, detaching);
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  const omit_props_names = ["size", "placeholder", "value"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { size = "lg" } = $$props;
  let { placeholder = "Search" } = $$props;
  let { value = void 0 } = $$props;
  const sizes = {
    sm: "w-3.5 h-3.5",
    md: "w-5 h-5",
    lg: "w-6 h-6"
  };
  function input_value_binding(value$1) {
    value = value$1;
    $$invalidate(0, value);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function paste_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(1, size = $$new_props.size);
    if ("placeholder" in $$new_props)
      $$invalidate(2, placeholder = $$new_props.placeholder);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("$$scope" in $$new_props)
      $$invalidate(21, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [
    value,
    size,
    placeholder,
    sizes,
    $$slots,
    $$restProps,
    $$props,
    slots,
    input_value_binding,
    blur_handler,
    change_handler,
    input_handler,
    click_handler,
    focus_handler,
    keydown_handler,
    keypress_handler,
    keyup_handler,
    mouseenter_handler,
    mouseleave_handler,
    mouseover_handler,
    paste_handler,
    $$scope
  ];
}
var Search = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance7, create_fragment7, safe_not_equal, { size: 1, placeholder: 2, value: 0 });
  }
};
var Search_default = Search;

// src/components/accordions/BaseAccordion.svelte
var import_obsidian12 = require("obsidian");
var get_default_slot_changes2 = (dirty) => ({
  app: dirty & /*app*/
  8,
  settingsService: dirty & /*settingsService*/
  16,
  aiService: dirty & /*aiService*/
  32
});
var get_default_slot_context2 = (ctx) => ({
  app: (
    /*app*/
    ctx[3]
  ),
  settingsService: (
    /*settingsService*/
    ctx[4]
  ),
  aiService: (
    /*aiService*/
    ctx[5]
  )
});
function create_default_slot_1(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context2
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "accordion-content");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, app, settingsService, aiService*/
        184)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes2
            ),
            get_default_slot_context2
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_if_block6(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(
        /*description*/
        ctx[1]
      );
      attr(span, "class", "accordion-description");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*description*/
      2)
        set_data(
          t,
          /*description*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_header_slot(ctx) {
  let div2;
  let div0;
  let span;
  let t0;
  let t1;
  let t2;
  let div1;
  let if_block = (
    /*description*/
    ctx[1] && create_if_block6(ctx)
  );
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      span = element("span");
      t0 = text(
        /*title*/
        ctx[0]
      );
      t1 = space();
      if (if_block)
        if_block.c();
      t2 = space();
      div1 = element("div");
      div1.innerHTML = `<svg viewBox="0 0 24 24" width="24" height="24" class="chevron"><path fill="currentColor" d="M9.29 6.71a.996.996 0 000 1.41L13.17 12l-3.88 3.88a.996.996 0 101.41 1.41l4.59-4.59a.996.996 0 000-1.41l-4.59-4.59a.996.996 0 00-1.41 0z"></path></svg>`;
      attr(span, "class", "accordion-title");
      attr(div0, "class", "accordion-title-wrapper");
      attr(div1, "class", "accordion-icon");
      attr(div1, "aria-hidden", "true");
      toggle_class(
        div1,
        "rotated",
        /*isOpen*/
        ctx[2]
      );
      attr(div2, "class", "accordion-header");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, span);
      append(span, t0);
      append(div0, t1);
      if (if_block)
        if_block.m(div0, null);
      append(div2, t2);
      append(div2, div1);
    },
    p(ctx2, dirty) {
      if (dirty & /*title*/
      1)
        set_data(
          t0,
          /*title*/
          ctx2[0]
        );
      if (
        /*description*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block6(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*isOpen*/
      4) {
        toggle_class(
          div1,
          "rotated",
          /*isOpen*/
          ctx2[2]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function create_default_slot4(ctx) {
  let accordionitem;
  let current;
  accordionitem = new AccordionItem_default({
    props: {
      isOpen: (
        /*isOpen*/
        ctx[2]
      ),
      $$slots: {
        header: [create_header_slot],
        default: [create_default_slot_1]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(accordionitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(accordionitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const accordionitem_changes = {};
      if (dirty & /*isOpen*/
      4)
        accordionitem_changes.isOpen = /*isOpen*/
        ctx2[2];
      if (dirty & /*$$scope, isOpen, description, title, app, settingsService, aiService*/
      191) {
        accordionitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      accordionitem.$set(accordionitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(accordionitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(accordionitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(accordionitem, detaching);
    }
  };
}
function create_fragment8(ctx) {
  let accordion;
  let current;
  accordion = new Accordion_default({
    props: {
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(accordion.$$.fragment);
    },
    m(target, anchor) {
      mount_component(accordion, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const accordion_changes = {};
      if (dirty & /*$$scope, isOpen, description, title, app, settingsService, aiService*/
      191) {
        accordion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      accordion.$set(accordion_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(accordion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(accordion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(accordion, detaching);
    }
  };
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { title } = $$props;
  let { description } = $$props;
  let { isOpen = false } = $$props;
  let { app } = $$props;
  let { settingsService } = $$props;
  let { aiService } = $$props;
  function showNotice(message) {
    new import_obsidian12.Notice(message);
  }
  function handleError(context, error) {
    console.error(`Error in ${context}:`, error);
    showNotice(`Error in ${context}: ${error instanceof Error ? error.message : "Unknown error"}`);
  }
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("description" in $$props2)
      $$invalidate(1, description = $$props2.description);
    if ("isOpen" in $$props2)
      $$invalidate(2, isOpen = $$props2.isOpen);
    if ("app" in $$props2)
      $$invalidate(3, app = $$props2.app);
    if ("settingsService" in $$props2)
      $$invalidate(4, settingsService = $$props2.settingsService);
    if ("aiService" in $$props2)
      $$invalidate(5, aiService = $$props2.aiService);
    if ("$$scope" in $$props2)
      $$invalidate(7, $$scope = $$props2.$$scope);
  };
  return [title, description, isOpen, app, settingsService, aiService, slots, $$scope];
}
var BaseAccordion = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance8, create_fragment8, safe_not_equal, {
      title: 0,
      description: 1,
      isOpen: 2,
      app: 3,
      settingsService: 4,
      aiService: 5
    });
  }
};
var BaseAccordion_default = BaseAccordion;

// src/components/accordions/ModelHookupAccordion.svelte
var import_obsidian13 = require("obsidian");
function add_css2(target) {
  append_styles(target, "svelte-mi65e", ".model-hookup-settings.svelte-mi65e{display:flex;flex-direction:column;gap:var(--size-4)}.setting-item.svelte-mi65e{display:flex;justify-content:space-between;align-items:flex-start;padding:var(--size-2) 0}.setting-item-info.svelte-mi65e{flex:1;margin-right:var(--size-4)}.setting-item-name.svelte-mi65e{font-weight:var(--font-bold);color:var(--text-normal)}.setting-item-description.svelte-mi65e{color:var(--text-muted);font-size:var(--font-ui-small)}.setting-item-control.svelte-mi65e{flex:0 0 200px}select.svelte-mi65e,input.svelte-mi65e{width:100%;padding:var(--size-2);border:1px solid var(--background-modifier-border);border-radius:var(--radius-s);background-color:var(--background-primary);color:var(--text-normal)}.test-connection-button.svelte-mi65e{padding:var(--size-2) var(--size-4);background-color:var(--interactive-accent);color:var(--text-on-accent);border-radius:var(--radius-s);border:none;cursor:pointer;font-weight:var(--font-bold);transition:background-color 0.2s ease;align-self:flex-start}.test-connection-button.svelte-mi65e:hover:not(:disabled){background-color:var(--interactive-accent-hover)}.test-connection-button.svelte-mi65e:disabled{opacity:0.5;cursor:not-allowed}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i][0];
  child_ctx[17] = list[i][1];
  return child_ctx;
}
function create_each_block2(ctx) {
  let option;
  let t_value = (
    /*label*/
    ctx[17] + ""
  );
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = /*value*/
      ctx[16];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_else_block4(ctx) {
  let div4;
  let div2;
  let div0;
  let t1;
  let div1;
  let t2;
  let t3_value = (
    /*providerOptions*/
    ctx[7][
      /*selectedProvider*/
      ctx[4]
    ] + ""
  );
  let t3;
  let t4;
  let div3;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div4 = element("div");
      div2 = element("div");
      div0 = element("div");
      div0.textContent = "API Key";
      t1 = space();
      div1 = element("div");
      t2 = text("Your API key for ");
      t3 = text(t3_value);
      t4 = space();
      div3 = element("div");
      input = element("input");
      attr(div0, "class", "setting-item-name svelte-mi65e");
      attr(div1, "class", "setting-item-description svelte-mi65e");
      attr(div2, "class", "setting-item-info svelte-mi65e");
      attr(input, "type", "password");
      attr(input, "class", "svelte-mi65e");
      attr(div3, "class", "setting-item-control svelte-mi65e");
      attr(div4, "class", "setting-item svelte-mi65e");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div2);
      append(div2, div0);
      append(div2, t1);
      append(div2, div1);
      append(div1, t2);
      append(div1, t3);
      append(div4, t4);
      append(div4, div3);
      append(div3, input);
      set_input_value(
        input,
        /*apiKey*/
        ctx[5]
      );
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler_1*/
            ctx[14]
          ),
          listen(
            input,
            "change",
            /*handleApiKeyChange*/
            ctx[9]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*selectedProvider*/
      16 && t3_value !== (t3_value = /*providerOptions*/
      ctx2[7][
        /*selectedProvider*/
        ctx2[4]
      ] + ""))
        set_data(t3, t3_value);
      if (dirty & /*apiKey*/
      32 && input.value !== /*apiKey*/
      ctx2[5]) {
        set_input_value(
          input,
          /*apiKey*/
          ctx2[5]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block7(ctx) {
  let div4;
  let div2;
  let t3;
  let div3;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div4 = element("div");
      div2 = element("div");
      div2.innerHTML = `<div class="setting-item-name svelte-mi65e">LM Studio Port</div> <div class="setting-item-description svelte-mi65e">Port number for your local LM Studio instance</div>`;
      t3 = space();
      div3 = element("div");
      input = element("input");
      attr(div2, "class", "setting-item-info svelte-mi65e");
      attr(input, "type", "number");
      attr(input, "class", "svelte-mi65e");
      attr(div3, "class", "setting-item-control svelte-mi65e");
      attr(div4, "class", "setting-item svelte-mi65e");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div2);
      append(div4, t3);
      append(div4, div3);
      append(div3, input);
      set_input_value(
        input,
        /*lmStudioPort*/
        ctx[6]
      );
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[13]
          ),
          listen(
            input,
            "change",
            /*handlePortChange*/
            ctx[10]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*lmStudioPort*/
      64 && to_number(input.value) !== /*lmStudioPort*/
      ctx2[6]) {
        set_input_value(
          input,
          /*lmStudioPort*/
          ctx2[6]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot5(ctx) {
  let div5;
  let div4;
  let div2;
  let t3;
  let div3;
  let select;
  let t4;
  let t5;
  let button;
  let t6_value = (
    /*isLoading*/
    ctx[3] ? "Testing..." : "Test Connection"
  );
  let t6;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(Object.entries(
    /*providerOptions*/
    ctx[7]
  ));
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  function select_block_type(ctx2, dirty) {
    if (
      /*selectedProvider*/
      ctx2[4] === "lmstudio" /* LMStudio */
    )
      return create_if_block7;
    return create_else_block4;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div5 = element("div");
      div4 = element("div");
      div2 = element("div");
      div2.innerHTML = `<div class="setting-item-name svelte-mi65e">AI Provider</div> <div class="setting-item-description svelte-mi65e">Select your AI provider</div>`;
      t3 = space();
      div3 = element("div");
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t4 = space();
      if_block.c();
      t5 = space();
      button = element("button");
      t6 = text(t6_value);
      attr(div2, "class", "setting-item-info svelte-mi65e");
      attr(select, "class", "svelte-mi65e");
      if (
        /*selectedProvider*/
        ctx[4] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[12].call(select)
        ));
      attr(div3, "class", "setting-item-control svelte-mi65e");
      attr(div4, "class", "setting-item svelte-mi65e");
      attr(button, "class", "test-connection-button svelte-mi65e");
      button.disabled = /*isLoading*/
      ctx[3];
      attr(div5, "class", "model-hookup-settings svelte-mi65e");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div4);
      append(div4, div2);
      append(div4, t3);
      append(div4, div3);
      append(div3, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*selectedProvider*/
        ctx[4],
        true
      );
      append(div5, t4);
      if_block.m(div5, null);
      append(div5, t5);
      append(div5, button);
      append(button, t6);
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[12]
          ),
          listen(
            select,
            "change",
            /*handleProviderChange*/
            ctx[8]
          ),
          listen(
            button,
            "click",
            /*testConnection*/
            ctx[11]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*Object, providerOptions*/
      128) {
        each_value = ensure_array_like(Object.entries(
          /*providerOptions*/
          ctx2[7]
        ));
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*selectedProvider, Object, providerOptions*/
      144) {
        select_option(
          select,
          /*selectedProvider*/
          ctx2[4]
        );
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div5, t5);
        }
      }
      if (dirty & /*isLoading*/
      8 && t6_value !== (t6_value = /*isLoading*/
      ctx2[3] ? "Testing..." : "Test Connection"))
        set_data(t6, t6_value);
      if (dirty & /*isLoading*/
      8) {
        button.disabled = /*isLoading*/
        ctx2[3];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div5);
      }
      destroy_each(each_blocks, detaching);
      if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment9(ctx) {
  let baseaccordion;
  let current;
  baseaccordion = new BaseAccordion_default({
    props: {
      title: "\u{1F50C} Model Hookup",
      description: "Configure AI providers and models",
      app: (
        /*app*/
        ctx[0]
      ),
      settingsService: (
        /*settingsService*/
        ctx[1]
      ),
      aiService: (
        /*aiService*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(baseaccordion.$$.fragment);
    },
    m(target, anchor) {
      mount_component(baseaccordion, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const baseaccordion_changes = {};
      if (dirty & /*app*/
      1)
        baseaccordion_changes.app = /*app*/
        ctx2[0];
      if (dirty & /*settingsService*/
      2)
        baseaccordion_changes.settingsService = /*settingsService*/
        ctx2[1];
      if (dirty & /*aiService*/
      4)
        baseaccordion_changes.aiService = /*aiService*/
        ctx2[2];
      if (dirty & /*$$scope, isLoading, lmStudioPort, selectedProvider, apiKey*/
      1048696) {
        baseaccordion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      baseaccordion.$set(baseaccordion_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(baseaccordion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(baseaccordion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(baseaccordion, detaching);
    }
  };
}
function instance9($$self, $$props, $$invalidate) {
  var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  let { app } = $$props;
  let { settingsService } = $$props;
  let { aiService } = $$props;
  let isLoading = false;
  const providerOptions = {
    ["openai" /* OpenAI */]: "OpenAI",
    ["anthropic" /* Anthropic */]: "Anthropic",
    ["google" /* Google */]: "Google Gemini",
    ["groq" /* Groq */]: "Groq",
    ["openrouter" /* OpenRouter */]: "OpenRouter",
    ["lmstudio" /* LMStudio */]: "LM Studio"
  };
  let selectedProvider;
  let apiKey;
  let lmStudioPort;
  onMount(() => {
    $$invalidate(4, selectedProvider = settingsService.getSettings().aiProvider.selected);
    $$invalidate(5, apiKey = settingsService.getSettings().aiProvider.apiKeys[selectedProvider] || "");
    $$invalidate(6, lmStudioPort = settingsService.getSettings().localLMStudio.port);
  });
  function handleProviderChange(event) {
    return __awaiter(this, void 0, void 0, function* () {
      const value = event.target.value;
      try {
        yield settingsService.updateNestedSetting("aiProvider", "selected", value);
        $$invalidate(4, selectedProvider = value);
        $$invalidate(5, apiKey = settingsService.getSettings().aiProvider.apiKeys[selectedProvider] || "");
        yield aiService.reinitialize();
        new import_obsidian13.Notice(`AI Service reinitialized with provider ${providerOptions[value]}.`);
      } catch (error) {
        console.error("Failed to reinitialize AI Service:", error);
        new import_obsidian13.Notice(`Failed to reinitialize AI Service: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    });
  }
  function handleApiKeyChange(event) {
    return __awaiter(this, void 0, void 0, function* () {
      const value = event.target.value;
      try {
        const currentApiKeys = settingsService.getNestedSetting("aiProvider", "apiKeys");
        yield settingsService.updateNestedSetting("aiProvider", "apiKeys", Object.assign(Object.assign({}, currentApiKeys), { [selectedProvider]: value }));
        $$invalidate(5, apiKey = value);
      } catch (error) {
        console.error("Error updating API key:", error);
        new import_obsidian13.Notice(`Failed to update API key: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    });
  }
  function handlePortChange(event) {
    return __awaiter(this, void 0, void 0, function* () {
      const value = parseInt(event.target.value);
      try {
        yield settingsService.updateNestedSetting("localLMStudio", "port", value);
        $$invalidate(6, lmStudioPort = value);
      } catch (error) {
        console.error("Error updating port:", error);
        new import_obsidian13.Notice(`Failed to update port: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    });
  }
  function testConnection() {
    return __awaiter(this, void 0, void 0, function* () {
      $$invalidate(3, isLoading = true);
      try {
        const result = yield aiService.testConnection(selectedProvider);
        const providerName = providerOptions[selectedProvider];
        new import_obsidian13.Notice(result ? `Successfully connected to ${providerName}` : `Failed to connect to ${providerName}. Please check your settings.`);
      } catch (error) {
        console.error("Error testing connection:", error);
        new import_obsidian13.Notice(`Connection test failed: ${error instanceof Error ? error.message : "Unknown error"}`);
      } finally {
        $$invalidate(3, isLoading = false);
      }
    });
  }
  function select_change_handler() {
    selectedProvider = select_value(this);
    $$invalidate(4, selectedProvider);
    $$invalidate(7, providerOptions);
  }
  function input_input_handler() {
    lmStudioPort = to_number(this.value);
    $$invalidate(6, lmStudioPort);
  }
  function input_input_handler_1() {
    apiKey = this.value;
    $$invalidate(5, apiKey);
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("settingsService" in $$props2)
      $$invalidate(1, settingsService = $$props2.settingsService);
    if ("aiService" in $$props2)
      $$invalidate(2, aiService = $$props2.aiService);
  };
  return [
    app,
    settingsService,
    aiService,
    isLoading,
    selectedProvider,
    apiKey,
    lmStudioPort,
    providerOptions,
    handleProviderChange,
    handleApiKeyChange,
    handlePortChange,
    testConnection,
    select_change_handler,
    input_input_handler,
    input_input_handler_1
  ];
}
var ModelHookupAccordion = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance9, create_fragment9, safe_not_equal, { app: 0, settingsService: 1, aiService: 2 }, add_css2);
  }
};
var ModelHookupAccordion_default = ModelHookupAccordion;

// src/components/accordions/PropertyManagerAccordion.svelte
var import_obsidian15 = require("obsidian");

// src/components/modals/EditPropertiesModal.svelte
var import_obsidian14 = require("obsidian");
function add_css3(target) {
  append_styles(target, "svelte-en16b6", ".edit-properties-modal.svelte-en16b6.svelte-en16b6{display:flex;flex-direction:column;gap:var(--size-4);padding:var(--size-4);max-width:800px;width:100%}.modal-header.svelte-en16b6.svelte-en16b6{border-bottom:1px solid var(--background-modifier-border);padding-bottom:var(--size-4)}.modal-header.svelte-en16b6 h2.svelte-en16b6{margin:0;color:var(--text-normal);font-size:var(--font-ui-large)}.select-all-container.svelte-en16b6.svelte-en16b6{margin-bottom:var(--size-4)}.select-all-label.svelte-en16b6.svelte-en16b6{display:flex;align-items:center;gap:var(--size-2);cursor:pointer}.table-container.svelte-en16b6.svelte-en16b6{overflow-x:auto;margin-bottom:var(--size-4)}table.svelte-en16b6.svelte-en16b6{width:100%;border-collapse:collapse}th.svelte-en16b6.svelte-en16b6,td.svelte-en16b6.svelte-en16b6{padding:var(--size-2) var(--size-4);border-bottom:1px solid var(--background-modifier-border)}.align-center.svelte-en16b6.svelte-en16b6{text-align:center}.align-left.svelte-en16b6.svelte-en16b6{text-align:left}.drag-handle.svelte-en16b6.svelte-en16b6{cursor:move;user-select:none}.property-input.svelte-en16b6.svelte-en16b6,.property-select.svelte-en16b6.svelte-en16b6{width:100%;background:var(--background-primary);border:1px solid var(--background-modifier-border);border-radius:var(--radius-s);padding:var(--size-2);color:var(--text-normal)}.modal-footer.svelte-en16b6.svelte-en16b6{display:flex;justify-content:flex-end;gap:var(--size-4);padding-top:var(--size-4);border-top:1px solid var(--background-modifier-border)}button.svelte-en16b6.svelte-en16b6{padding:var(--size-2) var(--size-4);border-radius:var(--radius-s);border:none;cursor:pointer;font-weight:var(--font-bold)}button.mod-cta.svelte-en16b6.svelte-en16b6{background-color:var(--interactive-accent);color:var(--text-on-accent)}button.mod-warning.svelte-en16b6.svelte-en16b6{background-color:var(--background-modifier-error);color:var(--text-on-accent)}button.mod-cancel.svelte-en16b6.svelte-en16b6{background-color:var(--background-modifier-border);color:var(--text-normal)}button.svelte-en16b6.svelte-en16b6:hover:not(:disabled){opacity:0.8}");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  child_ctx[20] = list;
  child_ctx[21] = i;
  return child_ctx;
}
function get_each_context_12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i];
  return child_ctx;
}
function create_each_block_12(ctx) {
  let option;
  let t_value = (
    /*type*/
    ctx[22] + ""
  );
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = /*type*/
      ctx[22];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_each_block3(key_1, ctx) {
  let tr;
  let td0;
  let t1;
  let td1;
  let input0;
  let t2;
  let td2;
  let input1;
  let t3;
  let td3;
  let select;
  let t4;
  let td4;
  let input2;
  let input2_data_index_value;
  let t5;
  let tr_data_index_value;
  let mounted;
  let dispose;
  function input0_input_handler() {
    ctx[13].call(
      input0,
      /*each_value*/
      ctx[20],
      /*index*/
      ctx[21]
    );
  }
  function input1_input_handler() {
    ctx[14].call(
      input1,
      /*each_value*/
      ctx[20],
      /*index*/
      ctx[21]
    );
  }
  let each_value_1 = ensure_array_like(
    /*propertyTypes*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_12(get_each_context_12(ctx, each_value_1, i));
  }
  function select_change_handler() {
    ctx[15].call(
      select,
      /*each_value*/
      ctx[20],
      /*index*/
      ctx[21]
    );
  }
  function dragstart_handler(...args) {
    return (
      /*dragstart_handler*/
      ctx[16](
        /*index*/
        ctx[21],
        ...args
      )
    );
  }
  function drop_handler(...args) {
    return (
      /*drop_handler*/
      ctx[17](
        /*index*/
        ctx[21],
        ...args
      )
    );
  }
  return {
    key: key_1,
    first: null,
    c() {
      tr = element("tr");
      td0 = element("td");
      td0.textContent = "\u2261";
      t1 = space();
      td1 = element("td");
      input0 = element("input");
      t2 = space();
      td2 = element("td");
      input1 = element("input");
      t3 = space();
      td3 = element("td");
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t4 = space();
      td4 = element("td");
      input2 = element("input");
      t5 = space();
      attr(td0, "class", "align-center drag-handle svelte-en16b6");
      attr(input0, "type", "text");
      attr(input0, "class", "property-input svelte-en16b6");
      attr(td1, "class", "svelte-en16b6");
      attr(input1, "type", "text");
      attr(input1, "class", "property-input svelte-en16b6");
      attr(td2, "class", "svelte-en16b6");
      attr(select, "class", "property-select svelte-en16b6");
      if (
        /*property*/
        ctx[19].type === void 0
      )
        add_render_callback(select_change_handler);
      attr(td3, "class", "svelte-en16b6");
      attr(input2, "type", "checkbox");
      input2.checked = /*selectAllChecked*/
      ctx[2];
      attr(input2, "data-index", input2_data_index_value = /*index*/
      ctx[21]);
      attr(td4, "class", "align-center svelte-en16b6");
      attr(tr, "draggable", "true");
      attr(tr, "data-index", tr_data_index_value = /*index*/
      ctx[21]);
      this.first = tr;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(tr, t1);
      append(tr, td1);
      append(td1, input0);
      set_input_value(
        input0,
        /*property*/
        ctx[19].name
      );
      append(tr, t2);
      append(tr, td2);
      append(td2, input1);
      set_input_value(
        input1,
        /*property*/
        ctx[19].description
      );
      append(tr, t3);
      append(tr, td3);
      append(td3, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*property*/
        ctx[19].type,
        true
      );
      append(tr, t4);
      append(tr, td4);
      append(td4, input2);
      append(tr, t5);
      if (!mounted) {
        dispose = [
          listen(input0, "input", input0_input_handler),
          listen(input1, "input", input1_input_handler),
          listen(select, "change", select_change_handler),
          listen(tr, "dragstart", dragstart_handler),
          listen(tr, "dragover", handleDragOver),
          listen(tr, "drop", drop_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*localProperties, propertyTypes*/
      10 && input0.value !== /*property*/
      ctx[19].name) {
        set_input_value(
          input0,
          /*property*/
          ctx[19].name
        );
      }
      if (dirty & /*localProperties, propertyTypes*/
      10 && input1.value !== /*property*/
      ctx[19].description) {
        set_input_value(
          input1,
          /*property*/
          ctx[19].description
        );
      }
      if (dirty & /*propertyTypes*/
      8) {
        each_value_1 = ensure_array_like(
          /*propertyTypes*/
          ctx[3]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_12(ctx, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_12(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty & /*localProperties, propertyTypes*/
      10) {
        select_option(
          select,
          /*property*/
          ctx[19].type
        );
      }
      if (dirty & /*selectAllChecked*/
      4) {
        input2.checked = /*selectAllChecked*/
        ctx[2];
      }
      if (dirty & /*localProperties, propertyTypes*/
      10 && input2_data_index_value !== (input2_data_index_value = /*index*/
      ctx[21])) {
        attr(input2, "data-index", input2_data_index_value);
      }
      if (dirty & /*localProperties, propertyTypes*/
      10 && tr_data_index_value !== (tr_data_index_value = /*index*/
      ctx[21])) {
        attr(tr, "data-index", tr_data_index_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(tr);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment10(ctx) {
  let div4;
  let header;
  let t1;
  let div3;
  let div0;
  let label;
  let input;
  let t2;
  let span;
  let t4;
  let div1;
  let table;
  let thead;
  let t14;
  let tbody;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t15;
  let div2;
  let button0;
  let t17;
  let button1;
  let t19;
  let button2;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*localProperties*/
    ctx[1]
  );
  const get_key = (ctx2) => (
    /*property*/
    ctx2[19].name
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context3(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block3(key, child_ctx));
  }
  return {
    c() {
      div4 = element("div");
      header = element("header");
      header.innerHTML = `<h2 class="svelte-en16b6">Edit Properties</h2>`;
      t1 = space();
      div3 = element("div");
      div0 = element("div");
      label = element("label");
      input = element("input");
      t2 = space();
      span = element("span");
      span.textContent = "Select All";
      t4 = space();
      div1 = element("div");
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr><th class="align-center svelte-en16b6">Drag</th> <th class="align-left svelte-en16b6">Name</th> <th class="align-left svelte-en16b6">Description</th> <th class="align-left svelte-en16b6">Type</th> <th class="align-center svelte-en16b6">Delete</th></tr>`;
      t14 = space();
      tbody = element("tbody");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t15 = space();
      div2 = element("div");
      button0 = element("button");
      button0.textContent = "Delete Selected";
      t17 = space();
      button1 = element("button");
      button1.textContent = "Save";
      t19 = space();
      button2 = element("button");
      button2.textContent = "Cancel";
      attr(header, "class", "modal-header svelte-en16b6");
      attr(input, "type", "checkbox");
      attr(label, "class", "select-all-label svelte-en16b6");
      attr(div0, "class", "select-all-container svelte-en16b6");
      attr(table, "class", "svelte-en16b6");
      attr(div1, "class", "table-container svelte-en16b6");
      attr(button0, "class", "mod-warning svelte-en16b6");
      attr(button1, "class", "mod-cta svelte-en16b6");
      attr(button2, "class", "mod-cancel svelte-en16b6");
      attr(div2, "class", "modal-footer svelte-en16b6");
      attr(div3, "class", "modal-content");
      attr(div4, "class", "edit-properties-modal svelte-en16b6");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, header);
      append(div4, t1);
      append(div4, div3);
      append(div3, div0);
      append(div0, label);
      append(label, input);
      input.checked = /*selectAllChecked*/
      ctx[2];
      append(label, t2);
      append(label, span);
      append(div3, t4);
      append(div3, div1);
      append(div1, table);
      append(table, thead);
      append(table, t14);
      append(table, tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tbody, null);
        }
      }
      append(div3, t15);
      append(div3, div2);
      append(div2, button0);
      append(div2, t17);
      append(div2, button1);
      append(div2, t19);
      append(div2, button2);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*input_change_handler*/
            ctx[12]
          ),
          listen(
            input,
            "change",
            /*handleSelectAll*/
            ctx[4]
          ),
          listen(
            button0,
            "click",
            /*handleDelete*/
            ctx[5]
          ),
          listen(
            button1,
            "click",
            /*handleSave*/
            ctx[6]
          ),
          listen(button2, "click", function() {
            if (is_function(
              /*onClose*/
              ctx[0]
            ))
              ctx[0].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*selectAllChecked*/
      4) {
        input.checked = /*selectAllChecked*/
        ctx[2];
      }
      if (dirty & /*localProperties, handleDragStart, handleDragOver, handleDrop, selectAllChecked, propertyTypes*/
      398) {
        each_value = ensure_array_like(
          /*localProperties*/
          ctx[1]
        );
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, tbody, destroy_block, create_each_block3, null, get_each_context3);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function handleDragOver(event) {
  var _a;
  event.preventDefault();
  const target = event.target;
  (_a = target.closest("tr")) === null || _a === void 0 ? void 0 : _a.classList.add("drag-over");
}
function instance10($$self, $$props, $$invalidate) {
  let { app } = $$props;
  let { properties } = $$props;
  let { onSubmit } = $$props;
  let { onClose } = $$props;
  let localProperties = [...properties];
  let selectAllChecked = false;
  let draggedIndex = null;
  const propertyTypes = ["string", "number", "boolean", "array", "date"];
  function handleSelectAll(event) {
    $$invalidate(2, selectAllChecked = event.target.checked);
  }
  function handleDelete() {
    $$invalidate(1, localProperties = localProperties.filter((_, index) => {
      const checkbox = document.querySelector(`input[data-index="${index}"]`);
      return !(checkbox === null || checkbox === void 0 ? void 0 : checkbox.checked);
    }));
    $$invalidate(2, selectAllChecked = false);
  }
  function handleSave() {
    onSubmit(localProperties);
    onClose();
  }
  function handleDragStart(event, index) {
    var _a;
    draggedIndex = index;
    (_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.setData("text/plain", index.toString());
    const target = event.target;
    target.classList.add("dragging");
  }
  function handleDrop(event, toIndex) {
    event.preventDefault();
    document.querySelectorAll(".dragging, .drag-over").forEach((el) => {
      el.classList.remove("dragging", "drag-over");
    });
    if (draggedIndex !== null && draggedIndex !== toIndex) {
      const [movedItem] = localProperties.splice(draggedIndex, 1);
      localProperties.splice(toIndex, 0, movedItem);
      $$invalidate(1, localProperties = [...localProperties]);
    }
    draggedIndex = null;
  }
  function input_change_handler() {
    selectAllChecked = this.checked;
    $$invalidate(2, selectAllChecked);
  }
  function input0_input_handler(each_value, index) {
    each_value[index].name = this.value;
    $$invalidate(1, localProperties);
    $$invalidate(3, propertyTypes);
  }
  function input1_input_handler(each_value, index) {
    each_value[index].description = this.value;
    $$invalidate(1, localProperties);
    $$invalidate(3, propertyTypes);
  }
  function select_change_handler(each_value, index) {
    each_value[index].type = select_value(this);
    $$invalidate(1, localProperties);
    $$invalidate(3, propertyTypes);
  }
  const dragstart_handler = (index, e) => handleDragStart(e, index);
  const drop_handler = (index, e) => handleDrop(e, index);
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(9, app = $$props2.app);
    if ("properties" in $$props2)
      $$invalidate(10, properties = $$props2.properties);
    if ("onSubmit" in $$props2)
      $$invalidate(11, onSubmit = $$props2.onSubmit);
    if ("onClose" in $$props2)
      $$invalidate(0, onClose = $$props2.onClose);
  };
  return [
    onClose,
    localProperties,
    selectAllChecked,
    propertyTypes,
    handleSelectAll,
    handleDelete,
    handleSave,
    handleDragStart,
    handleDrop,
    app,
    properties,
    onSubmit,
    input_change_handler,
    input0_input_handler,
    input1_input_handler,
    select_change_handler,
    dragstart_handler,
    drop_handler
  ];
}
var EditPropertiesModal = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance10,
      create_fragment10,
      safe_not_equal,
      {
        app: 9,
        properties: 10,
        onSubmit: 11,
        onClose: 0
      },
      add_css3
    );
  }
};
var EditPropertiesModal_default = EditPropertiesModal;

// src/components/accordions/PropertyManagerAccordion.svelte
function add_css4(target) {
  append_styles(target, "svelte-165u5gt", ".property-manager-container.svelte-165u5gt{display:flex;flex-direction:column;gap:var(--size-4)}.property-form.svelte-165u5gt{display:flex;flex-direction:column;gap:var(--size-4)}.form-group.svelte-165u5gt{display:flex;flex-direction:column;gap:var(--size-2)}label.svelte-165u5gt{font-weight:var(--font-bold);color:var(--text-normal)}input.svelte-165u5gt,textarea.svelte-165u5gt,select.svelte-165u5gt{background:var(--background-primary);border:1px solid var(--background-modifier-border);border-radius:var(--radius-s);padding:var(--size-2);color:var(--text-normal);width:100%}textarea.svelte-165u5gt{resize:vertical;min-height:100px}.description.svelte-165u5gt{color:var(--text-muted);font-size:var(--font-ui-smaller)}.property-actions.svelte-165u5gt{display:flex;gap:var(--size-4);margin-top:var(--size-4)}button.svelte-165u5gt{padding:var(--size-2) var(--size-4);border-radius:var(--radius-s);border:none;cursor:pointer;font-weight:var(--font-bold);transition:background-color 0.2s ease}.add-button.svelte-165u5gt{background-color:var(--interactive-accent);color:var(--text-on-accent)}.add-button.svelte-165u5gt:hover:not(:disabled){background-color:var(--interactive-accent-hover)}.edit-button.svelte-165u5gt{background-color:var(--background-modifier-border);color:var(--text-normal)}.edit-button.svelte-165u5gt:hover{background-color:var(--background-modifier-border-hover)}button.svelte-165u5gt:disabled{opacity:0.5;cursor:not-allowed}");
}
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i][0];
  child_ctx[17] = list[i][1];
  return child_ctx;
}
function create_each_block4(ctx) {
  let option;
  let t_value = (
    /*label*/
    ctx[17] + ""
  );
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = /*value*/
      ctx[16];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_default_slot6(ctx) {
  let div5;
  let div3;
  let div0;
  let label0;
  let t1;
  let input;
  let t2;
  let span0;
  let t4;
  let div1;
  let label1;
  let t6;
  let textarea;
  let t7;
  let span1;
  let t9;
  let div2;
  let label2;
  let t11;
  let select;
  let t12;
  let span2;
  let t14;
  let div4;
  let button0;
  let t15_value = (
    /*isAddingProperty*/
    ctx[6] ? "Adding..." : "Add Property"
  );
  let t15;
  let t16;
  let button1;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(Object.entries(
    /*propertyTypes*/
    ctx[7]
  ));
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  return {
    c() {
      div5 = element("div");
      div3 = element("div");
      div0 = element("div");
      label0 = element("label");
      label0.textContent = "Property Name";
      t1 = space();
      input = element("input");
      t2 = space();
      span0 = element("span");
      span0.textContent = "The name of the property";
      t4 = space();
      div1 = element("div");
      label1 = element("label");
      label1.textContent = "Property Description";
      t6 = space();
      textarea = element("textarea");
      t7 = space();
      span1 = element("span");
      span1.textContent = "A description of what the property represents";
      t9 = space();
      div2 = element("div");
      label2 = element("label");
      label2.textContent = "Property Type";
      t11 = space();
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t12 = space();
      span2 = element("span");
      span2.textContent = "The data type of the property";
      t14 = space();
      div4 = element("div");
      button0 = element("button");
      t15 = text(t15_value);
      t16 = space();
      button1 = element("button");
      button1.textContent = "Edit Properties";
      attr(label0, "for", "property-name");
      attr(label0, "class", "svelte-165u5gt");
      attr(input, "id", "property-name");
      attr(input, "type", "text");
      attr(input, "placeholder", "Enter property name");
      attr(input, "class", "svelte-165u5gt");
      attr(span0, "class", "description svelte-165u5gt");
      attr(div0, "class", "form-group svelte-165u5gt");
      attr(label1, "for", "property-description");
      attr(label1, "class", "svelte-165u5gt");
      attr(textarea, "id", "property-description");
      attr(textarea, "placeholder", "Enter property description");
      attr(textarea, "rows", "4");
      attr(textarea, "class", "svelte-165u5gt");
      attr(span1, "class", "description svelte-165u5gt");
      attr(div1, "class", "form-group svelte-165u5gt");
      attr(label2, "for", "property-type");
      attr(label2, "class", "svelte-165u5gt");
      attr(select, "id", "property-type");
      attr(select, "class", "svelte-165u5gt");
      if (
        /*propertyType*/
        ctx[5] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[12].call(select)
        ));
      attr(span2, "class", "description svelte-165u5gt");
      attr(div2, "class", "form-group svelte-165u5gt");
      attr(div3, "class", "property-form svelte-165u5gt");
      attr(button0, "class", "add-button svelte-165u5gt");
      button0.disabled = /*isAddingProperty*/
      ctx[6];
      attr(button1, "class", "edit-button svelte-165u5gt");
      attr(div4, "class", "property-actions svelte-165u5gt");
      attr(div5, "class", "property-manager-container svelte-165u5gt");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div3);
      append(div3, div0);
      append(div0, label0);
      append(div0, t1);
      append(div0, input);
      set_input_value(
        input,
        /*propertyName*/
        ctx[3]
      );
      append(div0, t2);
      append(div0, span0);
      append(div3, t4);
      append(div3, div1);
      append(div1, label1);
      append(div1, t6);
      append(div1, textarea);
      set_input_value(
        textarea,
        /*propertyDescription*/
        ctx[4]
      );
      append(div1, t7);
      append(div1, span1);
      append(div3, t9);
      append(div3, div2);
      append(div2, label2);
      append(div2, t11);
      append(div2, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*propertyType*/
        ctx[5],
        true
      );
      append(div2, t12);
      append(div2, span2);
      append(div5, t14);
      append(div5, div4);
      append(div4, button0);
      append(button0, t15);
      append(div4, t16);
      append(div4, button1);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[10]
          ),
          listen(
            textarea,
            "input",
            /*textarea_input_handler*/
            ctx[11]
          ),
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[12]
          ),
          listen(
            button0,
            "click",
            /*addProperty*/
            ctx[8]
          ),
          listen(
            button1,
            "click",
            /*openEditModal*/
            ctx[9]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*propertyName*/
      8 && input.value !== /*propertyName*/
      ctx2[3]) {
        set_input_value(
          input,
          /*propertyName*/
          ctx2[3]
        );
      }
      if (dirty & /*propertyDescription*/
      16) {
        set_input_value(
          textarea,
          /*propertyDescription*/
          ctx2[4]
        );
      }
      if (dirty & /*Object, propertyTypes*/
      128) {
        each_value = ensure_array_like(Object.entries(
          /*propertyTypes*/
          ctx2[7]
        ));
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*propertyType, Object, propertyTypes*/
      160) {
        select_option(
          select,
          /*propertyType*/
          ctx2[5]
        );
      }
      if (dirty & /*isAddingProperty*/
      64 && t15_value !== (t15_value = /*isAddingProperty*/
      ctx2[6] ? "Adding..." : "Add Property"))
        set_data(t15, t15_value);
      if (dirty & /*isAddingProperty*/
      64) {
        button0.disabled = /*isAddingProperty*/
        ctx2[6];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div5);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment11(ctx) {
  let baseaccordion;
  let current;
  baseaccordion = new BaseAccordion_default({
    props: {
      title: "\u{1F4CA} Property Management",
      description: "Create and manage custom properties for your notes.",
      app: (
        /*app*/
        ctx[0]
      ),
      settingsService: (
        /*settingsService*/
        ctx[1]
      ),
      aiService: (
        /*aiService*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(baseaccordion.$$.fragment);
    },
    m(target, anchor) {
      mount_component(baseaccordion, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const baseaccordion_changes = {};
      if (dirty & /*app*/
      1)
        baseaccordion_changes.app = /*app*/
        ctx2[0];
      if (dirty & /*settingsService*/
      2)
        baseaccordion_changes.settingsService = /*settingsService*/
        ctx2[1];
      if (dirty & /*aiService*/
      4)
        baseaccordion_changes.aiService = /*aiService*/
        ctx2[2];
      if (dirty & /*$$scope, isAddingProperty, propertyType, propertyDescription, propertyName*/
      1048696) {
        baseaccordion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      baseaccordion.$set(baseaccordion_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(baseaccordion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(baseaccordion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(baseaccordion, detaching);
    }
  };
}
function validateInput(value, type) {
  const trimmed = value.trim();
  const minLength = type === "name" ? 2 : 10;
  if (!trimmed) {
    return `Property ${type} cannot be empty.`;
  }
  if (trimmed.length < minLength) {
    return `Property ${type} must be at least ${minLength} characters.`;
  }
  return null;
}
function instance11($$self, $$props, $$invalidate) {
  var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  let { app } = $$props;
  let { settingsService } = $$props;
  let { aiService } = $$props;
  let propertyName = "";
  let propertyDescription = "";
  let propertyType = "string";
  let isAddingProperty = false;
  const propertyTypes = {
    "string": "Text",
    "number": "Number",
    "boolean": "True/False",
    "array": "List",
    "date": "Date"
  };
  function addProperty() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        $$invalidate(6, isAddingProperty = true);
        const nameError = validateInput(propertyName, "name");
        const descriptionError = validateInput(propertyDescription, "description");
        if (nameError || descriptionError) {
          throw new Error(nameError || descriptionError || "Validation failed");
        }
        const newProperty = {
          name: propertyName.trim(),
          description: propertyDescription.trim(),
          type: propertyType,
          required: false,
          multipleValues: false
        };
        const settings = settingsService.getSettings();
        const customProperties = [...settings.frontMatter.customProperties, newProperty];
        yield settingsService.updateSettings(Object.assign(Object.assign({}, settings), {
          frontMatter: Object.assign(Object.assign({}, settings.frontMatter), { customProperties })
        }));
        resetForm();
        new import_obsidian15.Notice(`Property "${newProperty.name}" has been added successfully.`);
      } catch (error) {
        console.error("Error adding property:", error);
        new import_obsidian15.Notice(`Failed to add property: ${error instanceof Error ? error.message : "Unknown error"}`);
      } finally {
        $$invalidate(6, isAddingProperty = false);
      }
    });
  }
  function resetForm() {
    $$invalidate(3, propertyName = "");
    $$invalidate(4, propertyDescription = "");
    $$invalidate(5, propertyType = "string");
  }
  function openEditModal() {
    try {
      const currentProperties = settingsService.getSettings().frontMatter.customProperties;
      const modal = new EditPropertiesModal_default({
        target: document.body,
        props: {
          app,
          properties: currentProperties,
          onSubmit: handlePropertiesUpdate,
          onClose: () => modal.close()
        }
      });
    } catch (error) {
      console.error("Error opening edit modal:", error);
      new import_obsidian15.Notice(`Failed to open edit modal: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  function handlePropertiesUpdate(updatedProperties) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const settings = settingsService.getSettings();
        yield settingsService.updateSettings(Object.assign(Object.assign({}, settings), {
          frontMatter: Object.assign(Object.assign({}, settings.frontMatter), { customProperties: updatedProperties })
        }));
        new import_obsidian15.Notice("Properties updated successfully");
      } catch (error) {
        console.error("Error updating properties:", error);
        new import_obsidian15.Notice(`Failed to update properties: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    });
  }
  function input_input_handler() {
    propertyName = this.value;
    $$invalidate(3, propertyName);
  }
  function textarea_input_handler() {
    propertyDescription = this.value;
    $$invalidate(4, propertyDescription);
  }
  function select_change_handler() {
    propertyType = select_value(this);
    $$invalidate(5, propertyType);
    $$invalidate(7, propertyTypes);
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("settingsService" in $$props2)
      $$invalidate(1, settingsService = $$props2.settingsService);
    if ("aiService" in $$props2)
      $$invalidate(2, aiService = $$props2.aiService);
  };
  return [
    app,
    settingsService,
    aiService,
    propertyName,
    propertyDescription,
    propertyType,
    isAddingProperty,
    propertyTypes,
    addProperty,
    openEditModal,
    input_input_handler,
    textarea_input_handler,
    select_change_handler
  ];
}
var PropertyManagerAccordion = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance11, create_fragment11, safe_not_equal, { app: 0, settingsService: 1, aiService: 2 }, add_css4);
  }
};
var PropertyManagerAccordion_default = PropertyManagerAccordion;

// src/components/accordions/TagManagerAccordion.svelte
var import_obsidian17 = require("obsidian");

// src/components/modals/EditTagsModal.svelte
var import_obsidian16 = require("obsidian");
function add_css5(target) {
  append_styles(target, "svelte-6yt03h", ".edit-tags-modal.svelte-6yt03h.svelte-6yt03h{display:flex;flex-direction:column;gap:var(--size-4);padding:var(--size-4);max-width:800px;width:100%}.modal-header.svelte-6yt03h.svelte-6yt03h{border-bottom:1px solid var(--background-modifier-border);padding-bottom:var(--size-4)}.modal-header.svelte-6yt03h h2.svelte-6yt03h{margin:0;color:var(--text-normal);font-size:var(--font-ui-large)}.search-sort-container.svelte-6yt03h.svelte-6yt03h{display:flex;gap:var(--size-4);margin-bottom:var(--size-4)}.sort-button.svelte-6yt03h.svelte-6yt03h{display:flex;align-items:center;gap:var(--size-2);padding:var(--size-2) var(--size-4);background-color:var(--background-secondary);border:1px solid var(--background-modifier-border);border-radius:var(--radius-s);color:var(--text-normal);cursor:pointer}.sort-button.svelte-6yt03h.svelte-6yt03h:hover{background-color:var(--background-modifier-hover)}.sort-icon.svelte-6yt03h.svelte-6yt03h{transition:transform 0.2s ease}.sort-icon.desc.svelte-6yt03h.svelte-6yt03h{transform:rotate(180deg)}.select-all-container.svelte-6yt03h.svelte-6yt03h{margin-bottom:var(--size-4)}.select-all-label.svelte-6yt03h.svelte-6yt03h{display:flex;align-items:center;gap:var(--size-2);cursor:pointer}.table-container.svelte-6yt03h.svelte-6yt03h{overflow-x:auto;margin-bottom:var(--size-4)}table.svelte-6yt03h.svelte-6yt03h{width:100%;border-collapse:collapse}th.svelte-6yt03h.svelte-6yt03h,td.svelte-6yt03h.svelte-6yt03h{padding:var(--size-2) var(--size-4);border-bottom:1px solid var(--background-modifier-border)}.align-center.svelte-6yt03h.svelte-6yt03h{text-align:center}.align-left.svelte-6yt03h.svelte-6yt03h{text-align:left}.tag-input.svelte-6yt03h.svelte-6yt03h,.tag-textarea.svelte-6yt03h.svelte-6yt03h{width:100%;background:var(--background-primary);border:1px solid var(--background-modifier-border);border-radius:var(--radius-s);padding:var(--size-2);color:var(--text-normal)}.tag-textarea.svelte-6yt03h.svelte-6yt03h{resize:vertical}.modal-footer.svelte-6yt03h.svelte-6yt03h{display:flex;justify-content:flex-end;gap:var(--size-4);padding-top:var(--size-4);border-top:1px solid var(--background-modifier-border)}button.svelte-6yt03h.svelte-6yt03h{padding:var(--size-2) var(--size-4);border-radius:var(--radius-s);border:none;cursor:pointer;font-weight:var(--font-bold)}button.mod-cta.svelte-6yt03h.svelte-6yt03h{background-color:var(--interactive-accent);color:var(--text-on-accent)}button.mod-warning.svelte-6yt03h.svelte-6yt03h{background-color:var(--background-modifier-error);color:var(--text-on-accent)}button.mod-cancel.svelte-6yt03h.svelte-6yt03h{background-color:var(--background-modifier-border);color:var(--text-normal)}button.svelte-6yt03h.svelte-6yt03h:hover:not(:disabled){opacity:0.8}");
}
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i];
  child_ctx[18] = list;
  child_ctx[19] = i;
  return child_ctx;
}
function create_else_block5(ctx) {
  let t;
  return {
    c() {
      t = text("\u25BC");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block8(ctx) {
  let t;
  return {
    c() {
      t = text("\u25B2");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_each_block5(key_1, ctx) {
  let tr;
  let td0;
  let input0;
  let t0;
  let td1;
  let textarea;
  let t1;
  let td2;
  let input1;
  let input1_data_index_value;
  let t2;
  let mounted;
  let dispose;
  function input0_input_handler() {
    ctx[15].call(
      input0,
      /*each_value*/
      ctx[18],
      /*index*/
      ctx[19]
    );
  }
  function textarea_input_handler() {
    ctx[16].call(
      textarea,
      /*each_value*/
      ctx[18],
      /*index*/
      ctx[19]
    );
  }
  return {
    key: key_1,
    first: null,
    c() {
      tr = element("tr");
      td0 = element("td");
      input0 = element("input");
      t0 = space();
      td1 = element("td");
      textarea = element("textarea");
      t1 = space();
      td2 = element("td");
      input1 = element("input");
      t2 = space();
      attr(input0, "type", "text");
      attr(input0, "class", "tag-input svelte-6yt03h");
      attr(td0, "class", "svelte-6yt03h");
      attr(textarea, "class", "tag-textarea svelte-6yt03h");
      attr(textarea, "rows", "2");
      attr(td1, "class", "svelte-6yt03h");
      attr(input1, "type", "checkbox");
      input1.checked = /*selectAllChecked*/
      ctx[3];
      attr(input1, "data-index", input1_data_index_value = /*index*/
      ctx[19]);
      attr(td2, "class", "align-center svelte-6yt03h");
      this.first = tr;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, input0);
      set_input_value(
        input0,
        /*tag*/
        ctx[17].name
      );
      append(tr, t0);
      append(tr, td1);
      append(td1, textarea);
      set_input_value(
        textarea,
        /*tag*/
        ctx[17].description
      );
      append(tr, t1);
      append(tr, td2);
      append(td2, input1);
      append(tr, t2);
      if (!mounted) {
        dispose = [
          listen(input0, "input", input0_input_handler),
          listen(textarea, "input", textarea_input_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*filteredTags*/
      16 && input0.value !== /*tag*/
      ctx[17].name) {
        set_input_value(
          input0,
          /*tag*/
          ctx[17].name
        );
      }
      if (dirty & /*filteredTags*/
      16) {
        set_input_value(
          textarea,
          /*tag*/
          ctx[17].description
        );
      }
      if (dirty & /*selectAllChecked*/
      8) {
        input1.checked = /*selectAllChecked*/
        ctx[3];
      }
      if (dirty & /*filteredTags*/
      16 && input1_data_index_value !== (input1_data_index_value = /*index*/
      ctx[19])) {
        attr(input1, "data-index", input1_data_index_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(tr);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment12(ctx) {
  let div6;
  let header;
  let t1;
  let div5;
  let div1;
  let search;
  let updating_value;
  let t2;
  let button0;
  let div0;
  let t3;
  let button0_title_value;
  let t4;
  let div2;
  let label;
  let input;
  let t5;
  let span;
  let t7;
  let div3;
  let table;
  let thead;
  let t13;
  let tbody;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t14;
  let div4;
  let button1;
  let t16;
  let button2;
  let t18;
  let button3;
  let current;
  let mounted;
  let dispose;
  function search_value_binding(value) {
    ctx[13](value);
  }
  let search_props = {
    size: "md",
    placeholder: "Search tags..."
  };
  if (
    /*searchQuery*/
    ctx[1] !== void 0
  ) {
    search_props.value = /*searchQuery*/
    ctx[1];
  }
  search = new Search_default({ props: search_props });
  binding_callbacks.push(() => bind(search, "value", search_value_binding));
  function select_block_type(ctx2, dirty) {
    if (
      /*sortDirection*/
      ctx2[2] === "asc"
    )
      return create_if_block8;
    return create_else_block5;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  let each_value = ensure_array_like(
    /*filteredTags*/
    ctx[4]
  );
  const get_key = (ctx2) => (
    /*tag*/
    ctx2[17].name
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context5(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block5(key, child_ctx));
  }
  return {
    c() {
      div6 = element("div");
      header = element("header");
      header.innerHTML = `<h2 class="svelte-6yt03h">Edit Tags</h2>`;
      t1 = space();
      div5 = element("div");
      div1 = element("div");
      create_component(search.$$.fragment);
      t2 = space();
      button0 = element("button");
      div0 = element("div");
      if_block.c();
      t3 = text("\r\n          Sort A-Z");
      t4 = space();
      div2 = element("div");
      label = element("label");
      input = element("input");
      t5 = space();
      span = element("span");
      span.textContent = "Select All";
      t7 = space();
      div3 = element("div");
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr><th class="align-left svelte-6yt03h">Name</th> <th class="align-left svelte-6yt03h">Description</th> <th class="align-center svelte-6yt03h">Delete</th></tr>`;
      t13 = space();
      tbody = element("tbody");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t14 = space();
      div4 = element("div");
      button1 = element("button");
      button1.textContent = "Delete Selected";
      t16 = space();
      button2 = element("button");
      button2.textContent = "Save";
      t18 = space();
      button3 = element("button");
      button3.textContent = "Cancel";
      attr(header, "class", "modal-header svelte-6yt03h");
      attr(div0, "class", "sort-icon svelte-6yt03h");
      toggle_class(
        div0,
        "desc",
        /*sortDirection*/
        ctx[2] === "desc"
      );
      attr(button0, "class", "sort-button svelte-6yt03h");
      attr(button0, "title", button0_title_value = `Sort ${/*sortDirection*/
      ctx[2] === "asc" ? "descending" : "ascending"}`);
      attr(div1, "class", "search-sort-container svelte-6yt03h");
      attr(input, "type", "checkbox");
      attr(label, "class", "select-all-label svelte-6yt03h");
      attr(div2, "class", "select-all-container svelte-6yt03h");
      attr(table, "class", "svelte-6yt03h");
      attr(div3, "class", "table-container svelte-6yt03h");
      attr(button1, "class", "mod-warning svelte-6yt03h");
      attr(button2, "class", "mod-cta svelte-6yt03h");
      attr(button3, "class", "mod-cancel svelte-6yt03h");
      attr(div4, "class", "modal-footer svelte-6yt03h");
      attr(div5, "class", "modal-content");
      attr(div6, "class", "edit-tags-modal svelte-6yt03h");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, header);
      append(div6, t1);
      append(div6, div5);
      append(div5, div1);
      mount_component(search, div1, null);
      append(div1, t2);
      append(div1, button0);
      append(button0, div0);
      if_block.m(div0, null);
      append(button0, t3);
      append(div5, t4);
      append(div5, div2);
      append(div2, label);
      append(label, input);
      input.checked = /*selectAllChecked*/
      ctx[3];
      append(label, t5);
      append(label, span);
      append(div5, t7);
      append(div5, div3);
      append(div3, table);
      append(table, thead);
      append(table, t13);
      append(table, tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tbody, null);
        }
      }
      append(div5, t14);
      append(div5, div4);
      append(div4, button1);
      append(div4, t16);
      append(div4, button2);
      append(div4, t18);
      append(div4, button3);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*toggleSort*/
            ctx[5]
          ),
          listen(
            input,
            "change",
            /*input_change_handler*/
            ctx[14]
          ),
          listen(
            input,
            "change",
            /*handleSelectAll*/
            ctx[6]
          ),
          listen(
            button1,
            "click",
            /*handleDelete*/
            ctx[7]
          ),
          listen(
            button2,
            "click",
            /*handleSave*/
            ctx[8]
          ),
          listen(button3, "click", function() {
            if (is_function(
              /*onClose*/
              ctx[0]
            ))
              ctx[0].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      const search_changes = {};
      if (!updating_value && dirty & /*searchQuery*/
      2) {
        updating_value = true;
        search_changes.value = /*searchQuery*/
        ctx[1];
        add_flush_callback(() => updating_value = false);
      }
      search.$set(search_changes);
      if (current_block_type !== (current_block_type = select_block_type(ctx, dirty))) {
        if_block.d(1);
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(div0, null);
        }
      }
      if (!current || dirty & /*sortDirection*/
      4) {
        toggle_class(
          div0,
          "desc",
          /*sortDirection*/
          ctx[2] === "desc"
        );
      }
      if (!current || dirty & /*sortDirection*/
      4 && button0_title_value !== (button0_title_value = `Sort ${/*sortDirection*/
      ctx[2] === "asc" ? "descending" : "ascending"}`)) {
        attr(button0, "title", button0_title_value);
      }
      if (dirty & /*selectAllChecked*/
      8) {
        input.checked = /*selectAllChecked*/
        ctx[3];
      }
      if (dirty & /*selectAllChecked, filteredTags*/
      24) {
        each_value = ensure_array_like(
          /*filteredTags*/
          ctx[4]
        );
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, tbody, destroy_block, create_each_block5, null, get_each_context5);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(search.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(search.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div6);
      }
      destroy_component(search);
      if_block.d();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance12($$self, $$props, $$invalidate) {
  let filteredTags;
  let { app } = $$props;
  let { tags } = $$props;
  let { onSubmit } = $$props;
  let { onClose } = $$props;
  let localTags = [...tags];
  let selectAllChecked = false;
  let searchQuery = "";
  let sortDirection = "asc";
  function toggleSort() {
    $$invalidate(2, sortDirection = sortDirection === "asc" ? "desc" : "asc");
  }
  function handleSelectAll(event) {
    $$invalidate(3, selectAllChecked = event.target.checked);
  }
  function handleDelete() {
    $$invalidate(12, localTags = localTags.filter((_, index) => {
      const checkbox = document.querySelector(`input[data-index="${index}"]`);
      return !(checkbox === null || checkbox === void 0 ? void 0 : checkbox.checked);
    }));
    $$invalidate(3, selectAllChecked = false);
  }
  function handleSave() {
    onSubmit(localTags);
    onClose();
  }
  function search_value_binding(value) {
    searchQuery = value;
    $$invalidate(1, searchQuery);
  }
  function input_change_handler() {
    selectAllChecked = this.checked;
    $$invalidate(3, selectAllChecked);
  }
  function input0_input_handler(each_value, index) {
    each_value[index].name = this.value;
    $$invalidate(4, filteredTags), $$invalidate(12, localTags), $$invalidate(1, searchQuery), $$invalidate(2, sortDirection);
  }
  function textarea_input_handler(each_value, index) {
    each_value[index].description = this.value;
    $$invalidate(4, filteredTags), $$invalidate(12, localTags), $$invalidate(1, searchQuery), $$invalidate(2, sortDirection);
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(9, app = $$props2.app);
    if ("tags" in $$props2)
      $$invalidate(10, tags = $$props2.tags);
    if ("onSubmit" in $$props2)
      $$invalidate(11, onSubmit = $$props2.onSubmit);
    if ("onClose" in $$props2)
      $$invalidate(0, onClose = $$props2.onClose);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*localTags, searchQuery, sortDirection*/
    4102) {
      $:
        $$invalidate(4, filteredTags = localTags.filter((tag) => {
          if (!searchQuery)
            return true;
          const query = searchQuery.toLowerCase();
          return tag.name.toLowerCase().includes(query) || tag.description.toLowerCase().includes(query);
        }).sort((a, b) => {
          const comparison = a.name.localeCompare(b.name);
          return sortDirection === "asc" ? comparison : -comparison;
        }));
    }
  };
  return [
    onClose,
    searchQuery,
    sortDirection,
    selectAllChecked,
    filteredTags,
    toggleSort,
    handleSelectAll,
    handleDelete,
    handleSave,
    app,
    tags,
    onSubmit,
    localTags,
    search_value_binding,
    input_change_handler,
    input0_input_handler,
    textarea_input_handler
  ];
}
var EditTagsModal = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance12,
      create_fragment12,
      safe_not_equal,
      {
        app: 9,
        tags: 10,
        onSubmit: 11,
        onClose: 0
      },
      add_css5
    );
  }
};
var EditTagsModal_default = EditTagsModal;

// src/components/accordions/TagManagerAccordion.svelte
function add_css6(target) {
  append_styles(target, "svelte-1nc1b3i", ".tag-manager-container.svelte-1nc1b3i{display:flex;flex-direction:column;gap:var(--size-4)}.tag-form.svelte-1nc1b3i{display:flex;flex-direction:column;gap:var(--size-4)}.form-group.svelte-1nc1b3i{display:flex;flex-direction:column;gap:var(--size-2)}label.svelte-1nc1b3i{font-weight:var(--font-bold);color:var(--text-normal)}input.svelte-1nc1b3i,textarea.svelte-1nc1b3i{background:var(--background-primary);border:1px solid var(--background-modifier-border);border-radius:var(--radius-s);padding:var(--size-2);color:var(--text-normal);width:100%}textarea.svelte-1nc1b3i{resize:vertical;min-height:100px}.description.svelte-1nc1b3i{color:var(--text-muted);font-size:var(--font-ui-smaller)}.tag-actions.svelte-1nc1b3i{display:flex;gap:var(--size-4);margin-top:var(--size-4)}button.svelte-1nc1b3i{padding:var(--size-2) var(--size-4);border-radius:var(--radius-s);border:none;cursor:pointer;font-weight:var(--font-bold);transition:background-color 0.2s ease}.add-button.svelte-1nc1b3i{background-color:var(--interactive-accent);color:var(--text-on-accent)}.add-button.svelte-1nc1b3i:hover:not(:disabled){background-color:var(--interactive-accent-hover)}.edit-button.svelte-1nc1b3i{background-color:var(--background-modifier-border);color:var(--text-normal)}.edit-button.svelte-1nc1b3i:hover{background-color:var(--background-modifier-border-hover)}button.svelte-1nc1b3i:disabled{opacity:0.5;cursor:not-allowed}");
}
function create_default_slot7(ctx) {
  let div4;
  let div2;
  let div0;
  let label0;
  let t1;
  let input;
  let t2;
  let span0;
  let t4;
  let div1;
  let label1;
  let t6;
  let textarea;
  let t7;
  let span1;
  let t9;
  let div3;
  let button0;
  let t10_value = (
    /*isAddingTag*/
    ctx[5] ? "Adding..." : "Add Tag"
  );
  let t10;
  let t11;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      div4 = element("div");
      div2 = element("div");
      div0 = element("div");
      label0 = element("label");
      label0.textContent = "Tag Name";
      t1 = space();
      input = element("input");
      t2 = space();
      span0 = element("span");
      span0.textContent = "The name of the tag";
      t4 = space();
      div1 = element("div");
      label1 = element("label");
      label1.textContent = "Tag Description";
      t6 = space();
      textarea = element("textarea");
      t7 = space();
      span1 = element("span");
      span1.textContent = "A description of what the tag represents";
      t9 = space();
      div3 = element("div");
      button0 = element("button");
      t10 = text(t10_value);
      t11 = space();
      button1 = element("button");
      button1.textContent = "Edit Tags";
      attr(label0, "for", "tag-name");
      attr(label0, "class", "svelte-1nc1b3i");
      attr(input, "id", "tag-name");
      attr(input, "type", "text");
      attr(input, "placeholder", "Enter tag name");
      attr(input, "class", "svelte-1nc1b3i");
      attr(span0, "class", "description svelte-1nc1b3i");
      attr(div0, "class", "form-group svelte-1nc1b3i");
      attr(label1, "for", "tag-description");
      attr(label1, "class", "svelte-1nc1b3i");
      attr(textarea, "id", "tag-description");
      attr(textarea, "placeholder", "Enter tag description");
      attr(textarea, "rows", "4");
      attr(textarea, "class", "svelte-1nc1b3i");
      attr(span1, "class", "description svelte-1nc1b3i");
      attr(div1, "class", "form-group svelte-1nc1b3i");
      attr(div2, "class", "tag-form svelte-1nc1b3i");
      attr(button0, "class", "add-button svelte-1nc1b3i");
      button0.disabled = /*isAddingTag*/
      ctx[5];
      attr(button1, "class", "edit-button svelte-1nc1b3i");
      attr(div3, "class", "tag-actions svelte-1nc1b3i");
      attr(div4, "class", "tag-manager-container svelte-1nc1b3i");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div2);
      append(div2, div0);
      append(div0, label0);
      append(div0, t1);
      append(div0, input);
      set_input_value(
        input,
        /*tagName*/
        ctx[3]
      );
      append(div0, t2);
      append(div0, span0);
      append(div2, t4);
      append(div2, div1);
      append(div1, label1);
      append(div1, t6);
      append(div1, textarea);
      set_input_value(
        textarea,
        /*tagDescription*/
        ctx[4]
      );
      append(div1, t7);
      append(div1, span1);
      append(div4, t9);
      append(div4, div3);
      append(div3, button0);
      append(button0, t10);
      append(div3, t11);
      append(div3, button1);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[8]
          ),
          listen(
            textarea,
            "input",
            /*textarea_input_handler*/
            ctx[9]
          ),
          listen(
            button0,
            "click",
            /*addTag*/
            ctx[6]
          ),
          listen(
            button1,
            "click",
            /*openEditModal*/
            ctx[7]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*tagName*/
      8 && input.value !== /*tagName*/
      ctx2[3]) {
        set_input_value(
          input,
          /*tagName*/
          ctx2[3]
        );
      }
      if (dirty & /*tagDescription*/
      16) {
        set_input_value(
          textarea,
          /*tagDescription*/
          ctx2[4]
        );
      }
      if (dirty & /*isAddingTag*/
      32 && t10_value !== (t10_value = /*isAddingTag*/
      ctx2[5] ? "Adding..." : "Add Tag"))
        set_data(t10, t10_value);
      if (dirty & /*isAddingTag*/
      32) {
        button0.disabled = /*isAddingTag*/
        ctx2[5];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment13(ctx) {
  let baseaccordion;
  let current;
  baseaccordion = new BaseAccordion_default({
    props: {
      title: "\u{1F3F7}\uFE0F Tag Management",
      description: "Create and manage custom tags for your notes.",
      app: (
        /*app*/
        ctx[0]
      ),
      settingsService: (
        /*settingsService*/
        ctx[1]
      ),
      aiService: (
        /*aiService*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot7] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(baseaccordion.$$.fragment);
    },
    m(target, anchor) {
      mount_component(baseaccordion, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const baseaccordion_changes = {};
      if (dirty & /*app*/
      1)
        baseaccordion_changes.app = /*app*/
        ctx2[0];
      if (dirty & /*settingsService*/
      2)
        baseaccordion_changes.settingsService = /*settingsService*/
        ctx2[1];
      if (dirty & /*aiService*/
      4)
        baseaccordion_changes.aiService = /*aiService*/
        ctx2[2];
      if (dirty & /*$$scope, isAddingTag, tagDescription, tagName*/
      8248) {
        baseaccordion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      baseaccordion.$set(baseaccordion_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(baseaccordion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(baseaccordion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(baseaccordion, detaching);
    }
  };
}
function validateInput2(value, type) {
  const trimmed = value.trim();
  const minLength = type === "name" ? 2 : 10;
  if (!trimmed) {
    return `Tag ${type} cannot be empty.`;
  }
  if (trimmed.length < minLength) {
    return `Tag ${type} must be at least ${minLength} characters.`;
  }
  return null;
}
function instance13($$self, $$props, $$invalidate) {
  var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  let { app } = $$props;
  let { settingsService } = $$props;
  let { aiService } = $$props;
  let tagName = "";
  let tagDescription = "";
  let isAddingTag = false;
  function addTag() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        $$invalidate(5, isAddingTag = true);
        const nameError = validateInput2(tagName, "name");
        const descriptionError = validateInput2(tagDescription, "description");
        if (nameError || descriptionError) {
          throw new Error(nameError || descriptionError || "Validation error");
        }
        const newTag = {
          name: tagName.trim(),
          description: tagDescription.trim(),
          type: "string",
          required: false,
          multipleValues: false
        };
        const settings = settingsService.getSettings();
        const customTags = [...settings.tags.customTags, newTag];
        yield settingsService.updateSettings(Object.assign(Object.assign({}, settings), {
          tags: Object.assign(Object.assign({}, settings.tags), { customTags })
        }));
        resetForm();
        new import_obsidian17.Notice(`Tag "${newTag.name}" has been added successfully.`);
      } catch (error) {
        console.error("Error adding tag:", error);
        new import_obsidian17.Notice(`Failed to add tag: ${error instanceof Error ? error.message : "Unknown error"}`);
      } finally {
        $$invalidate(5, isAddingTag = false);
      }
    });
  }
  function resetForm() {
    $$invalidate(3, tagName = "");
    $$invalidate(4, tagDescription = "");
  }
  function openEditModal() {
    try {
      const currentTags = settingsService.getSettings().tags.customTags;
      const modal = new EditTagsModal_default({
        target: document.body,
        props: {
          app,
          tags: currentTags,
          onSubmit: handleTagsUpdate,
          onClose: () => modal.close()
        }
      });
    } catch (error) {
      console.error("Error opening edit modal:", error);
      new import_obsidian17.Notice(`Failed to open edit modal: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  function handleTagsUpdate(updatedTags) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const settings = settingsService.getSettings();
        yield settingsService.updateSettings(Object.assign(Object.assign({}, settings), {
          tags: Object.assign(Object.assign({}, settings.tags), { customTags: updatedTags })
        }));
        new import_obsidian17.Notice("Tags updated successfully");
      } catch (error) {
        console.error("Error updating tags:", error);
        new import_obsidian17.Notice(`Failed to update tags: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    });
  }
  function input_input_handler() {
    tagName = this.value;
    $$invalidate(3, tagName);
  }
  function textarea_input_handler() {
    tagDescription = this.value;
    $$invalidate(4, tagDescription);
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("settingsService" in $$props2)
      $$invalidate(1, settingsService = $$props2.settingsService);
    if ("aiService" in $$props2)
      $$invalidate(2, aiService = $$props2.aiService);
  };
  return [
    app,
    settingsService,
    aiService,
    tagName,
    tagDescription,
    isAddingTag,
    addTag,
    openEditModal,
    input_input_handler,
    textarea_input_handler
  ];
}
var TagManagerAccordion = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance13, create_fragment13, safe_not_equal, { app: 0, settingsService: 1, aiService: 2 }, add_css6);
  }
};
var TagManagerAccordion_default = TagManagerAccordion;

// src/components/accordions/OntologyGenerationAccordion.svelte
var import_obsidian19 = require("obsidian");

// src/components/modals/OntologyGeneratorModal.svelte
var import_obsidian18 = require("obsidian");
function add_css7(target) {
  append_styles(target, "svelte-qwsugj", ".ontology-generator-modal.svelte-qwsugj.svelte-qwsugj{display:flex;flex-direction:column;gap:var(--size-4);padding:var(--size-4);max-width:600px;width:100%}.modal-header.svelte-qwsugj.svelte-qwsugj{border-bottom:1px solid var(--background-modifier-border);padding-bottom:var(--size-4)}.modal-header.svelte-qwsugj h2.svelte-qwsugj{margin:0;margin-bottom:var(--size-2);color:var(--text-normal);font-size:var(--font-ui-large)}.modal-header.svelte-qwsugj p.svelte-qwsugj{margin:0;color:var(--text-muted)}.stats-container.svelte-qwsugj.svelte-qwsugj{display:grid;grid-template-columns:repeat(3, 1fr);gap:var(--size-4);margin-bottom:var(--size-4)}.stat-card.svelte-qwsugj.svelte-qwsugj{background-color:var(--background-secondary);border-radius:var(--radius-m);padding:var(--size-4);display:flex;align-items:center;gap:var(--size-4);box-shadow:0 2px 4px rgba(0, 0, 0, 0.1)}.stat-icon.svelte-qwsugj.svelte-qwsugj{color:var(--text-muted);display:flex;align-items:center;justify-content:center;width:24px;height:24px}.stat-info.svelte-qwsugj.svelte-qwsugj{display:flex;flex-direction:column}.stat-label.svelte-qwsugj.svelte-qwsugj{font-weight:var(--font-bold);color:var(--text-muted);font-size:var(--font-ui-small)}.stat-count.svelte-qwsugj.svelte-qwsugj{font-size:1.2em;color:var(--text-normal);font-weight:var(--font-bold)}.model-selection.svelte-qwsugj.svelte-qwsugj,.context-input.svelte-qwsugj.svelte-qwsugj{display:flex;flex-direction:column;gap:var(--size-2);margin-bottom:var(--size-4)}label.svelte-qwsugj.svelte-qwsugj{font-weight:var(--font-bold);color:var(--text-normal)}select.svelte-qwsugj.svelte-qwsugj,textarea.svelte-qwsugj.svelte-qwsugj{background:var(--background-primary);border:1px solid var(--background-modifier-border);border-radius:var(--radius-s);padding:var(--size-2);color:var(--text-normal);width:100%}textarea.svelte-qwsugj.svelte-qwsugj{resize:vertical;min-height:100px}.description.svelte-qwsugj.svelte-qwsugj{color:var(--text-muted);font-size:var(--font-ui-small)}.guided-questions.svelte-qwsugj.svelte-qwsugj{background-color:var(--background-secondary);border-radius:var(--radius-m);padding:var(--size-4);margin-bottom:var(--size-4)}.guided-questions.svelte-qwsugj h4.svelte-qwsugj{margin:0;margin-bottom:var(--size-2);color:var(--text-normal)}.guided-questions.svelte-qwsugj ul.svelte-qwsugj{margin:0;padding-left:var(--size-4);color:var(--text-muted)}.guided-questions.svelte-qwsugj li.svelte-qwsugj{margin-bottom:var(--size-2)}.modal-footer.svelte-qwsugj.svelte-qwsugj{display:flex;justify-content:flex-end;gap:var(--size-4);margin-top:var(--size-4);padding-top:var(--size-4);border-top:1px solid var(--background-modifier-border)}button.svelte-qwsugj.svelte-qwsugj{padding:var(--size-2) var(--size-4);border-radius:var(--radius-s);border:none;cursor:pointer;font-weight:var(--font-bold)}button.mod-cta.svelte-qwsugj.svelte-qwsugj{background-color:var(--interactive-accent);color:var(--text-on-accent)}button.mod-cta.svelte-qwsugj.svelte-qwsugj:hover:not(:disabled){background-color:var(--interactive-accent-hover)}button.mod-cancel.svelte-qwsugj.svelte-qwsugj{background-color:var(--background-modifier-border);color:var(--text-normal)}button.mod-cancel.svelte-qwsugj.svelte-qwsugj:hover:not(:disabled){background-color:var(--background-modifier-border-hover)}button.svelte-qwsugj.svelte-qwsugj:disabled{opacity:0.5;cursor:not-allowed}");
}
function get_each_context6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[25] = list[i];
  return child_ctx;
}
function get_each_context_13(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[28] = list[i];
  return child_ctx;
}
function create_each_block_13(ctx) {
  let option;
  let t_value = (
    /*model*/
    ctx[28].model + ""
  );
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = /*model*/
      ctx[28].model;
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_each_block6(ctx) {
  let li;
  return {
    c() {
      li = element("li");
      li.textContent = `${/*question*/
      ctx[25]}`;
      attr(li, "class", "svelte-qwsugj");
    },
    m(target, anchor) {
      insert(target, li, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(li);
      }
    }
  };
}
function create_fragment14(ctx) {
  let div15;
  let header;
  let t3;
  let div14;
  let div9;
  let div2;
  let div0;
  let t4;
  let div1;
  let span0;
  let t6;
  let span1;
  let t7_value = (
    /*vaultStats*/
    ctx[7].files.length + ""
  );
  let t7;
  let t8;
  let div5;
  let div3;
  let t9;
  let div4;
  let span2;
  let t11;
  let span3;
  let t12_value = (
    /*vaultStats*/
    ctx[7].folders.length + ""
  );
  let t12;
  let t13;
  let div8;
  let div6;
  let t14;
  let div7;
  let span4;
  let t16;
  let span5;
  let t17_value = (
    /*vaultStats*/
    ctx[7].tags.length + ""
  );
  let t17;
  let t18;
  let div10;
  let label0;
  let t20;
  let select;
  let option;
  let t22;
  let span6;
  let t24;
  let div11;
  let label1;
  let t26;
  let textarea;
  let t27;
  let span7;
  let t29;
  let div12;
  let h4;
  let t31;
  let ul;
  let t32;
  let div13;
  let button0;
  let t33_value = (
    /*isGenerating*/
    ctx[6] ? "Generating..." : "Generate Ontology"
  );
  let t33;
  let button0_disabled_value;
  let t34;
  let button1;
  let t35;
  let mounted;
  let dispose;
  let each_value_1 = ensure_array_like(
    /*availableModels*/
    ctx[8]
  );
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_13(get_each_context_13(ctx, each_value_1, i));
  }
  let each_value = ensure_array_like(
    /*guidedQuestions*/
    ctx[9]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block6(get_each_context6(ctx, each_value, i));
  }
  return {
    c() {
      div15 = element("div");
      header = element("header");
      header.innerHTML = `<h2 class="svelte-qwsugj">Generate Ontology</h2> <p class="svelte-qwsugj">Generate and manage ontologies for your vault</p>`;
      t3 = space();
      div14 = element("div");
      div9 = element("div");
      div2 = element("div");
      div0 = element("div");
      t4 = space();
      div1 = element("div");
      span0 = element("span");
      span0.textContent = "Files";
      t6 = space();
      span1 = element("span");
      t7 = text(t7_value);
      t8 = space();
      div5 = element("div");
      div3 = element("div");
      t9 = space();
      div4 = element("div");
      span2 = element("span");
      span2.textContent = "Folders";
      t11 = space();
      span3 = element("span");
      t12 = text(t12_value);
      t13 = space();
      div8 = element("div");
      div6 = element("div");
      t14 = space();
      div7 = element("div");
      span4 = element("span");
      span4.textContent = "Tags";
      t16 = space();
      span5 = element("span");
      t17 = text(t17_value);
      t18 = space();
      div10 = element("div");
      label0 = element("label");
      label0.textContent = "AI Model";
      t20 = space();
      select = element("select");
      option = element("option");
      option.textContent = "Select a model...";
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t22 = space();
      span6 = element("span");
      span6.textContent = "Select the AI model to use for ontology generation";
      t24 = space();
      div11 = element("div");
      label1 = element("label");
      label1.textContent = "Additional Context";
      t26 = space();
      textarea = element("textarea");
      t27 = space();
      span7 = element("span");
      span7.textContent = "Provide any additional context or information about your knowledge base.";
      t29 = space();
      div12 = element("div");
      h4 = element("h4");
      h4.textContent = "Consider These Questions";
      t31 = space();
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t32 = space();
      div13 = element("div");
      button0 = element("button");
      t33 = text(t33_value);
      t34 = space();
      button1 = element("button");
      t35 = text("Cancel");
      attr(header, "class", "modal-header svelte-qwsugj");
      attr(div0, "class", "stat-icon svelte-qwsugj");
      attr(span0, "class", "stat-label svelte-qwsugj");
      attr(span1, "class", "stat-count svelte-qwsugj");
      attr(div1, "class", "stat-info svelte-qwsugj");
      attr(div2, "class", "stat-card svelte-qwsugj");
      attr(div3, "class", "stat-icon svelte-qwsugj");
      attr(span2, "class", "stat-label svelte-qwsugj");
      attr(span3, "class", "stat-count svelte-qwsugj");
      attr(div4, "class", "stat-info svelte-qwsugj");
      attr(div5, "class", "stat-card svelte-qwsugj");
      attr(div6, "class", "stat-icon svelte-qwsugj");
      attr(span4, "class", "stat-label svelte-qwsugj");
      attr(span5, "class", "stat-count svelte-qwsugj");
      attr(div7, "class", "stat-info svelte-qwsugj");
      attr(div8, "class", "stat-card svelte-qwsugj");
      attr(div9, "class", "stats-container svelte-qwsugj");
      attr(label0, "for", "model-select");
      attr(label0, "class", "svelte-qwsugj");
      option.__value = "";
      set_input_value(option, option.__value);
      attr(select, "id", "model-select");
      attr(select, "class", "svelte-qwsugj");
      if (
        /*selectedModel*/
        ctx[4] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[20].call(select)
        ));
      attr(span6, "class", "description svelte-qwsugj");
      attr(div10, "class", "model-selection svelte-qwsugj");
      attr(label1, "for", "context");
      attr(label1, "class", "svelte-qwsugj");
      attr(textarea, "id", "context");
      attr(textarea, "placeholder", "Enter additional context here...");
      attr(textarea, "rows", "4");
      attr(textarea, "class", "svelte-qwsugj");
      attr(span7, "class", "description svelte-qwsugj");
      attr(div11, "class", "context-input svelte-qwsugj");
      attr(h4, "class", "svelte-qwsugj");
      attr(ul, "class", "svelte-qwsugj");
      attr(div12, "class", "guided-questions svelte-qwsugj");
      attr(button0, "class", "mod-cta svelte-qwsugj");
      button0.disabled = button0_disabled_value = /*isGenerating*/
      ctx[6] || !/*selectedModel*/
      ctx[4];
      attr(button1, "class", "mod-cancel svelte-qwsugj");
      button1.disabled = /*isGenerating*/
      ctx[6];
      attr(div13, "class", "modal-footer svelte-qwsugj");
      attr(div14, "class", "modal-content");
      attr(div15, "class", "ontology-generator-modal svelte-qwsugj");
    },
    m(target, anchor) {
      insert(target, div15, anchor);
      append(div15, header);
      append(div15, t3);
      append(div15, div14);
      append(div14, div9);
      append(div9, div2);
      append(div2, div0);
      ctx[17](div0);
      append(div2, t4);
      append(div2, div1);
      append(div1, span0);
      append(div1, t6);
      append(div1, span1);
      append(span1, t7);
      append(div9, t8);
      append(div9, div5);
      append(div5, div3);
      ctx[18](div3);
      append(div5, t9);
      append(div5, div4);
      append(div4, span2);
      append(div4, t11);
      append(div4, span3);
      append(span3, t12);
      append(div9, t13);
      append(div9, div8);
      append(div8, div6);
      ctx[19](div6);
      append(div8, t14);
      append(div8, div7);
      append(div7, span4);
      append(div7, t16);
      append(div7, span5);
      append(span5, t17);
      append(div14, t18);
      append(div14, div10);
      append(div10, label0);
      append(div10, t20);
      append(div10, select);
      append(select, option);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(select, null);
        }
      }
      select_option(
        select,
        /*selectedModel*/
        ctx[4],
        true
      );
      append(div10, t22);
      append(div10, span6);
      append(div14, t24);
      append(div14, div11);
      append(div11, label1);
      append(div11, t26);
      append(div11, textarea);
      set_input_value(
        textarea,
        /*userContext*/
        ctx[5]
      );
      append(div11, t27);
      append(div11, span7);
      append(div14, t29);
      append(div14, div12);
      append(div12, h4);
      append(div12, t31);
      append(div12, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      append(div14, t32);
      append(div14, div13);
      append(div13, button0);
      append(button0, t33);
      append(div13, t34);
      append(div13, button1);
      append(button1, t35);
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[20]
          ),
          listen(
            textarea,
            "input",
            /*textarea_input_handler*/
            ctx[21]
          ),
          listen(
            button0,
            "click",
            /*handleGenerate*/
            ctx[10]
          ),
          listen(button1, "click", function() {
            if (is_function(
              /*onClose*/
              ctx[0]
            ))
              ctx[0].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*vaultStats*/
      128 && t7_value !== (t7_value = /*vaultStats*/
      ctx[7].files.length + ""))
        set_data(t7, t7_value);
      if (dirty & /*vaultStats*/
      128 && t12_value !== (t12_value = /*vaultStats*/
      ctx[7].folders.length + ""))
        set_data(t12, t12_value);
      if (dirty & /*vaultStats*/
      128 && t17_value !== (t17_value = /*vaultStats*/
      ctx[7].tags.length + ""))
        set_data(t17, t17_value);
      if (dirty & /*availableModels*/
      256) {
        each_value_1 = ensure_array_like(
          /*availableModels*/
          ctx[8]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_13(ctx, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_13(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(select, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_1.length;
      }
      if (dirty & /*selectedModel, availableModels*/
      272) {
        select_option(
          select,
          /*selectedModel*/
          ctx[4]
        );
      }
      if (dirty & /*userContext*/
      32) {
        set_input_value(
          textarea,
          /*userContext*/
          ctx[5]
        );
      }
      if (dirty & /*guidedQuestions*/
      512) {
        each_value = ensure_array_like(
          /*guidedQuestions*/
          ctx[9]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context6(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block6(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*isGenerating*/
      64 && t33_value !== (t33_value = /*isGenerating*/
      ctx[6] ? "Generating..." : "Generate Ontology"))
        set_data(t33, t33_value);
      if (dirty & /*isGenerating, selectedModel, availableModels*/
      336 && button0_disabled_value !== (button0_disabled_value = /*isGenerating*/
      ctx[6] || !/*selectedModel*/
      ctx[4])) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & /*isGenerating*/
      64) {
        button1.disabled = /*isGenerating*/
        ctx[6];
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div15);
      }
      ctx[17](null);
      ctx[18](null);
      ctx[19](null);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function extractTags(content) {
  const tagRegex = /#(\w+)/g;
  const tags = [];
  let match;
  while ((match = tagRegex.exec(content)) !== null) {
    tags.push(match[1]);
  }
  return tags;
}
function instance14($$self, $$props, $$invalidate) {
  var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  let { app } = $$props;
  let { aiAdapter } = $$props;
  let { aiGenerationService } = $$props;
  let { tagManagementService } = $$props;
  let { adapterRegistry } = $$props;
  let { onGenerate } = $$props;
  let { onClose } = $$props;
  let fileIconEl;
  let folderIconEl;
  let tagIconEl;
  let selectedModel = "";
  let userContext = "";
  let isGenerating2 = false;
  let vaultStats = { files: [], folders: [], tags: [] };
  let availableModels = AIModelUtils.getModelsForProvider(aiAdapter.getProviderType()).map((model) => ({
    provider: aiAdapter.getProviderType(),
    model: model.name
  }));
  const guidedQuestions = [
    "What are the main themes or topics in your knowledge base?",
    "Are there any specific hierarchies or relationships between concepts that you want to emphasize?",
    "What are your goals for organizing your knowledge base?"
  ];
  onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    yield loadVaultStats();
    if (fileIconEl)
      (0, import_obsidian18.setIcon)(fileIconEl, "file");
    if (folderIconEl)
      (0, import_obsidian18.setIcon)(folderIconEl, "folder");
    if (tagIconEl)
      (0, import_obsidian18.setIcon)(tagIconEl, "tag");
  }));
  function loadVaultStats() {
    return __awaiter(this, void 0, void 0, function* () {
      $$invalidate(7, vaultStats.files = app.vault.getMarkdownFiles(), vaultStats);
      $$invalidate(7, vaultStats.folders = app.vault.getAllLoadedFiles().filter((file) => file instanceof import_obsidian18.TFolder), vaultStats);
      $$invalidate(7, vaultStats.tags = yield getAllTags(vaultStats.files), vaultStats);
    });
  }
  function getAllTags(files) {
    return __awaiter(this, void 0, void 0, function* () {
      const tagSet = /* @__PURE__ */ new Set();
      for (const file of files) {
        const content = yield app.vault.read(file);
        extractTags(content).forEach((tag) => tagSet.add(tag));
      }
      return Array.from(tagSet);
    });
  }
  function handleGenerate() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!selectedModel) {
        new import_obsidian18.Notice("Please select an AI model.");
        return;
      }
      $$invalidate(6, isGenerating2 = true);
      try {
        const input = {
          files: vaultStats.files,
          folders: vaultStats.folders,
          tags: vaultStats.tags,
          provider: aiAdapter.getProviderType(),
          modelApiName: selectedModel,
          userContext
        };
        const ontology = yield aiGenerationService.generateOntology(input);
        onGenerate(ontology);
        new import_obsidian18.Notice("Ontology generated successfully.");
        onClose();
      } catch (error) {
        console.error("Error generating ontology:", error);
        new import_obsidian18.Notice(`Error generating ontology: ${error instanceof Error ? error.message : "Unknown error"}`);
      } finally {
        $$invalidate(6, isGenerating2 = false);
      }
    });
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      fileIconEl = $$value;
      $$invalidate(1, fileIconEl);
    });
  }
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      folderIconEl = $$value;
      $$invalidate(2, folderIconEl);
    });
  }
  function div6_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      tagIconEl = $$value;
      $$invalidate(3, tagIconEl);
    });
  }
  function select_change_handler() {
    selectedModel = select_value(this);
    $$invalidate(4, selectedModel);
    $$invalidate(8, availableModels);
  }
  function textarea_input_handler() {
    userContext = this.value;
    $$invalidate(5, userContext);
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(11, app = $$props2.app);
    if ("aiAdapter" in $$props2)
      $$invalidate(12, aiAdapter = $$props2.aiAdapter);
    if ("aiGenerationService" in $$props2)
      $$invalidate(13, aiGenerationService = $$props2.aiGenerationService);
    if ("tagManagementService" in $$props2)
      $$invalidate(14, tagManagementService = $$props2.tagManagementService);
    if ("adapterRegistry" in $$props2)
      $$invalidate(15, adapterRegistry = $$props2.adapterRegistry);
    if ("onGenerate" in $$props2)
      $$invalidate(16, onGenerate = $$props2.onGenerate);
    if ("onClose" in $$props2)
      $$invalidate(0, onClose = $$props2.onClose);
  };
  return [
    onClose,
    fileIconEl,
    folderIconEl,
    tagIconEl,
    selectedModel,
    userContext,
    isGenerating2,
    vaultStats,
    availableModels,
    guidedQuestions,
    handleGenerate,
    app,
    aiAdapter,
    aiGenerationService,
    tagManagementService,
    adapterRegistry,
    onGenerate,
    div0_binding,
    div3_binding,
    div6_binding,
    select_change_handler,
    textarea_input_handler
  ];
}
var OntologyGeneratorModal = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance14,
      create_fragment14,
      safe_not_equal,
      {
        app: 11,
        aiAdapter: 12,
        aiGenerationService: 13,
        tagManagementService: 14,
        adapterRegistry: 15,
        onGenerate: 16,
        onClose: 0
      },
      add_css7
    );
  }
};
var OntologyGeneratorModal_default = OntologyGeneratorModal;

// src/components/accordions/OntologyGenerationAccordion.svelte
function add_css8(target) {
  append_styles(target, "svelte-1nm11xr", ".ontology-generation-container.svelte-1nm11xr{display:flex;flex-direction:column;gap:var(--size-4)}.generate-button.svelte-1nm11xr{background-color:var(--interactive-accent);color:var(--text-on-accent);padding:var(--size-2) var(--size-4);border-radius:var(--radius-s);border:none;cursor:pointer;font-weight:var(--font-bold);transition:background-color 0.2s ease}.generate-button.svelte-1nm11xr:hover:not(:disabled){background-color:var(--interactive-accent-hover)}.generate-button.svelte-1nm11xr:disabled{opacity:0.5;cursor:not-allowed}");
}
function create_default_slot8(ctx) {
  let div;
  let button;
  let t_value = isGenerating ? "Generating..." : "Generate Ontology";
  let t;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      t = text(t_value);
      attr(button, "class", "generate-button svelte-1nm11xr");
      button.disabled = isGenerating;
      attr(div, "class", "ontology-generation-container svelte-1nm11xr");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(button, t);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*openOntologyGeneratorModal*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment15(ctx) {
  let baseaccordion;
  let current;
  baseaccordion = new BaseAccordion_default({
    props: {
      title: "\u{1F9E0} Ontology Generation",
      description: "Generate and manage ontologies for your application.",
      app: (
        /*app*/
        ctx[0]
      ),
      settingsService: (
        /*settingsService*/
        ctx[1]
      ),
      aiService: (
        /*aiService*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot8] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(baseaccordion.$$.fragment);
    },
    m(target, anchor) {
      mount_component(baseaccordion, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const baseaccordion_changes = {};
      if (dirty & /*app*/
      1)
        baseaccordion_changes.app = /*app*/
        ctx2[0];
      if (dirty & /*settingsService*/
      2)
        baseaccordion_changes.settingsService = /*settingsService*/
        ctx2[1];
      if (dirty & /*aiService*/
      4)
        baseaccordion_changes.aiService = /*aiService*/
        ctx2[2];
      if (dirty & /*$$scope*/
      2048) {
        baseaccordion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      baseaccordion.$set(baseaccordion_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(baseaccordion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(baseaccordion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(baseaccordion, detaching);
    }
  };
}
var isGenerating = false;
function convertOntologyToTags(suggestedTags, existingTags) {
  const existingTagMap = new Map(existingTags.map((tag) => [tag.name.toLowerCase(), tag]));
  const processedTags = suggestedTags.map((suggestedTag) => {
    const existingTag = existingTagMap.get(suggestedTag.name.toLowerCase());
    if (existingTag) {
      return Object.assign(Object.assign({}, existingTag), {
        description: existingTag.description || suggestedTag.description
      });
    }
    return {
      name: suggestedTag.name,
      description: suggestedTag.description,
      type: "string",
      required: false,
      multipleValues: false,
      defaultValue: void 0,
      options: void 0
    };
  });
  existingTags.forEach((existingTag) => {
    if (!processedTags.some((tag) => tag.name.toLowerCase() === existingTag.name.toLowerCase())) {
      processedTags.push(Object.assign({}, existingTag));
    }
  });
  return processedTags;
}
function instance15($$self, $$props, $$invalidate) {
  var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  let { app } = $$props;
  let { settingsService } = $$props;
  let { aiAdapter } = $$props;
  let { generationService } = $$props;
  let { adapterRegistry } = $$props;
  let { tagManagementService } = $$props;
  let { aiService } = $$props;
  let modal = null;
  function openOntologyGeneratorModal() {
    try {
      if (!modal) {
        modal = new OntologyGeneratorModal_default({
          target: document.body,
          props: {
            app,
            aiAdapter,
            aiGenerationService: generationService,
            tagManagementService,
            adapterRegistry,
            onGenerate: handleOntologyGenerated,
            onClose: () => {
              modal === null || modal === void 0 ? void 0 : modal.$destroy();
              modal = null;
            }
          }
        });
      }
    } catch (error) {
      console.error("Failed to open ontology generator:", error);
      new import_obsidian19.Notice(`Failed to open ontology generator: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  function handleOntologyGenerated(ontology) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      try {
        if (!((_a = ontology === null || ontology === void 0 ? void 0 : ontology.suggestedTags) === null || _a === void 0 ? void 0 : _a.length)) {
          throw new Error("No tags suggested in ontology result");
        }
        const existingTags = settingsService.getSettings().tags.customTags;
        const newTags = convertOntologyToTags(ontology.suggestedTags, existingTags);
        const editTagsModal = new EditTagsModal_default({
          target: document.body,
          props: {
            app,
            tags: newTags,
            onSubmit: (updatedTags) => __awaiter(this, void 0, void 0, function* () {
              try {
                yield settingsService.updateNestedSetting("tags", "customTags", updatedTags);
                new import_obsidian19.Notice("Tags updated successfully");
                editTagsModal.$destroy();
              } catch (error) {
                console.error("Failed to save tags:", error);
                new import_obsidian19.Notice(`Failed to save tags: ${error instanceof Error ? error.message : "Unknown error"}`);
              }
            }),
            onClose: () => editTagsModal.$destroy()
          }
        });
        new import_obsidian19.Notice("Ontology generated successfully. Please review the suggested tags.");
      } catch (error) {
        console.error("Failed to handle generated ontology:", error);
        new import_obsidian19.Notice(`Failed to process ontology: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    });
  }
  onDestroy(() => {
    if (modal) {
      modal.$destroy();
      modal = null;
    }
  });
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("settingsService" in $$props2)
      $$invalidate(1, settingsService = $$props2.settingsService);
    if ("aiAdapter" in $$props2)
      $$invalidate(4, aiAdapter = $$props2.aiAdapter);
    if ("generationService" in $$props2)
      $$invalidate(5, generationService = $$props2.generationService);
    if ("adapterRegistry" in $$props2)
      $$invalidate(6, adapterRegistry = $$props2.adapterRegistry);
    if ("tagManagementService" in $$props2)
      $$invalidate(7, tagManagementService = $$props2.tagManagementService);
    if ("aiService" in $$props2)
      $$invalidate(2, aiService = $$props2.aiService);
  };
  return [
    app,
    settingsService,
    aiService,
    openOntologyGeneratorModal,
    aiAdapter,
    generationService,
    adapterRegistry,
    tagManagementService
  ];
}
var OntologyGenerationAccordion = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance15,
      create_fragment15,
      safe_not_equal,
      {
        app: 0,
        settingsService: 1,
        aiAdapter: 4,
        generationService: 5,
        adapterRegistry: 6,
        tagManagementService: 7,
        aiService: 2
      },
      add_css8
    );
  }
};
var OntologyGenerationAccordion_default = OntologyGenerationAccordion;

// src/components/accordions/BatchProcessorAccordion.svelte
var import_obsidian20 = require("obsidian");
function add_css9(target) {
  append_styles(target, "svelte-pxfeaa", '.batch-processor-container.svelte-pxfeaa.svelte-pxfeaa{display:flex;flex-direction:column;gap:var(--size-4)}.setting-item.svelte-pxfeaa.svelte-pxfeaa{display:flex;justify-content:space-between;align-items:flex-start;padding:var(--size-2) 0}.setting-item-info.svelte-pxfeaa.svelte-pxfeaa{flex:1;margin-right:var(--size-4)}.setting-item-name.svelte-pxfeaa.svelte-pxfeaa{font-weight:var(--font-bold);color:var(--text-normal);margin-bottom:var(--size-1)}.setting-item-description.svelte-pxfeaa.svelte-pxfeaa{color:var(--text-muted);font-size:var(--font-ui-small)}.toggle.svelte-pxfeaa.svelte-pxfeaa{position:relative;display:inline-block;width:40px;height:20px}.toggle.svelte-pxfeaa input.svelte-pxfeaa{opacity:0;width:0;height:0}.toggle-slider.svelte-pxfeaa.svelte-pxfeaa{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background-color:var(--background-modifier-border);transition:.2s;border-radius:20px}.toggle-slider.svelte-pxfeaa.svelte-pxfeaa:before{position:absolute;content:"";height:16px;width:16px;left:2px;bottom:2px;background-color:var(--background-primary);transition:.2s;border-radius:50%}input.svelte-pxfeaa:checked+.toggle-slider.svelte-pxfeaa{background-color:var(--interactive-accent)}input.svelte-pxfeaa:checked+.toggle-slider.svelte-pxfeaa:before{transform:translateX(20px)}.batch-processor-button.svelte-pxfeaa.svelte-pxfeaa{background-color:var(--interactive-accent);color:var(--text-on-accent);padding:var(--size-2) var(--size-4);border-radius:var(--radius-s);border:none;cursor:pointer;font-weight:var(--font-bold);transition:background-color 0.2s ease}.batch-processor-button.svelte-pxfeaa.svelte-pxfeaa:hover{background-color:var(--interactive-accent-hover)}');
}
function create_default_slot9(ctx) {
  let div5;
  let div4;
  let div2;
  let t3;
  let div3;
  let label;
  let input;
  let t4;
  let span;
  let t5;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div5 = element("div");
      div4 = element("div");
      div2 = element("div");
      div2.innerHTML = `<div class="setting-item-name svelte-pxfeaa">Auto-generate Front Matter</div> <div class="setting-item-description svelte-pxfeaa">Automatically generate front matter for new or unprocessed notes when you open your vault.</div>`;
      t3 = space();
      div3 = element("div");
      label = element("label");
      input = element("input");
      t4 = space();
      span = element("span");
      t5 = space();
      button = element("button");
      button.textContent = "Run Batch Processor";
      attr(div2, "class", "setting-item-info svelte-pxfeaa");
      attr(input, "type", "checkbox");
      attr(input, "class", "svelte-pxfeaa");
      attr(span, "class", "toggle-slider svelte-pxfeaa");
      attr(label, "class", "toggle svelte-pxfeaa");
      attr(div3, "class", "setting-item-control");
      attr(div4, "class", "setting-item svelte-pxfeaa");
      attr(button, "class", "batch-processor-button svelte-pxfeaa");
      attr(div5, "class", "batch-processor-container svelte-pxfeaa");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div4);
      append(div4, div2);
      append(div4, t3);
      append(div4, div3);
      append(div3, label);
      append(label, input);
      input.checked = /*autoGenerate*/
      ctx[3];
      append(label, t4);
      append(label, span);
      append(div5, t5);
      append(div5, button);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*input_change_handler*/
            ctx[6]
          ),
          listen(
            input,
            "change",
            /*change_handler*/
            ctx[7]
          ),
          listen(
            button,
            "click",
            /*openBatchProcessor*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*autoGenerate*/
      8) {
        input.checked = /*autoGenerate*/
        ctx2[3];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div5);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment16(ctx) {
  let baseaccordion;
  let current;
  baseaccordion = new BaseAccordion_default({
    props: {
      title: "\u{1F504} Batch Processor",
      description: "Process multiple files to generate front matter and wikilinks.",
      app: (
        /*app*/
        ctx[0]
      ),
      settingsService: (
        /*settingsService*/
        ctx[1]
      ),
      aiService: (
        /*aiService*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot9] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(baseaccordion.$$.fragment);
    },
    m(target, anchor) {
      mount_component(baseaccordion, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const baseaccordion_changes = {};
      if (dirty & /*app*/
      1)
        baseaccordion_changes.app = /*app*/
        ctx2[0];
      if (dirty & /*settingsService*/
      2)
        baseaccordion_changes.settingsService = /*settingsService*/
        ctx2[1];
      if (dirty & /*aiService*/
      4)
        baseaccordion_changes.aiService = /*aiService*/
        ctx2[2];
      if (dirty & /*$$scope, autoGenerate*/
      520) {
        baseaccordion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      baseaccordion.$set(baseaccordion_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(baseaccordion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(baseaccordion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(baseaccordion, detaching);
    }
  };
}
function instance16($$self, $$props, $$invalidate) {
  var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  let { app } = $$props;
  let { settingsService } = $$props;
  let { aiService } = $$props;
  let autoGenerate = settingsService.getSettings().frontMatter.autoGenerate;
  function handleAutoGenerateToggle(value) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        yield settingsService.updateNestedSetting("frontMatter", "autoGenerate", value);
        $$invalidate(3, autoGenerate = value);
        new import_obsidian20.Notice("Auto-generate Front Matter updated.");
      } catch (error) {
        console.error("Error updating auto-generate setting:", error);
        new import_obsidian20.Notice(`Failed to update setting: ${error instanceof Error ? error.message : "Unknown error"}`);
        $$invalidate(3, autoGenerate = !value);
      }
    });
  }
  function openBatchProcessor() {
    try {
      const modal = new BatchProcessorModal_default({
        target: document.body,
        props: {
          app,
          aiService,
          settingsService,
          onClose: () => modal.$destroy()
        }
      });
    } catch (error) {
      console.error("Error opening batch processor:", error);
      new import_obsidian20.Notice(`Failed to open batch processor: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  function input_change_handler() {
    autoGenerate = this.checked;
    $$invalidate(3, autoGenerate);
  }
  const change_handler = (e) => handleAutoGenerateToggle(e.currentTarget.checked);
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("settingsService" in $$props2)
      $$invalidate(1, settingsService = $$props2.settingsService);
    if ("aiService" in $$props2)
      $$invalidate(2, aiService = $$props2.aiService);
  };
  return [
    app,
    settingsService,
    aiService,
    autoGenerate,
    handleAutoGenerateToggle,
    openBatchProcessor,
    input_change_handler,
    change_handler
  ];
}
var BatchProcessorAccordion = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance16, create_fragment16, safe_not_equal, { app: 0, settingsService: 1, aiService: 2 }, add_css9);
  }
};
var BatchProcessorAccordion_default = BatchProcessorAccordion;

// src/components/accordions/AdvancedAccordion.svelte
var import_obsidian21 = require("obsidian");
function add_css10(target) {
  append_styles(target, "svelte-208dib", '.advanced-settings-container.svelte-208dib.svelte-208dib{display:flex;flex-direction:column;gap:var(--size-4)}.setting-item.svelte-208dib.svelte-208dib{display:flex;justify-content:space-between;align-items:flex-start;padding:var(--size-2) 0}.setting-item-info.svelte-208dib.svelte-208dib{flex:1;margin-right:var(--size-4)}.setting-item-name.svelte-208dib.svelte-208dib{font-weight:var(--font-bold);color:var(--text-normal);margin-bottom:var(--size-1)}.setting-item-description.svelte-208dib.svelte-208dib{color:var(--text-muted);font-size:var(--font-ui-small)}input[type="number"].svelte-208dib.svelte-208dib{background:var(--background-primary);border:1px solid var(--background-modifier-border);border-radius:var(--radius-s);padding:var(--size-2);color:var(--text-normal);width:100px}.toggle.svelte-208dib.svelte-208dib{position:relative;display:inline-block;width:40px;height:20px}.toggle.svelte-208dib input.svelte-208dib{opacity:0;width:0;height:0}.toggle-slider.svelte-208dib.svelte-208dib{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background-color:var(--background-modifier-border);transition:.2s;border-radius:20px}.toggle-slider.svelte-208dib.svelte-208dib:before{position:absolute;content:"";height:16px;width:16px;left:2px;bottom:2px;background-color:var(--background-primary);transition:.2s;border-radius:50%}input.svelte-208dib:checked+.toggle-slider.svelte-208dib{background-color:var(--interactive-accent)}input.svelte-208dib:checked+.toggle-slider.svelte-208dib:before{transform:translateX(20px)}');
}
function create_default_slot10(ctx) {
  let div15;
  let div4;
  let div2;
  let t3;
  let div3;
  let label;
  let input0;
  let t4;
  let span;
  let t5;
  let div9;
  let div7;
  let t9;
  let div8;
  let input1;
  let t10;
  let div14;
  let div12;
  let t14;
  let div13;
  let input2;
  let mounted;
  let dispose;
  return {
    c() {
      div15 = element("div");
      div4 = element("div");
      div2 = element("div");
      div2.innerHTML = `<div class="setting-item-name svelte-208dib">Generate Wikilinks</div> <div class="setting-item-description svelte-208dib">Automatically generate wikilinks for your notes.</div>`;
      t3 = space();
      div3 = element("div");
      label = element("label");
      input0 = element("input");
      t4 = space();
      span = element("span");
      t5 = space();
      div9 = element("div");
      div7 = element("div");
      div7.innerHTML = `<div class="setting-item-name svelte-208dib">Temperature</div> <div class="setting-item-description svelte-208dib">Set the temperature for AI responses (0.0 - 1.0).</div>`;
      t9 = space();
      div8 = element("div");
      input1 = element("input");
      t10 = space();
      div14 = element("div");
      div12 = element("div");
      div12.innerHTML = `<div class="setting-item-name svelte-208dib">Max Tokens</div> <div class="setting-item-description svelte-208dib">Set the maximum number of tokens for AI responses.</div>`;
      t14 = space();
      div13 = element("div");
      input2 = element("input");
      attr(div2, "class", "setting-item-info svelte-208dib");
      attr(input0, "type", "checkbox");
      attr(input0, "class", "svelte-208dib");
      attr(span, "class", "toggle-slider svelte-208dib");
      attr(label, "class", "toggle svelte-208dib");
      attr(div3, "class", "setting-item-control");
      attr(div4, "class", "setting-item svelte-208dib");
      attr(div7, "class", "setting-item-info svelte-208dib");
      attr(input1, "type", "number");
      attr(input1, "min", "0");
      attr(input1, "max", "1");
      attr(input1, "step", "0.1");
      attr(input1, "class", "svelte-208dib");
      attr(div8, "class", "setting-item-control");
      attr(div9, "class", "setting-item svelte-208dib");
      attr(div12, "class", "setting-item-info svelte-208dib");
      attr(input2, "type", "number");
      attr(input2, "min", "1");
      attr(input2, "step", "1");
      attr(input2, "class", "svelte-208dib");
      attr(div13, "class", "setting-item-control");
      attr(div14, "class", "setting-item svelte-208dib");
      attr(div15, "class", "advanced-settings-container svelte-208dib");
    },
    m(target, anchor) {
      insert(target, div15, anchor);
      append(div15, div4);
      append(div4, div2);
      append(div4, t3);
      append(div4, div3);
      append(div3, label);
      append(label, input0);
      input0.checked = /*generateWikilinks*/
      ctx[3];
      append(label, t4);
      append(label, span);
      append(div15, t5);
      append(div15, div9);
      append(div9, div7);
      append(div9, t9);
      append(div9, div8);
      append(div8, input1);
      set_input_value(
        input1,
        /*temperature*/
        ctx[4]
      );
      append(div15, t10);
      append(div15, div14);
      append(div14, div12);
      append(div14, t14);
      append(div14, div13);
      append(div13, input2);
      set_input_value(
        input2,
        /*maxTokens*/
        ctx[5]
      );
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "change",
            /*input0_change_handler*/
            ctx[9]
          ),
          listen(
            input0,
            "change",
            /*change_handler*/
            ctx[10]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[11]
          ),
          listen(
            input1,
            "change",
            /*change_handler_1*/
            ctx[12]
          ),
          listen(
            input2,
            "input",
            /*input2_input_handler*/
            ctx[13]
          ),
          listen(
            input2,
            "change",
            /*change_handler_2*/
            ctx[14]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*generateWikilinks*/
      8) {
        input0.checked = /*generateWikilinks*/
        ctx2[3];
      }
      if (dirty & /*temperature*/
      16 && to_number(input1.value) !== /*temperature*/
      ctx2[4]) {
        set_input_value(
          input1,
          /*temperature*/
          ctx2[4]
        );
      }
      if (dirty & /*maxTokens*/
      32 && to_number(input2.value) !== /*maxTokens*/
      ctx2[5]) {
        set_input_value(
          input2,
          /*maxTokens*/
          ctx2[5]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div15);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment17(ctx) {
  let baseaccordion;
  let current;
  baseaccordion = new BaseAccordion_default({
    props: {
      title: "\u2699\uFE0F Advanced",
      description: "Configuration options for the plugin.",
      app: (
        /*app*/
        ctx[0]
      ),
      settingsService: (
        /*settingsService*/
        ctx[1]
      ),
      aiService: (
        /*aiService*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot10] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(baseaccordion.$$.fragment);
    },
    m(target, anchor) {
      mount_component(baseaccordion, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const baseaccordion_changes = {};
      if (dirty & /*app*/
      1)
        baseaccordion_changes.app = /*app*/
        ctx2[0];
      if (dirty & /*settingsService*/
      2)
        baseaccordion_changes.settingsService = /*settingsService*/
        ctx2[1];
      if (dirty & /*aiService*/
      4)
        baseaccordion_changes.aiService = /*aiService*/
        ctx2[2];
      if (dirty & /*$$scope, maxTokens, temperature, generateWikilinks*/
      65592) {
        baseaccordion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      baseaccordion.$set(baseaccordion_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(baseaccordion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(baseaccordion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(baseaccordion, detaching);
    }
  };
}
function instance17($$self, $$props, $$invalidate) {
  var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  let { app } = $$props;
  let { settingsService } = $$props;
  let { aiService } = $$props;
  let generateWikilinks = settingsService.getSettings().advanced.generateWikilinks;
  let temperature = settingsService.getSettings().advanced.temperature.toString();
  let maxTokens = settingsService.getSettings().advanced.maxTokens.toString();
  function handleWikilinksToggle(value) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        yield settingsService.updateNestedSetting("advanced", "generateWikilinks", value);
        $$invalidate(3, generateWikilinks = value);
      } catch (error) {
        console.error("Error updating wikilinks setting:", error);
        new import_obsidian21.Notice(`Failed to update setting: ${error instanceof Error ? error.message : "Unknown error"}`);
        $$invalidate(3, generateWikilinks = !value);
      }
    });
  }
  function handleTemperatureChange(value) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const temp = parseFloat(value);
        if (isNaN(temp) || temp < 0 || temp > 1) {
          throw new Error("Temperature must be between 0 and 1");
        }
        yield settingsService.updateNestedSetting("advanced", "temperature", temp);
        $$invalidate(4, temperature = temp.toString());
      } catch (error) {
        console.error("Error updating temperature:", error);
        new import_obsidian21.Notice(`Failed to update temperature: ${error instanceof Error ? error.message : "Unknown error"}`);
        $$invalidate(4, temperature = settingsService.getSettings().advanced.temperature.toString());
      }
    });
  }
  function handleMaxTokensChange(value) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const tokens = parseInt(value);
        if (isNaN(tokens) || tokens <= 0) {
          throw new Error("Max tokens must be a positive number");
        }
        yield settingsService.updateNestedSetting("advanced", "maxTokens", tokens);
        $$invalidate(5, maxTokens = tokens.toString());
      } catch (error) {
        console.error("Error updating max tokens:", error);
        new import_obsidian21.Notice(`Failed to update max tokens: ${error instanceof Error ? error.message : "Unknown error"}`);
        $$invalidate(5, maxTokens = settingsService.getSettings().advanced.maxTokens.toString());
      }
    });
  }
  function input0_change_handler() {
    generateWikilinks = this.checked;
    $$invalidate(3, generateWikilinks);
  }
  const change_handler = (e) => handleWikilinksToggle(e.currentTarget.checked);
  function input1_input_handler() {
    temperature = to_number(this.value);
    $$invalidate(4, temperature);
  }
  const change_handler_1 = (e) => handleTemperatureChange(e.currentTarget.value);
  function input2_input_handler() {
    maxTokens = to_number(this.value);
    $$invalidate(5, maxTokens);
  }
  const change_handler_2 = (e) => handleMaxTokensChange(e.currentTarget.value);
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("settingsService" in $$props2)
      $$invalidate(1, settingsService = $$props2.settingsService);
    if ("aiService" in $$props2)
      $$invalidate(2, aiService = $$props2.aiService);
  };
  return [
    app,
    settingsService,
    aiService,
    generateWikilinks,
    temperature,
    maxTokens,
    handleWikilinksToggle,
    handleTemperatureChange,
    handleMaxTokensChange,
    input0_change_handler,
    change_handler,
    input1_input_handler,
    change_handler_1,
    input2_input_handler,
    change_handler_2
  ];
}
var AdvancedAccordion = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance17, create_fragment17, safe_not_equal, { app: 0, settingsService: 1, aiService: 2 }, add_css10);
  }
};
var AdvancedAccordion_default = AdvancedAccordion;

// src/components/accordions/KnowledgeBloomAccordion.svelte
var import_obsidian22 = require("obsidian");
function add_css11(target) {
  append_styles(target, "svelte-1pu0o5y", ".knowledge-bloom-container.svelte-1pu0o5y{display:flex;flex-direction:column;gap:var(--size-4)}.knowledge-bloom-description.svelte-1pu0o5y{color:var(--text-muted);font-size:var(--font-ui-small)}.model-selector.svelte-1pu0o5y,.prompt-input.svelte-1pu0o5y{display:flex;flex-direction:column;gap:var(--size-2)}label.svelte-1pu0o5y{font-weight:var(--font-bold);color:var(--text-normal)}select.svelte-1pu0o5y,textarea.svelte-1pu0o5y{background:var(--background-primary);border:1px solid var(--background-modifier-border);border-radius:var(--radius-s);padding:var(--size-2);color:var(--text-normal);width:100%}textarea.svelte-1pu0o5y{resize:vertical;min-height:100px}.description.svelte-1pu0o5y{color:var(--text-muted);font-size:var(--font-ui-smaller)}.generate-button.svelte-1pu0o5y{background-color:var(--interactive-accent);color:var(--text-on-accent);padding:var(--size-2) var(--size-4);border-radius:var(--radius-s);border:none;cursor:pointer;font-weight:var(--font-bold);transition:background-color 0.2s ease}.generate-button.svelte-1pu0o5y:hover:not(:disabled){background-color:var(--interactive-accent-hover)}.generate-button.svelte-1pu0o5y:disabled{opacity:0.5;cursor:not-allowed}");
}
function get_each_context7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i];
  return child_ctx;
}
function create_each_block7(ctx) {
  let option;
  let t0_value = (
    /*modelInfo*/
    ctx[15].model.name + ""
  );
  let t0;
  let t1;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t0 = text(t0_value);
      t1 = space();
      option.__value = option_value_value = /*modelInfo*/
      ctx[15].model.apiName;
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t0);
      append(option, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*models*/
      16 && t0_value !== (t0_value = /*modelInfo*/
      ctx2[15].model.name + ""))
        set_data(t0, t0_value);
      if (dirty & /*models*/
      16 && option_value_value !== (option_value_value = /*modelInfo*/
      ctx2[15].model.apiName)) {
        option.__value = option_value_value;
        set_input_value(option, option.__value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_default_slot11(ctx) {
  let div3;
  let div0;
  let t3;
  let div1;
  let label0;
  let t5;
  let select;
  let t6;
  let span0;
  let t8;
  let div2;
  let label1;
  let t10;
  let textarea;
  let t11;
  let span1;
  let t13;
  let button;
  let t14_value = (
    /*isGenerating*/
    ctx[6] ? "Generating..." : "Generate Knowledge Bloom"
  );
  let t14;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*models*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block7(get_each_context7(ctx, each_value, i));
  }
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      div0.innerHTML = `<p>Knowledge Bloom analyzes the current note, extracts wikilinks, and 
          generates new notes for each link in the current note. This helps expand 
          your knowledge base and create connections between ideas.</p> <p>For best results, we recommend using Perplexity models as they can 
          search online for up-to-date information.</p>`;
      t3 = space();
      div1 = element("div");
      label0 = element("label");
      label0.textContent = "AI Model";
      t5 = space();
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t6 = space();
      span0 = element("span");
      span0.textContent = "Select the AI model to use for Knowledge Bloom";
      t8 = space();
      div2 = element("div");
      label1 = element("label");
      label1.textContent = "Additional Context";
      t10 = space();
      textarea = element("textarea");
      t11 = space();
      span1 = element("span");
      span1.textContent = "Provide any additional context or instructions for note generation (optional)";
      t13 = space();
      button = element("button");
      t14 = text(t14_value);
      attr(div0, "class", "knowledge-bloom-description svelte-1pu0o5y");
      attr(label0, "for", "model-select");
      attr(label0, "class", "svelte-1pu0o5y");
      attr(select, "id", "model-select");
      attr(select, "class", "svelte-1pu0o5y");
      if (
        /*selectedModel*/
        ctx[3] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[9].call(select)
        ));
      attr(span0, "class", "description svelte-1pu0o5y");
      attr(div1, "class", "model-selector svelte-1pu0o5y");
      attr(label1, "for", "prompt-textarea");
      attr(label1, "class", "svelte-1pu0o5y");
      attr(textarea, "id", "prompt-textarea");
      attr(textarea, "rows", "4");
      attr(textarea, "placeholder", "Enter your prompts here...");
      attr(textarea, "class", "svelte-1pu0o5y");
      attr(span1, "class", "description svelte-1pu0o5y");
      attr(div2, "class", "prompt-input svelte-1pu0o5y");
      attr(button, "class", "generate-button svelte-1pu0o5y");
      button.disabled = /*isGenerating*/
      ctx[6];
      attr(div3, "class", "knowledge-bloom-container svelte-1pu0o5y");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div3, t3);
      append(div3, div1);
      append(div1, label0);
      append(div1, t5);
      append(div1, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*selectedModel*/
        ctx[3],
        true
      );
      append(div1, t6);
      append(div1, span0);
      append(div3, t8);
      append(div3, div2);
      append(div2, label1);
      append(div2, t10);
      append(div2, textarea);
      set_input_value(
        textarea,
        /*userPromptInput*/
        ctx[5]
      );
      append(div2, t11);
      append(div2, span1);
      append(div3, t13);
      append(div3, button);
      append(button, t14);
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[9]
          ),
          listen(
            select,
            "change",
            /*change_handler*/
            ctx[10]
          ),
          listen(
            textarea,
            "input",
            /*textarea_input_handler*/
            ctx[11]
          ),
          listen(
            button,
            "click",
            /*handleGenerateKnowledgeBloom*/
            ctx[8]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*models*/
      16) {
        each_value = ensure_array_like(
          /*models*/
          ctx2[4]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context7(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block7(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*selectedModel, models*/
      24) {
        select_option(
          select,
          /*selectedModel*/
          ctx2[3]
        );
      }
      if (dirty & /*userPromptInput*/
      32) {
        set_input_value(
          textarea,
          /*userPromptInput*/
          ctx2[5]
        );
      }
      if (dirty & /*isGenerating*/
      64 && t14_value !== (t14_value = /*isGenerating*/
      ctx2[6] ? "Generating..." : "Generate Knowledge Bloom"))
        set_data(t14, t14_value);
      if (dirty & /*isGenerating*/
      64) {
        button.disabled = /*isGenerating*/
        ctx2[6];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment18(ctx) {
  let baseaccordion;
  let current;
  baseaccordion = new BaseAccordion_default({
    props: {
      title: "\u{1F33A} Knowledge Bloom",
      description: "Generate notes from wikilinks in your current note.",
      app: (
        /*app*/
        ctx[0]
      ),
      settingsService: (
        /*settingsService*/
        ctx[1]
      ),
      aiService: (
        /*aiService*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot11] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(baseaccordion.$$.fragment);
    },
    m(target, anchor) {
      mount_component(baseaccordion, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const baseaccordion_changes = {};
      if (dirty & /*app*/
      1)
        baseaccordion_changes.app = /*app*/
        ctx2[0];
      if (dirty & /*settingsService*/
      2)
        baseaccordion_changes.settingsService = /*settingsService*/
        ctx2[1];
      if (dirty & /*aiService*/
      4)
        baseaccordion_changes.aiService = /*aiService*/
        ctx2[2];
      if (dirty & /*$$scope, isGenerating, userPromptInput, selectedModel, models*/
      262264) {
        baseaccordion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      baseaccordion.$set(baseaccordion_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(baseaccordion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(baseaccordion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(baseaccordion, detaching);
    }
  };
}
function instance18($$self, $$props, $$invalidate) {
  var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var _a;
  let { app } = $$props;
  let { settingsService } = $$props;
  let { aiService } = $$props;
  let userPromptInput = "";
  let selectedModel = ((_a = settingsService.getSettings().knowledgeBloom) === null || _a === void 0 ? void 0 : _a.selectedModel) || "";
  let models = [];
  let isGenerating2 = false;
  function updateKnowledgeBloomSettings(model) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        yield settingsService.updateKnowledgeBloomSettings({ selectedModel: model });
        yield aiService.reinitialize();
        new import_obsidian22.Notice("AI Service reinitialized with the new model.");
      } catch (error) {
        console.error("Error updating settings:", error);
        new import_obsidian22.Notice(`Error updating settings: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    });
  }
  function handleGenerateKnowledgeBloom() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        $$invalidate(6, isGenerating2 = true);
        const activeFile = app.workspace.getActiveFile();
        if (!(activeFile instanceof import_obsidian22.TFile)) {
          new import_obsidian22.Notice("No active file found.");
          return;
        }
        const generationService = aiService.getGenerationService();
        const result = yield generationService.generateKnowledgeBloom(activeFile, userPromptInput);
        if (result === null || result === void 0 ? void 0 : result.generatedNotes) {
          yield createGeneratedNotes(result.generatedNotes);
          new import_obsidian22.Notice(`Generated ${result.generatedNotes.length} new notes!`);
        } else {
          new import_obsidian22.Notice("No notes were generated.");
        }
      } catch (error) {
        console.error("Error generating knowledge bloom:", error);
        new import_obsidian22.Notice(`Error generating knowledge bloom: ${error instanceof Error ? error.message : "Unknown error"}`);
      } finally {
        $$invalidate(6, isGenerating2 = false);
      }
    });
  }
  function createGeneratedNotes(notes) {
    return __awaiter(this, void 0, void 0, function* () {
      for (const note of notes) {
        const filePath = `${note.title}.md`;
        const existingFile = app.vault.getAbstractFileByPath(filePath);
        if (existingFile instanceof import_obsidian22.TFile) {
          yield app.vault.modify(existingFile, note.content);
        } else {
          yield app.vault.create(filePath, note.content);
        }
      }
    });
  }
  function select_change_handler() {
    selectedModel = select_value(this);
    $$invalidate(3, selectedModel), $$invalidate(4, models);
    $$invalidate(4, models), $$invalidate(3, selectedModel);
  }
  const change_handler = () => updateKnowledgeBloomSettings(selectedModel);
  function textarea_input_handler() {
    userPromptInput = this.value;
    $$invalidate(5, userPromptInput);
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("settingsService" in $$props2)
      $$invalidate(1, settingsService = $$props2.settingsService);
    if ("aiService" in $$props2)
      $$invalidate(2, aiService = $$props2.aiService);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*selectedModel, models*/
    24) {
      $: {
        const modelEntries = [];
        Object.entries(AIModelMap).forEach(([provider, modelList]) => {
          modelList.forEach((model) => {
            modelEntries.push({ provider, model });
          });
        });
        $$invalidate(4, models = modelEntries);
        if (!selectedModel && models.length > 0) {
          $$invalidate(3, selectedModel = models[0].model.apiName);
          updateKnowledgeBloomSettings(selectedModel);
        }
      }
    }
  };
  return [
    app,
    settingsService,
    aiService,
    selectedModel,
    models,
    userPromptInput,
    isGenerating2,
    updateKnowledgeBloomSettings,
    handleGenerateKnowledgeBloom,
    select_change_handler,
    change_handler,
    textarea_input_handler
  ];
}
var KnowledgeBloomAccordion = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance18, create_fragment18, safe_not_equal, { app: 0, settingsService: 1, aiService: 2 }, add_css11);
  }
};
var KnowledgeBloomAccordion_default = KnowledgeBloomAccordion;

// src/settings/SettingsTab.svelte
function add_css12(target) {
  append_styles(target, "svelte-lrwn3h", ".graphweaver-plugin-settings.svelte-lrwn3h.svelte-lrwn3h{padding:var(--size-4)}.settings-header.svelte-lrwn3h.svelte-lrwn3h{margin-bottom:var(--size-8)}.settings-header.svelte-lrwn3h h2.svelte-lrwn3h{margin:0;margin-bottom:var(--size-2);color:var(--text-normal);font-size:var(--font-ui-large)}.settings-header.svelte-lrwn3h p.svelte-lrwn3h{margin:0;color:var(--text-muted)}.settings-accordions.svelte-lrwn3h.svelte-lrwn3h{display:flex;flex-direction:column;gap:var(--size-4)}.settings-section.svelte-lrwn3h.svelte-lrwn3h{border:1px solid var(--background-modifier-border);border-radius:var(--radius-m);overflow:hidden}.settings-error.svelte-lrwn3h.svelte-lrwn3h{padding:var(--size-4);background-color:var(--background-modifier-error);border-radius:var(--radius-m);color:var(--text-error)}.settings-loading.svelte-lrwn3h.svelte-lrwn3h{display:flex;justify-content:center;align-items:center;padding:var(--size-8);color:var(--text-muted)}");
}
function get_each_context8(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  return child_ctx;
}
function create_else_block6(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<p>Initializing settings...</p>`;
      attr(div, "class", "settings-loading svelte-lrwn3h");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_14(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = ensure_array_like(
    /*accordionConfigs*/
    ctx[4]
  );
  const get_key = (ctx2) => (
    /*config*/
    ctx2[9].id
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context8(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block8(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "settings-accordions svelte-lrwn3h");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*accordionConfigs, app, services*/
      19) {
        each_value = ensure_array_like(
          /*accordionConfigs*/
          ctx2[4]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block8, null, get_each_context8);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
function create_if_block9(ctx) {
  let div;
  let p;
  let t0;
  let t1;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      p = element("p");
      t0 = text(
        /*error*/
        ctx[3]
      );
      t1 = space();
      button = element("button");
      button.textContent = "Retry";
      attr(div, "class", "settings-error svelte-lrwn3h");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p);
      append(p, t0);
      append(div, t1);
      append(div, button);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*error*/
      8)
        set_data(
          t0,
          /*error*/
          ctx2[3]
        );
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_each_block8(key_1, ctx) {
  let div;
  let switch_instance;
  let t;
  let div_data_section_id_value;
  let current;
  var switch_value = (
    /*config*/
    ctx[9].component
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        app: (
          /*app*/
          ctx2[0]
        ),
        aiService: (
          /*services*/
          ctx2[1].aiService
        ),
        settingsService: (
          /*services*/
          ctx2[1].settingsService
        ),
        generationService: (
          /*services*/
          ctx2[1].generationService
        ),
        adapterRegistry: (
          /*services*/
          ctx2[1].adapterRegistry
        ),
        tagManagementService: (
          /*services*/
          ctx2[1].tagManagementService
        )
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    key: key_1,
    first: null,
    c() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t = space();
      attr(div, "class", "settings-section svelte-lrwn3h");
      attr(div, "data-section-id", div_data_section_id_value = /*config*/
      ctx[9].id);
      this.first = div;
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      append(div, t);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (switch_value !== (switch_value = /*config*/
      ctx[9].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, t);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*app*/
        1)
          switch_instance_changes.app = /*app*/
          ctx[0];
        if (dirty & /*services*/
        2)
          switch_instance_changes.aiService = /*services*/
          ctx[1].aiService;
        if (dirty & /*services*/
        2)
          switch_instance_changes.settingsService = /*services*/
          ctx[1].settingsService;
        if (dirty & /*services*/
        2)
          switch_instance_changes.generationService = /*services*/
          ctx[1].generationService;
        if (dirty & /*services*/
        2)
          switch_instance_changes.adapterRegistry = /*services*/
          ctx[1].adapterRegistry;
        if (dirty & /*services*/
        2)
          switch_instance_changes.tagManagementService = /*services*/
          ctx[1].tagManagementService;
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
}
function create_fragment19(ctx) {
  let div1;
  let div0;
  let t3;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block9, create_if_block_14, create_else_block6];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*error*/
      ctx2[3]
    )
      return 0;
    if (
      /*isInitialized*/
      ctx2[2]
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      div0.innerHTML = `<h2 class="svelte-lrwn3h">GraphWeaver</h2> <p class="svelte-lrwn3h">Configure AI models, manage properties and tags, and customize your knowledge graph generation.</p>`;
      t3 = space();
      if_block.c();
      attr(div0, "class", "settings-header svelte-lrwn3h");
      attr(div1, "class", "graphweaver-plugin-settings svelte-lrwn3h");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div1, t3);
      if_blocks[current_block_type_index].m(div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div1, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance19($$self, $$props, $$invalidate) {
  var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  let { app } = $$props;
  let { plugin } = $$props;
  let services = {};
  let isInitialized = false;
  let error = null;
  const accordionConfigs = [
    {
      id: "modelHookup",
      component: ModelHookupAccordion_default,
      title: "Model Hookup",
      description: "Configure AI providers and models",
      priority: 1
    },
    {
      id: "knowledgeBloom",
      component: KnowledgeBloomAccordion_default,
      title: "Knowledge Bloom",
      description: "Generate notes from wikilinks",
      priority: 2
    },
    {
      id: "ontologyGeneration",
      component: OntologyGenerationAccordion_default,
      title: "Ontology Generation",
      description: "Generate and manage ontologies",
      priority: 3
    },
    {
      id: "propertyManager",
      component: PropertyManagerAccordion_default,
      title: "Property Manager",
      description: "Manage custom properties",
      priority: 4
    },
    {
      id: "tagManager",
      component: TagManagerAccordion_default,
      title: "Tag Manager",
      description: "Manage custom tags",
      priority: 5
    },
    {
      id: "batchProcessor",
      component: BatchProcessorAccordion_default,
      title: "Batch Processor",
      description: "Process multiple files",
      priority: 6
    },
    {
      id: "advanced",
      component: AdvancedAccordion_default,
      title: "Advanced Settings",
      description: "Configure advanced options",
      priority: 7
    }
  ].sort((a, b) => a.priority - b.priority);
  onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    try {
      yield initializeServices2();
    } catch (e) {
      $$invalidate(3, error = e instanceof Error ? e.message : "Failed to initialize services");
    }
  }));
  function initializeServices2() {
    return __awaiter(this, void 0, void 0, function* () {
      const aiService = plugin === null || plugin === void 0 ? void 0 : plugin.getAIService();
      if (!aiService)
        throw new Error("AIService not initialized");
      const settingsService = plugin === null || plugin === void 0 ? void 0 : plugin.getSettingsService();
      if (!settingsService)
        throw new Error("SettingsService not initialized");
      const tagManagementService = new TagManagementService(app);
      try {
        $$invalidate(1, services = {
          aiService,
          settingsService,
          tagManagementService,
          generationService: aiService.getGenerationService(),
          adapterRegistry: aiService.getAdapterRegistry()
        });
        $$invalidate(2, isInitialized = true);
      } catch (err) {
        console.warn("Optional services not available:", err);
        $$invalidate(1, services = {
          aiService,
          settingsService,
          tagManagementService
        });
        $$invalidate(2, isInitialized = true);
      }
    });
  }
  const click_handler = () => initializeServices2();
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("plugin" in $$props2)
      $$invalidate(6, plugin = $$props2.plugin);
  };
  return [
    app,
    services,
    isInitialized,
    error,
    accordionConfigs,
    initializeServices2,
    plugin,
    click_handler
  ];
}
var SettingsTab = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance19, create_fragment19, safe_not_equal, { app: 0, plugin: 6 }, add_css12);
  }
};
var SettingsTab_default = SettingsTab;

// src/settings/GraphWeaverSettingTab.ts
var GraphWeaverSettingTab = class extends import_obsidian23.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.svelteComponent = null;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.svelteComponent = new SettingsTab_default({
      target: containerEl,
      props: {
        app: this.app,
        plugin: this.plugin
      }
    });
  }
  hide() {
    var _a;
    (_a = this.svelteComponent) == null ? void 0 : _a.$destroy();
    this.svelteComponent = null;
    const { containerEl } = this;
    containerEl.empty();
  }
};

// main.ts
var import_lodash = __toESM(require_lodash(), 1);
var GraphWeaverPlugin = class extends import_obsidian24.Plugin {
  constructor() {
    super(...arguments);
    this.SAVE_DEBOUNCE_MS = 1e3;
    this.unsubscribers = [];
    this.registeredServices = [];
    this.isInitialized = false;
  }
  /**
   * Plugin load lifecycle method
   */
  onload() {
    return __async(this, null, function* () {
      console.log("\u{1F987} [GraphWeaver] Starting plugin load sequence...");
      try {
        console.log("\u{1F987} [GraphWeaver] Initializing core services...");
        yield initializeCoreServices(this);
        console.log("\u{1F987} [GraphWeaver] Core services initialized successfully");
        console.log("\u{1F987} [GraphWeaver] Initializing plugin infrastructure...");
        yield this.initializePluginInfrastructure();
        console.log("\u{1F987} [GraphWeaver] Plugin infrastructure initialized");
        console.log("\u{1F987} [GraphWeaver] Setting up plugin features...");
        yield this.setupPluginFeatures();
        console.log("\u{1F987} [GraphWeaver] Plugin features setup complete");
        this.notifySuccess("GraphWeaver initialized successfully! \u{1F680}");
      } catch (error) {
        this.handleError("Critical failure during plugin load", error);
        throw error;
      }
    });
  }
  /**
   * Initialize core plugin infrastructure
   */
  initializePluginInfrastructure() {
    return __async(this, null, function* () {
      if (this.isInitialized) {
        console.log("\u{1F987} [GraphWeaver] Plugin already initialized, skipping...");
        return;
      }
      try {
        console.log("\u{1F987} [GraphWeaver] Starting stores initialization...");
        yield this.initializeStores();
        console.log("\u{1F987} [GraphWeaver] Stores initialized successfully");
        console.log("\u{1F987} [GraphWeaver] Starting services registration...");
        yield this.registerServices();
        console.log("\u{1F987} [GraphWeaver] Services registered successfully");
        console.log("\u{1F987} [GraphWeaver] Setting up event listeners...");
        this.setupEventListeners();
        console.log("\u{1F987} [GraphWeaver] Event listeners configured");
        this.isInitialized = true;
      } catch (error) {
        console.error("\u{1F987} [GraphWeaver] Failed to initialize plugin infrastructure:", error);
        throw error;
      }
    });
  }
  /**
   * Initialize plugin stores with saved data
   */
  initializeStores() {
    return __async(this, null, function* () {
      console.log("\u{1F987} [GraphWeaver] Loading saved plugin data...");
      const savedData = yield this.loadData();
      console.log("\u{1F987} [GraphWeaver] Saved data loaded:", savedData ? "Found" : "Not found");
      try {
        yield initializeStores({
          plugin: this,
          data: {
            settings: savedData == null ? void 0 : savedData.settings,
            processing: savedData == null ? void 0 : savedData.processing,
            ai: savedData == null ? void 0 : savedData.ai,
            ui: savedData == null ? void 0 : savedData.ui,
            files: savedData == null ? void 0 : savedData.files
          }
        });
        console.log("\u{1F987} [GraphWeaver] Stores initialized with saved data");
      } catch (error) {
        console.error("\u{1F987} [GraphWeaver] Store initialization failed:", error);
        throw error;
      }
    });
  }
  /**
   * Register and initialize services
   */
  registerServices() {
    return __async(this, null, function* () {
      console.log("\u{1F987} [GraphWeaver] Beginning service registration...");
      const registry = ServiceRegistry.getInstance();
      try {
        console.log("\u{1F987} [GraphWeaver] Registering AI services...");
        yield registerAIServices(this.app, this);
        console.log("\u{1F987} [GraphWeaver] Registering file services...");
        yield registerFileServices(this.app);
        this.registeredServices = Array.from(registry.getRegisteredServices());
        console.log(`\u{1F987} [GraphWeaver] Registered ${this.registeredServices.length} services`);
      } catch (error) {
        console.error("\u{1F987} [GraphWeaver] Service registration failed:", error);
        throw error;
      }
    });
  }
  /**
   * Set up plugin features and UI components
   */
  setupPluginFeatures() {
    return __async(this, null, function* () {
      console.log("\u{1F987} [GraphWeaver] Setting up plugin commands...");
      this.registerPluginCommands();
      console.log("\u{1F987} [GraphWeaver] Adding settings tab...");
      this.addSettingTab(new GraphWeaverSettingTab(this.app, this));
    });
  }
  /**
   * Set up store subscriptions and event listeners
   */
  setupEventListeners() {
    console.log("\u{1F987} [GraphWeaver] Creating debounced save function...");
    const debouncedSave = this.createDebouncedSave();
    console.log("\u{1F987} [GraphWeaver] Setting up store subscriptions...");
    this.subscribeToStores(debouncedSave);
  }
  /**
   * Create debounced save function
   */
  createDebouncedSave() {
    return (0, import_lodash.debounce)((state) => __async(this, null, function* () {
      console.log("\u{1F987} [GraphWeaver] Saving plugin state...");
      try {
        yield this.saveData(state);
        console.log("\u{1F987} [GraphWeaver] Plugin state saved successfully");
      } catch (error) {
        this.handleError("Failed to save plugin data", error);
      }
    }), this.SAVE_DEBOUNCE_MS);
  }
  /**
   * Subscribe to all stores for state management
   */
  subscribeToStores(debouncedSave) {
    const stores = [
      { store: pluginStore, name: "pluginStore" },
      { store: settingsStore, name: "settingsStore" },
      { store: aiStore, name: "aiStore" },
      { store: processingStore, name: "processingStore" },
      { store: UIStore.getInstance(), name: "UIStore" }
    ];
    stores.forEach(({ store, name }) => {
      console.log(`\u{1F987} [GraphWeaver] Setting up ${name} subscription...`);
      this.unsubscribers.push(
        store.subscribe((value) => {
          console.log(`\u{1F987} [GraphWeaver] ${name} updated, triggering save...`);
          debouncedSave(__spreadValues({}, get_store_value(pluginStore)));
        })
      );
    });
  }
  /**
   * Register plugin commands
   */
  registerPluginCommands() {
    const commands = [
      {
        id: "generate-frontmatter",
        name: "Generate Front Matter",
        callback: () => this.generateFrontMatter()
      },
      {
        id: "generate-wikilinks",
        name: "Generate Wikilinks",
        callback: () => this.generateWikilinks()
      },
      {
        id: "generate-knowledge-bloom",
        name: "Generate Knowledge Bloom",
        callback: () => this.generateKnowledgeBloom()
      },
      {
        id: "batch-process-files",
        name: "Batch Process Files",
        callback: () => this.batchProcessFiles()
      }
    ];
    commands.forEach((command) => {
      console.log(`\u{1F987} [GraphWeaver] Registering command: ${command.name}`);
      this.addCommand(command);
    });
  }
  /**
   * Command implementations
   */
  generateFrontMatter() {
    return __async(this, null, function* () {
      console.log("\u{1F987} [GraphWeaver] Executing generateFrontMatter command...");
      if (!this.validateActiveFile())
        return;
    });
  }
  generateWikilinks() {
    return __async(this, null, function* () {
      console.log("\u{1F987} [GraphWeaver] Executing generateWikilinks command...");
      if (!this.validateActiveFile())
        return;
    });
  }
  generateKnowledgeBloom() {
    return __async(this, null, function* () {
      console.log("\u{1F987} [GraphWeaver] Executing generateKnowledgeBloom command...");
      if (!this.validateActiveFile())
        return;
    });
  }
  batchProcessFiles() {
    return __async(this, null, function* () {
      console.log("\u{1F987} [GraphWeaver] Executing batchProcessFiles command...");
      if (!this.validateActiveFile())
        return;
    });
  }
  /**
   * Validate active file exists
   */
  validateActiveFile() {
    var _a;
    if (!((_a = this.app.workspace.activeLeaf) == null ? void 0 : _a.view)) {
      this.notifyError("No active file. Please open a file first.");
      return false;
    }
    return true;
  }
  /**
   * Error handling
   */
  handleError(context, error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error(`\u{1F987} [GraphWeaver] ${context}:`, error);
    this.notifyError(`${context}. Check console for details.`);
  }
  /**
   * Notification helpers
   */
  notifySuccess(message) {
    console.log(`\u{1F987} [GraphWeaver] Success: ${message}`);
    new import_obsidian24.Notice(message);
  }
  notifyError(message) {
    console.error(`\u{1F987} [GraphWeaver] Error: ${message}`);
    new import_obsidian24.Notice(message);
  }
  /**
   * Plugin unload lifecycle method
   */
  onunload() {
    return __async(this, null, function* () {
      console.log("\u{1F987} [GraphWeaver] Starting plugin unload sequence...");
      try {
        yield this.cleanup();
        this.notifySuccess("GraphWeaver unloaded successfully! \u{1F44B}");
      } catch (error) {
        this.handleError("Error during plugin unload", error);
      }
    });
  }
  /**
   * Cleanup plugin resources
   */
  cleanup() {
    return __async(this, null, function* () {
      console.log("\u{1F987} [GraphWeaver] Running cleanup...");
      try {
        console.log("\u{1F987} [GraphWeaver] Cleaning up store subscriptions...");
        this.unsubscribers.forEach((unsub) => unsub());
        this.unsubscribers = [];
        if (this.registeredServices.length > 0) {
          console.log("\u{1F987} [GraphWeaver] Destroying registered services...");
          yield destroyCoreServices(this.registeredServices);
        }
        this.registeredServices = [];
        this.isInitialized = false;
        console.log("\u{1F987} [GraphWeaver] Cleanup completed successfully");
      } catch (error) {
        console.error("\u{1F987} [GraphWeaver] Cleanup failed:", error);
        throw error;
      }
    });
  }
};
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
