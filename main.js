
/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports, module2) {
    (function() {
      var undefined2;
      var VERSION2 = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        // Latin Extended-A block.
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = function() {
          function object() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity2;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity2];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity2), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity2 : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity2 : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity2, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity2;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop2 : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result2;
        }
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now2 = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce2(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now2();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush2() {
            return timerId === undefined2 ? result2 : trailingEdge(now2());
          }
          function debounced() {
            var time = now2(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush2;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay2 = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce2(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign2 = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity2));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index < length) {
            var value = object == null ? undefined2 : object[toKey(path[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update2(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape2(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity2(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop2() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity2, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity2);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity2, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity2) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign2;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce2;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay2;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update2;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape2;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity2;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop2;
        lodash.now = now2;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION2;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity2);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }).call(exports);
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GraphWeaverPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian27 = require("obsidian");

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return (
    /** @type {T & S} */
    tar
  );
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    for (const callback of callbacks) {
      callback(void 0);
    }
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_) => value = _)();
  return value;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    var _a;
    return (_a = this._observer) != null ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) == null ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
  return function(event) {
    event.preventDefault();
    return fn.call(this, event);
  };
}
function stop_propagation(fn) {
  return function(event) {
    event.stopPropagation();
    return fn.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function to_number(value) {
  return value === "" ? null : +value;
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = /** @type {string} */
  data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function select_option(select, value, mounting) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function select_value(select) {
  const selected_option = select.querySelector(":checked");
  return selected_option && selected_option.__value;
}
function toggle_class(element2, name, toggle) {
  element2.classList.toggle(name, !!toggle);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  return new CustomEvent(type, { detail, bubbles, cancelable });
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}
function construct_svelte_component(component, props) {
  return new component(props);
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(
        /** @type {string} */
        type,
        detail,
        { cancelable }
      );
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block3, next, get_context) {
  let o = old_blocks.length;
  let n = list.length;
  let i = o;
  const old_indexes = {};
  while (i--)
    old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  const updates = [];
  i = n;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block3(key, child_ctx);
      block.c();
    } else if (dynamic) {
      updates.push(() => block.p(child_ctx, dirty));
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n--;
  }
  while (o && n) {
    const new_block = new_blocks[n - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o--;
      n--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key))
      destroy(old_block, lookup);
  }
  while (n)
    insert2(new_blocks[n - 1]);
  run_all(updates);
  return new_blocks;
}

// node_modules/svelte/src/runtime/internal/spread.js
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n = updates[i];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance15, create_fragment15, not_equal, props, append_styles2 = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance15 ? instance15(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment15 ? create_fragment15($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    connectedCallback() {
      return __async(this, null, function* () {
        this.$$cn = true;
        if (!this.$$c) {
          let create_slot2 = function(name) {
            return () => {
              let node;
              const obj = {
                c: function create() {
                  node = element("slot");
                  if (name !== "default") {
                    attr(node, "name", name);
                  }
                },
                /**
                 * @param {HTMLElement} target
                 * @param {HTMLElement} [anchor]
                 */
                m: function mount(target, anchor) {
                  insert(target, node, anchor);
                },
                d: function destroy(detaching) {
                  if (detaching) {
                    detach(node);
                  }
                }
              };
              return obj;
            };
          };
          yield Promise.resolve();
          if (!this.$$cn || this.$$c) {
            return;
          }
          const $$slots = {};
          const existing_slots = get_custom_elements_slots(this);
          for (const name of this.$$s) {
            if (name in existing_slots) {
              $$slots[name] = [create_slot2(name)];
            }
          }
          for (const attribute of this.attributes) {
            const name = this.$$g_p(attribute.name);
            if (!(name in this.$$d)) {
              this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
            }
          }
          for (const key in this.$$p_d) {
            if (!(key in this.$$d) && this[key] !== void 0) {
              this.$$d[key] = this[key];
              delete this[key];
            }
          }
          this.$$c = new this.$$ctor({
            target: this.shadowRoot || this,
            props: __spreadProps(__spreadValues({}, this.$$d), {
              $$slots,
              $$scope: {
                ctx: []
              }
            })
          });
          const reflect_attributes = () => {
            this.$$r = true;
            for (const key in this.$$p_d) {
              this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
              if (this.$$p_d[key].reflect) {
                const attribute_value = get_custom_element_value(
                  key,
                  this.$$d[key],
                  this.$$p_d,
                  "toAttribute"
                );
                if (attribute_value == null) {
                  this.removeAttribute(this.$$p_d[key].attribute || key);
                } else {
                  this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
                }
              }
            }
            this.$$r = false;
          };
          this.$$c.$$.after_update.push(reflect_attributes);
          reflect_attributes();
          for (const type in this.$$l) {
            for (const listener of this.$$l[type]) {
              const unsub = this.$$c.$on(type, listener);
              this.$$l_u.set(listener, unsub);
            }
          }
          this.$$l = {};
        }
      });
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      var _a;
      if (this.$$r)
        return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      (_a = this.$$c) == null ? void 0 : _a.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn && this.$$c) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  var _a;
  const type = (_a = props_definition[prop]) == null ? void 0 : _a.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/store/index.js
var subscriber_queue = [];
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set, update2) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  if (!stores_array.every(Boolean)) {
    throw new Error("derived() expects stores as input, got a falsy value");
  }
  const auto = fn.length < 2;
  return readable(initial_value, (set, update2) => {
    let started = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set, update2);
      if (auto) {
        set(result);
      } else {
        cleanup = is_function(result) ? result : noop;
      }
    };
    const unsubscribers = stores_array.map(
      (store, i) => subscribe(
        store,
        (value) => {
          values[i] = value;
          pending &= ~(1 << i);
          if (started) {
            sync();
          }
        },
        () => {
          pending |= 1 << i;
        }
      )
    );
    started = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
      started = false;
    };
  });
}

// src/stores/CoreStore.ts
function createPersistentStore(key, initialState2) {
  const loadState = () => {
    try {
      const saved = localStorage.getItem(key);
      return saved ? __spreadValues(__spreadValues({}, initialState2), JSON.parse(saved)) : initialState2;
    } catch (e) {
      return initialState2;
    }
  };
  const { subscribe: subscribe2, set, update: update2 } = writable(loadState());
  return {
    subscribe: subscribe2,
    set,
    update: update2,
    // Type-safe patch method
    patch: (partial) => {
      update2((state) => __spreadValues(__spreadValues({}, state), partial));
    },
    // Reset to initial state
    reset: () => set(initialState2),
    // Persist state
    persist: () => {
      const state = get_store_value({ subscribe: subscribe2 });
      localStorage.setItem(key, JSON.stringify(state));
    }
  };
}
var core = createPersistentStore("graphweaver-core", {
  plugin: null,
  initialized: false,
  lastUpdate: Date.now()
});
var errors = writable({
  message: null,
  timestamp: null,
  type: null,
  context: {}
});
var utils = {
  initialize: (plugin) => {
    core.patch({
      plugin,
      initialized: true,
      lastUpdate: Date.now()
    });
  },
  reportError: (message, type = "error", context) => {
    errors.set({
      message,
      type,
      timestamp: Date.now(),
      context
    });
  },
  clearError: () => {
    errors.set({
      message: null,
      timestamp: null,
      type: null
    });
  }
};
var isInitialized = derived(core, ($core) => $core.initialized);
var hasError = derived(errors, ($errors) => $errors.message !== null);

// src/types/ai.types.ts
var AIProvider = /* @__PURE__ */ ((AIProvider2) => {
  AIProvider2["OpenAI"] = "openai";
  AIProvider2["Anthropic"] = "anthropic";
  AIProvider2["Google"] = "google";
  AIProvider2["Groq"] = "groq";
  AIProvider2["OpenRouter"] = "openrouter";
  AIProvider2["LMStudio"] = "lmstudio";
  return AIProvider2;
})(AIProvider || {});

// src/types/operations.types.ts
var OperationType = /* @__PURE__ */ ((OperationType2) => {
  OperationType2["Generation"] = "generation";
  OperationType2["FrontMatter"] = "frontMatter";
  OperationType2["Wikilink"] = "wikilink";
  OperationType2["Ontology"] = "ontology";
  OperationType2["KnowledgeBloom"] = "knowledgeBloom";
  return OperationType2;
})(OperationType || {});

// src/types/settings.types.ts
var DEFAULT_SETTINGS = {
  aiProvider: {
    selected: "openai" /* OpenAI */,
    apiKeys: {},
    selectedModels: {
      ["openai" /* OpenAI */]: "gpt-4o-mini"
    }
  },
  frontMatter: {
    customProperties: [],
    // Initialize as PropertyTag[]
    autoGenerate: false
  },
  tags: {
    customTags: []
  },
  localLMStudio: {
    enabled: false,
    port: 1234,
    modelName: ""
  },
  advanced: {
    maxTokens: 4096,
    temperature: 0.3,
    generateWikilinks: false,
    minWordCount: 5,
    maxLinksPerNote: 10,
    batchSize: 10,
    delayBetweenChunks: 1e3,
    // Default value
    maxRetries: 3,
    // Default value
    maxConcurrentProcessing: 3
    // Default value
  },
  ontology: {
    lastGenerated: ""
  },
  knowledgeBloom: {
    selectedModel: "string",
    defaultPrompt: "Generate a comprehensive note about {LINK}. Include key concepts, definitions, and relevant examples if applicable."
  }
};

// src/generators/BaseGenerator.ts
var BaseGenerator = class {
  constructor(aiAdapter, settingsService) {
    this.aiAdapter = aiAdapter;
    this.settingsService = settingsService;
  }
  /**
   * Generate content based on input and settings.
   * @param input The input data for generation
   * @returns Promise resolving to the generated content
   */
  generate(input) {
    return __async(this, null, function* () {
      try {
        if (!this.validateInput(input)) {
          throw new Error("Invalid input provided");
        }
        const prompt = this.preparePrompt(input);
        const model = yield this.getCurrentModel();
        const aiResponse = yield this.aiAdapter.generateResponse(prompt, model);
        if (!aiResponse.success || !aiResponse.data) {
          throw new Error(aiResponse.error || "Failed to generate content");
        }
        return this.formatOutput(aiResponse.data, input);
      } catch (error) {
        return this.handleError(error);
      }
    });
  }
  /**
   * Initialize the generator.
   * Derived classes can override this method if specific initialization is needed.
   */
  initialize() {
    return __async(this, null, function* () {
    });
  }
  /**
   * Destroy the generator.
   * Derived classes can override this method to clean up resources.
   */
  destroy() {
    return __async(this, null, function* () {
    });
  }
  /**
   * Get the current model for this generator.
   * @returns The model identifier string
   */
  getCurrentModel() {
    return __async(this, null, function* () {
      const settings = this.getSettings();
      const selectedModel = this.getSelectedModel(settings);
      if (!selectedModel) {
        throw new Error(`No model selected for ${this.constructor.name}`);
      }
      return selectedModel;
    });
  }
  /**
   * Get the selected model from settings.
   * Can be overridden by subclasses to use specific model settings.
   */
  getSelectedModel(settings) {
    var _a, _b;
    const provider = this.aiAdapter.getProviderType();
    return (_b = (_a = settings.aiProvider) == null ? void 0 : _a.selectedModels) == null ? void 0 : _b[provider];
  }
  /**
   * Get the current settings for this generator.
   */
  getSettings() {
    return this.settingsService.getSettings();
  }
  /**
   * Validate the input before generation.
   * @param input The input to validate
   */
  validateInput(input) {
    return input !== null && input !== void 0;
  }
  /**
   * Handle errors that occur during generation.
   * @param error The error that occurred
   */
  handleError(error) {
    const errorMessage = `${this.constructor.name} error: ${error.message}`;
    console.error(errorMessage);
    throw new Error(errorMessage);
  }
  /**
   * Utility method to clean and format text content
   */
  cleanContent(content) {
    return content.trim().replace(/\n{3,}/g, "\n\n");
  }
  /**
   * Utility method to validate JSON data
   */
  isValidJson(data) {
    try {
      JSON.parse(JSON.stringify(data));
      return true;
    } catch (e) {
      return false;
    }
  }
};

// src/generators/FrontMatterGenerator.ts
var FrontMatterGenerator = class extends BaseGenerator {
  constructor(aiAdapter, settingsService, jsonSchemaGenerator) {
    super(aiAdapter, settingsService);
    this.jsonSchemaGenerator = jsonSchemaGenerator;
  }
  /**
   * Generates front matter for the provided content
   * @param input The input containing content and optional properties
   * @returns Promise resolving to content with front matter
   */
  generate(input) {
    return __async(this, null, function* () {
      try {
        const settings = this.getSettings();
        const completeInput = __spreadProps(__spreadValues({}, input), {
          customProperties: input.customProperties || settings.frontMatter.customProperties,
          customTags: input.customTags || settings.tags.customTags.map((tag) => tag.name)
        });
        const prompt = this.preparePrompt(completeInput);
        const model = yield this.getCurrentModel();
        const aiResponse = yield this.aiAdapter.generateResponse(prompt, model);
        if (!aiResponse.success || !aiResponse.data) {
          return { content: input.content };
        }
        return this.formatOutput(aiResponse.data, completeInput);
      } catch (error) {
        console.error("FrontMatterGenerator: Error during generation:", error);
        return { content: input.content };
      }
    });
  }
  /**
   * Prepares the AI prompt with schema and context
   * @param input The input containing content and properties
   * @returns Formatted prompt string
   */
  preparePrompt(input) {
    var _a, _b;
    const schema = this.jsonSchemaGenerator.generateBaseSchema();
    const propertyPrompt = ((_a = input.customProperties) == null ? void 0 : _a.map(
      (prop) => `${prop.name} (${prop.type}): ${prop.description}`
    ).join("\n")) || "";
    const tagPrompt = ((_b = input.customTags) == null ? void 0 : _b.join(", ")) || "";
    return `
# MISSION
Act as an expert analyzer and creator of metadata, with a specialization in ontological organization for Obsidian Vaults. Generate ONLY front matter fields based on the provided schema and available properties/tags.

# GUIDELINES
- You must ONLY use the properties provided in the schema
- Front matter fields will NOT include the note content itself
- Prioritize using available tags, but remain flexible in choosing additional relevant tags
- Return ONLY the formatted JSON object with front matter fields
- Do NOT include the content field in your response

## Custom Properties
${propertyPrompt}

## Available Tags
${tagPrompt}

## Note Content for Reference (OMIT FROM OUTPUT)
${input.content}

## JSON Schema for Front Matter Fields:
${JSON.stringify(schema, null, 2)}

Generate ONLY the front matter fields as JSON. Do not include any other text or the note content.
`;
  }
  /**
   * Formats AI response into proper front matter structure
   * @param aiResponse The AI response data
   * @param originalInput The original input parameters
   * @returns Formatted output with front matter
   */
  formatOutput(aiResponse, originalInput) {
    const parsedResponse = this.parseAIResponse(aiResponse);
    if (!parsedResponse) {
      console.error("FrontMatterGenerator: Failed to parse AI response");
      return { content: originalInput.content };
    }
    if ("content" in parsedResponse) {
      delete parsedResponse.content;
    }
    const frontMatter = this.convertToFrontMatter(parsedResponse);
    const finalContent = this.mergeFrontMatter(originalInput.content, frontMatter);
    return { content: finalContent };
  }
  /**
   * Parses and validates AI response
   */
  parseAIResponse(data) {
    if (typeof data === "object" && data !== null) {
      return data;
    }
    try {
      const parsed = JSON.parse(data);
      if (typeof parsed === "object" && parsed !== null) {
        return parsed;
      }
    } catch (error) {
      console.error("FrontMatterGenerator: Error parsing AI response as JSON:", error);
    }
    return null;
  }
  /**
   * Converts parsed response to YAML front matter format
   */
  convertToFrontMatter(data) {
    return Object.entries(data).map(([key, value]) => {
      if (Array.isArray(value)) {
        return `${key}:
${value.map((item) => `  - ${item}`).join("\n")}`;
      } else if (typeof value === "object" && value !== null) {
        return `${key}: ${JSON.stringify(value)}`;
      } else {
        return `${key}: ${value}`;
      }
    }).join("\n");
  }
  /**
   * Merges front matter with original content
   */
  mergeFrontMatter(content, frontMatter) {
    const hasFrontMatter = content.trim().startsWith("---");
    if (!hasFrontMatter) {
      return `---
${frontMatter}
---

${content.trim()}`;
    }
    const parts = content.split("---");
    if (parts.length >= 3) {
      const existingFrontMatter = parts[1].trim();
      const contentParts = parts.slice(2).join("---").trim();
      return `---
${frontMatter}
---
${contentParts}`;
    }
    return `---
${frontMatter}
---

${content.trim()}`;
  }
  /**
   * Validates input parameters
   */
  validateInput(input) {
    return typeof input.content === "string" && input.content.trim().length > 0;
  }
  /**
   * Gets the current AI model
   */
  getCurrentModel() {
    return __async(this, null, function* () {
      var _a, _b;
      const settings = this.getSettings();
      const providerType = this.aiAdapter.getProviderType();
      const modelApiName = (_b = (_a = settings.aiProvider) == null ? void 0 : _a.selectedModels) == null ? void 0 : _b[providerType];
      if (!modelApiName) {
        throw new Error(`No model selected for provider: ${providerType}`);
      }
      return modelApiName;
    });
  }
};

// src/services/core/ServiceError.ts
var ServiceError = class extends Error {
  constructor(serviceId, message, details) {
    super(message);
    this.name = "ServiceError";
    this.serviceId = serviceId;
    this.details = details;
    Object.setPrototypeOf(this, ServiceError.prototype);
    if ((details == null ? void 0 : details.cause) instanceof Error) {
      this.cause = details.cause;
    }
  }
  /**
   * Create ServiceError from unknown error
   * @param serviceId Service identifier
   * @param error Original error
   * @param additionalDetails Additional error details
   */
  static from(serviceId, error, additionalDetails) {
    if (error instanceof ServiceError) {
      return error;
    }
    const details = __spreadProps(__spreadValues({}, additionalDetails), {
      cause: error instanceof Error ? error : void 0
    });
    const message = error instanceof Error ? error.message : String(error);
    return new ServiceError(serviceId, message, details);
  }
  /**
   * Get error details
   * @returns Structured error details
   */
  getDetails() {
    return {
      message: this.message,
      serviceId: this.serviceId,
      details: this.details,
      stack: this.stack,
      cause: this.cause
    };
  }
};

// src/services/core/CoreService.ts
var CoreService = class {
  constructor(serviceId, serviceName) {
    this.serviceId = serviceId;
    this.serviceName = serviceName;
    this.state = "uninitialized" /* Uninitialized */;
    this.error = null;
    this.isUnloading = false;
  }
  /**
   * Initialize the service
   * Manages state transitions and error handling
   */
  initialize() {
    return __async(this, null, function* () {
      if (this.isUnloading) {
        throw new ServiceError(this.serviceName, "Cannot initialize while unloading");
      }
      try {
        this.state = "initializing" /* Initializing */;
        yield this.initializeInternal();
        this.state = "ready" /* Ready */;
        this.error = null;
      } catch (error) {
        this.handleError("Initialization failed", error);
        this.state = "error" /* Error */;
        throw error;
      }
    });
  }
  /**
   * Check if service is ready for use
   */
  isReady() {
    return this.state === "ready" /* Ready */ && !this.isUnloading;
  }
  /**
   * Clean up service resources
   */
  destroy() {
    return __async(this, null, function* () {
      if (this.isUnloading)
        return;
      try {
        this.isUnloading = true;
        this.state = "destroying" /* Destroying */;
        yield this.destroyInternal();
        this.state = "destroyed" /* Destroyed */;
      } catch (error) {
        this.handleError("Destroy failed", error);
        throw error;
      }
    });
  }
  /**
   * Get current service state
   */
  getState() {
    return { state: this.state, error: this.error };
  }
  /**
   * Standard error handling
   */
  handleError(message, error) {
    const serviceError = ServiceError.from(this.serviceName, error, {
      state: this.state,
      isUnloading: this.isUnloading
    });
    console.error(`${this.serviceName} error:`, serviceError.getDetails());
    this.error = serviceError;
  }
};

// src/generators/utils/WikilinkPatterns.ts
var WikilinkPatterns = {
  WIKILINK_REGEX: /\[\[([^\[\]]*(?:\[\[[^\[\]]*\]\][^\[\]]*)*)\]\]/g,
  SIMPLE_WIKILINK_REGEX: /\[\[([^\]]+)\]\]/g,
  MALFORMED_REGEX: /\[\[[^\]\[]*(?:\](?!\])|$)|(?:\[\[)+[^\]\[]*\]\]/g,
  CODE_BLOCK_REGEX: /`[^`]*`|```[\s\S]*?```/g,
  INLINE_CODE_REGEX: /`[^`]+`/g,
  SPECIAL_CHARS_REGEX: /[!@#$%^&*(),.?":{}|<>]/g
};
var WikilinkConfig = {
  MAX_LINK_LENGTH: 100,
  MAX_NESTING_DEPTH: 5,
  CONTEXT_WINDOW_SIZE: 100,
  ALLOWED_SPECIAL_CHARS: ["'", "-", "_", "&", "."]
};
function isAllowedSpecialChar(char) {
  return WikilinkConfig.ALLOWED_SPECIAL_CHARS.includes(char);
}
var WikilinkUtils = class {
  /**
   * Escapes special regex characters in a string
   */
  static escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  /**
   * Calculates the nesting depth of a wikilink
   */
  static calculateNestingDepth(text2) {
    let maxDepth = 0;
    let currentDepth = 0;
    for (let i = 0; i < text2.length - 1; i++) {
      if (text2[i] === "[" && text2[i + 1] === "[") {
        currentDepth++;
        maxDepth = Math.max(maxDepth, currentDepth);
        i++;
      } else if (text2[i] === "]" && text2[i + 1] === "]") {
        currentDepth--;
        i++;
      }
    }
    return maxDepth;
  }
};

// src/services/WikilinkTextProcessor.ts
var WikilinkTextProcessor = class extends CoreService {
  constructor() {
    super("wikilink-processor", "Wikilink Text Processor");
  }
  initializeInternal() {
    return __async(this, null, function* () {
    });
  }
  destroyInternal() {
    return __async(this, null, function* () {
    });
  }
  /**
   * Add wikilinks to the content based on suggested links
   */
  addWikilinks(content, suggestedLinks, existingWikilinks) {
    const codeBlocks = /* @__PURE__ */ new Map();
    let processedContent = this.protectCodeBlocks(content, codeBlocks);
    suggestedLinks.filter((link) => this.isValidWikilinkText(link)).sort((a, b) => b.length - a.length).forEach((phrase) => {
      const normalizedLink = this.normalizeWikilinkText(phrase);
      if (!existingWikilinks.has(normalizedLink.toLowerCase())) {
        const escapedPhrase = WikilinkUtils.escapeRegExp(phrase);
        const regex = new RegExp(
          `(?<!\\[\\[.*?)\\b${escapedPhrase}\\b(?![^\\[]*\\]\\])`,
          "gi"
        );
        processedContent = processedContent.replace(regex, (match, offset) => {
          if (this.shouldSkipWikilink(processedContent, offset, match.length, existingWikilinks)) {
            return match;
          }
          return `[[${normalizedLink}]]`;
        });
      }
    });
    const finalContent = this.restoreCodeBlocks(processedContent, codeBlocks);
    return finalContent;
  }
  /**
   * Clean nested wikilinks while preserving structure
   */
  cleanNestedWikilinks(content) {
    const processedLinks = /* @__PURE__ */ new Set();
    let result = content;
    const matches = Array.from(content.matchAll(WikilinkPatterns.WIKILINK_REGEX)).map((match) => ({
      full: match[0],
      inner: match[1],
      index: match.index,
      length: match[0].length,
      depth: WikilinkUtils.calculateNestingDepth(match[0])
    })).filter((match) => match.depth <= WikilinkConfig.MAX_NESTING_DEPTH).sort((a, b) => b.length - a.length);
    const processedPositions = /* @__PURE__ */ new Set();
    for (const match of matches) {
      if (processedPositions.has(match.index))
        continue;
      if (match.inner.includes("[[")) {
        const cleaned = this.removeNestedDuplicates(match.inner);
        if (this.isValidWikilinkText(cleaned) && !processedLinks.has(cleaned.toLowerCase())) {
          processedLinks.add(cleaned.toLowerCase());
          result = this.safeReplace(
            result,
            match.index,
            match.length,
            `[[${this.normalizeWikilinkText(cleaned)}]]`
          );
          processedPositions.add(match.index);
        }
      } else {
        processedLinks.add(match.inner.toLowerCase());
      }
    }
    return result;
  }
  /**
   * Normalize text for wikilink usage
   */
  normalizeWikilinkText(text2) {
    const original = text2.trim();
    let normalized = original.replace(/\s+/g, " ");
    normalized = normalized.replace(
      WikilinkPatterns.SPECIAL_CHARS_REGEX,
      (char) => isAllowedSpecialChar(char) ? char : " "
    ).trim();
    return normalized.toLowerCase() === original.toLowerCase() ? original : normalized;
  }
  /**
   * Protected and utility methods
   */
  protectCodeBlocks(content, codeBlocks) {
    let processed = content;
    let counter = 0;
    const replaceWithPlaceholder = (match, type) => {
      const placeholder = `__${type}_${counter}__`;
      codeBlocks.set(placeholder, match);
      counter++;
      return placeholder;
    };
    processed = processed.replace(
      WikilinkPatterns.CODE_BLOCK_REGEX,
      (match) => replaceWithPlaceholder(match, "CODE_BLOCK")
    );
    processed = processed.replace(
      WikilinkPatterns.INLINE_CODE_REGEX,
      (match) => replaceWithPlaceholder(match, "INLINE_CODE")
    );
    return processed;
  }
  restoreCodeBlocks(content, codeBlocks) {
    let processed = content;
    for (const [placeholder, original] of codeBlocks.entries()) {
      processed = processed.replace(placeholder, original);
    }
    return processed;
  }
  isWithinExistingWikilink(content, offset, length, existingWikilinks) {
    const contextStart = Math.max(0, offset - WikilinkConfig.CONTEXT_WINDOW_SIZE);
    const contextEnd = Math.min(
      content.length,
      offset + length + WikilinkConfig.CONTEXT_WINDOW_SIZE
    );
    const context = content.slice(contextStart, contextEnd);
    let bracketCount = 0;
    for (let i = 0; i < offset - contextStart; i++) {
      if (context[i] === "[" && context[i + 1] === "[") {
        bracketCount++;
        i++;
      } else if (context[i] === "]" && context[i + 1] === "]") {
        bracketCount--;
        i++;
      }
    }
    if (bracketCount > 0)
      return true;
    return Array.from(existingWikilinks).some((wikilink) => {
      const index = context.indexOf(wikilink);
      if (index === -1)
        return false;
      const absStart = contextStart + index;
      const absEnd = absStart + wikilink.length;
      return offset >= absStart && offset + length <= absEnd;
    });
  }
  isWithinProtectedContext(content, offset) {
    return [WikilinkPatterns.CODE_BLOCK_REGEX, WikilinkPatterns.INLINE_CODE_REGEX].some((regex) => {
      const matches = Array.from(content.matchAll(regex));
      return matches.some(
        (match) => match.index !== void 0 && offset >= match.index && offset < match.index + match[0].length
      );
    });
  }
  extractExistingWikilinks(content) {
    const matches = content.match(WikilinkPatterns.SIMPLE_WIKILINK_REGEX) || [];
    return matches.map((match) => match.slice(2, -2).toLowerCase());
  }
  removeNestedDuplicates(text2) {
    return text2.replace(/\[\[([^\[\]]+)\]\]/g, "$1");
  }
  safeReplace(text2, start, length, replacement) {
    return text2.slice(0, start) + replacement + text2.slice(start + length);
  }
  /**
   * Determine if the wikilink should be skipped based on context
   */
  shouldSkipWikilink(content, offset, length, existingWikilinks) {
    if (this.isWithinExistingWikilink(content, offset, length, existingWikilinks)) {
      return true;
    }
    if (this.isWithinProtectedContext(content, offset)) {
      return true;
    }
    const contextStart = Math.max(0, offset - 4);
    const contextEnd = Math.min(content.length, offset + length + 4);
    const context = content.slice(contextStart, contextEnd);
    if (context.match(/\[\[.*?\]\]/)) {
      return true;
    }
    return false;
  }
  /**
   * Validate wikilink text
   */
  isValidWikilinkText(text2) {
    if (!text2 || typeof text2 !== "string")
      return false;
    const trimmed = text2.trim();
    if (trimmed.length === 0 || trimmed.length > WikilinkConfig.MAX_LINK_LENGTH) {
      return false;
    }
    const bracketCount = (trimmed.match(/[\[\]]/g) || []).length;
    if (bracketCount % 2 !== 0)
      return false;
    if (trimmed.match(WikilinkPatterns.MALFORMED_REGEX))
      return false;
    const validCharPattern = /^[a-zA-Z0-9\s\-_'&.]+$/;
    return validCharPattern.test(trimmed);
  }
};

// src/generators/WikilinkGenerator.ts
var WikilinkGenerator = class extends BaseGenerator {
  constructor(aiAdapter, settingsService) {
    super(aiAdapter, settingsService);
    this.textProcessor = new WikilinkTextProcessor();
  }
  /**
   * Initialize required services
   */
  initialize() {
    return __async(this, null, function* () {
      yield this.textProcessor.initialize();
    });
  }
  /**
   * Clean up resources
   */
  destroy() {
    return __async(this, null, function* () {
      this.textProcessor.destroy();
    });
  }
  /**
   * Generate wikilinks for the provided content
   */
  generate(input) {
    return __async(this, null, function* () {
      try {
        if (!this.validateInput(input)) {
          throw new Error("Invalid input for wikilink generation");
        }
        const prompt = this.preparePrompt(input);
        const model = yield this.getCurrentModel();
        const aiResponse = yield this.aiAdapter.generateResponse(prompt, model);
        let aiResponseValue;
        if (aiResponse && aiResponse.success && aiResponse.data && aiResponse.data.value) {
          aiResponseValue = aiResponse.data.value;
        } else {
          throw new Error("Invalid AI response format");
        }
        const output = this.formatOutput(aiResponseValue, input);
        return output;
      } catch (error) {
        console.error("WikilinkGenerator: Error during generation:", error);
        throw new ServiceError(
          "WikilinkGenerator",
          "Failed to generate wikilinks",
          error instanceof Error ? error : void 0
        );
      }
    });
  }
  /**
   * Prepare AI prompt with custom tags and context
   */
  preparePrompt(input) {
    const settings = this.getSettings();
    const customTags = settings.tags.customTags.map((tag) => tag.name).join(", ") || "";
    return `
# MISSION
Act as an expert in recommending wikilinks for potential future research notes.
Analyze the following content and suggest key phrases, proper nouns, people, places, events, and concepts that would make for a relevant and practical note.
Consider the existing pages in the vault and prioritize linking to them. Ignore all tags and front matter when generating.

# CONTENT
${input.content}

# EXISTING PAGES
${input.existingPages.join(", ")}

Provide your suggestions as a JSON array of strings, omitting all characters before or after, including backticks.
        `;
  }
  /**
   * Format AI response into wikilink output using text processor
   */
  formatOutput(aiResponse, originalInput) {
    const suggestedLinks = this.parseSuggestedLinks(aiResponse);
    const existingLinks = this.extractExistingWikilinks(originalInput.content);
    let processedContent = originalInput.content;
    processedContent = this.textProcessor.addWikilinks(
      processedContent,
      suggestedLinks,
      existingLinks
    );
    processedContent = this.textProcessor.cleanNestedWikilinks(processedContent);
    return { content: processedContent };
  }
  /**
   * Parse suggested links from AI response
   */
  parseSuggestedLinks(aiResponse) {
    if (aiResponse && Array.isArray(aiResponse.suggestions)) {
      return aiResponse.suggestions.filter((item) => typeof item === "string");
    }
    console.error("WikilinkGenerator: Unexpected AI response format:", aiResponse);
    return [];
  }
  /**
   * Validate input structure
   */
  validateInput(input) {
    return typeof input.content === "string" && input.content.trim().length > 0 && Array.isArray(input.existingPages) && input.existingPages.every((page) => typeof page === "string");
  }
  /**
   * Get current AI model based on settings
   */
  getCurrentModel() {
    return __async(this, null, function* () {
      var _a, _b;
      const settings = this.getSettings();
      const providerType = this.aiAdapter.getProviderType();
      const selectedModel = (_b = (_a = settings.aiProvider) == null ? void 0 : _a.selectedModels) == null ? void 0 : _b[providerType];
      if (!selectedModel) {
        throw new ServiceError(
          "WikilinkGenerator",
          `No model selected for provider type: ${providerType}`
        );
      }
      return selectedModel;
    });
  }
  /**
   * Extract existing wikilinks from content
   */
  extractExistingWikilinks(content) {
    const regex = /\[\[([^\]]+)\]\]/g;
    const existingLinks = /* @__PURE__ */ new Set();
    let match;
    while ((match = regex.exec(content)) !== null) {
      const link = match[1].split("|")[0].trim().toLowerCase();
      existingLinks.add(link);
    }
    return existingLinks;
  }
};

// src/generators/OntologyGenerator.ts
var OntologyGenerator = class extends BaseGenerator {
  constructor(aiAdapter, settingsService) {
    super(aiAdapter, settingsService);
  }
  /**
   * Main method to generate ontology.
   * @param input - Input parameters for ontology generation.
   * @returns Promise resolving to the generated ontology.
   */
  generate(input) {
    return __async(this, null, function* () {
      if (!this.validateInput(input)) {
        throw new Error("Invalid input for ontology generation");
      }
      try {
        const prompt = this.preparePrompt(input);
        const aiResponse = yield this.aiAdapter.generateResponse(prompt, input.modelApiName);
        return this.formatOutput(aiResponse.data);
      } catch (error) {
        this.handleError(error);
        throw error;
      }
    });
  }
  /**
   * Prepares the AI prompt based on the input.
   * @param input - Input parameters for ontology generation.
   * @returns Formatted prompt string.
   */
  preparePrompt(input) {
    const fileNames = input.files.map((file) => file.basename).join(", ");
    const folderNames = input.folders.map((folder) => folder.name).join(", ");
    const tags = input.tags.join(", ");
    return `
# MISSION
Act as an expert in Ontological Science, specializing in taking unstructured information from an Obsidian vault, and creating tags to create a means of connecting the information.
Analyze the following information about a knowledge base and synthesize an ontology.
Based on the overall structure and content, suggest a set of tags that would create a cohesive and useful ontology for this knowledge base.

**Files:**
${fileNames}

**Folders:** 
${folderNames}

**Existing Tags:** 
${tags}

${input.userContext ? `**Additional Context:** ${input.userContext}` : ""}

For each suggested tag in the ontology, provide:
{
    "Name": {
        "description": "a brief but robust instruction on what this tag represents, and when it should be applied",
    }
}

Consider the following when creating the ontology:
1. Identify overarching themes and concepts present in the knowledge base.
2. Suggest tags that would help categorize and connect information across different files and folders.
3. Build upon existing tags, either by refining them or suggesting complementary tags.
4. Aim for a balance between specificity and generality in the suggested tags.
5. Consider the hierarchical structure implied by the folder organization.
6. Omit all spaces from tags names (e.g. AlbertEinstein instead of Albert Einstein)

Provide your response as a JSON object where the keys are the tag names and the values are objects containing the description.
Suggest enough tags to form a comprehensive ontology for this knowledge base.
        `;
  }
  /**
   * Formats the AI response into the OntologyResult structure.
   * @param aiResponse - Raw AI response data.
   * @returns OntologyResult containing suggested tags.
   */
  formatOutput(aiResponse) {
    let parsedResponse;
    if (typeof aiResponse === "string") {
      try {
        const fixedJson = this.fixIncompleteJson(aiResponse);
        parsedResponse = JSON.parse(fixedJson);
      } catch (error) {
        console.error("Failed to parse AI response as JSON:", error);
        throw new Error("Invalid AI response: unable to parse as JSON");
      }
    } else if (typeof aiResponse === "object" && aiResponse !== null) {
      parsedResponse = aiResponse;
    } else {
      console.error("Unexpected AI response format:", aiResponse);
      throw new Error("Invalid AI response format: expected an object or valid JSON string");
    }
    if (typeof parsedResponse !== "object" || parsedResponse === null) {
      throw new Error("Invalid AI response format: expected an object after parsing");
    }
    const suggestedTags = Object.entries(parsedResponse).map(([name, value]) => {
      if (typeof value === "object" && value !== null && "description" in value) {
        return {
          name: String(name).trim(),
          description: String(value.description).trim(),
          type: "string",
          required: false,
          multipleValues: false
        };
      }
      return null;
    }).filter((tag) => tag !== null);
    if (suggestedTags.length === 0) {
      throw new Error("No valid tags found in AI response");
    }
    return {
      tags: suggestedTags,
      properties: []
    };
  }
  /**
   * Attempts to fix incomplete JSON strings.
   * @param json - Raw JSON string.
   * @returns Fixed JSON string.
   */
  fixIncompleteJson(json) {
    let fixedJson = json.trim();
    if (!fixedJson.endsWith("}")) {
      fixedJson += "}}";
    }
    fixedJson = fixedJson.replace(/,\s*}$/, "}");
    return fixedJson;
  }
  /**
   * Validates the input parameters for ontology generation.
   * @param input - Input parameters.
   * @returns Boolean indicating validity.
   */
  validateInput(input) {
    return Array.isArray(input.files) && Array.isArray(input.folders) && Array.isArray(input.tags) && typeof input.provider === "string" && typeof input.modelApiName === "string" && (!input.userContext || typeof input.userContext === "string");
  }
  /**
   * Handles errors during ontology generation.
   * @param error - The error encountered.
   */
  handleError(error) {
    console.error(`Ontology generation error: ${error.message}`, error);
    throw new Error(`Ontology generation failed: ${error.message}`);
  }
};

// src/generators/JsonSchemaGenerator.ts
var JsonSchemaGenerator = class extends BaseGenerator {
  constructor(aiAdapter, settingsService) {
    super(aiAdapter, settingsService);
    this.settingsInitialized = false;
    this.cachedSchema = null;
  }
  /**
   * Generates a base JSON schema based on settings.
   * Handles lazy initialization of settings to avoid circular dependencies.
   */
  generateBaseSchema() {
    return __async(this, null, function* () {
      var _a, _b;
      const schema = {
        type: "object",
        properties: {},
        required: []
      };
      try {
        if (!this.settingsInitialized) {
          this.settingsInitialized = true;
          const settings = this.settingsService.getSettings();
          if ((_a = settings.frontMatter) == null ? void 0 : _a.customProperties) {
            settings.frontMatter.customProperties.forEach((property) => {
              schema.properties[property.name] = {
                type: this.getJsonSchemaType(property.type),
                description: `Create ${property.description}`
              };
              if (property.required) {
                schema.required.push(property.name);
              }
            });
          }
          if ((_b = settings.tags) == null ? void 0 : _b.customTags) {
            schema.properties.tags = {
              type: "array",
              items: {
                type: "string",
                enum: settings.tags.customTags.map((tag) => tag.name)
              },
              description: "Select appropriate tags from the provided list"
            };
          }
        }
      } catch (error) {
        console.warn("JsonSchemaGenerator: Settings not yet available, using basic schema");
      }
      schema.additionalProperties = false;
      return schema;
    });
  }
  /**
   * Determines the JSON schema type based on the provided property type.
   * @param propertyType The type of the property (e.g., 'number', 'boolean', 'array')
   * @returns The corresponding JSON schema type as a string
   */
  getJsonSchemaType(propertyType) {
    switch (propertyType) {
      case "number":
        return "number";
      case "boolean":
        return "boolean";
      case "array":
        return "array";
      default:
        return "string";
    }
  }
  /**
   * Resets the cached schema and settings initialization flag.
   * Useful for scenarios where settings have changed and the schema needs to be regenerated.
   */
  resetCache() {
    this.cachedSchema = null;
    this.settingsInitialized = false;
  }
  /**
   * Overrides the preparePrompt method.
   * Not used in JsonSchemaGenerator, returns an empty string.
   */
  preparePrompt(_input) {
    return "";
  }
  /**
   * Overrides the formatOutput method.
   * Not used in JsonSchemaGenerator, returns an empty object.
   */
  formatOutput(_aiResponse, _originalInput) {
    return {};
  }
};

// src/generators/KnowledgeBloomGenerator.ts
var import_obsidian = require("obsidian");
var KnowledgeBloomGenerator = class extends BaseGenerator {
  constructor(aiAdapter, settingsService, app, frontMatterGenerator, wikilinkProcessor) {
    super(aiAdapter, settingsService);
    this.app = app;
    this.currentInput = null;
    this.frontMatterGenerator = frontMatterGenerator;
    this.wikilinkProcessor = wikilinkProcessor;
  }
  /**
   * Generate new notes from wikilinks in the source document
   * @param input The input parameters for generation
   * @returns Promise resolving to generated notes
   */
  generate(input) {
    return __async(this, null, function* () {
      this.currentInput = input;
      try {
        if (!this.validateInput(input)) {
          throw new Error("Invalid input for Knowledge Bloom generation");
        }
        const wikilinks = yield this.extractWikilinks(input.sourceFile);
        if (wikilinks.length === 0) {
          throw new Error("No wikilinks found in the source file.");
        }
        const folderPath = this.getFolderPath(input.sourceFile);
        const output = { generatedNotes: [] };
        const generationPromises = wikilinks.map(
          (link) => this.processWikilink(link, folderPath, input, output)
        );
        yield Promise.allSettled(generationPromises);
        return output;
      } catch (error) {
        return this.handleError(error);
      } finally {
        this.currentInput = null;
      }
    });
  }
  /**
   * Extract and generate wikilinks from a file
   */
  extractWikilinks(file) {
    return __async(this, null, function* () {
      try {
        const content = yield this.app.vault.read(file);
        const existingWikilinks = /* @__PURE__ */ new Set();
        const suggestedLinks = yield this.generateSuggestedLinks(content);
        const processedContent = this.wikilinkProcessor.addWikilinks(
          content,
          suggestedLinks,
          existingWikilinks
        );
        const links = this.wikilinkProcessor.extractExistingWikilinks(processedContent);
        yield this.app.vault.modify(file, processedContent);
        return Array.from(new Set(links));
      } catch (error) {
        console.error("\u274C Error extracting wikilinks:", error);
        throw new Error(`Failed to extract wikilinks: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    });
  }
  /**
   * Generate suggested links using AI
   */
  generateSuggestedLinks(content) {
    return __async(this, null, function* () {
      try {
        const prompt = `
Analyze the following content and identify key phrases, proper nouns, concepts, and terms that would make good wiki links. 
Focus on important concepts, technical terms, proper nouns, and significant phrases.
Return them as a simple array of strings.

Content:
${content}

Return ONLY the array of strings, nothing else.
`;
        const model = yield this.getCurrentModel();
        const response = yield this.aiAdapter.generateResponse(prompt, model);
        if (!response.success || !response.data) {
          throw new Error("Failed to generate suggested links");
        }
        let suggestions = [];
        if (Array.isArray(response.data)) {
          suggestions = response.data.filter((item) => typeof item === "string");
        } else if (typeof response.data === "object" && response.data !== null) {
          suggestions = Object.values(response.data).filter((item) => typeof item === "string");
        }
        return suggestions;
      } catch (error) {
        console.error("\u274C Error generating suggested links:", error);
        return [];
      }
    });
  }
  /**
   * Process a single wikilink to generate a new note
   */
  processWikilink(link, folderPath, input, output) {
    return __async(this, null, function* () {
      try {
        if (this.doesNoteExist(link, folderPath)) {
          return;
        }
        const markdownContent = yield this.generateMarkdownContent(link, input);
        const finalContent = yield this.addFrontMatter(markdownContent);
        const newFilePath = `${folderPath}/${link}.md`;
        yield this.app.vault.create(newFilePath, finalContent);
        output.generatedNotes.push({ title: link, content: finalContent });
      } catch (error) {
        console.error(`\u274C Error processing wikilink "${link}":`, error);
        new import_obsidian.Notice(`Failed to generate note for "${link}": ${error.message}`);
      }
    });
  }
  /**
   * Generate markdown content for a single wikilink
   */
  generateMarkdownContent(link, input) {
    return __async(this, null, function* () {
      const prompt = this.preparePrompt(__spreadProps(__spreadValues({}, input), {
        currentWikilink: link,
        currentNoteTitle: input.sourceFile.basename
      }));
      const model = yield this.getCurrentModel();
      const options = { rawResponse: true };
      const response = yield this.aiAdapter.generateResponse(prompt, model, options);
      if (!response.success || !response.data) {
        throw new Error(`Failed to generate content for "${link}": ${response.error || "Unknown error"}`);
      }
      let content = response.data;
      if (typeof content === "object" && content !== null) {
        const contentObj = content;
        if ("content" in contentObj && typeof contentObj.content === "string") {
          content = contentObj.content;
        } else if ("response" in contentObj && typeof contentObj.response === "string") {
          content = contentObj.response;
        } else {
          content = JSON.stringify(content);
        }
      }
      const contentString = String(content).trim();
      return contentString.replace(/^---\n[\s\S]*?\n---\n*/g, "");
    });
  }
  /**
   * Add front matter to the generated content
   */
  addFrontMatter(content) {
    return __async(this, null, function* () {
      const frontMatterInput = {
        content,
        customProperties: this.extractCustomProperties(content),
        customTags: this.extractCustomTags(content)
      };
      const frontMatterResult = yield this.frontMatterGenerator.generate(frontMatterInput);
      return frontMatterResult.content;
    });
  }
  /**
   * Extract custom properties from content
   */
  extractCustomProperties(content) {
    try {
      return this.settingsService.getSettings().frontMatter.customProperties;
    } catch (error) {
      console.error("\u274C Error extracting custom properties:", error);
      return [];
    }
  }
  /**
   * Extract custom tags from content
   */
  extractCustomTags(content) {
    try {
      return this.settingsService.getSettings().tags.customTags.map((tag) => tag.name);
    } catch (error) {
      console.error("\u274C Error extracting custom tags:", error);
      return [];
    }
  }
  /**
   * Prepare the AI prompt for content generation
   */
  preparePrompt(input) {
    if (!input.currentWikilink || !input.currentNoteTitle) {
      throw new Error("Missing required wikilink or note title");
    }
    return `
# MISSION
Act as an expert Research Assistant that specializes in writing structured notes that are accessible and practical based on a provided topic.

# GUIDELINES
- Write the note in Markdown format.
- Do NOT include any JSON objects or front matter.
- Ensure the content is well-structured and comprehensive.
- Include relevant wikilinks to other concepts where appropriate.
- Omit any words before or after the Markdown content.

# TOPIC
Write a detailed note about "${input.currentWikilink}" in relation to "${input.currentNoteTitle}".

${input.userPrompt ? `## Additional Context:
${input.userPrompt}` : ""}
`;
  }
  /**
   * Check if a note exists at the given path
   */
  doesNoteExist(title, folderPath) {
    const filePath = `${folderPath}/${title}.md`;
    const file = this.app.vault.getAbstractFileByPath(filePath);
    return file instanceof import_obsidian.TFile;
  }
  /**
   * Get the folder path for the new note
   */
  getFolderPath(file) {
    const pathSegments = file.path.split("/");
    pathSegments.pop();
    return pathSegments.join("/");
  }
  /**
   * Validate the input parameters
   */
  validateInput(input) {
    const isValid = (input == null ? void 0 : input.sourceFile) instanceof import_obsidian.TFile;
    return isValid;
  }
  /**
   * Get the current AI model
   */
  getCurrentModel() {
    return __async(this, null, function* () {
      var _a;
      const settings = this.getSettings();
      const selectedModel = (_a = settings.knowledgeBloom) == null ? void 0 : _a.selectedModel;
      if (!selectedModel) {
        throw new Error("No model selected for Knowledge Bloom.");
      }
      return selectedModel;
    });
  }
  /**
   * Handle generation errors
   */
  handleError(error) {
    console.error(`\u274C KnowledgeBloomGenerator: Knowledge Bloom generation error: ${error.message}`, error);
    new import_obsidian.Notice(`Knowledge Bloom generation failed: ${error.message}`);
    throw error;
  }
  /**
   * Format output (not used in this implementation)
   */
  formatOutput(_aiResponse, _originalInput) {
    throw new Error("Method not implemented - using custom generate method");
  }
};

// src/stores/AIStore.ts
var import_obsidian2 = require("obsidian");

// src/stores/StoreUtils.ts
function createEnhancedStore(initialValue) {
  let currentValue = initialValue;
  const subscribers = [];
  return {
    subscribe(run2, invalidate) {
      subscribers.push(run2);
      run2(currentValue);
      return () => {
        const index = subscribers.indexOf(run2);
        if (index > -1) {
          subscribers.splice(index, 1);
        }
      };
    },
    set(value) {
      currentValue = value;
      subscribers.forEach((sub) => sub(currentValue));
    },
    update(updater) {
      this.set(updater(currentValue));
    },
    initialize(initialData) {
      currentValue = __spreadValues(__spreadValues({}, currentValue), initialData);
      this.set(currentValue);
    },
    reset() {
      currentValue = initialValue;
      this.set(currentValue);
    },
    getSnapshot() {
      return currentValue;
    }
  };
}
function createBaseStore(initialValue) {
  const store = writable(initialValue);
  return __spreadProps(__spreadValues({}, store), {
    initialize: () => __async(this, null, function* () {
      return store.set(initialValue);
    }),
    reset: () => __async(this, null, function* () {
      return store.set(initialValue);
    }),
    getSnapshot: () => get_store_value(store)
  });
}
function createPersistedStore(key, initialState2, validator) {
  const loadPersistedData = () => {
    try {
      const stored = localStorage.getItem(key);
      if (!stored)
        return null;
      const parsed = JSON.parse(stored);
      if (validator && !validator(parsed)) {
        console.error("\u{1F987} Invalid persisted state:", parsed);
        return null;
      }
      return parsed;
    } catch (error) {
      console.error("\u{1F987} Error loading persisted state:", error);
      return null;
    }
  };
  const store = createEnhancedStore(
    __spreadValues(__spreadValues({}, initialState2), loadPersistedData() || {})
  );
  store.subscribe((state) => {
    try {
      localStorage.setItem(key, JSON.stringify(state));
    } catch (error) {
      console.error("\u{1F987} Error persisting state:", error);
    }
  });
  return store;
}

// src/types/aiModels.ts
var OpenAIModels = [
  {
    name: "GPT 4o mini",
    apiName: "gpt-4o-mini",
    capabilities: {
      maxTokens: 128e3,
      supportsFunctions: true,
      supportsStreaming: true
    }
  },
  {
    name: "GPT 4o",
    apiName: "gpt-4o",
    capabilities: {
      maxTokens: 128e3,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsVision: true
    }
  },
  {
    name: "GPT o1 Preview",
    apiName: "o1-preview",
    capabilities: {
      maxTokens: 128e3,
      supportsFunctions: true,
      supportsStreaming: true
    }
  },
  {
    name: "GPT o1 Mini",
    apiName: "o1-mini",
    capabilities: {
      maxTokens: 128e3,
      supportsFunctions: true,
      supportsStreaming: true
    }
  }
];
var AnthropicModels = [
  {
    name: "Claude 3 Haiku",
    apiName: "claude-3-haiku-20240307",
    capabilities: {
      maxTokens: 2e5,
      supportsFunctions: true,
      supportsStreaming: true
    }
  },
  {
    name: "Claude 3 Sonnet",
    apiName: "claude-3-sonnet-20240229",
    capabilities: {
      maxTokens: 2e5,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsVision: true
    }
  },
  {
    name: "Claude 3 Opus",
    apiName: "claude-3-opus-20240229",
    capabilities: {
      maxTokens: 2e5,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsVision: true
    }
  },
  {
    name: "Claude 3.5 Sonnet",
    apiName: "claude-3-5-sonnet-20240620",
    capabilities: {
      maxTokens: 2e5,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsVision: true
    }
  }
];
var GoogleModels = [
  {
    name: "Gemini 1.5 Flash",
    apiName: "gemini-1.5-flash",
    capabilities: {
      maxTokens: 32e3,
      supportsStreaming: true
    }
  },
  {
    name: "Gemini 1.5 Flash 8B",
    apiName: "gemini-1.5-flash-8b",
    capabilities: {
      maxTokens: 32e3,
      supportsStreaming: true
    }
  },
  {
    name: "Gemini 1.5 Pro",
    apiName: "gemini-1.5-pro",
    capabilities: {
      maxTokens: 32e3,
      supportsStreaming: true,
      supportsVision: true
    }
  }
];
var GroqModels = [
  {
    name: "Llama 3.1 70B",
    apiName: "llama-3.1-70b-versatile",
    capabilities: {
      maxTokens: 32e3,
      supportsStreaming: true
    }
  },
  {
    name: "Llama 3.1 8B",
    apiName: "llama-3.1-8b-instant",
    capabilities: {
      maxTokens: 32e3,
      supportsStreaming: true
    }
  },
  {
    name: "Llama 3.2 1B (Preview)",
    apiName: "llama-3.2-1b-preview",
    capabilities: {
      maxTokens: 32e3,
      supportsStreaming: true
    }
  },
  {
    name: "Llama 3.2 3B (Preview)",
    apiName: "llama-3.2-3b-preview",
    capabilities: {
      maxTokens: 32e3,
      supportsStreaming: true
    }
  }
];
var OpenRouterModels = [
  {
    name: "Anthropic Claude 3 Opus",
    apiName: "anthropic/claude-3-opus",
    capabilities: {
      maxTokens: 2e5,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsVision: true
    }
  },
  {
    name: "Anthropic Claude 3.5 Sonnet",
    apiName: "anthropic/claude-3.5-sonnet",
    capabilities: {
      maxTokens: 2e5,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsVision: true
    }
  },
  {
    name: "Google Gemini Flash 1.5",
    apiName: "google/gemini-flash-1.5",
    capabilities: {
      maxTokens: 32e3,
      supportsStreaming: true
    }
  },
  {
    name: "Google Gemini Flash 1.5 8B",
    apiName: "google/gemini-flash-1.5-8b",
    capabilities: {
      maxTokens: 32e3,
      supportsStreaming: true
    }
  },
  {
    name: "Google Gemini Pro 1.5",
    apiName: "google/gemini-pro-1.5",
    capabilities: {
      maxTokens: 32e3,
      supportsStreaming: true,
      supportsVision: true
    }
  },
  {
    name: "Mistralai Mistral Large",
    apiName: "mistralai/mistral-large",
    capabilities: {
      maxTokens: 32e3,
      supportsStreaming: true
    }
  },
  {
    name: "Mistralai Mistral Nemo",
    apiName: "mistralai/mistral-nemo",
    capabilities: {
      maxTokens: 32e3,
      supportsStreaming: true
    }
  },
  {
    name: "OpenAI GPT 4o",
    apiName: "openai/gpt-4o",
    capabilities: {
      maxTokens: 128e3,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsVision: true
    }
  },
  {
    name: "OpenAI GPT 4o Mini",
    apiName: "openai/gpt-4o-mini",
    capabilities: {
      maxTokens: 128e3,
      supportsFunctions: true,
      supportsStreaming: true
    }
  },
  {
    name: "OpenAI o1 Mini",
    apiName: "openai/o1-mini",
    capabilities: {
      maxTokens: 128e3,
      supportsFunctions: true,
      supportsStreaming: true
    }
  },
  {
    name: "OpenAI o1 Preview",
    apiName: "openai/o1-preview",
    capabilities: {
      maxTokens: 128e3,
      supportsFunctions: true,
      supportsStreaming: true
    }
  }
];
var LMStudioModels = [
  {
    name: "Custom",
    apiName: "custom",
    capabilities: {
      supportsStreaming: false
    }
  }
];
var AIModelMap = {
  ["openai" /* OpenAI */]: OpenAIModels,
  ["anthropic" /* Anthropic */]: AnthropicModels,
  ["google" /* Google */]: GoogleModels,
  ["groq" /* Groq */]: GroqModels,
  ["openrouter" /* OpenRouter */]: OpenRouterModels,
  ["lmstudio" /* LMStudio */]: LMStudioModels
};
var AIModelUtils = {
  /**
   * Get a model by its API name
   * @param apiName The API name to look up
   * @returns The matching model or undefined
   */
  getModelByApiName(apiName) {
    for (const models of Object.values(AIModelMap)) {
      const model = models.find((m) => m.apiName === apiName);
      if (model)
        return model;
    }
    return void 0;
  },
  /**
   * Get all models for a specific provider
   * @param provider The provider to get models for
   * @returns Array of models for the provider
   */
  getModelsForProvider(provider) {
    return AIModelMap[provider] || [];
  },
  /**
   * Check if a model supports a specific capability
   * @param model The model to check
   * @param capability The capability to check for
   * @returns Whether the model supports the capability
   */
  modelSupportsCapability(model, capability) {
    var _a;
    return !!((_a = model.capabilities) == null ? void 0 : _a[capability]);
  },
  /**
   * Get all models that support a specific capability
   * @param capability The capability to filter by
   * @returns Array of models that support the capability
   */
  getModelsByCapability(capability) {
    const supportedModels = [];
    for (const models of Object.values(AIModelMap)) {
      supportedModels.push(...models.filter((m) => this.modelSupportsCapability(m, capability)));
    }
    return supportedModels;
  },
  /**
   * Get models by provider and capability
   * @param provider The provider to filter by
   * @param capability The capability to filter by
   * @returns Array of matching models
   */
  getModelsByProviderAndCapability(provider, capability) {
    return this.getModelsForProvider(provider).filter((m) => this.modelSupportsCapability(m, capability));
  }
};

// src/stores/AIStore.ts
var createInitialOperationMetrics = () => {
  return Object.values(OperationType).reduce((acc, type) => __spreadProps(__spreadValues({}, acc), {
    [type]: {
      count: 0,
      averageTime: 0,
      errorCount: 0
    }
  }), {});
};
var defaultInitialState = {
  isInitialized: false,
  isConnected: false,
  currentModel: "",
  isProcessing: false,
  provider: "openai" /* OpenAI */,
  availableModels: [],
  performanceMetrics: {
    responseTime: { average: 0, min: Infinity, max: 0, samples: 0 },
    successRate: { total: 0, successful: 0, rate: 0 },
    errorRate: { total: 0, errors: 0, rate: 0 },
    operationMetrics: createInitialOperationMetrics()
  },
  stateHistory: [],
  lastUpdated: Date.now(),
  knowledgeBloom: {
    isGenerating: false,
    selectedModel: "",
    userPrompt: ""
  }
};
function createAIStore(initialState2 = defaultInitialState) {
  const store = createEnhancedStore(initialState2);
  const eventSubscribers = /* @__PURE__ */ new Map();
  function recordTransition(event, update2, metadata) {
    var _a;
    const previousState = get_store_value(store);
    store.update((state) => __spreadValues(__spreadValues({}, state), update2));
    const newState = get_store_value(store);
    const transition = {
      event,
      from: previousState,
      to: newState,
      timestamp: Date.now(),
      metadata
    };
    store.update((state) => __spreadProps(__spreadValues({}, state), {
      stateHistory: [transition, ...state.stateHistory].slice(0, 100)
    }));
    (_a = eventSubscribers.get(event)) == null ? void 0 : _a.forEach((callback) => {
      try {
        callback(transition);
      } catch (error) {
        console.error("Error in state transition subscriber:", error);
        utils.reportError("AI Store event subscriber error", "error", { error });
      }
    });
    return transition;
  }
  return __spreadProps(__spreadValues({}, store), {
    setProvider: (provider) => {
      const models = AIModelUtils.getModelsForProvider(provider);
      if (!models.length) {
        throw new Error(`No models available for provider: ${provider}`);
      }
      recordTransition("providerChanged" /* ProviderChanged */, {
        provider,
        availableModels: models,
        currentModel: models[0].apiName
      });
    },
    updateConnection: (isConnected) => {
      recordTransition("connectionChanged" /* ConnectionChanged */, { isConnected });
    },
    setModel: (model) => {
      const modelInfo = AIModelUtils.getModelByApiName(model);
      if (!modelInfo) {
        throw new Error(`Invalid model: ${model}`);
      }
      recordTransition("modelChanged" /* ModelChanged */, { currentModel: model });
    },
    setInitialized: (isInitialized2) => {
      recordTransition("initializationChanged" /* InitializationChanged */, { isInitialized: isInitialized2 });
    },
    setProcessing: (isProcessing) => {
      recordTransition("processingChanged" /* ProcessingChanged */, { isProcessing });
    },
    setAvailableModels: (models) => {
      recordTransition("modelsUpdated" /* ModelsUpdated */, { availableModels: models });
    },
    setError: (error) => {
      recordTransition("errorOccurred" /* ErrorOccurred */, {
        error: error ? { message: error, timestamp: Date.now() } : void 0
      });
    },
    setLastResponse: (response) => {
      store.update((state) => __spreadProps(__spreadValues({}, state), { lastResponse: response }));
    },
    updateMetrics: (metrics) => {
      store.update((state) => __spreadProps(__spreadValues({}, state), {
        performanceMetrics: __spreadValues(__spreadValues({}, state.performanceMetrics), metrics)
      }));
    },
    updateOperation: (operation) => {
      recordTransition(
        operation ? "operationStarted" /* OperationStarted */ : "operationCompleted" /* OperationCompleted */,
        { currentOperation: operation && "type" in operation ? operation : null }
      );
    },
    reportError: (error, metadata) => {
      recordTransition("errorOccurred" /* ErrorOccurred */, {
        error: {
          message: error.message,
          timestamp: Date.now()
        },
        lastError: {
          message: error.message,
          timestamp: Date.now()
        }
      }, metadata);
      utils.reportError(`AI Error: ${error.message}`, "error", metadata);
      new import_obsidian2.Notice(`AI Error: ${error.message}`);
    },
    subscribeToEvent: (event, callback) => {
      var _a;
      if (!eventSubscribers.has(event)) {
        eventSubscribers.set(event, /* @__PURE__ */ new Set());
      }
      (_a = eventSubscribers.get(event)) == null ? void 0 : _a.add(callback);
      return () => {
        var _a2;
        (_a2 = eventSubscribers.get(event)) == null ? void 0 : _a2.delete(callback);
      };
    },
    getStateHistory: () => get_store_value(store).stateHistory,
    clearHistory: () => {
      store.update((state) => __spreadProps(__spreadValues({}, state), { stateHistory: [] }));
    },
    resetMetrics: () => {
      store.update((state) => __spreadProps(__spreadValues({}, state), {
        performanceMetrics: initialState2.performanceMetrics
      }));
    },
    setKnowledgeBloomGenerating: (isGenerating) => {
      recordTransition(
        isGenerating ? "knowledgeBloomStarted" /* KnowledgeBloomStarted */ : "knowledgeBloomCompleted" /* KnowledgeBloomCompleted */,
        { knowledgeBloom: __spreadProps(__spreadValues({}, get_store_value(store).knowledgeBloom), { isGenerating }) }
      );
    },
    updateKnowledgeBloomSettings: (settings) => {
      store.update((state) => __spreadProps(__spreadValues({}, state), {
        knowledgeBloom: __spreadValues(__spreadValues({}, state.knowledgeBloom), settings)
      }));
    },
    recordKnowledgeBloomGeneration: (noteCount) => {
      store.update((state) => __spreadProps(__spreadValues({}, state), {
        knowledgeBloom: __spreadProps(__spreadValues({}, state.knowledgeBloom), {
          lastGenerated: {
            timestamp: Date.now(),
            noteCount
          }
        })
      }));
    }
  });
}
var aiStore = createAIStore();
var aiStatus = derived(aiStore, ($store) => ({
  isInitialized: $store.isInitialized,
  isConnected: $store.isConnected,
  currentModel: $store.currentModel,
  isProcessing: $store.isProcessing,
  provider: $store.provider,
  availableModels: $store.availableModels,
  hasError: !!$store.error
}));
var knowledgeBloomStatus = derived(aiStore, ($store) => ({
  isGenerating: $store.knowledgeBloom.isGenerating,
  selectedModel: $store.knowledgeBloom.selectedModel,
  userPrompt: $store.knowledgeBloom.userPrompt,
  lastGenerated: $store.knowledgeBloom.lastGenerated
}));

// src/services/ai/GeneratorFactory.ts
var GeneratorType = /* @__PURE__ */ ((GeneratorType2) => {
  GeneratorType2["JsonSchema"] = "jsonSchema";
  GeneratorType2["FrontMatter"] = "frontMatter";
  GeneratorType2["Wikilink"] = "wikilink";
  GeneratorType2["Ontology"] = "ontology";
  GeneratorType2["KnowledgeBloom"] = "knowledgeBloom";
  return GeneratorType2;
})(GeneratorType || {});
var GeneratorFactory = class {
  constructor(app, settingsService, adapterRegistry, wikilinkProcessor) {
    this.app = app;
    this.settingsService = settingsService;
    this.adapterRegistry = adapterRegistry;
    // IService implementation
    this.serviceId = "generator-factory";
    this.serviceName = "Generator Factory Service";
    this.LifecycleState = "uninitialized" /* Uninitialized */;
    this.serviceError = null;
    this.isUnloading = false;
    // Generator factory properties
    this.instances = /* @__PURE__ */ new Map();
    this.states = /* @__PURE__ */ new Map();
    this.lastRun = /* @__PURE__ */ new Map();
    this.wikilinkProcessor = wikilinkProcessor;
    this.initializeStates();
  }
  /**
   * Initialize service and all essential generators
   */
  initialize() {
    return __async(this, null, function* () {
      if (this.isUnloading) {
        throw new ServiceError(this.serviceName, "Cannot initialize while unloading");
      }
      try {
        this.LifecycleState = "initializing" /* Initializing */;
        yield this.initializeEssentialGenerators();
        this.LifecycleState = "ready" /* Ready */;
      } catch (error) {
        this.LifecycleState = "error" /* Error */;
        this.serviceError = ServiceError.from(
          this.serviceName,
          error,
          { context: "Service initialization failed" }
        );
        console.error("GeneratorFactory: Initialization failed:", error);
        throw this.serviceError;
      }
    });
  }
  /**
   * Initialize essential generators needed for basic functionality
   */
  initializeEssentialGenerators() {
    return __async(this, null, function* () {
      try {
        const jsonSchemaGen = this.createJsonSchemaGenerator();
        this.instances.set("jsonSchema" /* JsonSchema */, jsonSchemaGen);
        yield jsonSchemaGen.initialize();
        this.updateState("jsonSchema" /* JsonSchema */, "ready" /* Ready */);
        const frontMatterGen = new FrontMatterGenerator(
          this.adapterRegistry.getCurrentAdapter(),
          this.settingsService,
          jsonSchemaGen
        );
        this.instances.set("frontMatter" /* FrontMatter */, frontMatterGen);
        yield frontMatterGen.initialize();
        this.updateState("frontMatter" /* FrontMatter */, "ready" /* Ready */);
      } catch (error) {
        throw new ServiceError(
          this.serviceName,
          "Failed to initialize essential generators",
          error instanceof Error ? error : void 0
        );
      }
    });
  }
  /**
   * Check if service is ready
   */
  isReady() {
    return this.LifecycleState === "ready" /* Ready */ && !this.isUnloading;
  }
  /**
   * Clean up service resources
   */
  destroy() {
    return __async(this, null, function* () {
      if (this.isUnloading)
        return;
      try {
        this.isUnloading = true;
        this.LifecycleState = "destroying" /* Destroying */;
        yield this.cleanup();
        this.LifecycleState = "destroyed" /* Destroyed */;
      } catch (error) {
        this.LifecycleState = "error" /* Error */;
        this.serviceError = ServiceError.from(
          this.serviceName,
          error,
          { context: "Service destroy failed" }
        );
        throw this.serviceError;
      }
    });
  }
  /**
   * Internal cleanup method
   */
  cleanup() {
    return __async(this, null, function* () {
      yield this.resetAll();
      this.instances.clear();
      this.states.clear();
      this.lastRun.clear();
    });
  }
  /**
   * Initialize generator states
   */
  initializeStates() {
    Object.values(GeneratorType).forEach((type) => {
      this.states.set(type, "not_initialized" /* NotInitialized */);
    });
  }
  getState() {
    return {
      state: this.LifecycleState,
      error: this.serviceError
    };
  }
  /**
   * Get a specific type of generator with proper typing
   */
  getTypedGenerator(type) {
    return __async(this, null, function* () {
      const generator = yield this.getGenerator(type);
      return generator;
    });
  }
  /**
   * Get generator for FrontMatter
   */
  getFrontMatterGenerator() {
    return __async(this, null, function* () {
      return this.getTypedGenerator("frontMatter" /* FrontMatter */);
    });
  }
  /**
   * Get generator for Wikilinks
   */
  getWikilinkGenerator() {
    return __async(this, null, function* () {
      return this.getTypedGenerator("wikilink" /* Wikilink */);
    });
  }
  /**
   * Get a generator by type with lifecycle management
   */
  getGenerator(type) {
    return __async(this, null, function* () {
      if (!this.isReady()) {
        throw new ServiceError(this.serviceName, "Service not ready");
      }
      try {
        this.updateState(type, "creating" /* Creating */);
        let generator = this.instances.get(type);
        if (generator) {
          return generator;
        }
        generator = yield this.createGenerator(type);
        this.instances.set(type, generator);
        this.lastRun.set(type, new Date());
        this.updateState(type, "ready" /* Ready */);
        return generator;
      } catch (error) {
        this.updateState(type, "error" /* Error */, error instanceof Error ? error.message : "Unknown error");
        console.error(`GeneratorFactory: Error creating generator of type ${type}:`, error);
        throw error;
      }
    });
  }
  /**
   * Create a generator of specific type
   */
  createGenerator(type) {
    return __async(this, null, function* () {
      switch (type) {
        case "frontMatter" /* FrontMatter */:
          return this.createFrontMatterGenerator();
        case "wikilink" /* Wikilink */:
          return this.createWikilinkGenerator();
        case "ontology" /* Ontology */:
          return this.createOntologyGenerator();
        case "knowledgeBloom" /* KnowledgeBloom */:
          return this.createKnowledgeBloomGenerator();
        case "jsonSchema" /* JsonSchema */:
          return this.createJsonSchemaGenerator();
        default:
          throw new Error(`Unknown GeneratorType: ${type}`);
      }
    });
  }
  /**
   * Create FrontMatter Generator
   */
  createFrontMatterGenerator() {
    return __async(this, null, function* () {
      const jsonSchemaGen = this.instances.get("jsonSchema" /* JsonSchema */);
      if (!jsonSchemaGen) {
        throw new ServiceError(
          this.serviceName,
          "JsonSchemaGenerator instance not found"
        );
      }
      const frontMatterGen = new FrontMatterGenerator(
        this.adapterRegistry.getCurrentAdapter(),
        this.settingsService,
        jsonSchemaGen
      );
      yield frontMatterGen.initialize();
      return frontMatterGen;
    });
  }
  /**
   * Create Wikilink Generator
   */
  createWikilinkGenerator() {
    return __async(this, null, function* () {
      const wikilinkGen = new WikilinkGenerator(
        this.adapterRegistry.getCurrentAdapter(),
        this.settingsService
      );
      yield wikilinkGen.initialize();
      return wikilinkGen;
    });
  }
  /**
   * Create Ontology Generator
   */
  createOntologyGenerator() {
    return __async(this, null, function* () {
      const ontologyGen = new OntologyGenerator(
        this.adapterRegistry.getCurrentAdapter(),
        this.settingsService
      );
      yield ontologyGen.initialize();
      return ontologyGen;
    });
  }
  /**
   * Create KnowledgeBloom Generator
   */
  createKnowledgeBloomGenerator() {
    return __async(this, null, function* () {
      const frontMatterGen = this.instances.get("frontMatter" /* FrontMatter */);
      if (!frontMatterGen) {
        throw new ServiceError(
          this.serviceName,
          "FrontMatterGenerator instance not found"
        );
      }
      const knowledgeBloomGen = new KnowledgeBloomGenerator(
        this.adapterRegistry.getCurrentAdapter(),
        this.settingsService,
        this.app,
        frontMatterGen,
        this.wikilinkProcessor
      );
      yield knowledgeBloomGen.initialize();
      return knowledgeBloomGen;
    });
  }
  /**
   * Create JsonSchema Generator
   */
  createJsonSchemaGenerator() {
    return new JsonSchemaGenerator(
      this.adapterRegistry.getCurrentAdapter(),
      this.settingsService
    );
  }
  /**
   * Update generator state and notify store
   */
  updateState(type, state, error) {
    if (this.isUnloading)
      return;
    this.states.set(type, state);
    this.updateStore(type, error);
  }
  /**
   * Update AI store with current generator status
   */
  updateStore(updatedType, error) {
    if (this.isUnloading)
      return;
    const generatorStatuses = {};
    Object.values(GeneratorType).forEach((type) => {
      const state = this.states.get(type) || "not_initialized" /* NotInitialized */;
      generatorStatuses[type] = {
        isInitialized: state === "ready" /* Ready */,
        lastRun: this.lastRun.get(type) || null,
        statusMessage: state === "ready" /* Ready */ ? "Ready" : state === "creating" /* Creating */ ? "Creating..." : state === "error" /* Error */ ? error || "Error" : "Not Initialized"
      };
    });
    aiStore.update((state) => __spreadProps(__spreadValues({}, state), {
      generators: generatorStatuses
    }));
  }
  /**
   * Reset a specific generator
   */
  resetGenerator(type) {
    return __async(this, null, function* () {
      if (this.isUnloading)
        return;
      const instance15 = this.instances.get(type);
      if (instance15) {
        if ("reset" in instance15 && typeof instance15.reset === "function") {
          yield instance15.reset();
        }
        this.instances.delete(type);
        this.lastRun.delete(type);
        this.states.set(type, "not_initialized" /* NotInitialized */);
        this.updateStore(type);
      }
    });
  }
  /**
   * Reset all generators
   */
  resetAll() {
    return __async(this, null, function* () {
      if (this.isUnloading)
        return;
      for (const type of this.instances.keys()) {
        yield this.resetGenerator(type);
      }
    });
  }
  /**
   * Get generator state
   */
  getGeneratorState(type) {
    return this.states.get(type) || "not_initialized" /* NotInitialized */;
  }
  /**
   * Check if a specific generator is ready
   */
  isGeneratorReady(type) {
    return this.states.get(type) === "ready" /* Ready */;
  }
  /**
   * Get service state information
   */
  getLifecycleState() {
    return {
      state: this.LifecycleState,
      error: this.serviceError
    };
  }
};

// src/types/store.types.ts
var DEFAULT_PLUGIN_STATE = {
  plugin: null,
  app: null,
  settings: DEFAULT_SETTINGS,
  processing: {
    isProcessing: false,
    currentFile: null,
    queue: [],
    progress: 0,
    state: "idle" /* IDLE */,
    filesQueued: 0,
    filesProcessed: 0,
    filesRemaining: 0,
    errors: [],
    error: null,
    startTime: null,
    estimatedTimeRemaining: null
  },
  ai: {
    isInitialized: false,
    isConnected: false,
    currentModel: "",
    isProcessing: false,
    provider: "openai" /* OpenAI */,
    availableModels: [],
    knowledgeBloom: {
      isGenerating: false,
      selectedModel: "",
      userPrompt: ""
    },
    generators: Object.values(GeneratorType).reduce(
      (acc, type) => __spreadProps(__spreadValues({}, acc), {
        [type]: {
          isInitialized: false,
          lastRun: null,
          statusMessage: "Not Initialized"
        }
      }),
      {}
    ),
    error: void 0,
    lastResponse: void 0,
    lastError: void 0,
    operationMetrics: Object.values(OperationType).reduce(
      (acc, type) => __spreadProps(__spreadValues({}, acc), {
        [type]: {
          totalOperations: 0,
          successfulOperations: 0,
          failedOperations: 0,
          averageDuration: 0,
          lastOperation: void 0
        }
      }),
      {}
    ),
    performanceMetrics: {
      responseTime: {
        average: 0,
        min: Infinity,
        max: 0,
        samples: 0
      },
      successRate: {
        total: 0,
        successful: 0,
        rate: 0
      },
      errorRate: {
        total: 0,
        errors: 0,
        rate: 0
      },
      operationMetrics: Object.values(OperationType).reduce(
        (acc, type) => __spreadProps(__spreadValues({}, acc), {
          [type]: {
            count: 0,
            averageTime: 0,
            errorCount: 0
          }
        }),
        {}
      )
    },
    currentOperation: null,
    queueLength: 0,
    lastOperation: void 0,
    stateHistory: [],
    // Make this mutable
    lastUpdated: Date.now()
    // Add this line
  },
  ui: {
    isInitialized: false,
    error: void 0,
    lastUpdated: Date.now(),
    darkMode: false,
    activeAccordion: null,
    notifications: [],
    lastInteraction: Date.now(),
    modalStack: []
  },
  files: {
    processedFiles: [],
    lastProcessed: void 0,
    stats: {
      totalProcessed: 0,
      successCount: 0,
      errorCount: 0,
      averageProcessingTime: 0
    },
    activeFilters: [],
    sortOrder: "asc",
    searchQuery: ""
  }
};

// src/stores/PluginStore.ts
var _PluginStore = class {
  constructor() {
    this.store = createBaseStore({
      plugin: null,
      app: null,
      settings: DEFAULT_SETTINGS,
      processing: DEFAULT_PLUGIN_STATE.processing,
      ai: DEFAULT_PLUGIN_STATE.ai,
      ui: DEFAULT_PLUGIN_STATE.ui,
      files: DEFAULT_PLUGIN_STATE.files
    });
    this.subscribe = this.store.subscribe;
    this.set = this.store.set;
    this.update = this.store.update;
  }
  static getInstance() {
    if (!_PluginStore.instance) {
      _PluginStore.instance = new _PluginStore();
    }
    return _PluginStore.instance;
  }
  initialize() {
    return __async(this, null, function* () {
      try {
        const coreState = get_store_value(core);
        if (!coreState.initialized) {
          throw new Error("Core store must be initialized first");
        }
        yield this.saveState(this.getSnapshot());
      } catch (error) {
        this.handleError("Failed to initialize Plugin Store", error);
        throw error;
      }
    });
  }
  updateSection(section, update2) {
    try {
      const currentState = this.getSnapshot();
      this.update((state) => {
        const newState = __spreadProps(__spreadValues({}, state), {
          [section]: typeof update2 === "function" ? update2(state[section]) : __spreadValues(__spreadValues({}, state[section]), update2)
        });
        return this.resetVolatileState(newState);
      });
      this.saveState(this.getSnapshot());
    } catch (error) {
      this.handleError(`Failed to update section: ${String(section)}`, error);
    }
  }
  reset() {
    return __async(this, null, function* () {
      this.set(structuredClone(DEFAULT_PLUGIN_STATE));
      yield this.saveState(this.getSnapshot());
    });
  }
  getSnapshot() {
    return get_store_value(this.store);
  }
  saveState(state) {
    return __async(this, null, function* () {
      try {
        const persistedState = this.resetVolatileState(state);
        localStorage.setItem(_PluginStore.STORAGE_KEY, JSON.stringify(persistedState));
      } catch (error) {
        this.handleError("Failed to save state", error);
      }
    });
  }
  resetVolatileState(state) {
    return __spreadProps(__spreadValues(__spreadValues({}, DEFAULT_PLUGIN_STATE), state), {
      processing: __spreadProps(__spreadValues(__spreadValues({}, DEFAULT_PLUGIN_STATE.processing), state.processing), {
        isProcessing: false,
        currentFile: null,
        progress: 0
      }),
      ai: __spreadProps(__spreadValues(__spreadValues({}, DEFAULT_PLUGIN_STATE.ai), state.ai), {
        isProcessing: false,
        currentOperation: null
      }),
      ui: __spreadProps(__spreadValues(__spreadValues({}, DEFAULT_PLUGIN_STATE.ui), state.ui), {
        notifications: []
      }),
      files: __spreadValues(__spreadValues({}, DEFAULT_PLUGIN_STATE.files), state.files)
    });
  }
  handleError(message, error) {
    utils.reportError(message, "error", { error });
  }
  sanitizeState(state) {
    var _a, _b;
    return __spreadProps(__spreadValues({}, state), {
      plugin: state.plugin,
      // Keep the full plugin instance
      app: state.app ? {
        workspace: {
          activeLeaf: (_a = state.app.workspace) == null ? void 0 : _a.activeLeaf,
          config: (_b = state.app.workspace) == null ? void 0 : _b.config
        }
      } : null
    });
  }
};
var PluginStore = _PluginStore;
PluginStore.STORAGE_KEY = "graphweaver-plugin-state";
PluginStore.instance = null;
var pluginStore = PluginStore.getInstance();
var settingsState = derived(
  pluginStore,
  ($store) => $store.settings
);
var processingState = derived(
  pluginStore,
  ($store) => $store.processing
);
var aiState = derived(
  pluginStore,
  ($store) => $store.ai
);
var uiState = derived(
  pluginStore,
  ($store) => $store.ui
);
var filesState = derived(
  pluginStore,
  ($store) => $store.files
);
var pluginStatus = derived(pluginStore, ($store) => {
  const state = $store;
  return {
    isInitialized: state.ai.isInitialized,
    isProcessing: state.processing.isProcessing,
    hasErrors: state.processing.errors.length > 0 || !!state.ai.error,
    activeSection: state.ui.activeAccordion,
    serviceState: pluginStore.getSnapshot()
  };
});

// src/stores/SettingStore.ts
var import_events = require("events");
var _SettingsStoreImpl = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.eventEmitter = new import_events.EventEmitter();
    this.store = createPersistedStore(
      _SettingsStoreImpl.STORAGE_KEY,
      DEFAULT_SETTINGS,
      this.validateSettings
    );
    this.subscribe = this.store.subscribe;
    this.set = this.store.set;
    this.update = this.store.update;
    this.subscribe((settings) => {
      this.emit("settingsChanged", settings);
    });
  }
  static getInstance(plugin) {
    if (!_SettingsStoreImpl.instance) {
      _SettingsStoreImpl.instance = new _SettingsStoreImpl(plugin);
    }
    return _SettingsStoreImpl.instance;
  }
  initialize() {
    return __async(this, null, function* () {
      try {
        const loadedData = yield this.plugin.loadData();
        if (loadedData) {
          this.update((current) => __spreadValues(__spreadValues(__spreadValues({}, DEFAULT_SETTINGS), current), loadedData));
        }
      } catch (error) {
        utils.reportError("Failed to initialize settings", "error", { error });
        this.emit("persistenceError", error instanceof Error ? error : new Error("Unknown error"));
        throw error;
      }
    });
  }
  getSettings() {
    return this.store.getSnapshot();
  }
  getSettingSection(section) {
    return __spreadValues({}, this.getSettings()[section]);
  }
  getNestedSetting(section, key) {
    return this.getSettings()[section][key];
  }
  updateNestedSetting(section, key, value) {
    return __async(this, null, function* () {
      this.update((settings) => __spreadProps(__spreadValues({}, settings), {
        [section]: __spreadProps(__spreadValues({}, settings[section]), {
          [key]: value
        })
      }));
      yield this.save(this.getSettings());
    });
  }
  save(settings) {
    return __async(this, null, function* () {
      try {
        if (!this.validateSettings(settings)) {
          throw new Error("Invalid settings configuration");
        }
        yield this.plugin.saveData(settings);
        this.set(settings);
      } catch (error) {
        this.emit("persistenceError", error instanceof Error ? error : new Error("Save failed"));
        throw error;
      }
    });
  }
  updateSetting(key, value) {
    this.update((settings) => __spreadProps(__spreadValues({}, settings), {
      [key]: value
    }));
    this.emit("settingChanged", key, value);
  }
  validateSettings(settings) {
    var _a;
    const requiredSections = [
      "aiProvider",
      "frontMatter",
      "tags",
      "localLMStudio",
      "advanced",
      "ontology",
      "knowledgeBloom"
    ];
    if (!requiredSections.every((section) => section in settings))
      return false;
    const { aiProvider } = settings;
    if (!(aiProvider == null ? void 0 : aiProvider.selected) || !aiProvider.apiKeys || !aiProvider.selectedModels) {
      return false;
    }
    if ((_a = settings.frontMatter) == null ? void 0 : _a.customProperties) {
      const isValidProps = settings.frontMatter.customProperties.every(
        (prop) => typeof prop.name === "string" && typeof prop.description === "string" && typeof prop.type === "string" && typeof prop.required === "boolean" && (!prop.options || Array.isArray(prop.options)) && typeof prop.multipleValues === "boolean"
      );
      if (!isValidProps)
        return false;
    }
    return true;
  }
  reset() {
    this.set(DEFAULT_SETTINGS);
  }
  getSnapshot() {
    return this.store.getSnapshot();
  }
  destroy() {
    return __async(this, null, function* () {
      this.eventEmitter.removeAllListeners();
    });
  }
  // Event emitter methods
  emit(event, ...args) {
    this.eventEmitter.emit(event, ...args);
  }
  on(event, listener) {
    this.eventEmitter.on(event, listener);
  }
  off(event, listener) {
    this.eventEmitter.off(event, listener);
  }
};
var SettingsStoreImpl = _SettingsStoreImpl;
SettingsStoreImpl.STORAGE_KEY = "graphweaver-settings";
SettingsStoreImpl.instance = null;
var settingsStore;
function initializeSettingsStore(plugin) {
  settingsStore = SettingsStoreImpl.getInstance(plugin);
}

// src/stores/ProcessingStore.ts
var initialState = {
  isProcessing: false,
  currentFile: null,
  queue: [],
  progress: 0,
  state: "idle" /* IDLE */,
  filesQueued: 0,
  filesProcessed: 0,
  filesRemaining: 0,
  errors: [],
  error: null,
  startTime: null,
  estimatedTimeRemaining: null
};
var _ProcessingStore = class {
  constructor() {
    this.serviceId = "processing-store";
    this.serviceName = "Processing Store";
    const store = createPersistedStore(
      _ProcessingStore.STORAGE_KEY,
      structuredClone(initialState)
    );
    this.store = store;
    this.subscribe = store.subscribe;
    this.set = store.set;
    this.update = store.update;
  }
  static getInstance() {
    if (!_ProcessingStore.instance) {
      _ProcessingStore.instance = new _ProcessingStore();
    }
    return _ProcessingStore.instance;
  }
  initialize() {
    return __async(this, null, function* () {
      try {
        const currentState = this.getSnapshot();
        if (!currentState) {
          this.set(structuredClone(initialState));
        }
      } catch (error) {
        this.handleError("Failed to initialize Processing Store", error);
        throw error;
      }
    });
  }
  reset() {
    this.set(structuredClone(initialState));
  }
  getSnapshot() {
    return get_store_value(this.store);
  }
  startProcessing(file) {
    try {
      this.update((state) => __spreadProps(__spreadValues({}, state), {
        isProcessing: true,
        currentFile: file,
        progress: 0,
        state: "running" /* RUNNING */,
        startTime: Date.now(),
        filesQueued: state.queue.length,
        filesRemaining: state.queue.length
      }));
    } catch (error) {
      this.handleError("Failed to start processing", error);
    }
  }
  completeFile(file) {
    try {
      this.update((state) => {
        const filesProcessed = state.filesProcessed + 1;
        const filesRemaining = state.filesQueued - filesProcessed;
        const elapsedTime = Date.now() - (state.startTime || Date.now());
        const averageTimePerFile = elapsedTime / filesProcessed;
        const estimatedTimeRemaining = averageTimePerFile * filesRemaining;
        return __spreadProps(__spreadValues({}, state), {
          isProcessing: filesRemaining > 0,
          currentFile: null,
          progress: filesProcessed / state.filesQueued * 100,
          state: filesRemaining > 0 ? "running" /* RUNNING */ : "idle" /* IDLE */,
          filesProcessed,
          filesRemaining,
          estimatedTimeRemaining
        });
      });
    } catch (error) {
      this.handleError("Failed to complete file processing", error);
    }
  }
  setError(error) {
    try {
      this.update((state) => {
        const newError = error ? {
          filePath: state.currentFile || "unknown",
          error,
          timestamp: Date.now(),
          retryCount: 0
        } : void 0;
        return __spreadProps(__spreadValues({}, state), {
          state: error ? "error" /* ERROR */ : state.state,
          errors: newError ? [...state.errors, newError] : state.errors
        });
      });
    } catch (err) {
      this.handleError("Failed to set error state", err);
    }
  }
  clearError() {
    try {
      this.update((state) => __spreadProps(__spreadValues({}, state), {
        state: state.isProcessing ? "running" /* RUNNING */ : "idle" /* IDLE */,
        errors: []
      }));
    } catch (error) {
      this.handleError("Failed to clear error state", error);
    }
  }
  updateProgress(progress) {
    try {
      this.update((state) => __spreadProps(__spreadValues({}, state), {
        progress: Math.min(Math.max(progress, 0), 100)
      }));
    } catch (error) {
      this.handleError("Failed to update progress", error);
    }
  }
  updateQueue(files) {
    try {
      this.update((state) => __spreadProps(__spreadValues({}, state), {
        queue: files,
        filesQueued: files.length,
        filesRemaining: files.length
      }));
    } catch (error) {
      this.handleError("Failed to update queue", error);
    }
  }
  isReady() {
    const state = this.getSnapshot();
    return state.state !== "error" /* ERROR */;
  }
  destroy() {
    return __async(this, null, function* () {
      this.reset();
    });
  }
  getState() {
    const snapshot = this.getSnapshot();
    return {
      state: snapshot.state === "error" /* ERROR */ ? "error" /* Error */ : "initializing" /* Initializing */,
      error: snapshot.error ? new ServiceError(
        this.serviceId,
        snapshot.error,
        { state: snapshot }
      ) : null
    };
  }
  handleError(message, error) {
    utils.reportError(message, "error", { error });
  }
};
var ProcessingStore = _ProcessingStore;
ProcessingStore.STORAGE_KEY = "graphweaver-processing-state";
ProcessingStore.instance = null;
var processingStore = ProcessingStore.getInstance();
var processingStatus = derived(processingStore, ($store) => ({
  isProcessing: $store.isProcessing,
  currentFile: $store.currentFile,
  progress: $store.progress,
  state: $store.state,
  filesQueued: $store.filesQueued,
  filesProcessed: $store.filesProcessed,
  filesRemaining: $store.filesRemaining,
  hasErrors: $store.errors.length > 0
}));
var processingErrors = derived(
  processingStore,
  ($store) => $store.errors
);
var processingProgress = derived(processingStore, ($store) => ({
  progress: $store.progress,
  estimatedTimeRemaining: $store.estimatedTimeRemaining
}));

// src/stores/UIStore.ts
var INITIAL_STATE = {
  darkMode: false,
  activeAccordion: null,
  notifications: [],
  modalStack: [],
  lastInteraction: Date.now(),
  isInitialized: false,
  lastUpdated: Date.now()
};
var _UIStore = class {
  constructor() {
    this.serviceId = "ui-store";
    this.serviceName = "UI Store";
    this.state = "uninitialized" /* Uninitialized */;
    this.error = null;
    this.modalTransitionTimeout = null;
    this.store = createPersistedStore(
      _UIStore.STORAGE_KEY,
      INITIAL_STATE,
      this.validateState
    );
    this.subscribe = this.store.subscribe;
    this.set = this.store.set;
    this.update = this.store.update;
    this.setupNotificationHandling();
  }
  /**
   * Get singleton instance of UIStore
   */
  static getInstance() {
    if (!_UIStore.instance) {
      _UIStore.instance = new _UIStore();
    }
    return _UIStore.instance;
  }
  /**
   * Initialize the UI store and reset any stale state
   */
  initialize() {
    return __async(this, null, function* () {
      try {
        console.log("\u{1F987} Initializing UI Store");
        this.state = "initializing" /* Initializing */;
        this.update((state) => __spreadProps(__spreadValues({}, state), {
          modalStack: [],
          notifications: [],
          activeAccordion: null,
          isInitialized: true,
          lastUpdated: Date.now()
        }));
        this.state = "ready" /* Ready */;
        console.log("\u{1F987} UI Store initialized");
      } catch (error) {
        this.state = "error" /* Error */;
        this.error = new ServiceError(
          this.serviceName,
          "Failed to initialize UI Store",
          error
        );
        utils.reportError("Failed to initialize UI Store", "error", { error });
        throw this.error;
      }
    });
  }
  // Modal Management
  // ---------------
  /**
   * Push a new modal onto the stack
   */
  pushModal(modalId) {
    console.log("\u{1F987} Pushing modal:", modalId);
    if (this.modalTransitionTimeout) {
      clearTimeout(this.modalTransitionTimeout);
      this.modalTransitionTimeout = null;
    }
    this.update((state) => {
      if (state.modalStack.includes(modalId)) {
        return state;
      }
      return __spreadProps(__spreadValues({}, state), {
        modalStack: [...state.modalStack, modalId],
        lastInteraction: Date.now()
      });
    });
  }
  /**
   * Remove the top modal from the stack
   */
  popModal() {
    console.log("\u{1F987} Popping modal");
    this.modalTransitionTimeout = setTimeout(() => {
      this.update((state) => __spreadProps(__spreadValues({}, state), {
        modalStack: state.modalStack.slice(0, -1),
        lastInteraction: Date.now()
      }));
      this.modalTransitionTimeout = null;
    }, _UIStore.MODAL_TRANSITION_MS);
  }
  /**
   * Clear all modals from the stack
   */
  clearModals() {
    console.log("\u{1F987} Clearing all modals");
    if (this.modalTransitionTimeout) {
      clearTimeout(this.modalTransitionTimeout);
      this.modalTransitionTimeout = null;
    }
    this.update((state) => __spreadProps(__spreadValues({}, state), {
      modalStack: [],
      lastInteraction: Date.now()
    }));
  }
  /**
   * Check if a specific modal is open
   */
  isModalOpen(modalId) {
    return this.getSnapshot().modalStack.includes(modalId);
  }
  /**
   * Get the ID of the currently visible modal
   */
  getTopModal() {
    const { modalStack } = this.getSnapshot();
    return modalStack.length > 0 ? modalStack[modalStack.length - 1] : null;
  }
  // Accordion Management
  // -------------------
  /**
   * Set the currently active accordion section
   */
  setActiveAccordion(accordionId) {
    this.update((state) => __spreadProps(__spreadValues({}, state), {
      activeAccordion: accordionId,
      lastInteraction: Date.now()
    }));
  }
  // Notification Management
  // ----------------------
  /**
   * Add a new notification
   */
  addNotification(notification) {
    this.update((state) => {
      const notifications2 = [...state.notifications];
      if (notifications2.length >= _UIStore.MAX_NOTIFICATIONS) {
        notifications2.shift();
      }
      return __spreadProps(__spreadValues({}, state), {
        notifications: [...notifications2, __spreadProps(__spreadValues({}, notification), {
          timestamp: Date.now()
        })],
        lastInteraction: Date.now()
      });
    });
  }
  /**
   * Remove a notification by ID
   */
  removeNotification(id) {
    this.update((state) => __spreadProps(__spreadValues({}, state), {
      notifications: state.notifications.filter((n) => n.id !== id),
      lastInteraction: Date.now()
    }));
  }
  /**
   * Clear all notifications
   */
  clearNotifications() {
    this.update((state) => __spreadProps(__spreadValues({}, state), {
      notifications: [],
      lastInteraction: Date.now()
    }));
  }
  // Theme Management
  // ---------------
  /**
   * Set dark mode state
   */
  setDarkMode(isDark) {
    this.update((state) => __spreadProps(__spreadValues({}, state), {
      darkMode: isDark,
      lastUpdated: Date.now()
    }));
  }
  // Store Management
  // ---------------
  /**
   * Reset store to initial state
   */
  reset() {
    if (this.modalTransitionTimeout) {
      clearTimeout(this.modalTransitionTimeout);
      this.modalTransitionTimeout = null;
    }
    this.set(INITIAL_STATE);
    try {
      localStorage.removeItem(_UIStore.STORAGE_KEY);
    } catch (error) {
      utils.reportError("Failed to clear UI state", "error", { error });
    }
  }
  /**
   * Get current store state
   */
  getSnapshot() {
    return this.store.getSnapshot();
  }
  // Service Implementation
  // ---------------------
  isReady() {
    return this.state === "ready" /* Ready */;
  }
  destroy() {
    return __async(this, null, function* () {
      this.state = "destroying" /* Destroying */;
      if (this.modalTransitionTimeout) {
        clearTimeout(this.modalTransitionTimeout);
        this.modalTransitionTimeout = null;
      }
      yield this.reset();
      this.state = "destroyed" /* Destroyed */;
    });
  }
  getState() {
    return { state: this.state, error: this.error };
  }
  // Private Methods
  // --------------
  /**
   * Setup auto-dismiss for notifications
   */
  setupNotificationHandling() {
    this.subscribe((state) => {
      state.notifications.forEach((notification) => {
        if (notification.duration !== void 0) {
          setTimeout(() => {
            this.removeNotification(notification.id);
          }, notification.duration || _UIStore.AUTO_DISMISS_DELAY);
        }
      });
    });
  }
  /**
   * Validate store state
   */
  validateState(state) {
    var _a, _b, _c, _d, _e, _f;
    const validation = {
      isValid: false,
      errors: []
    };
    if (!state || typeof state !== "object") {
      (_a = validation.errors) == null ? void 0 : _a.push("State must be an object");
      return false;
    }
    const validState = state;
    if (validState.modalStack !== void 0 && !Array.isArray(validState.modalStack)) {
      (_b = validation.errors) == null ? void 0 : _b.push("modalStack must be an array");
    }
    if (validState.notifications !== void 0 && !Array.isArray(validState.notifications)) {
      (_c = validation.errors) == null ? void 0 : _c.push("notifications must be an array");
    }
    if (validState.darkMode !== void 0 && typeof validState.darkMode !== "boolean") {
      (_d = validation.errors) == null ? void 0 : _d.push("darkMode must be a boolean");
    }
    if (validState.activeAccordion !== void 0 && validState.activeAccordion !== null && typeof validState.activeAccordion !== "string") {
      (_e = validation.errors) == null ? void 0 : _e.push("activeAccordion must be a string or null");
    }
    validation.isValid = ((_f = validation.errors) == null ? void 0 : _f.length) === 0;
    return validation.isValid;
  }
};
var UIStore = _UIStore;
UIStore.STORAGE_KEY = "graphweaver-ui-state";
UIStore.MAX_NOTIFICATIONS = 5;
UIStore.AUTO_DISMISS_DELAY = 5e3;
UIStore.MODAL_TRANSITION_MS = 300;
UIStore.instance = null;
var uiStore = UIStore.getInstance();
var isDarkMode = derived(uiStore, ($store) => $store.darkMode);
var activeModal = derived(
  uiStore,
  ($store) => $store.modalStack[$store.modalStack.length - 1] || null
);
var activeAccordion = derived(uiStore, ($store) => $store.activeAccordion);
var notifications = derived(uiStore, ($store) => $store.notifications);
var hasActiveModal = derived(uiStore, ($store) => $store.modalStack.length > 0);
var hasNotifications = derived(uiStore, ($store) => $store.notifications.length > 0);
var uiStatus = derived(uiStore, ($store) => ({
  isInitialized: $store.isInitialized,
  hasModal: $store.modalStack.length > 0,
  hasNotifications: $store.notifications.length > 0,
  darkMode: $store.darkMode,
  activeAccordion: $store.activeAccordion
}));

// src/registrations/StoreRegistrations.ts
function hasInitialize(store) {
  return typeof (store == null ? void 0 : store.initialize) === "function";
}
function hasIsReady(store) {
  return typeof (store == null ? void 0 : store.isReady) === "function";
}
function checkDependencies(store, dependencies) {
  return dependencies.every((depId) => {
    const depStore = getStore(depId);
    return !hasIsReady(depStore) || depStore.isReady();
  });
}
function getInitData(id, data) {
  var _a;
  if (!data)
    return {};
  if (id === "plugin")
    return {};
  return (_a = data[id]) != null ? _a : {};
}
function initializePluginStore(plugin) {
  return __async(this, null, function* () {
    console.log("\u{1F987} [StoreRegistrations] Initializing plugin store...");
    yield pluginStore.initialize();
    pluginStore.update((state) => __spreadProps(__spreadValues({}, state), { plugin }));
  });
}
function initSettingsStore(plugin, data) {
  return __async(this, null, function* () {
    console.log("\u{1F987} [StoreRegistrations] Initializing settings store...");
    initializeSettingsStore(plugin);
    yield settingsStore.initialize();
    const settingsData = getInitData("settings", data);
    if (Object.keys(settingsData).length > 0) {
      yield settingsStore.save(__spreadValues(__spreadValues({}, settingsStore.getSnapshot()), settingsData));
    }
  });
}
function initializeStore(sequence, data) {
  return __async(this, null, function* () {
    const { store, id, dependencies } = sequence;
    if (!hasInitialize(store)) {
      throw new Error(`Store ${id} missing initialize method`);
    }
    if (!checkDependencies(store, dependencies)) {
      throw new Error(`Dependencies not ready for ${id} store`);
    }
    console.log(`\u{1F987} [StoreRegistrations] Initializing ${id} store...`);
    yield store.initialize(getInitData(id, data));
    console.log(`\u{1F987} [StoreRegistrations] Initialized ${id} store`);
  });
}
function initializeStores(config) {
  return __async(this, null, function* () {
    try {
      console.log("\u{1F987} [StoreRegistrations] Starting store initialization...");
      utils.initialize(config.plugin);
      yield initializePluginStore(config.plugin);
      try {
        yield initSettingsStore(config.plugin, config.data);
      } catch (error) {
        console.error("\u{1F987} [StoreRegistrations] Settings store initialization failed:", error);
        throw new ServiceError(
          "StoreRegistrations",
          "Failed to initialize settings store",
          error instanceof Error ? error : void 0
        );
      }
      const initSequence = [
        { store: aiStore, id: "ai", dependencies: ["settings"] },
        { store: processingStore, id: "processing", dependencies: ["plugin"] },
        { store: uiStore, id: "ui", dependencies: [] }
      ];
      for (const sequence of initSequence) {
        try {
          yield initializeStore(sequence, config.data);
        } catch (error) {
          throw new ServiceError(
            "StoreRegistrations",
            `Failed to initialize ${sequence.id} store`,
            error instanceof Error ? error : void 0
          );
        }
      }
    } catch (error) {
      console.error("\u{1F987} [StoreRegistrations] Store initialization failed:", error);
      throw error instanceof ServiceError ? error : new ServiceError("StoreRegistrations", "Store initialization failed", error);
    }
  });
}
function getStore(id) {
  const stores = {
    plugin: pluginStore,
    settings: settingsStore,
    processing: processingStore,
    ui: uiStore,
    ai: aiStore
  };
  const store = stores[id];
  if (!store) {
    throw new ServiceError("StoreRegistrations", `Unknown store: ${id}`);
  }
  return store;
}

// src/registrations/ServiceRegistrations.ts
var ServiceRegistry = class {
  constructor() {
    this.services = /* @__PURE__ */ new Map();
    this.initializedServices = /* @__PURE__ */ new Set();
    this.isInitialized = false;
  }
  static getInstance() {
    if (!ServiceRegistry.instance) {
      console.log("\u{1F987} [ServiceRegistry] Creating new instance");
      ServiceRegistry.instance = new ServiceRegistry();
    }
    return ServiceRegistry.instance;
  }
  getRegisteredServices() {
    console.log("\u{1F987} [ServiceRegistry] Getting registered services");
    return Array.from(this.services.entries()).map(([id, service]) => ({
      id,
      service: service.instance,
      name: service.instance.serviceName || id,
      initialize: () => service.instance.initialize(),
      destroy: () => service.instance.destroy()
    }));
  }
  hasRegisteredServices() {
    return this.services.size > 0;
  }
  getServiceState(id) {
    const service = this.services.get(id);
    if (!service) {
      return {
        registered: false,
        status: "NOT_REGISTERED" /* NotRegistered */,
        dependencies: []
      };
    }
    return {
      registered: true,
      status: this.initializedServices.has(id) ? "INITIALIZED" /* Initialized */ : "REGISTERED" /* Registered */,
      dependencies: service.dependencies,
      error: service.error
    };
  }
  getInitializationStatus() {
    const failedServices = [];
    const pendingServices = [];
    this.services.forEach((service, id) => {
      if (service.error) {
        failedServices.push({ id, error: service.error });
      } else if (!this.initializedServices.has(id)) {
        pendingServices.push(id);
      }
    });
    return {
      totalServices: this.services.size,
      initializedServices: this.initializedServices.size,
      pendingServices,
      failedServices,
      timestamp: Date.now()
    };
  }
  getService(id) {
    console.log(`\u{1F987} [ServiceRegistry] Getting service: ${id}`);
    if (!this.isInitialized) {
      throw new ServiceError(
        "ServiceRegistry",
        "Registry not initialized. Call initializeRegistry() first.",
        "REGISTRY_NOT_INITIALIZED"
      );
    }
    const service = this.services.get(id);
    if (!service) {
      const available = Array.from(this.services.keys()).join(", ");
      throw new ServiceError(
        "ServiceRegistry",
        `Service ${id} not found. Available: ${available}`,
        "SERVICE_NOT_FOUND"
      );
    }
    return service.instance;
  }
  getDependencies(serviceId) {
    const service = this.services.get(serviceId);
    return service ? service.dependencies : [];
  }
  hasService(serviceId) {
    return this.services.has(serviceId);
  }
  getAllServiceIds() {
    return Array.from(this.services.keys());
  }
  initializeRegistry() {
    return __async(this, null, function* () {
      console.log("\u{1F987} [ServiceRegistry] Initializing registry");
      this.isInitialized = true;
    });
  }
  registerService(_0, _1) {
    return __async(this, arguments, function* (id, instance15, dependencies = []) {
      console.log(`\u{1F987} [ServiceRegistry] Registering service: ${id}`);
      try {
        if (!this.isInitialized) {
          throw new ServiceError(
            "ServiceRegistry",
            "Registry not initialized. Call initializeRegistry() first."
          );
        }
        if (!instance15) {
          throw new ServiceError(
            "ServiceRegistry",
            `Invalid service instance for ${id}`
          );
        }
        if (this.hasCircularDependency(id, dependencies)) {
          throw new ServiceError(
            "ServiceRegistry",
            `Circular dependency detected for service ${id}`
          );
        }
        if (!this.validateServiceInterface(instance15)) {
          throw new ServiceError(
            "ServiceRegistry",
            `Service ${id} missing required interface methods`
          );
        }
        this.services.set(id, {
          instance: instance15,
          dependencies,
          error: void 0
        });
        console.log(`\u{1F987} [ServiceRegistry] Successfully registered service: ${id}`);
      } catch (error) {
        const serviceError = ServiceError.from(
          "ServiceRegistry",
          error,
          { context: `Failed to register service: ${id}` }
        );
        console.error("\u{1F987} [ServiceRegistry] Registration error:", serviceError);
        throw serviceError;
      }
    });
  }
  validateServiceInterface(service) {
    return typeof service.initialize === "function" && typeof service.destroy === "function" && typeof service.serviceName === "string";
  }
  hasCircularDependency(serviceId, dependencies, visited = /* @__PURE__ */ new Set()) {
    if (visited.has(serviceId))
      return true;
    visited.add(serviceId);
    for (const depId of dependencies) {
      const service = this.services.get(depId);
      if (service && this.hasCircularDependency(depId, service.dependencies, visited)) {
        return true;
      }
    }
    visited.delete(serviceId);
    return false;
  }
  initializeAll() {
    return __async(this, null, function* () {
      console.log("\u{1F987} [ServiceRegistry] Initializing all services");
      for (const [id, service] of this.services) {
        if (!this.initializedServices.has(id)) {
          try {
            yield service.instance.initialize();
            this.initializedServices.add(id);
          } catch (error) {
            service.error = error instanceof ServiceError ? error : new ServiceError(`Failed to initialize ${id}`, "INITIALIZATION_FAILED");
            throw service.error;
          }
        }
      }
    });
  }
  destroyAll() {
    return __async(this, null, function* () {
      console.log("\u{1F987} [ServiceRegistry] Destroying all services");
      const services = Array.from(this.services.entries()).reverse();
      for (const [id, service] of services) {
        try {
          yield service.instance.destroy();
          this.initializedServices.delete(id);
        } catch (error) {
          console.error(`\u{1F987} [ServiceRegistry] Error destroying ${id}:`, error);
        }
      }
      this.services.clear();
      this.isInitialized = false;
    });
  }
};

// src/types/events.types.ts
var import_events2 = require("events");
var TypedEventEmitter = class {
  constructor() {
    this.emitter = new import_events2.EventEmitter();
  }
  on(event, listener) {
    this.emitter.on(event, listener);
    return this;
  }
  off(event, listener) {
    this.emitter.off(event, listener);
    return this;
  }
  emit(event, ...args) {
    return this.emitter.emit(event, ...args);
  }
  once(event, listener) {
    this.emitter.once(event, listener);
    return this;
  }
  removeAllListeners(event) {
    if (event) {
      this.emitter.removeAllListeners(event);
    } else {
      this.emitter.removeAllListeners();
    }
    return this;
  }
};

// src/services/SettingsService.ts
var SettingsService = class extends CoreService {
  constructor(plugin) {
    super("settings-service", "Settings Service");
    this.plugin = plugin;
    this.isInitialized = false;
    this.eventEmitter = new TypedEventEmitter();
  }
  /**
   * Initialize settings service
   */
  initializeInternal() {
    return __async(this, null, function* () {
      try {
        if (this.isInitialized) {
          return;
        }
        if (!this.plugin) {
          throw new ServiceError(
            this.serviceName,
            "Plugin instance not provided"
          );
        }
        try {
          initializeSettingsStore(this.plugin);
          yield settingsStore.initialize();
        } catch (error) {
          throw ServiceError.from(
            this.serviceName,
            error,
            { context: "Settings store initialization failed" }
          );
        }
        try {
          settingsStore.subscribe((settings) => {
            this.eventEmitter.emit("settingsChanged", settings);
          });
        } catch (error) {
          throw ServiceError.from(
            this.serviceName,
            error,
            { context: "Failed to subscribe to settings changes" }
          );
        }
        this.isInitialized = true;
        console.log("\u{1F987} [SettingsService] Initialized successfully");
      } catch (error) {
        console.error("\u{1F987} [SettingsService] Initialization failed:", error);
        throw ServiceError.from(
          this.serviceName,
          error,
          { context: "Service initialization failed" }
        );
      }
    });
  }
  /**
   * Clean up service resources
   */
  destroyInternal() {
    return __async(this, null, function* () {
      try {
        yield settingsStore.destroy();
        this.eventEmitter.removeAllListeners();
        this.isInitialized = false;
      } catch (error) {
        console.error("\u{1F987} [SettingsService] Cleanup failed:", error);
      }
    });
  }
  /**
   * Get full settings object
   */
  getSettings() {
    return settingsStore.getSnapshot();
  }
  /**
   * Get specific settings section
   */
  getSettingSection(section) {
    return settingsStore.getSettingSection(section);
  }
  /**
   * Get nested setting value
   */
  getNestedSetting(section, key) {
    return settingsStore.getNestedSetting(section, key);
  }
  /**
   * Update nested setting with proper typing
   */
  updateNestedSetting(section, key, value) {
    return __async(this, null, function* () {
      yield settingsStore.updateNestedSetting(section, key, value);
    });
  }
  /**
   * Update specific Knowledge Bloom settings
   */
  updateKnowledgeBloomSettings(settings) {
    return __async(this, null, function* () {
      const currentSettings = settingsStore.getSnapshot();
      yield settingsStore.save(__spreadProps(__spreadValues({}, currentSettings), {
        knowledgeBloom: __spreadValues(__spreadValues({}, currentSettings.knowledgeBloom), settings)
      }));
    });
  }
  /**
   * Update plugin settings
   */
  updateSettings(settings) {
    return __async(this, null, function* () {
      const currentSettings = settingsStore.getSnapshot();
      yield settingsStore.save(__spreadValues(__spreadValues({}, currentSettings), settings));
    });
  }
  /**
   * Register event listener
   */
  on(event, listener) {
    this.eventEmitter.on(event, listener);
  }
  /**
   * Remove event listener
   */
  off(event, listener) {
    this.eventEmitter.off(event, listener);
  }
};

// src/services/DatabaseService.ts
var _DatabaseService = class extends CoreService {
  constructor(plugin) {
    super("database-service", "Database Service");
    this.plugin = plugin;
    this.MONTH_IN_MS = 30 * 24 * 60 * 60 * 1e3;
    this.config = {
      maxHistoryLength: 100,
      pruneThreshold: 1e3,
      processingCooldown: 5e3
    };
    this.processedFiles = /* @__PURE__ */ new Set();
    this.recentlyProcessed = /* @__PURE__ */ new Map();
    this.processingQueue = /* @__PURE__ */ new Set();
    if (_DatabaseService.instance) {
      return _DatabaseService.instance;
    }
    _DatabaseService.instance = this;
  }
  /**
   * Initialize database service
   */
  initializeInternal() {
    return __async(this, null, function* () {
      try {
        const savedData = yield this.plugin.loadData();
        if (savedData) {
          yield this.loadSavedData(savedData);
        }
        yield this.updateProcessingStore();
      } catch (error) {
        this.handleError("Failed to initialize database", error);
      }
    });
  }
  /**
   * Clean up resources
   */
  destroyInternal() {
    return __async(this, null, function* () {
      this.recentlyProcessed.clear();
      this.processingQueue.clear();
      processingStore.update((state) => __spreadProps(__spreadValues({}, state), {
        databaseReady: false
      }));
    });
  }
  /**
   * Configure service settings
   */
  configure(config) {
    return __async(this, null, function* () {
      this.config = __spreadValues(__spreadValues({}, this.config), config);
    });
  }
  /**
   * Track file processing
   */
  trackFileProcessing(filePath) {
    this.recentlyProcessed.set(filePath, Date.now());
    this.processingQueue.add(filePath);
    processingStore.update((state) => __spreadProps(__spreadValues({}, state), {
      currentFile: filePath
    }));
    setTimeout(() => {
      this.recentlyProcessed.delete(filePath);
      this.processingQueue.delete(filePath);
    }, this.config.processingCooldown);
  }
  /**
   * Check if file needs processing
   */
  needsProcessing(file) {
    if (this.processingQueue.has(file.path)) {
      return false;
    }
    const lastProcessTime = this.recentlyProcessed.get(file.path);
    if (lastProcessTime && Date.now() - lastProcessTime < this.config.processingCooldown) {
      return false;
    }
    return !this.processedFiles.has(file.path);
  }
  /**
   * Mark file as processed
   */
  markFileAsProcessed(file, result) {
    return __async(this, null, function* () {
      this.processedFiles.add(file.path);
      this.trackFileProcessing(file.path);
      yield this.saveData();
    });
  }
  /**
   * Load saved data
   */
  loadSavedData(savedData) {
    return __async(this, null, function* () {
      if (savedData.processedFiles) {
        this.processedFiles = new Set(savedData.processedFiles);
      }
    });
  }
  /**
   * Save current state
   */
  saveData() {
    return __async(this, null, function* () {
      try {
        const data = {
          processedFiles: Array.from(this.processedFiles),
          lastUpdated: Date.now()
        };
        yield this.plugin.saveData(data);
        yield this.updateProcessingStore();
      } catch (error) {
        this.handleError("Failed to save data", error);
      }
    });
  }
  /**
   * Update processing store state
   */
  updateProcessingStore() {
    return __async(this, null, function* () {
      processingStore.update((state) => __spreadProps(__spreadValues({}, state), {
        databaseReady: true,
        totalProcessed: this.processedFiles.size,
        filesProcessing: Array.from(this.processingQueue)
      }));
    });
  }
  /**
   * Get singleton instance
   */
  static getInstance(plugin) {
    if (!_DatabaseService.instance) {
      _DatabaseService.instance = new _DatabaseService(plugin);
    }
    return _DatabaseService.instance;
  }
};
var DatabaseService = _DatabaseService;
DatabaseService.instance = null;

// src/services/file/FileScannerService.ts
var import_events4 = require("events");
var FileScannerService = class extends CoreService {
  constructor(vault, config = {}) {
    super("file-scanner", "File Scanner Service");
    this.vault = vault;
    this.scanTimeout = null;
    this.lastProgressUpdate = 0;
    this.scanErrors = [];
    this.state = "uninitialized" /* Uninitialized */;
    this.config = __spreadValues({
      batchSize: 100,
      progressInterval: 1e3,
      // 1 second
      scanTimeoutMs: 3e4,
      // 30 seconds
      debug: false
    }, config);
    this.eventEmitter = new import_events4.EventEmitter();
  }
  /**
   * Initialize scanner service
   */
  initializeInternal() {
    return __async(this, null, function* () {
      try {
        console.log("\u{1F987} FileScannerService: Starting initialization...");
        this.state = "initializing" /* Initializing */;
        if (!this.vault) {
          throw new Error("Vault is required but not provided");
        }
        yield this.testVaultAccess();
        console.log("\u{1F987} FileScannerService: Initialization complete");
        this.state = "ready" /* Ready */;
      } catch (error) {
        this.state = "error" /* Error */;
        console.error("\u{1F987} FileScannerService initialization failed:", error);
        throw new ServiceError(
          this.serviceName,
          "Failed to initialize file scanner",
          error instanceof Error ? error : void 0
        );
      }
    });
  }
  testVaultAccess() {
    return __async(this, null, function* () {
      try {
        yield this.vault.getMarkdownFiles();
      } catch (error) {
        throw new Error("Failed to access vault");
      }
    });
  }
  /**
   * Clean up resources
   */
  destroyInternal() {
    return __async(this, null, function* () {
      this.eventEmitter.removeAllListeners();
      if (this.scanTimeout) {
        clearTimeout(this.scanTimeout);
        this.scanTimeout = null;
      }
    });
  }
  /**
   * Configure scanner options
   */
  configure(config) {
    return __async(this, null, function* () {
      this.config = __spreadValues(__spreadValues({}, this.config), config);
    });
  }
  /**
   * Get all files missing front matter with progress tracking
   */
  getFilesMissingFrontMatter() {
    return __async(this, null, function* () {
      try {
        const startTime = Date.now();
        const files = this.vault.getMarkdownFiles();
        const filesMissingFM = [];
        this.scanErrors = [];
        this.emit("scanStart", files.length);
        for (let i = 0; i < files.length; i += this.config.batchSize) {
          const batch = files.slice(i, i + this.config.batchSize);
          yield this.processBatch(batch, filesMissingFM, startTime, i, files.length);
        }
        const result = {
          filesMissingFrontMatter: filesMissingFM,
          totalScanned: files.length,
          scanDuration: Date.now() - startTime,
          errors: this.scanErrors
        };
        this.emit("scanComplete", result);
        return result;
      } catch (error) {
        const serviceError = new ServiceError(
          this.serviceName,
          "Failed to scan files",
          error instanceof Error ? error : void 0
        );
        this.emit("scanError", serviceError);
        throw serviceError;
      }
    });
  }
  /**
   * Process a batch of files
   */
  processBatch(batch, filesMissingFM, startTime, processedCount, totalFiles) {
    return __async(this, null, function* () {
      yield Promise.all(
        batch.map((file) => __async(this, null, function* () {
          try {
            if (!(yield this.hasFrontMatter(file))) {
              filesMissingFM.push(file);
            }
          } catch (error) {
            this.scanErrors.push({
              path: file.path,
              error: error instanceof Error ? error.message : "Unknown error"
            });
          }
        }))
      );
      yield this.emitProgress(
        processedCount + batch.length,
        totalFiles,
        batch[batch.length - 1].path,
        filesMissingFM.length,
        startTime
      );
    });
  }
  /**
   * Check if file has front matter
   */
  hasFrontMatter(file) {
    return __async(this, null, function* () {
      try {
        const startTime = Date.now();
        const content = yield this.vault.read(file);
        const timeoutPromise = new Promise((_, reject) => {
          this.scanTimeout = setTimeout(() => {
            reject(new Error(`Timeout reading file ${file.path}`));
          }, this.config.scanTimeoutMs);
        });
        const result = content.startsWith("---\n");
        if (this.scanTimeout) {
          clearTimeout(this.scanTimeout);
          this.scanTimeout = null;
        }
        return result;
      } catch (error) {
        throw new ServiceError(
          this.serviceName,
          `Failed to check front matter for ${file.path}`,
          error instanceof Error ? error : void 0
        );
      }
    });
  }
  /**
   * Emit progress update if interval elapsed
   */
  emitProgress(scannedFiles, totalFiles, currentFile, missingCount, startTime) {
    return __async(this, null, function* () {
      const now2 = Date.now();
      if (now2 - this.lastProgressUpdate >= this.config.progressInterval) {
        this.lastProgressUpdate = now2;
        const progress = {
          scannedFiles,
          totalFiles,
          currentFile,
          missingFrontMatter: missingCount,
          elapsedTime: now2 - startTime
        };
        this.emit("scanProgress", progress);
      }
    });
  }
  /**
   * Subscribe to scanner events
   */
  on(event, callback) {
    this.eventEmitter.on(event, callback);
  }
  /**
   * Remove event subscription
   */
  off(event, callback) {
    this.eventEmitter.off(event, callback);
  }
  /**
   * Emit scanner event
   */
  emit(event, ...args) {
    this.eventEmitter.emit(event, ...args);
  }
};

// src/services/JsonValidationService.ts
var JsonValidationService = class extends CoreService {
  constructor(config = {}) {
    super("json-validation", "JSON Validation Service");
    this.config = __spreadValues({
      notifyOnError: true,
      strictMode: false,
      maxDepth: 100,
      allowComments: false,
      fixMalformed: true,
      debug: false
    }, config);
  }
  /**
   * Initialize validation service
   */
  initializeInternal() {
    return __async(this, null, function* () {
      if (this.config.debug) {
      }
    });
  }
  /**
   * Clean up resources
   */
  destroyInternal() {
    return __async(this, null, function* () {
      if (this.config.debug) {
      }
    });
  }
  /**
   * Configure validation options
   */
  configure(config) {
    return __async(this, null, function* () {
      this.config = __spreadValues(__spreadValues({}, this.config), config);
    });
  }
  /**
   * Validate JSON data with type safety
   */
  validate(data) {
    try {
      if (this.isValidJsonObject(data)) {
        return {
          valid: true,
          value: data
        };
      }
      if (typeof data === "string") {
        const parsed = JSON.parse(data);
        if (this.isValidJsonObject(parsed)) {
          return {
            valid: true,
            value: parsed
          };
        }
      }
      throw new Error("Invalid JSON data type");
    } catch (error) {
      const serviceError = new ServiceError(
        this.serviceName,
        "JSON validation failed",
        error instanceof Error ? error : void 0
      );
      if (this.config.debug) {
        console.error(serviceError.getDetails());
      }
      return {
        valid: false,
        error: serviceError.message
      };
    }
  }
  /**
   * Clean and validate JSON string with enhanced error handling
   */
  validateAndCleanJson(jsonString) {
    try {
      const cleaned = this.cleanJsonString(jsonString);
      const fixes = [];
      try {
        const parsed = JSON.parse(cleaned);
        return {
          valid: true,
          value: parsed,
          fixes: fixes.length > 0 ? fixes : void 0
        };
      } catch (parseError) {
        if (this.config.fixMalformed) {
          const fixResult = this.fixAndParseJson(cleaned);
          if (fixResult.valid) {
            return fixResult;
          }
        }
        throw parseError;
      }
    } catch (error) {
      const serviceError = new ServiceError(
        this.serviceName,
        "JSON validation and cleaning failed",
        error instanceof Error ? error : void 0
      );
      if (this.config.debug) {
        console.error(serviceError.getDetails());
      }
      if (this.config.notifyOnError) {
      }
      return {
        valid: false,
        error: serviceError.message
      };
    }
  }
  /**
   * Fix and parse potentially malformed JSON
   */
  fixAndParseJson(str) {
    const fixes = [];
    try {
      return {
        valid: true,
        value: JSON.parse(str)
      };
    } catch (initialError) {
      if (this.config.debug) {
      }
      try {
        let fixed = str;
        const unquotedKeysFix = fixed.replace(/(\w+)(?=\s*:)/g, '"$1"');
        if (unquotedKeysFix !== fixed) {
          fixes.push("Added quotes to keys");
          fixed = unquotedKeysFix;
        }
        const singleQuotesFix = fixed.replace(/'/g, '"');
        if (singleQuotesFix !== fixed) {
          fixes.push("Converted single quotes to double quotes");
          fixed = singleQuotesFix;
        }
        const trailingCommasFix = fixed.replace(/,\s*([\]}])/g, "$1");
        if (trailingCommasFix !== fixed) {
          fixes.push("Removed trailing commas");
          fixed = trailingCommasFix;
        }
        const fixedJson = JSON.parse(fixed);
        return {
          valid: true,
          value: fixedJson,
          fixes
        };
      } catch (fixError) {
        const serviceError = new ServiceError(
          this.serviceName,
          "Failed to fix malformed JSON",
          {
            originalError: fixError instanceof Error ? fixError : void 0,
            context: { original: str }
          }
        );
        if (this.config.debug) {
          console.error(serviceError.getDetails());
        }
        return {
          valid: false,
          error: serviceError.message,
          fixes
        };
      }
    }
  }
  /**
   * Clean JSON string by removing whitespace and markdown
   */
  cleanJsonString(str) {
    let cleaned = str.trim();
    cleaned = cleaned.replace(/^```json?\s*|\s*```$/g, "");
    if (!this.config.allowComments) {
      cleaned = cleaned.replace(/\/\*[\s\S]*?\*\//g, "").replace(/\/\/.*/g, "");
    }
    return cleaned;
  }
  /**
   * Check if value is a valid JSON object
   */
  isValidJsonObject(value) {
    return typeof value === "object" && value !== null && !Array.isArray(value);
  }
  /**
   * Validate object against max depth constraint
   */
  validateDepth(obj, currentDepth = 0) {
    if (currentDepth > this.config.maxDepth) {
      return false;
    }
    if (typeof obj !== "object" || obj === null) {
      return true;
    }
    for (const value of Object.values(obj)) {
      if (!this.validateDepth(value, currentDepth + 1)) {
        return false;
      }
    }
    return true;
  }
};

// src/registrations/CoreRegistrations.ts
var CORE_SERVICES = [
  {
    id: "settingsService",
    name: "Settings Service",
    factory: (plugin) => new SettingsService(plugin)
  },
  {
    id: "jsonValidationService",
    name: "JSON Validation Service",
    factory: (plugin) => new JsonValidationService()
  },
  {
    id: "databaseService",
    name: "Database Service",
    factory: (plugin) => new DatabaseService(plugin),
    dependencies: ["settingsService"]
  },
  {
    id: "wikilinkProcessor",
    name: "Wikilink Processor",
    factory: (plugin) => new WikilinkTextProcessor()
  },
  {
    id: "fileScanner",
    name: "File Scanner",
    factory: (plugin) => new FileScannerService(plugin.app.vault),
    dependencies: ["settingsService"]
  }
];
function reportError(message, source, error) {
  console.error(`\u{1F987} [CoreRegistrations] ${message}:`, error);
  utils.reportError(
    error ? `${message}: ${error.message}` : message,
    "error",
    { source }
  );
}
function initializeCoreServices(plugin) {
  return __async(this, null, function* () {
    console.log("\u{1F987} [CoreRegistrations] Starting initialization sequence");
    const registry = ServiceRegistry.getInstance();
    yield registry.initializeRegistry();
    const registeredServices = [];
    try {
      console.log("\u{1F987} [CoreRegistrations] Phase 1: Registering services");
      for (const config of CORE_SERVICES) {
        yield registerService(config, plugin, registry, registeredServices);
      }
      console.log("\u{1F987} [CoreRegistrations] Phase 2: Validating dependencies");
      yield validateServiceDependencies(registry);
      console.log("\u{1F987} [CoreRegistrations] Phase 3: Initializing services");
      yield initializeServices(registeredServices);
      console.log("\u{1F987} [CoreRegistrations] All services initialized successfully");
    } catch (error) {
      console.error("\u{1F987} [CoreRegistrations] Initialization failed:", error);
      yield performCleanup(registeredServices);
      throw error instanceof ServiceError ? error : new ServiceError("CoreRegistrations", "Service initialization failed", error);
    }
  });
}
function registerService(config, plugin, registry, registeredServices) {
  return __async(this, null, function* () {
    console.log(`\u{1F987} [CoreRegistrations] Registering ${config.name}`);
    try {
      const service = config.factory(plugin);
      yield registry.registerService(config.id, service, config.dependencies);
      registeredServices.push({
        id: config.id,
        service,
        name: config.name,
        initialize: service.initialize.bind(service),
        destroy: service.destroy.bind(service)
      });
      console.log(`\u{1F987} [CoreRegistrations] Registered ${config.name} successfully`);
    } catch (error) {
      throw new ServiceError(
        "CoreRegistrations",
        `Failed to register ${config.name}`,
        error
      );
    }
  });
}
function validateServiceDependencies(registry) {
  return __async(this, null, function* () {
    console.log("\u{1F987} [CoreRegistrations] Validating service dependencies");
    const serviceIds = registry.getAllServiceIds();
    for (const id of serviceIds) {
      const deps = registry.getDependencies(id);
      const missingDeps = deps.filter((dep) => !registry.hasService(dep));
      if (missingDeps.length > 0) {
        throw new ServiceError(
          "CoreRegistrations",
          `Service ${id} missing dependencies: ${missingDeps.join(", ")}`
        );
      }
    }
  });
}
function initializeServices(services) {
  return __async(this, null, function* () {
    for (const { name, initialize } of services) {
      try {
        console.log(`\u{1F987} [CoreRegistrations] Initializing ${name}`);
        yield initialize();
        console.log(`\u{1F987} [CoreRegistrations] Initialized ${name} successfully`);
      } catch (error) {
        throw new ServiceError(
          "CoreRegistrations",
          `Failed to initialize ${name}`,
          error
        );
      }
    }
  });
}
function performCleanup(services) {
  return __async(this, null, function* () {
    console.log("\u{1F987} [CoreRegistrations] Starting cleanup sequence");
    const reversedServices = [...services].reverse();
    for (const { name, destroy } of reversedServices) {
      try {
        yield destroy();
        console.log(`\u{1F987} [CoreRegistrations] Cleaned up ${name}`);
      } catch (error) {
        reportError(
          `Cleanup failed for ${name}`,
          "ServiceCleanup",
          error
        );
      }
    }
  });
}

// src/adapters/OpenAIAdapter.ts
var import_obsidian3 = require("obsidian");
var OpenAIAdapter = class {
  constructor(settingsService, jsonValidationService) {
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    const aiProviderSettings = this.settingsService.getSettingSection("aiProvider");
    this.apiKey = aiProviderSettings.apiKeys["openai" /* OpenAI */] || "";
    this.models = AIModelMap["openai" /* OpenAI */];
  }
  /**
   * Generate a response using the OpenAI API
   */
  generateResponse(prompt, modelApiName, options) {
    return __async(this, null, function* () {
      try {
        const apiModel = this.getApiModelName(modelApiName);
        if (!apiModel) {
          throw new Error(`No valid model found for ${this.getProviderType()}`);
        }
        if (!this.apiKey) {
          throw new Error("OpenAI API key is not set");
        }
        const settings = this.settingsService.getSettings();
        const temperature = this.getTemperature(settings);
        const maxTokens = (options == null ? void 0 : options.maxTokens) || this.getMaxTokens(settings);
        const response = yield this.makeApiRequest({
          model: apiModel,
          prompt,
          temperature,
          maxTokens,
          rawResponse: options == null ? void 0 : options.rawResponse
        });
        const content = this.extractContentFromResponse(response);
        if (options == null ? void 0 : options.rawResponse) {
          return { success: true, data: content };
        }
        const validatedContent = yield this.jsonValidationService.validateAndCleanJson(content);
        return { success: true, data: validatedContent };
      } catch (error) {
        return this.handleError(error);
      }
    });
  }
  /**
   * Test connection to OpenAI API
   */
  testConnection(prompt, modelApiName) {
    return __async(this, null, function* () {
      try {
        if (!this.apiKey) {
          return false;
        }
        const response = yield this.generateResponse(
          prompt || "Return the word 'OK'.",
          modelApiName,
          { rawResponse: true }
        );
        if (!response.success || typeof response.data !== "string") {
          return false;
        }
        return response.data.toLowerCase().includes("ok");
      } catch (error) {
        console.error("Error in OpenAI test connection:", error);
        return false;
      }
    });
  }
  /**
   * Make a request to the OpenAI API
   */
  makeApiRequest(params) {
    return __async(this, null, function* () {
      var _a;
      const response = yield (0, import_obsidian3.requestUrl)({
        url: "https://api.openai.com/v1/chat/completions",
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.apiKey}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          model: params.model,
          messages: [
            {
              role: "system",
              content: params.rawResponse ? "You are a helpful assistant." : "You are a helpful assistant that responds in JSON format."
            },
            { role: "user", content: params.prompt }
          ],
          temperature: params.temperature,
          max_tokens: params.maxTokens,
          n: 1,
          stream: false,
          response_format: params.rawResponse ? void 0 : { type: "json_object" }
        })
      });
      if (response.status !== 200) {
        const errorBody = response.json;
        throw new Error(
          `API request failed with status ${response.status}: ${((_a = errorBody == null ? void 0 : errorBody.error) == null ? void 0 : _a.message) || "Unknown error"}`
        );
      }
      return response;
    });
  }
  /**
   * Extract content from API response
   */
  extractContentFromResponse(response) {
    var _a, _b, _c, _d;
    if (!((_d = (_c = (_b = (_a = response.json) == null ? void 0 : _a.choices) == null ? void 0 : _b[0]) == null ? void 0 : _c.message) == null ? void 0 : _d.content)) {
      throw new Error("Invalid response format from OpenAI API");
    }
    return response.json.choices[0].message.content;
  }
  /**
   * Get temperature setting
   */
  getTemperature(settings) {
    var _a, _b;
    return ((_a = settings.advanced) == null ? void 0 : _a.temperature) >= 0 && ((_b = settings.advanced) == null ? void 0 : _b.temperature) <= 1 ? settings.advanced.temperature : 0.7;
  }
  /**
   * Get max tokens setting
   */
  getMaxTokens(settings) {
    var _a;
    return ((_a = settings.advanced) == null ? void 0 : _a.maxTokens) > 0 ? settings.advanced.maxTokens : 1e3;
  }
  /**
   * Handle errors in API calls
   */
  handleError(error) {
    console.error("Error in OpenAI API call:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    new import_obsidian3.Notice(`OpenAI API Error: ${errorMessage}`);
    return { success: false, error: errorMessage };
  }
  /**
   * Validate API key
   */
  validateApiKey() {
    return __async(this, null, function* () {
      try {
        if (!this.apiKey) {
          throw new Error("OpenAI API key is not set");
        }
        if (this.models.length === 0) {
          throw new Error("No models available for OpenAI");
        }
        const isValid = yield this.testConnection(
          "Return the word 'OK'.",
          this.models[0].apiName
        );
        if (isValid) {
          new import_obsidian3.Notice("OpenAI API key validated successfully");
          return true;
        } else {
          throw new Error("Failed to validate API key");
        }
      } catch (error) {
        console.error("Error validating OpenAI API key:", error);
        new import_obsidian3.Notice(`Failed to validate OpenAI API key: ${error instanceof Error ? error.message : "Unknown error occurred"}`);
        return false;
      }
    });
  }
  /**
   * Get available models
   */
  getAvailableModels() {
    return this.models.map((model) => model.apiName);
  }
  /**
   * Get provider type
   */
  getProviderType() {
    return "openai" /* OpenAI */;
  }
  /**
   * Set API key
   */
  setApiKey(apiKey) {
    this.apiKey = apiKey;
  }
  /**
   * Get API key
   */
  getApiKey() {
    return this.apiKey;
  }
  /**
   * Configure the adapter
   */
  configure(config) {
    if (config == null ? void 0 : config.apiKey) {
      this.setApiKey(config.apiKey);
    }
  }
  /**
   * Check if adapter is ready
   */
  isReady() {
    return !!this.apiKey && this.models.length > 0;
  }
  /**
   * Get API model name
   */
  getApiModelName(modelApiName) {
    var _a;
    const model = this.models.find((m) => m.apiName === modelApiName);
    if (!model) {
      console.warn(`Model ${modelApiName} not found for ${this.getProviderType()}. Using first available model.`);
      return ((_a = this.models[0]) == null ? void 0 : _a.apiName) || modelApiName;
    }
    return model.apiName;
  }
};

// src/adapters/AnthropicAdapter.ts
var import_obsidian4 = require("obsidian");
var AnthropicAdapter = class {
  constructor(settingsService, jsonValidationService) {
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    const aiProviderSettings = this.settingsService.getSettingSection("aiProvider");
    this.apiKey = aiProviderSettings.apiKeys["anthropic" /* Anthropic */] || "";
    this.models = AIModelMap["anthropic" /* Anthropic */];
  }
  generateResponse(prompt, modelApiName, options) {
    return __async(this, null, function* () {
      try {
        const apiModel = this.getApiModelName(modelApiName);
        if (!apiModel) {
          throw new Error(`Invalid model: ${modelApiName} for ${this.getProviderType()}`);
        }
        if (!this.apiKey) {
          throw new Error("Anthropic API key is not set");
        }
        const settings = this.settingsService.getSettings();
        const temperature = this.getTemperature(settings);
        const maxTokens = (options == null ? void 0 : options.maxTokens) || this.getMaxTokens(settings);
        const response = yield this.makeApiRequest(apiModel, prompt, temperature, maxTokens);
        const content = this.extractContentFromResponse(response);
        if (options == null ? void 0 : options.rawResponse) {
          return { success: true, data: content };
        }
        const validatedContent = yield this.jsonValidationService.validateAndCleanJson(content);
        return { success: true, data: validatedContent };
      } catch (error) {
        return this.handleError(error);
      }
    });
  }
  testConnection(prompt, modelApiName) {
    return __async(this, null, function* () {
      try {
        if (!this.apiKey) {
          throw new Error("Anthropic API key is not set");
        }
        const apiModel = this.getApiModelName(modelApiName);
        const response = yield this.makeApiRequest(apiModel, prompt, 0.7, 50);
        const content = this.extractContentFromResponse(response);
        return content.toLowerCase().includes("ok");
      } catch (error) {
        console.error("Error in Anthropic test connection:", error);
        return false;
      }
    });
  }
  getTemperature(settings) {
    return settings.advanced.temperature >= 0 && settings.advanced.temperature <= 1 ? settings.advanced.temperature : 0.7;
  }
  getMaxTokens(settings) {
    return settings.advanced.maxTokens > 0 ? settings.advanced.maxTokens : 1e3;
  }
  makeApiRequest(apiModel, prompt, temperature, maxTokens) {
    return __async(this, null, function* () {
      const requestBody = {
        model: apiModel,
        messages: [{ role: "user", content: prompt }],
        max_tokens: maxTokens,
        temperature
      };
      const response = yield (0, import_obsidian4.requestUrl)({
        url: "https://api.anthropic.com/v1/messages",
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-api-key": this.apiKey,
          "anthropic-version": "2023-06-01"
        },
        body: JSON.stringify(requestBody)
      });
      if (response.status !== 200) {
        throw new Error(`API request failed with status ${response.status}: ${response.text}`);
      }
      return response;
    });
  }
  extractContentFromResponse(response) {
    return response.json.content[0].text;
  }
  handleError(error) {
    console.error("Error in Anthropic API call:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    new import_obsidian4.Notice(`Anthropic API Error: ${errorMessage}`);
    return { success: false, error: errorMessage };
  }
  validateApiKey() {
    return __async(this, null, function* () {
      try {
        if (!this.apiKey) {
          throw new Error("Anthropic API key is not set");
        }
        const response = yield this.testConnection("Return the word 'OK'.", this.models[0].apiName);
        if (response) {
          new import_obsidian4.Notice("Anthropic API key validated successfully");
          return true;
        } else {
          throw new Error("Failed to validate API key");
        }
      } catch (error) {
        console.error("Error validating Anthropic API key:", error);
        new import_obsidian4.Notice(`Failed to validate Anthropic API key: ${error instanceof Error ? error.message : "Unknown error occurred"}`);
        return false;
      }
    });
  }
  getAvailableModels() {
    return this.models.map((model) => model.apiName);
  }
  getProviderType() {
    return "anthropic" /* Anthropic */;
  }
  setApiKey(apiKey) {
    this.apiKey = apiKey;
  }
  getApiKey() {
    return this.apiKey;
  }
  configure(config) {
  }
  isReady() {
    return !!this.apiKey;
  }
  getApiModelName(modelApiName) {
    const model = this.models.find((m) => m.apiName === modelApiName);
    if (!model) {
      throw new Error(`Model ${modelApiName} not found for ${this.getProviderType()}`);
    }
    return model.apiName;
  }
};

// src/adapters/GeminiAdapter.ts
var import_obsidian5 = require("obsidian");
var GeminiAdapter = class {
  constructor(settingsService, jsonValidationService) {
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    const aiProviderSettings = this.settingsService.getSettingSection("aiProvider");
    this.apiKey = aiProviderSettings.apiKeys["google" /* Google */] || "";
    this.models = AIModelMap["google" /* Google */];
  }
  /**
   * Generate a response using the Gemini API
   */
  generateResponse(prompt, modelApiName, options) {
    return __async(this, null, function* () {
      try {
        const apiModel = this.getApiModelName(modelApiName);
        if (!apiModel) {
          throw new Error(`No valid model found for ${this.getProviderType()}`);
        }
        if (!this.apiKey) {
          throw new Error("Google API key is not set");
        }
        const settings = this.settingsService.getSettings();
        const temperature = this.getTemperature(settings);
        const maxTokens = (options == null ? void 0 : options.maxTokens) || this.getMaxTokens(settings);
        const response = yield this.makeApiRequest({
          model: apiModel,
          prompt,
          temperature,
          maxTokens,
          rawResponse: options == null ? void 0 : options.rawResponse
        });
        const content = this.extractContentFromResponse(response);
        if (options == null ? void 0 : options.rawResponse) {
          return { success: true, data: content };
        }
        try {
          const validatedContent = yield this.jsonValidationService.validateAndCleanJson(content);
          return { success: true, data: validatedContent };
        } catch (jsonError) {
          return {
            success: true,
            data: { response: content }
          };
        }
      } catch (error) {
        return this.handleError(error);
      }
    });
  }
  /**
   * Test connection to Gemini API
   */
  testConnection(prompt, modelApiName) {
    return __async(this, null, function* () {
      try {
        if (!this.apiKey) {
          return false;
        }
        const response = yield this.generateResponse(
          prompt || "Return the word 'OK'.",
          modelApiName,
          { rawResponse: true }
        );
        if (!response.success || typeof response.data !== "string") {
          return false;
        }
        return response.data.toLowerCase().includes("ok");
      } catch (error) {
        console.error("Error in Gemini test connection:", error);
        return false;
      }
    });
  }
  /**
   * Make a request to the Gemini API
   */
  makeApiRequest(params) {
    return __async(this, null, function* () {
      var _a;
      const systemPrompt = params.rawResponse ? "You are a helpful assistant." : "You are a helpful assistant that responds in JSON format. Your response should be valid JSON with a 'response' field containing your answer.";
      const requestBody = {
        contents: [
          {
            parts: [
              { text: systemPrompt },
              { text: params.prompt }
            ]
          }
        ],
        generationConfig: {
          temperature: params.temperature,
          maxOutputTokens: params.maxTokens,
          topK: 40,
          topP: 0.95
        }
      };
      const response = yield (0, import_obsidian5.requestUrl)({
        url: `https://generativelanguage.googleapis.com/v1/models/${params.model}:generateContent`,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-goog-api-key": this.apiKey
        },
        body: JSON.stringify(requestBody)
      });
      if (response.status !== 200) {
        const errorBody = response.json;
        throw new Error(
          `API request failed with status ${response.status}: ${((_a = errorBody == null ? void 0 : errorBody.error) == null ? void 0 : _a.message) || response.text}`
        );
      }
      return response;
    });
  }
  /**
   * Extract content from Gemini API response
   */
  extractContentFromResponse(response) {
    var _a, _b, _c, _d, _e, _f;
    if (!((_f = (_e = (_d = (_c = (_b = (_a = response.json) == null ? void 0 : _a.candidates) == null ? void 0 : _b[0]) == null ? void 0 : _c.content) == null ? void 0 : _d.parts) == null ? void 0 : _e[0]) == null ? void 0 : _f.text)) {
      throw new Error("Invalid response format from Gemini API");
    }
    const content = response.json.candidates[0].content;
    return content.parts[0].text;
  }
  /**
   * Get temperature setting
   */
  getTemperature(settings) {
    var _a, _b;
    return ((_a = settings.advanced) == null ? void 0 : _a.temperature) >= 0 && ((_b = settings.advanced) == null ? void 0 : _b.temperature) <= 1 ? settings.advanced.temperature : 0.7;
  }
  /**
   * Get max tokens setting
   */
  getMaxTokens(settings) {
    var _a;
    return ((_a = settings.advanced) == null ? void 0 : _a.maxTokens) > 0 ? settings.advanced.maxTokens : 1e3;
  }
  /**
   * Handle errors in API calls
   */
  handleError(error) {
    console.error("Error in Gemini API call:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    new import_obsidian5.Notice(`Gemini API Error: ${errorMessage}`);
    return { success: false, error: errorMessage };
  }
  /**
   * Validate API key
   */
  validateApiKey() {
    return __async(this, null, function* () {
      try {
        if (!this.apiKey) {
          throw new Error("Google API key is not set");
        }
        if (this.models.length === 0) {
          throw new Error("No models available for Gemini");
        }
        const isValid = yield this.testConnection(
          "Return the word 'OK'.",
          this.models[0].apiName
        );
        if (isValid) {
          new import_obsidian5.Notice("Gemini API key validated successfully");
          return true;
        } else {
          throw new Error("Failed to validate API key");
        }
      } catch (error) {
        console.error("Error validating Gemini API key:", error);
        new import_obsidian5.Notice(`Failed to validate Gemini API key: ${error instanceof Error ? error.message : "Unknown error occurred"}`);
        return false;
      }
    });
  }
  /**
   * Get available models
   */
  getAvailableModels() {
    return this.models.map((model) => model.apiName);
  }
  /**
   * Get provider type
   */
  getProviderType() {
    return "google" /* Google */;
  }
  /**
   * Set API key
   */
  setApiKey(apiKey) {
    this.apiKey = apiKey;
  }
  /**
   * Get API key
   */
  getApiKey() {
    return this.apiKey;
  }
  /**
   * Configure the adapter
   */
  configure(config) {
    if (config == null ? void 0 : config.apiKey) {
      this.setApiKey(config.apiKey);
    }
  }
  /**
   * Check if adapter is ready
   */
  isReady() {
    return !!this.apiKey && this.models.length > 0;
  }
  /**
   * Get API model name
   */
  getApiModelName(modelApiName) {
    var _a;
    const model = this.models.find((m) => m.apiName === modelApiName);
    if (!model) {
      console.warn(`Model ${modelApiName} not found for ${this.getProviderType()}. Using first available model.`);
      return ((_a = this.models[0]) == null ? void 0 : _a.apiName) || modelApiName;
    }
    return model.apiName;
  }
};

// src/adapters/GroqAdapter.ts
var import_obsidian6 = require("obsidian");
var GroqAdapter = class {
  constructor(settingsService, jsonValidationService) {
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    const aiProviderSettings = this.settingsService.getSettingSection("aiProvider");
    this.apiKey = aiProviderSettings.apiKeys["groq" /* Groq */] || "";
    this.models = AIModelMap["groq" /* Groq */];
  }
  /**
   * Generate a response using the Groq API
   */
  generateResponse(prompt, modelApiName, options) {
    return __async(this, null, function* () {
      try {
        const apiModel = this.getApiModelName(modelApiName);
        if (!apiModel) {
          throw new Error(`No valid model found for ${this.getProviderType()}`);
        }
        if (!this.apiKey) {
          throw new Error("Groq API key is not set");
        }
        const settings = this.settingsService.getSettings();
        const temperature = this.getTemperature(settings);
        const maxTokens = (options == null ? void 0 : options.maxTokens) || this.getMaxTokens(settings);
        const response = yield this.makeApiRequest({
          model: apiModel,
          prompt,
          temperature,
          maxTokens,
          rawResponse: options == null ? void 0 : options.rawResponse
        });
        const content = this.extractContentFromResponse(response);
        if (options == null ? void 0 : options.rawResponse) {
          return { success: true, data: content };
        }
        const validatedContent = yield this.jsonValidationService.validateAndCleanJson(content);
        return { success: true, data: validatedContent };
      } catch (error) {
        return this.handleError(error);
      }
    });
  }
  /**
   * Test connection to Groq API
   */
  testConnection(prompt, modelApiName) {
    return __async(this, null, function* () {
      try {
        if (!this.apiKey) {
          throw new Error("Groq API key is not set");
        }
        const response = yield this.generateResponse(
          prompt || "Return the word 'OK'.",
          modelApiName,
          { rawResponse: true }
        );
        if (!response.success || typeof response.data !== "string") {
          return false;
        }
        return response.data.toLowerCase().includes("ok");
      } catch (error) {
        console.error("Error in Groq test connection:", error);
        return false;
      }
    });
  }
  /**
   * Make a request to the Groq API
   */
  makeApiRequest(params) {
    return __async(this, null, function* () {
      var _a;
      const response = yield (0, import_obsidian6.requestUrl)({
        url: "https://api.groq.com/openai/v1/chat/completions",
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.apiKey}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          model: params.model,
          messages: [
            {
              role: "system",
              content: params.rawResponse ? "You are a helpful assistant." : "You are a helpful assistant that responds in JSON format."
            },
            { role: "user", content: params.prompt }
          ],
          temperature: params.temperature,
          max_tokens: params.maxTokens,
          response_format: params.rawResponse ? void 0 : { type: "json_object" }
        })
      });
      if (response.status !== 200) {
        const errorBody = response.json;
        throw new Error(
          `API request failed with status ${response.status}: ${((_a = errorBody == null ? void 0 : errorBody.error) == null ? void 0 : _a.message) || "Unknown error"}`
        );
      }
      return response;
    });
  }
  /**
   * Extract content from API response
   */
  extractContentFromResponse(response) {
    var _a, _b, _c, _d;
    if (!((_d = (_c = (_b = (_a = response.json) == null ? void 0 : _a.choices) == null ? void 0 : _b[0]) == null ? void 0 : _c.message) == null ? void 0 : _d.content)) {
      throw new Error("Invalid response format from Groq API");
    }
    return response.json.choices[0].message.content;
  }
  /**
   * Get temperature setting
   */
  getTemperature(settings) {
    var _a, _b;
    return ((_a = settings.advanced) == null ? void 0 : _a.temperature) >= 0 && ((_b = settings.advanced) == null ? void 0 : _b.temperature) <= 1 ? settings.advanced.temperature : 0.7;
  }
  /**
   * Get max tokens setting
   */
  getMaxTokens(settings) {
    var _a;
    return ((_a = settings.advanced) == null ? void 0 : _a.maxTokens) > 0 ? settings.advanced.maxTokens : 1e3;
  }
  /**
   * Handle errors in API calls
   */
  handleError(error) {
    console.error("Error in Groq API call:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    new import_obsidian6.Notice(`Groq API Error: ${errorMessage}`);
    return { success: false, error: errorMessage };
  }
  /**
   * Validate API key
   */
  validateApiKey() {
    return __async(this, null, function* () {
      try {
        if (!this.apiKey) {
          throw new Error("Groq API key is not set");
        }
        if (this.models.length === 0) {
          throw new Error("No models available for Groq");
        }
        const isValid = yield this.testConnection(
          "Return the word 'OK'.",
          this.models[0].apiName
        );
        if (isValid) {
          new import_obsidian6.Notice("Groq API key validated successfully");
          return true;
        } else {
          throw new Error("Failed to validate API key");
        }
      } catch (error) {
        console.error("Error validating Groq API key:", error);
        new import_obsidian6.Notice(`Failed to validate Groq API key: ${error instanceof Error ? error.message : "Unknown error occurred"}`);
        return false;
      }
    });
  }
  /**
   * Get available models
   */
  getAvailableModels() {
    return this.models.map((model) => model.apiName);
  }
  /**
   * Get provider type
   */
  getProviderType() {
    return "groq" /* Groq */;
  }
  /**
   * Set API key
   */
  setApiKey(apiKey) {
    this.apiKey = apiKey;
  }
  /**
   * Get API key
   */
  getApiKey() {
    return this.apiKey;
  }
  /**
   * Configure the adapter
   */
  configure(config) {
    if (config == null ? void 0 : config.apiKey) {
      this.setApiKey(config.apiKey);
    }
  }
  /**
   * Check if adapter is ready
   */
  isReady() {
    return !!this.apiKey && this.models.length > 0;
  }
  /**
   * Get API model name
   */
  getApiModelName(modelApiName) {
    var _a;
    const model = this.models.find((m) => m.apiName === modelApiName);
    if (!model) {
      console.warn(`Model ${modelApiName} not found for ${this.getProviderType()}. Using first available model.`);
      return ((_a = this.models[0]) == null ? void 0 : _a.apiName) || modelApiName;
    }
    return model.apiName;
  }
};

// src/adapters/OpenRouterAdapter.ts
var import_obsidian7 = require("obsidian");
var OpenRouterAdapter = class {
  constructor(settingsService, jsonValidationService) {
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    const aiProviderSettings = this.settingsService.getSettingSection("aiProvider");
    this.apiKey = aiProviderSettings.apiKeys["openrouter" /* OpenRouter */] || "";
    this.models = AIModelMap["openrouter" /* OpenRouter */];
  }
  /**
   * Generate a response using the OpenRouter API
   */
  generateResponse(prompt, modelApiName, options) {
    return __async(this, null, function* () {
      try {
        const apiModel = this.getApiModelName(modelApiName);
        if (!apiModel) {
          throw new Error(`No valid model found for ${this.getProviderType()}`);
        }
        if (!this.apiKey) {
          throw new Error("OpenRouter API key is not set");
        }
        const settings = this.settingsService.getSettings();
        const temperature = this.getTemperature(settings);
        const maxTokens = (options == null ? void 0 : options.maxTokens) || this.getMaxTokens(settings);
        console.log(`OpenRouterAdapter: Sending prompt to AI: ${prompt}`);
        const response = yield this.makeApiRequest(
          apiModel,
          prompt,
          temperature,
          maxTokens,
          options == null ? void 0 : options.rawResponse
        );
        const content = this.extractContentFromResponse(response);
        console.log(`OpenRouterAdapter: Received response from AI: ${content}`);
        if (options == null ? void 0 : options.rawResponse) {
          return { success: true, data: content };
        }
        const validatedContent = yield this.jsonValidationService.validateAndCleanJson(content);
        console.log(`OpenRouterAdapter: Validated JSON content:`, validatedContent);
        return { success: true, data: validatedContent };
      } catch (error) {
        return this.handleError(error);
      }
    });
  }
  /**
   * Test connection to OpenRouter API
   */
  testConnection(prompt, modelApiName) {
    return __async(this, null, function* () {
      try {
        if (!this.apiKey) {
          return false;
        }
        const response = yield this.generateResponse(
          prompt || "Return the word 'OK'.",
          modelApiName,
          { rawResponse: true }
        );
        if (!response.success || typeof response.data !== "string") {
          return false;
        }
        return response.data.toLowerCase().includes("ok");
      } catch (error) {
        console.error("Error in OpenRouter test connection:", error);
        return false;
      }
    });
  }
  /**
   * Make a request to the OpenRouter API
   */
  makeApiRequest(apiModel, prompt, temperature, maxTokens, rawResponse) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d;
      const headers = {
        "Authorization": `Bearer ${this.apiKey}`,
        "Content-Type": "application/json",
        "HTTP-Referer": window.location.href,
        // Dynamic referrer
        "X-Title": "Obsidian GraphWeaver Plugin"
      };
      try {
        const response = yield (0, import_obsidian7.requestUrl)({
          url: "https://openrouter.ai/api/v1/chat/completions",
          method: "POST",
          headers,
          body: JSON.stringify({
            model: apiModel,
            messages: [
              {
                role: "system",
                content: rawResponse ? "You are a helpful assistant." : "You are a helpful assistant that responds in JSON format."
              },
              { role: "user", content: prompt }
            ],
            temperature,
            max_tokens: maxTokens,
            response_format: rawResponse ? void 0 : { type: "json_object" }
          })
        });
        if (!((_d = (_c = (_b = (_a = response.json) == null ? void 0 : _a.choices) == null ? void 0 : _b[0]) == null ? void 0 : _c.message) == null ? void 0 : _d.content)) {
          throw new Error("Invalid response format from OpenRouter API");
        }
        return response;
      } catch (error) {
        if (error.status === 401) {
          throw new Error("OpenRouter API authentication failed. Please check your API key.");
        }
        throw error;
      }
    });
  }
  /**
   * Extract content from API response
   */
  extractContentFromResponse(response) {
    var _a, _b, _c, _d;
    if (!((_d = (_c = (_b = (_a = response.json) == null ? void 0 : _a.choices) == null ? void 0 : _b[0]) == null ? void 0 : _c.message) == null ? void 0 : _d.content)) {
      throw new Error("Invalid response format from OpenRouter API");
    }
    return response.json.choices[0].message.content;
  }
  /**
   * Get temperature setting
   */
  getTemperature(settings) {
    var _a, _b;
    return ((_a = settings.advanced) == null ? void 0 : _a.temperature) >= 0 && ((_b = settings.advanced) == null ? void 0 : _b.temperature) <= 1 ? settings.advanced.temperature : 0.7;
  }
  /**
   * Get max tokens setting
   */
  getMaxTokens(settings) {
    var _a;
    return ((_a = settings.advanced) == null ? void 0 : _a.maxTokens) > 0 ? settings.advanced.maxTokens : 1e3;
  }
  /**
   * Handle errors in API calls
   */
  handleError(error) {
    console.error("Error in OpenRouter API call:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    new import_obsidian7.Notice(`OpenRouter API Error: ${errorMessage}`);
    return { success: false, error: errorMessage };
  }
  /**
   * Validate API key
   */
  validateApiKey() {
    return __async(this, null, function* () {
      try {
        if (!this.apiKey) {
          throw new Error("OpenRouter API key is not set");
        }
        if (this.models.length === 0) {
          throw new Error("No models available for OpenRouter");
        }
        const isValid = yield this.testConnection(
          "Return the word 'OK'.",
          this.models[0].apiName
        );
        if (isValid) {
          new import_obsidian7.Notice("OpenRouter API key validated successfully");
          return true;
        } else {
          throw new Error("Failed to validate API key");
        }
      } catch (error) {
        console.error("Error validating OpenRouter API key:", error);
        new import_obsidian7.Notice(`Failed to validate OpenRouter API key: ${error instanceof Error ? error.message : "Unknown error occurred"}`);
        return false;
      }
    });
  }
  /**
   * Get available models
   */
  getAvailableModels() {
    return this.models.map((model) => model.apiName);
  }
  /**
   * Get provider type
   */
  getProviderType() {
    return "openrouter" /* OpenRouter */;
  }
  /**
   * Set API key
   */
  setApiKey(apiKey) {
    this.apiKey = apiKey;
  }
  /**
   * Get API key
   */
  getApiKey() {
    return this.apiKey;
  }
  /**
   * Configure the adapter
   */
  configure(config) {
    if (config == null ? void 0 : config.apiKey) {
      this.setApiKey(config.apiKey);
    }
  }
  /**
   * Check if adapter is ready
   */
  isReady() {
    return !!this.apiKey && this.models.length > 0;
  }
  /**
   * Get API model name
   */
  getApiModelName(modelApiName) {
    var _a;
    const model = this.models.find((m) => m.apiName === modelApiName);
    if (!model) {
      console.warn(`Model ${modelApiName} not found for ${this.getProviderType()}. Using first available model.`);
      return ((_a = this.models[0]) == null ? void 0 : _a.apiName) || modelApiName;
    }
    return model.apiName;
  }
};

// src/adapters/LMStudioAdapter.ts
var import_obsidian8 = require("obsidian");
var LMStudioAdapter = class {
  constructor(settingsService, jsonValidationService) {
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    this.model = "";
    this.port = "";
    this.updateSettings();
  }
  generateResponse(prompt, model = "default", options) {
    return __async(this, null, function* () {
      try {
        if (!this.isReady()) {
          throw new Error("LM Studio settings are not properly configured");
        }
        const response = yield (0, import_obsidian8.requestUrl)({
          url: `http://localhost:${this.port}/v1/chat/completions`,
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            model: this.model,
            messages: [
              {
                role: "system",
                content: (options == null ? void 0 : options.rawResponse) ? "You are a helpful assistant." : "You are a helpful assistant that responds in JSON format."
              },
              {
                role: "user",
                content: prompt
              }
            ],
            response_format: (options == null ? void 0 : options.rawResponse) ? void 0 : {
              type: "json_schema",
              json_schema: this.createJsonSchema()
            },
            temperature: 0.7,
            max_tokens: (options == null ? void 0 : options.maxTokens) || 1e3,
            stream: false
          })
        });
        if (response.status !== 200) {
          throw new Error(`API request failed with status ${response.status}`);
        }
        const content = response.json.choices[0].message.content;
        if (options == null ? void 0 : options.rawResponse) {
          return {
            success: true,
            data: content
          };
        }
        const validatedContent = yield this.jsonValidationService.validateAndCleanJson(content);
        return {
          success: true,
          data: validatedContent
        };
      } catch (error) {
        console.error("Error in LM Studio API call:", error);
        new import_obsidian8.Notice(`LM Studio API Error: ${error instanceof Error ? error.message : "Unknown error occurred"}`);
        return {
          success: false,
          error: error instanceof Error ? error.message : "Unknown error occurred"
        };
      }
    });
  }
  createJsonSchema() {
    return {
      name: "assistant_response",
      strict: "true",
      schema: {
        type: "object",
        properties: {
          response: {
            type: "string"
          }
        },
        required: ["response"]
      }
    };
  }
  testConnection(prompt, model = "default") {
    return __async(this, null, function* () {
      try {
        if (!this.isReady()) {
          return false;
        }
        const response = yield this.generateResponse("Return the word 'OK'.", model);
        if (!response.success || !response.data) {
          return false;
        }
        if (typeof response.data === "object" && response.data !== null && "response" in response.data && typeof response.data.response === "string") {
          return response.data.response.toLowerCase().includes("ok");
        }
        return false;
      } catch (error) {
        console.error("Error in LM Studio test connection:", error);
        return false;
      }
    });
  }
  validateApiKey() {
    return __async(this, null, function* () {
      return this.isReady();
    });
  }
  getAvailableModels() {
    return [this.model];
  }
  getProviderType() {
    return "lmstudio" /* LMStudio */;
  }
  setApiKey(apiKey) {
  }
  getApiKey() {
    return "";
  }
  configure(config) {
    if (config.model) {
      this.model = config.model;
    }
    if (config.port) {
      this.port = config.port.toString();
    }
    this.settingsService.updateNestedSetting("localLMStudio", "modelName", this.model);
    this.settingsService.updateNestedSetting("localLMStudio", "port", parseInt(this.port, 10));
  }
  isReady() {
    return !!this.model && !!this.port;
  }
  getApiModelName(modelName) {
    return modelName;
  }
  updateSettings() {
    const localLMStudioSettings = this.settingsService.getSettingSection("localLMStudio");
    this.model = localLMStudioSettings.modelName;
    this.port = localLMStudioSettings.port.toString();
  }
};

// src/services/ai/AdapterRegistry.ts
var AdapterRegistry = class {
  constructor(settingsService, jsonValidationService) {
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    // IService implementation
    this.serviceId = "adapter-registry";
    this.serviceName = "Adapter Registry";
    this.LifecycleState = "uninitialized" /* Uninitialized */;
    this.serviceError = null;
    this.unsubscribers = [];
    this.isUnloading = false;
    this.adapters = /* @__PURE__ */ new Map();
    this.adapterStatus = /* @__PURE__ */ new Map();
    const settings = get_store_value(settingsStore);
    this.currentProvider = settings.aiProvider.selected;
  }
  /**
   * Get current service state
   */
  getState() {
    return {
      state: this.LifecycleState,
      error: this.serviceError
    };
  }
  /**
   * Initialize the service and adapters
   */
  initialize() {
    return __async(this, null, function* () {
      try {
        this.LifecycleState = "initializing" /* Initializing */;
        yield this.initializeAdapters();
        this.setupSubscriptions();
        this.LifecycleState = "ready" /* Ready */;
      } catch (error) {
        this.LifecycleState = "error" /* Error */;
        this.serviceError = error instanceof ServiceError ? error : new ServiceError(this.serviceName, "Failed to initialize adapters");
        throw this.serviceError;
      }
    });
  }
  /**
   * Check if service is ready
   */
  isReady() {
    return this.LifecycleState === "ready" /* Ready */ && !this.isUnloading;
  }
  /**
   * Clean up resources and destroy adapters
   */
  destroy() {
    return __async(this, null, function* () {
      if (this.isUnloading)
        return;
      try {
        this.isUnloading = true;
        this.LifecycleState = "destroying" /* Destroying */;
        this.unsubscribers.forEach((unsubscribe) => unsubscribe());
        this.unsubscribers = [];
        const cleanupPromises = Array.from(this.adapters.values()).map((adapter) => __async(this, null, function* () {
          if ("destroy" in adapter && adapter.destroy && typeof adapter.destroy === "function") {
            try {
              yield adapter.destroy();
            } catch (error) {
              console.warn(
                `Failed to destroy adapter for ${adapter.getProviderType()}: ${error instanceof Error ? error.message : "Unknown error"}`
              );
            }
          }
        }));
        yield Promise.all(cleanupPromises);
        this.adapters.clear();
        this.adapterStatus.clear();
        this.updateAIStore();
        this.LifecycleState = "destroyed" /* Destroyed */;
      } catch (error) {
        this.LifecycleState = "error" /* Error */;
        this.serviceError = error instanceof ServiceError ? error : new ServiceError(this.serviceName, "Failed to destroy adapters");
        throw this.serviceError;
      }
    });
  }
  /**
   * Set up store subscriptions
   */
  setupSubscriptions() {
    const settingsUnsub = settingsStore.subscribe((settings) => {
      if (!this.isUnloading && settings.aiProvider.selected !== this.currentProvider) {
        void this.handleProviderChange(settings.aiProvider.selected);
      }
    });
    this.unsubscribers.push(settingsUnsub);
  }
  /**
   * Initialize all supported adapters
   */
  initializeAdapters() {
    return __async(this, null, function* () {
      const adapterInitializers = /* @__PURE__ */ new Map([
        ["openai" /* OpenAI */, () => new OpenAIAdapter(this.settingsService, this.jsonValidationService)],
        ["anthropic" /* Anthropic */, () => new AnthropicAdapter(this.settingsService, this.jsonValidationService)],
        ["google" /* Google */, () => new GeminiAdapter(this.settingsService, this.jsonValidationService)],
        ["groq" /* Groq */, () => new GroqAdapter(this.settingsService, this.jsonValidationService)],
        ["openrouter" /* OpenRouter */, () => new OpenRouterAdapter(this.settingsService, this.jsonValidationService)],
        ["lmstudio" /* LMStudio */, () => new LMStudioAdapter(this.settingsService, this.jsonValidationService)]
      ]);
      for (const [provider, initializer] of adapterInitializers) {
        try {
          this.adapters.set(provider, initializer());
          this.adapterStatus.set(provider, {
            isInitialized: true,
            isConnected: false
          });
        } catch (error) {
          console.error(`Failed to initialize adapter for ${provider}:`, error);
          this.updateAdapterStatus(provider, {
            isInitialized: false,
            isConnected: false,
            lastError: error instanceof Error ? error.message : "Unknown error"
          });
        }
      }
      this.updateAIStore();
    });
  }
  /**
   * Handle provider changes
   */
  handleProviderChange(newProvider) {
    return __async(this, null, function* () {
      if (this.isUnloading)
        return;
      try {
        const adapter = this.getAdapter(newProvider);
        if (!adapter) {
          throw new Error(`No adapter available for provider: ${newProvider}`);
        }
        const isValid = yield this.validateAdapter(newProvider);
        if (!isValid) {
          throw new Error(`Failed to validate adapter for provider: ${newProvider}`);
        }
        this.currentProvider = newProvider;
        this.updateAIStore();
      } catch (error) {
        this.handleError(error);
        if (!this.isUnloading) {
          settingsStore.update((settings) => __spreadProps(__spreadValues({}, settings), {
            aiProvider: __spreadProps(__spreadValues({}, settings.aiProvider), {
              selected: this.currentProvider
            })
          }));
        }
      }
    });
  }
  getAdapter(provider) {
    return this.adapters.get(provider);
  }
  getCurrentAdapter() {
    if (this.isUnloading) {
      throw new Error("Service is being unloaded");
    }
    const adapter = this.getAdapter(this.currentProvider);
    if (!adapter) {
      throw new Error(`No adapter available for current provider: ${this.currentProvider}`);
    }
    return adapter;
  }
  validateAdapter(provider) {
    return __async(this, null, function* () {
      if (this.isUnloading)
        return false;
      const adapter = this.getAdapter(provider);
      if (!adapter)
        return false;
      try {
        const isValid = yield adapter.validateApiKey();
        this.updateAdapterStatus(provider, {
          isConnected: isValid,
          lastValidated: Date.now()
        });
        return isValid;
      } catch (error) {
        this.updateAdapterStatus(provider, {
          isConnected: false,
          lastError: error instanceof Error ? error.message : "Unknown error",
          lastValidated: Date.now()
        });
        return false;
      }
    });
  }
  testConnection(provider) {
    return __async(this, null, function* () {
      if (this.isUnloading)
        return false;
      const adapter = this.getAdapter(provider);
      if (!adapter) {
        this.handleError(new Error(`No adapter available for provider: ${provider}`));
        return false;
      }
      try {
        const models = AIModelMap[provider] || [];
        if (models.length === 0) {
          throw new Error(`No models available for provider: ${provider}`);
        }
        const testModel = models[0].apiName;
        const testPrompt = "Return the word 'OK'.";
        const isConnected = yield adapter.testConnection(testPrompt, testModel);
        this.updateAdapterStatus(provider, {
          isConnected,
          lastConnected: isConnected ? Date.now() : void 0,
          lastError: isConnected ? void 0 : "Connection test failed"
        });
        return isConnected;
      } catch (error) {
        this.updateAdapterStatus(provider, {
          isConnected: false,
          lastError: error instanceof Error ? error.message : "Unknown error during connection test"
        });
        this.handleError(error instanceof Error ? error : new Error("Connection test failed"));
        return false;
      }
    });
  }
  updateAdapterStatus(provider, status) {
    if (this.isUnloading)
      return;
    const currentStatus = this.adapterStatus.get(provider) || {
      isInitialized: false,
      isConnected: false
    };
    this.adapterStatus.set(provider, __spreadValues(__spreadValues({}, currentStatus), status));
    this.updateAIStore();
  }
  updateAIStore() {
    if (this.isUnloading)
      return;
    const currentAdapter = this.adapters.get(this.currentProvider);
    const currentStatus = this.adapterStatus.get(this.currentProvider);
    if (currentAdapter && currentStatus) {
      aiStore.update((state) => __spreadProps(__spreadValues({}, state), {
        isConnected: currentStatus.isConnected,
        currentModel: currentAdapter.getApiKey() ? AIModelMap[this.currentProvider][0].apiName : "",
        isProcessing: false,
        provider: this.currentProvider,
        availableModels: AIModelMap[this.currentProvider] || [],
        error: currentStatus.lastError ? {
          message: currentStatus.lastError,
          timestamp: Date.now()
        } : void 0
      }));
    }
  }
  handleError(error) {
    if (this.isUnloading)
      return;
    console.error("AdapterRegistry error:", error);
    this.serviceError = new ServiceError(this.serviceName, error.message);
    aiStore.update((state) => __spreadProps(__spreadValues({}, state), {
      error: {
        message: error.message,
        timestamp: Date.now()
      },
      lastError: {
        message: error.message,
        timestamp: Date.now()
      },
      isConnected: false,
      isProcessing: false
    }));
  }
  // Utility methods
  getAdapterStatus(provider) {
    return this.adapterStatus.get(provider);
  }
  getAllAdapterStatus() {
    return new Map(this.adapterStatus);
  }
  isAdapterHealthy(provider) {
    const status = this.adapterStatus.get(provider);
    return !!((status == null ? void 0 : status.isInitialized) && (status == null ? void 0 : status.isConnected));
  }
  getHealthyAdapters() {
    return Array.from(this.adapterStatus.entries()).filter(([_, status]) => status.isInitialized && status.isConnected).map(([provider]) => provider);
  }
  getAllAvailableModels() {
    const allModels = [];
    for (const provider of this.adapters.keys()) {
      allModels.push(...AIModelMap[provider] || []);
    }
    return allModels;
  }
};

// src/stores/MetricsStore.ts
function createInitialMetrics() {
  return Object.values(OperationType).reduce((acc, type) => __spreadProps(__spreadValues({}, acc), {
    [type]: {
      totalOperations: 0,
      successfulOperations: 0,
      failedOperations: 0,
      averageDuration: 0
    }
  }), {});
}
function updateMetrics(typeMetrics, operation) {
  const newTotal = typeMetrics.totalOperations + 1;
  const newSuccesses = typeMetrics.successfulOperations + (operation.success ? 1 : 0);
  const newFailures = typeMetrics.failedOperations + (!operation.success ? 1 : 0);
  const newAverageDuration = (typeMetrics.averageDuration * typeMetrics.totalOperations + (operation.duration || 0)) / newTotal;
  return {
    totalOperations: newTotal,
    successfulOperations: newSuccesses,
    failedOperations: newFailures,
    averageDuration: newAverageDuration
  };
}
function createMetricsStore() {
  const { subscribe: subscribe2, set, update: update2 } = writable(createInitialMetrics());
  return {
    subscribe: subscribe2,
    trackOperation: (operation) => update2((metrics) => {
      const typeMetrics = metrics[operation.type];
      const updatedMetrics = updateMetrics(typeMetrics, operation);
      return __spreadProps(__spreadValues({}, metrics), {
        [operation.type]: updatedMetrics
      });
    }),
    resetMetrics: () => set(createInitialMetrics())
  };
}
var metricsStore = createMetricsStore();

// src/stores/OperationStore.ts
function createOperationStore() {
  const eventEmitter = new TypedEventEmitter();
  const store = writable({
    currentOperation: null,
    operations: [],
    progress: 0,
    queueLength: 0,
    metrics: createInitialMetrics()
  });
  return {
    subscribe: store.subscribe,
    eventEmitter,
    startOperation: (operation) => store.update((state) => __spreadProps(__spreadValues({}, state), {
      currentOperation: operation,
      operations: [operation, ...state.operations]
    })),
    completeOperation: (operation) => store.update((state) => __spreadProps(__spreadValues({}, state), {
      currentOperation: null,
      operations: state.operations.map(
        (op) => op.id === operation.id ? operation : op
      )
    })),
    updateProgress: (progress) => store.update((state) => __spreadProps(__spreadValues({}, state), {
      progress
    })),
    updateQueue: (length) => store.update((state) => __spreadProps(__spreadValues({}, state), {
      queueLength: length
    })),
    trackMetrics: (operation) => store.update((state) => __spreadProps(__spreadValues({}, state), {
      metrics: __spreadProps(__spreadValues({}, state.metrics), {
        [operation.type]: updateMetrics(state.metrics[operation.type], operation)
      })
    })),
    errorOperation: (status) => {
      eventEmitter.emit("operationError", status);
    },
    getCurrentOperation: () => {
      return get_store_value(store).currentOperation;
    }
  };
}
var operationStore = createOperationStore();
var currentOperation = derived(
  operationStore,
  ($store) => $store.currentOperation
);
var operationProgress = derived(
  operationStore,
  ($store) => $store.progress
);

// src/services/ai/QueueManagerService.ts
var QueueManagerService = class extends CoreService {
  constructor(processOperation) {
    super("queue-manager", "Queue Manager Service");
    this.processOperation = processOperation;
    this.operationQueue = [];
    this.isProcessing = false;
    this.MAX_QUEUE_SIZE = 100;
    this.QUEUE_PROCESS_INTERVAL = 100;
  }
  initializeInternal() {
    return __async(this, null, function* () {
      this.startQueueProcessor();
    });
  }
  destroyInternal() {
    return __async(this, null, function* () {
      if (this.queueProcessorInterval) {
        clearInterval(this.queueProcessorInterval);
        this.queueProcessorInterval = void 0;
      }
    });
  }
  /**
   * Add operation to queue
   */
  enqueueOperation(operation) {
    if (this.operationQueue.length >= this.MAX_QUEUE_SIZE) {
      throw new Error("Operation queue is full");
    }
    this.operationQueue.push(operation);
    this.sortQueue();
    operationStore.updateQueue(this.operationQueue.length);
  }
  /**
   * Sort queue by priority
   */
  sortQueue() {
    this.operationQueue.sort((a, b) => b.priority - a.priority);
  }
  /**
   * Get priority for operation type
   */
  getOperationPriority(type) {
    const priorities = {
      ["generation" /* Generation */]: 1,
      ["frontMatter" /* FrontMatter */]: 2,
      ["wikilink" /* Wikilink */]: 2,
      ["ontology" /* Ontology */]: 3,
      ["knowledgeBloom" /* KnowledgeBloom */]: 4
    };
    return priorities[type] || 1;
  }
  /**
   * Start queue processor
   */
  startQueueProcessor() {
    if (this.queueProcessorInterval) {
      clearInterval(this.queueProcessorInterval);
    }
    this.queueProcessorInterval = setInterval(
      () => this.processQueue(),
      this.QUEUE_PROCESS_INTERVAL
    );
  }
  /**
   * Process queued operations
   */
  processQueue() {
    return __async(this, null, function* () {
      if (this.isProcessing || this.operationQueue.length === 0) {
        return;
      }
      this.isProcessing = true;
      operationStore.updateProgress(0);
      try {
        const operation = this.operationQueue[0];
        yield this.processOperation(operation);
        this.operationQueue = this.operationQueue.filter((op) => op.id !== operation.id);
        operationStore.updateQueue(this.operationQueue.length);
      } finally {
        this.isProcessing = false;
      }
    });
  }
  /**
   * Get operation by ID
   */
  getOperation(operationId) {
    return this.operationQueue.find((op) => op.id === operationId);
  }
  /**
   * Get queue length
   */
  getQueueLength() {
    return this.operationQueue.length;
  }
  /**
   * Check if queue is processing
   */
  isQueueProcessing() {
    return this.isProcessing;
  }
  /**
   * Clear the queue
   */
  clearQueue() {
    this.operationQueue = [];
  }
};

// src/services/ai/OperationExecutor.ts
var OperationExecutor = class {
  constructor(store) {
    this.store = store;
  }
  /**
   * Execute operation with tracking
   */
  execute(type, operation, metadata, config) {
    return __async(this, null, function* () {
      const operationId = this.generateOperationId();
      const status = {
        id: operationId,
        type,
        startTime: Date.now(),
        metadata
      };
      try {
        this.store.startOperation(status);
        const result = yield operation();
        this.store.completeOperation(__spreadProps(__spreadValues({}, status), {
          endTime: Date.now(),
          success: true
        }));
        return result;
      } catch (error) {
        const endTime = Date.now();
        status.endTime = endTime;
        status.duration = endTime - status.startTime;
        status.success = false;
        status.error = error instanceof Error ? error.message : "Unknown error";
        this.store.errorOperation(status);
        throw error;
      }
    });
  }
  /**
   * Generate unique operation ID
   */
  generateOperationId() {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  /**
   * Get current operation
   */
  getCurrentOperation() {
    return this.store.getCurrentOperation();
  }
};

// src/services/ai/AIOperationManager.ts
var AIOperationManager = class {
  constructor(adapterRegistry, generatorFactory) {
    this.adapterRegistry = adapterRegistry;
    this.generatorFactory = generatorFactory;
    // IService implementation
    this.serviceId = "ai-operation-manager";
    this.serviceName = "AI Operation Manager";
    this.LifecycleState = "uninitialized" /* Uninitialized */;
    this.serviceError = null;
    this.unsubscribers = [];
    this.eventEmitter = operationStore.eventEmitter;
    this.queueManager = new QueueManagerService(this.processOperation.bind(this));
    this.operationExecutor = new OperationExecutor(operationStore);
  }
  /**
   * Initialize service and components
   */
  initialize() {
    return __async(this, null, function* () {
      try {
        this.LifecycleState = "initializing" /* Initializing */;
        this.setupEventListeners();
        this.LifecycleState = "ready" /* Ready */;
      } catch (error) {
        this.LifecycleState = "error" /* Error */;
        this.serviceError = ServiceError.from(this.serviceName, error);
        throw this.serviceError;
      }
    });
  }
  /**
   * Process a single operation
   */
  processOperation(operation) {
    return __async(this, null, function* () {
      yield operation.execute();
    });
  }
  /**
   * Set up event listeners
   */
  setupEventListeners() {
    this.eventEmitter.on("operationComplete", (status) => {
      metricsStore.trackOperation(status);
      this.updateAIStore();
    });
    this.eventEmitter.on("operationError", (status) => {
      console.error(`Operation error (${status.type}):`, status.error);
      this.updateAIStore();
    });
    const aiStoreUnsub = aiStore.subscribe(() => {
    });
    this.unsubscribers.push(aiStoreUnsub);
  }
  /**
   * Check if service is ready
   */
  isReady() {
    return this.LifecycleState === "ready" /* Ready */;
  }
  /**
   * Get service state
   */
  getState() {
    return {
      state: this.LifecycleState,
      error: this.serviceError
    };
  }
  /**
   * Get the OperationExecutor instance
   */
  getOperationExecutor() {
    return this.operationExecutor;
  }
  /**
   * Clean up resources
   */
  destroy() {
    return __async(this, null, function* () {
      try {
        this.LifecycleState = "destroying" /* Destroying */;
        this.unsubscribers.forEach((unsub) => unsub());
        this.unsubscribers = [];
        yield this.queueManager.destroy();
        this.eventEmitter.removeAllListeners();
        this.LifecycleState = "destroyed" /* Destroyed */;
      } catch (error) {
        this.serviceError = ServiceError.from(this.serviceName, error);
        throw this.serviceError;
      }
    });
  }
  /**
   * Generate AI response
   */
  generateResponse(prompt, config) {
    return __async(this, null, function* () {
      if (!this.isReady()) {
        throw new Error("AIOperationManager not ready");
      }
      return this.operationExecutor.execute(
        "generation" /* Generation */,
        () => __async(this, null, function* () {
          const adapter = this.adapterRegistry.getCurrentAdapter();
          const aiState2 = get_store_value(aiStore);
          return adapter.generateResponse(prompt, aiState2.currentModel);
        }),
        { prompt },
        config
      );
    });
  }
  /**
   * Generate front matter
   */
  generateFrontMatter(content, config) {
    return __async(this, null, function* () {
      if (!this.isReady()) {
        throw new Error("AIOperationManager not ready");
      }
      return this.operationExecutor.execute(
        "frontMatter" /* FrontMatter */,
        () => __async(this, null, function* () {
          const generator = yield this.generatorFactory.getGenerator("frontMatter" /* FrontMatter */);
          const result = yield generator.generate({ content });
          return result.content;
        }),
        { contentLength: content.length },
        config
      );
    });
  }
  /**
   * Update AI store state
   */
  updateAIStore() {
    aiStore.update((state) => __spreadProps(__spreadValues({}, state), {
      currentOperation: this.operationExecutor.getCurrentOperation(),
      queueLength: this.queueManager.getQueueLength(),
      operationMetrics: get_store_value(metricsStore),
      error: this.serviceError ? { message: this.serviceError.message, timestamp: Date.now() } : state.error
    }));
  }
  // Public access methods for metrics and history
  // Removed metricsTracker method calls
};

// src/services/ai/AIService.ts
var import_obsidian9 = require("obsidian");

// src/services/ai/AIGenerationService.ts
var AIGenerationService = class {
  constructor(generatorFactory) {
    this.generatorFactory = generatorFactory;
  }
  /**
   * Generate front matter content
   */
  generateFrontMatter(content) {
    return __async(this, null, function* () {
      try {
        const generator = yield this.generatorFactory.getGenerator("frontMatter" /* FrontMatter */);
        const result = yield generator.generate({ content });
        return result.content;
      } catch (error) {
        throw new ServiceError("Failed to generate front matter", error.message);
      }
    });
  }
  /**
   * Generate wikilinks for content
   */
  generateWikilinks(content, existingPages) {
    return __async(this, null, function* () {
      try {
        const generator = yield this.generatorFactory.getGenerator("wikilink" /* Wikilink */);
        const result = yield generator.generate({ content, existingPages });
        return result.content;
      } catch (error) {
        throw new ServiceError("Failed to generate wikilinks", error.message);
      }
    });
  }
  /**
   * Generate Knowledge Bloom content
   */
  generateKnowledgeBloom(sourceFile, userPrompt) {
    return __async(this, null, function* () {
      try {
        const generator = yield this.generatorFactory.getGenerator("knowledgeBloom" /* KnowledgeBloom */);
        return yield generator.generate({ sourceFile, userPrompt });
      } catch (error) {
        throw new ServiceError("Failed to generate Knowledge Bloom", error.message);
      }
    });
  }
  /**
   * Generate ontology
   */
  generateOntology(input) {
    return __async(this, null, function* () {
      try {
        const generator = yield this.generatorFactory.getGenerator("ontology" /* Ontology */);
        return yield generator.generate(input);
      } catch (error) {
        throw new ServiceError("Failed to generate ontology", error.message);
      }
    });
  }
};

// src/services/ai/AIService.ts
var AIService = class extends CoreService {
  constructor(app, operationManager, settingsService, jsonValidationService, databaseService, wikilinkProcessor, config = {}) {
    super("ai-service", "AI Service");
    this.app = app;
    this.operationManager = operationManager;
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    this.databaseService = databaseService;
    this.wikilinkProcessor = wikilinkProcessor;
    this.unsubscribers = [];
    this.isInitializing = false;
    this.config = __spreadValues({
      defaultProvider: "openai" /* OpenAI */,
      enableNotifications: true,
      debug: false
    }, config);
    this.adapterRegistry = new AdapterRegistry(
      settingsService,
      jsonValidationService
    );
    this.generatorFactory = new GeneratorFactory(
      app,
      settingsService,
      this.adapterRegistry,
      wikilinkProcessor
    );
  }
  /**
   * Initialize core components and services
   */
  initializeInternal() {
    return __async(this, null, function* () {
      try {
        yield this.adapterRegistry.initialize();
        yield this.generatorFactory.initialize();
        const provider = this.getProviderFromStore();
        const models = AIModelUtils.getModelsForProvider(provider);
        if (!models.length) {
          throw new Error(`No models available for provider: ${provider}`);
        }
        aiStore.update((state) => __spreadProps(__spreadValues({}, state), {
          availableModels: models,
          currentModel: models[0].apiName,
          isInitialized: true
        }));
        this.generationService = new AIGenerationService(this.generatorFactory);
        this.setupSubscriptions();
      } catch (error) {
        throw new ServiceError(
          this.serviceName,
          "Failed to initialize AI service",
          error instanceof Error ? error : void 0
        );
      }
    });
  }
  /**
   * Initialize core components
   */
  initializeComponents() {
    this.adapterRegistry = new AdapterRegistry(
      this.settingsService,
      this.jsonValidationService
    );
    this.generatorFactory = new GeneratorFactory(
      this.app,
      // App
      this.settingsService,
      // SettingsService
      this.adapterRegistry,
      // AdapterRegistry
      this.wikilinkProcessor
      // WikilinkTextProcessor
    );
  }
  /**
   * Set up store subscriptions
   */
  setupSubscriptions() {
    const settingsUnsub = settingsStore.subscribe((settings) => {
      if (this.config.debug) {
        console.log("\u{1F987} AI Service settings update:", settings);
      }
    });
    const aiStoreUnsub = aiStore.subscribe((state) => {
      if (this.config.debug) {
        console.log("\u{1F987} AI Service state update:", state);
      }
    });
    this.unsubscribers.push(settingsUnsub, aiStoreUnsub);
  }
  /**
   * Clean up resources
   */
  destroyInternal() {
    return __async(this, null, function* () {
      var _a, _b;
      try {
        this.unsubscribers.forEach((unsub) => unsub());
        this.unsubscribers = [];
        yield (_a = this.generatorFactory) == null ? void 0 : _a.resetAll();
        yield (_b = this.adapterRegistry) == null ? void 0 : _b.destroy();
        aiStore.update((state) => __spreadProps(__spreadValues({}, state), {
          isInitialized: false
        }));
      } catch (error) {
        throw new ServiceError(
          this.serviceName,
          "Failed to clean up AI service",
          error instanceof Error ? error : void 0
        );
      }
    });
  }
  /**
   * Configure the service
   */
  configure(config) {
    return __async(this, null, function* () {
      this.config = __spreadValues(__spreadValues({}, this.config), config);
      if (config.defaultProvider) {
        const currentProvider = this.getProviderFromStore();
        if (currentProvider !== config.defaultProvider) {
          yield this.adapterRegistry.testConnection(config.defaultProvider);
          this.updateAIStore({ provider: config.defaultProvider });
        }
      }
      if (this.config.debug) {
        console.log("\u{1F987} AI Service configured:", this.config);
      }
    });
  }
  /**
   * Get current provider from store
   */
  getProviderFromStore() {
    const state = get_store_value(aiStore);
    return state.provider;
  }
  /**
   * Reinitialize the service
   */
  reinitialize() {
    return __async(this, null, function* () {
      if (this.isInitializing) {
        throw new ServiceError("AI Service", "Service is already initializing");
      }
      try {
        this.isInitializing = true;
        yield this.waitForDependencies();
        yield this.initialize();
      } finally {
        this.isInitializing = false;
      }
    });
  }
  waitForDependencies() {
    return __async(this, null, function* () {
      const maxAttempts = 50;
      const interval = 100;
      for (let i = 0; i < maxAttempts; i++) {
        if (this.checkDependenciesReady()) {
          return;
        }
        yield new Promise((resolve) => setTimeout(resolve, interval));
      }
      throw new ServiceError("AI Service", "Dependencies failed to initialize");
    });
  }
  checkDependenciesReady() {
    var _a, _b, _c;
    return ((_a = this.settingsService) == null ? void 0 : _a.isReady()) && ((_b = this.operationManager) == null ? void 0 : _b.isReady()) && ((_c = this.databaseService) == null ? void 0 : _c.isReady());
  }
  /**
   * Update AI store state
   */
  updateAIStore(update2) {
    aiStore.update((state) => __spreadValues(__spreadValues({}, state), update2));
  }
  /**
   * Get the current AI adapter
   */
  getCurrentAdapter() {
    return this.adapterRegistry.getCurrentAdapter();
  }
  /**
   * Get the current provider
   */
  getCurrentProvider() {
    return this.getProviderFromStore();
  }
  /**
   * Get the adapter registry
   */
  getAdapterRegistry() {
    if (!this.adapterRegistry) {
      throw new ServiceError(this.serviceName, "AdapterRegistry not initialized");
    }
    return this.adapterRegistry;
  }
  /**
   * Get the generator factory
   */
  getGeneratorFactory() {
    if (!this.generatorFactory) {
      throw new ServiceError(this.serviceName, "GeneratorFactory not initialized");
    }
    return this.generatorFactory;
  }
  /**
   * Get the generation service
   */
  getGenerationService() {
    if (!this.generationService) {
      this.generationService = new AIGenerationService(this.generatorFactory);
    }
    return this.generationService;
  }
  /**
   * Test connection to provider
   */
  testConnection(provider) {
    return __async(this, null, function* () {
      if (!this.isReady()) {
        yield this.initialize();
      }
      try {
        const result = yield this.adapterRegistry.testConnection(provider);
        if (this.config.enableNotifications) {
          new import_obsidian9.Notice(
            result ? `Successfully connected to ${provider}` : `Failed to connect to ${provider}`
          );
        }
        return result;
      } catch (error) {
        this.handleError("Failed to test connection", error);
        return false;
      }
    });
  }
};

// src/services/file/FileProcessorService.ts
var import_obsidian10 = require("obsidian");
var _FileProcessorService = class extends CoreService {
  constructor(app, aiService, settingsService, databaseService, fileScanner, generatorFactory, store) {
    super("file-processor", "File Processor Service");
    this.app = app;
    this.aiService = aiService;
    this.settingsService = settingsService;
    this.databaseService = databaseService;
    this.fileScanner = fileScanner;
    this.generatorFactory = generatorFactory;
    this.store = store;
    this.isInitializing = false;
    this.initializationError = null;
    this.processingQueue = [];
    this.activeChunks = /* @__PURE__ */ new Map();
    this.processingStats = {
      totalFiles: 0,
      processedFiles: 0,
      skippedFiles: 0,
      errorFiles: 0,
      startTime: 0,
      averageProcessingTime: 0
    };
    // Default processing options
    this.options = {
      chunkSize: 10,
      delayBetweenChunks: 1e3,
      maxRetries: 3,
      generateFrontMatter: true,
      generateWikilinks: true,
      maxConcurrentProcessing: 3
    };
    if (_FileProcessorService.instance) {
      console.log("\u{1F987} FileProcessorService: Returning existing instance");
      return _FileProcessorService.instance;
    }
    this.state = "uninitialized" /* Uninitialized */;
    _FileProcessorService.instance = this;
    console.log("\u{1F987} FileProcessorService: Created new instance with state:", this.state);
  }
  isReady() {
    var _a, _b, _c, _d, _e;
    const dependencyStates = {
      aiService: (_a = this.aiService) == null ? void 0 : _a.isReady(),
      settingsService: (_b = this.settingsService) == null ? void 0 : _b.isReady(),
      fileScanner: (_c = this.fileScanner) == null ? void 0 : _c.isReady(),
      generatorFactory: (_d = this.generatorFactory) == null ? void 0 : _d.isReady(),
      databaseService: (_e = this.databaseService) == null ? void 0 : _e.isReady()
    };
    const allDependenciesReady = Object.values(dependencyStates).every((state) => state === true);
    const storeInitialized = get_store_value(this.store) !== void 0;
    console.log("\u{1F987} FileProcessorService.isReady check:", {
      serviceState: this.state,
      isInitializing: this.isInitializing,
      hasError: this.initializationError !== null,
      dependencyStates,
      allDependenciesReady,
      storeInitialized
    });
    return this.state === "ready" /* Ready */ && !this.isInitializing && this.initializationError === null && allDependenciesReady && storeInitialized;
  }
  initializeInternal() {
    return __async(this, null, function* () {
      if (this.isInitializing) {
        console.log("\u{1F987} FileProcessorService: Already initializing, waiting...");
        while (this.isInitializing) {
          yield new Promise((resolve) => setTimeout(resolve, 100));
        }
        return;
      }
      try {
        console.log("\u{1F987} FileProcessorService: Starting initialization...");
        this.isInitializing = true;
        this.state = "initializing" /* Initializing */;
        const dependencies = [
          { service: this.aiService, name: "AIService" },
          { service: this.settingsService, name: "SettingsService" },
          { service: this.fileScanner, name: "FileScannerService" },
          { service: this.generatorFactory, name: "GeneratorFactory" },
          { service: this.databaseService, name: "DatabaseService" }
        ];
        for (const { service, name } of dependencies) {
          console.log(`\u{1F987} FileProcessorService: Checking dependency ${name}...`);
          if (!service) {
            throw new Error(`Required dependency ${name} not provided`);
          }
        }
        console.log("\u{1F987} FileProcessorService: Waiting for dependencies...");
        yield this.waitForDependencies();
        console.log("\u{1F987} FileProcessorService: Initializing store...");
        this.initializeStore();
        console.log("\u{1F987} FileProcessorService: Loading settings...");
        yield this.loadProcessingOptions();
        console.log("\u{1F987} FileProcessorService: Setting ready state...");
        this.state = "ready" /* Ready */;
        this.isInitializing = false;
        this.initializationError = null;
        console.log("\u{1F987} FileProcessorService: Verifying ready state...");
        if (!this.isReady()) {
          throw new Error("Service failed to reach ready state after initialization");
        }
        console.log("\u{1F987} FileProcessorService: Initialization complete");
      } catch (error) {
        console.error("\u{1F987} FileProcessorService: Initialization failed:", error);
        this.handleInitializationError(error);
        throw error;
      } finally {
        this.isInitializing = false;
      }
    });
  }
  waitForDependencies() {
    return __async(this, null, function* () {
      const dependencies = [
        { service: this.aiService, name: "AIService" },
        { service: this.settingsService, name: "SettingsService" },
        { service: this.fileScanner, name: "FileScannerService" },
        { service: this.generatorFactory, name: "GeneratorFactory" }
      ];
      for (const { service, name } of dependencies) {
        yield this.waitForDependency(service, name);
      }
    });
  }
  waitForDependency(service, name) {
    return __async(this, null, function* () {
      console.log(`\u{1F987} FileProcessorService: Waiting for ${name}...`);
      const timeout = 3e4;
      const startTime = Date.now();
      let lastLog = 0;
      while (!service.isReady()) {
        const now2 = Date.now();
        if (now2 - lastLog >= 5e3) {
          console.log(`\u{1F987} FileProcessorService: Still waiting for ${name}... (${Math.round((now2 - startTime) / 1e3)}s)`);
          lastLog = now2;
        }
        if (now2 - startTime > timeout) {
          throw new Error(`Timeout waiting for ${name} to be ready`);
        }
        yield new Promise((resolve) => setTimeout(resolve, 100));
      }
      console.log(`\u{1F987} FileProcessorService: ${name} is ready`);
    });
  }
  initializeStore() {
    const initialState2 = {
      isProcessing: false,
      currentFile: null,
      progress: 0,
      error: null,
      queue: [],
      state: "idle" /* IDLE */,
      filesQueued: 0,
      filesProcessed: 0,
      filesRemaining: 0,
      errors: [],
      startTime: null,
      estimatedTimeRemaining: null
    };
    this.store.set(initialState2);
    const state = get_store_value(this.store);
    if (!state) {
      throw new Error("Failed to initialize processing state store");
    }
  }
  loadProcessingOptions() {
    return __async(this, null, function* () {
      const settings = this.settingsService.getSettings();
      this.options = __spreadProps(__spreadValues({}, this.options), {
        generateFrontMatter: settings.frontMatter.autoGenerate,
        generateWikilinks: settings.advanced.generateWikilinks,
        maxConcurrentProcessing: settings.advanced.maxConcurrentProcessing,
        chunkSize: settings.advanced.batchSize,
        delayBetweenChunks: settings.advanced.delayBetweenChunks,
        maxRetries: settings.advanced.maxRetries
      });
    });
  }
  setStatusBar(statusBar) {
    this.statusBar = statusBar;
  }
  processSingleFile(file, options) {
    return __async(this, null, function* () {
      if (!this.isReady()) {
        throw new ServiceError(this.serviceName, "Service not ready");
      }
      const startTime = Date.now();
      let result = {
        success: false,
        path: file.path,
        frontMatterGenerated: false,
        wikilinksGenerated: false,
        processingTime: 0
      };
      try {
        this.updateProcessingState({
          isProcessing: true,
          currentFile: file.path,
          state: "running" /* RUNNING */
        });
        result = yield this.processFile(file, options);
        yield this.handleProcessingResult(result);
        return result;
      } catch (error) {
        result = this.createErrorResult(file, error, startTime);
        yield this.handleProcessingError(error, file);
        return result;
      } finally {
        this.updateProcessingStats(result);
        this.updateStatusBar(file.path);
      }
    });
  }
  processFile(file, options) {
    return __async(this, null, function* () {
      const startTime = Date.now();
      const processOptions = __spreadValues(__spreadValues({}, this.options), options);
      let frontMatterGenerated = false;
      let wikilinksGenerated = false;
      try {
        if (processOptions.generateFrontMatter) {
          const hasFM = yield this.fileScanner.hasFrontMatter(file);
          if (!hasFM) {
            yield this.generateFrontMatter(file);
            frontMatterGenerated = true;
          }
        }
        if (processOptions.generateWikilinks) {
          const wikilinkResult = yield this.generateWikilinks(file);
          wikilinksGenerated = wikilinkResult.success;
        }
        return {
          success: true,
          path: file.path,
          frontMatterGenerated,
          wikilinksGenerated,
          processingTime: Date.now() - startTime
        };
      } catch (error) {
        throw new ServiceError(
          this.serviceName,
          `Failed to process file ${file.path}`,
          error instanceof Error ? error : void 0
        );
      }
    });
  }
  generateFrontMatter(file) {
    return __async(this, null, function* () {
      const frontMatter = `---
title: ${file.basename}
created: ${new Date().toISOString()}
---
`;
      const content = yield this.app.vault.read(file);
      yield this.app.vault.modify(file, frontMatter + content);
    });
  }
  generateWikilinks(file) {
    return __async(this, null, function* () {
      const wikilinkGenerator = yield this.generatorFactory.getWikilinkGenerator();
      yield wikilinkGenerator.initialize();
      const content = yield this.app.vault.read(file);
      const existingPages = this.app.vault.getMarkdownFiles().map((f) => f.basename);
      const result = yield wikilinkGenerator.generate({
        content,
        existingPages
      });
      yield this.app.vault.modify(file, result.content);
      return { success: true };
    });
  }
  handleInitializationError(error) {
    this.initializationError = error instanceof Error ? error : new Error("Unknown error");
    this.state = "error" /* Error */;
    this.isInitializing = false;
    console.error("\u{1F987} FileProcessorService: Initialization failed:", error);
    throw new ServiceError(
      this.serviceName,
      "Failed to initialize file processor",
      error instanceof Error ? error : void 0
    );
  }
  handleProcessingResult(result) {
    return __async(this, null, function* () {
      yield this.databaseService.markFileAsProcessed({ path: result.path }, result);
      if (result.success) {
        new import_obsidian10.Notice(`Successfully processed ${result.path}`);
      }
    });
  }
  createErrorResult(file, error, startTime) {
    return {
      success: false,
      path: file.path,
      frontMatterGenerated: false,
      wikilinksGenerated: false,
      processingTime: Date.now() - startTime,
      error: error instanceof Error ? error.message : "Unknown error"
    };
  }
  handleProcessingError(error, file) {
    return __async(this, null, function* () {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      console.error("\u{1F987} Processing error:", error);
      if (file) {
        new import_obsidian10.Notice(`Error processing file ${file.path}: ${errorMessage}`);
      }
      this.updateProcessingState({
        isProcessing: false,
        currentFile: null,
        state: "error" /* ERROR */,
        error: errorMessage
      });
    });
  }
  updateProcessingState(update2) {
    this.store.update((state) => __spreadValues(__spreadValues({}, state), update2));
  }
  updateProcessingStats(result) {
    this.processingStats.processedFiles++;
    if (!result.success) {
      this.processingStats.errorFiles++;
    }
    const totalTime = this.processingStats.averageProcessingTime * (this.processingStats.processedFiles - 1);
    this.processingStats.averageProcessingTime = (totalTime + result.processingTime) / this.processingStats.processedFiles;
  }
  updateStatusBar(currentFile) {
    if (!this.statusBar)
      return;
    const state = get_store_value(this.store);
    this.statusBar.updateFromState({
      currentFile: currentFile || null,
      progress: state.filesProcessed / state.filesQueued * 100,
      status: {
        state,
        filesQueued: state.filesQueued,
        filesProcessed: state.filesProcessed,
        filesRemaining: state.filesRemaining,
        currentFile: currentFile || void 0,
        errors: state.errors,
        startTime: state.startTime || void 0,
        estimatedTimeRemaining: state.estimatedTimeRemaining || void 0
      }
    });
  }
  destroyInternal() {
    return __async(this, null, function* () {
      try {
        this.processingQueue = [];
        this.activeChunks.clear();
        this.initializeStore();
        console.log("\u{1F987} FileProcessorService: Cleanup complete");
        _FileProcessorService.instance = null;
      } catch (error) {
        console.error("\u{1F987} FileProcessorService: Error during cleanup:", error);
      }
    });
  }
};
var FileProcessorService = _FileProcessorService;
FileProcessorService.instance = null;

// src/generators/BatchProcessor.ts
var import_obsidian11 = require("obsidian");
var import_events6 = require("events");

// src/services/file/BatchHandler.ts
var BatchHandler = class {
  constructor(processFile, options, maxRetries, retryDelay) {
    this.processFile = processFile;
    this.options = options;
    this.maxRetries = maxRetries;
    this.retryDelay = retryDelay;
  }
  processBatches(batches) {
    return __async(this, null, function* () {
      for (const batch of batches) {
        yield Promise.all(
          batch.map(
            (file) => this.processFile(file)
          )
        );
        if (this.options.delayBetweenChunks > 0) {
          yield delay(this.options.delayBetweenChunks);
        }
      }
    });
  }
  createBatches(files) {
    const batches = [];
    const batchSize = this.options.chunkSize;
    for (let i = 0; i < files.length; i += batchSize) {
      batches.push(files.slice(i, i + batchSize));
    }
    return batches;
  }
};
function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// src/types/constants.ts
var DEFAULT_PROCESSING_OPTIONS = {
  chunkSize: 10,
  delayBetweenChunks: 1e3,
  maxRetries: 3,
  generateFrontMatter: true,
  generateWikilinks: false,
  maxConcurrentProcessing: 3
};
var CACHE_DURATIONS = {
  MODEL_LIST: 24 * 60 * 60 * 1e3,
  // 24 hours
  FILE_SCAN: 5 * 60 * 1e3,
  // 5 minutes
  API_KEY: 12 * 60 * 60 * 1e3
  // 12 hours
};
var VALIDATION_LIMITS = {
  MAX_FILE_SIZE: 1024 * 1024 * 10,
  // 10MB
  MAX_BATCH_SIZE: 50,
  MAX_CONCURRENT_REQUESTS: 5,
  MIN_CHUNK_SIZE: 1,
  MAX_CHUNK_SIZE: 100
};

// src/generators/BatchProcessor.ts
var BatchProcessor = class extends import_events6.EventEmitter {
  constructor(app, coreService, statusBar) {
    super();
    this.app = app;
    this.coreService = coreService;
    this.statusBar = statusBar;
    const defaultState = this.createInitialProcessingState();
    this.state = {
      status: {
        state: defaultState,
        filesQueued: 0,
        filesProcessed: 0,
        filesRemaining: 0,
        currentFile: void 0,
        // Changed from null to undefined
        startTime: 0,
        errors: []
      },
      options: __spreadValues({}, DEFAULT_PROCESSING_OPTIONS),
      isProcessing: false,
      isPaused: false,
      results: [],
      startTime: 0,
      batchHandler: null
    };
  }
  // 🎸 Public API Methods
  process(input) {
    return __async(this, null, function* () {
      this.validateInput(input);
      this.initializeProcessing(input);
      try {
        const tfiles = this.getValidFiles(input.files);
        yield this.initializeBatchHandler(tfiles, input);
        yield this.processBatches(this.state.batchHandler.createBatches(tfiles));
        return this.generateStats();
      } catch (error) {
        this.handleError(this.normalizeError(error));
        throw error;
      } finally {
        this.cleanup();
      }
    });
  }
  pause() {
    this.state.isPaused = true;
    this.updateStatusAndEmit("paused" /* PAUSED */);
  }
  resume() {
    this.state.isPaused = false;
    this.updateStatusAndEmit("running" /* RUNNING */);
  }
  // 🎸 Private Processing Methods
  processBatches(batches) {
    return __async(this, null, function* () {
      for (const [index, batch] of batches.entries()) {
        yield this.processSingleBatch(batch, index, batches.length);
      }
    });
  }
  processSingleBatch(batch, index, total) {
    return __async(this, null, function* () {
      if (this.state.isPaused) {
        yield this.waitForResume();
      }
      const batchInfo = {
        files: batch.map((f) => f.path),
        index,
        size: batch.length
      };
      this.emit("chunkStart", batchInfo);
      yield this.state.batchHandler.processBatches([batch]);
      this.emit("chunkComplete", batchInfo);
    });
  }
  processFile(file, input) {
    return __async(this, null, function* () {
      this.emit("fileStart", { file: file.path });
      try {
        const result = yield this.executeFileProcessing(file, input);
        this.updateFileProgress(file.path, result);
        this.emit("fileComplete", { result });
      } catch (error) {
        this.handleFileError(file.path, this.normalizeError(error));
      }
    });
  }
  // 🎸 State Management Methods
  updateStatusAndEmit(newState) {
    this.updateStatus({
      state: this.createProcessingState(newState)
    });
  }
  // 🎸 Create initial processing state without dependencies
  createInitialProcessingState() {
    return {
      isProcessing: false,
      currentFile: null,
      queue: [],
      progress: 0,
      state: "idle" /* IDLE */,
      filesQueued: 0,
      filesProcessed: 0,
      filesRemaining: 0,
      errors: [],
      error: null,
      startTime: null,
      estimatedTimeRemaining: null
    };
  }
  createProcessingState(state) {
    if (!this.state) {
      return this.createInitialProcessingState();
    }
    const { status, isProcessing, startTime } = this.state;
    return {
      isProcessing,
      currentFile: status.currentFile || null,
      // Ensures null when undefined
      queue: [],
      progress: this.calculateProgress(),
      state,
      filesQueued: status.filesQueued,
      filesProcessed: status.filesProcessed,
      filesRemaining: status.filesRemaining,
      errors: status.errors,
      error: null,
      startTime: startTime || null,
      estimatedTimeRemaining: this.calculateETA()
    };
  }
  updateStatus(update2) {
    this.state.status = __spreadValues(__spreadValues({}, this.state.status), update2);
    this.emit("stateChanged", {
      state: this.state.status.state,
      currentFile: this.state.status.currentFile,
      progress: this.calculateProgress(),
      status: this.state.status
    });
  }
  // 🎸 Utility Methods
  calculateProgress() {
    const { filesProcessed, filesQueued } = this.state.status;
    return filesQueued === 0 ? 0 : filesProcessed / filesQueued * 100;
  }
  calculateETA() {
    const { filesProcessed, filesRemaining } = this.state.status;
    if (filesProcessed === 0)
      return null;
    const elapsed = Date.now() - this.state.startTime;
    const averageTimePerFile = elapsed / filesProcessed;
    return averageTimePerFile * filesRemaining;
  }
  calculateAverageProcessingTime() {
    const { results } = this.state;
    if (results.length === 0)
      return 0;
    const totalTime = results.reduce((sum, r) => sum + r.processingTime, 0);
    return totalTime / results.length;
  }
  // 🎸 Initialization Methods
  initializeStatus() {
    const defaultState = this.createProcessingState("idle" /* IDLE */);
    return {
      state: defaultState,
      filesQueued: 0,
      filesProcessed: 0,
      filesRemaining: 0,
      currentFile: void 0,
      // Changed from null to undefined
      startTime: 0,
      errors: []
    };
  }
  initializeProcessing(input) {
    Object.assign(this.state, {
      isProcessing: true,
      startTime: Date.now(),
      results: [],
      options: __spreadValues(__spreadValues({}, this.state.options), input.options)
    });
    this.updateStatus({
      state: this.createProcessingState("running" /* RUNNING */),
      filesQueued: input.files.length,
      filesProcessed: 0,
      filesRemaining: input.files.length,
      startTime: this.state.startTime,
      errors: []
    });
    this.emit("start", { status: this.state.status });
  }
  initializeBatchHandler(files, input) {
    return __async(this, null, function* () {
      this.state.batchHandler = new BatchHandler(
        (file) => __async(this, null, function* () {
          return this.processFile(file, input);
        }),
        this.state.options,
        this.state.options.maxRetries,
        this.state.options.delayBetweenChunks
      );
    });
  }
  // 🎸 Helper Methods
  executeFileProcessing(file, input) {
    return __async(this, null, function* () {
      const startTime = Date.now();
      yield this.state.batchHandler.processBatches([[file]]);
      return {
        success: true,
        path: file.path,
        frontMatterGenerated: input.generateFrontMatter,
        wikilinksGenerated: input.generateWikilinks,
        processingTime: Date.now() - startTime
      };
    });
  }
  updateFileProgress(filePath, result) {
    this.state.results.push(result);
    this.state.status.filesProcessed++;
    this.state.status.filesRemaining--;
    this.statusBar.updateFromState({
      currentFile: filePath,
      progress: this.calculateProgress(),
      status: this.state.status
    });
  }
  getValidFiles(filePaths) {
    return filePaths.map((path) => this.app.vault.getAbstractFileByPath(path)).filter((file) => file instanceof import_obsidian11.TFile);
  }
  validateInput(input) {
    if (!Array.isArray(input.files) || input.files.length === 0 || typeof input.generateFrontMatter !== "boolean" || typeof input.generateWikilinks !== "boolean") {
      throw new Error("Invalid batch input");
    }
  }
  // 🎸 Error Handling Methods
  normalizeError(error) {
    return error instanceof Error ? error : new Error(String(error));
  }
  handleError(error) {
    this.updateStatus({
      state: this.createProcessingState("error" /* ERROR */)
    });
    this.emit("error", {
      filePath: this.state.status.currentFile || "",
      error: error.message,
      timestamp: Date.now(),
      retryCount: 0
    });
  }
  handleFileError(filePath, error) {
    const newError = {
      filePath,
      error: error.message,
      timestamp: Date.now(),
      retryCount: 0
    };
    this.state.status.errors.push(newError);
    this.emit("error", newError);
  }
  // 🎸 Cleanup and Management Methods
  cleanup() {
    this.state.isProcessing = false;
    this.updateStatus({
      state: this.createProcessingState("idle" /* IDLE */)
    });
  }
  waitForResume() {
    return __async(this, null, function* () {
      return new Promise((resolve) => {
        const resumeHandler = () => {
          this.off("resume", resumeHandler);
          resolve();
        };
        this.on("resume", resumeHandler);
      });
    });
  }
  generateStats() {
    const endTime = Date.now();
    return {
      totalFiles: this.state.status.filesQueued,
      processedFiles: this.state.status.filesProcessed,
      skippedFiles: 0,
      errorFiles: this.state.status.errors.length,
      startTime: this.state.startTime,
      endTime,
      averageProcessingTime: this.calculateAverageProcessingTime(),
      timestamp: endTime
    };
  }
};

// src/registrations/FileRegistrations.ts
var BatchProcessorService = class {
  constructor(app, fileProcessor, operationExecutor) {
    this.serviceId = "batchProcessor";
    this.serviceName = "Batch Processor Service";
    this.batchProcessor = new BatchProcessor(
      app,
      fileProcessor,
      operationExecutor
    );
  }
  initialize() {
    return __async(this, null, function* () {
      return Promise.resolve();
    });
  }
  isReady() {
    return true;
  }
  destroy() {
    return __async(this, null, function* () {
      return Promise.resolve();
    });
  }
  getState() {
    return {};
  }
  // Expose the underlying batch processor methods
  getBatchProcessor() {
    return this.batchProcessor;
  }
};
function registerFileServices(app) {
  return __async(this, null, function* () {
    const registry = ServiceRegistry.getInstance();
    try {
      const aiService = registry.getService("aiService");
      const settingsService = registry.getService("settingsService");
      const databaseService = registry.getService("databaseService");
      const fileScannerService = registry.getService("fileScanner");
      const generatorFactory = registry.getService("generatorFactory");
      const operationManager = registry.getService("aiOperationManager");
      yield registry.registerService(
        "fileProcessorService",
        new FileProcessorService(
          app,
          aiService,
          settingsService,
          databaseService,
          fileScannerService,
          generatorFactory,
          processingStore
        )
      );
      yield registry.registerService(
        "batchProcessor",
        new BatchProcessorService(
          app,
          registry.getService("fileProcessorService"),
          operationManager.getOperationExecutor()
        ),
        ["fileProcessorService", "aiOperationManager", "generatorFactory"]
        // Dependencies array
      );
      console.log("\u{1F987} File services registered successfully");
    } catch (error) {
      console.error("\u{1F987} Failed to register file services:", error);
      throw error;
    }
  });
}

// src/registrations/UIRegistrations.ts
function registerUIServices() {
  return __async(this, null, function* () {
    const registry = ServiceRegistry.getInstance();
    try {
      yield registry.registerService(
        uiStore.serviceId,
        uiStore,
        []
        // No dependencies
      );
      yield registry.registerService(
        processingStore.serviceId,
        processingStore,
        [uiStore.serviceId]
        // Depends on UI store
      );
      console.log("\u{1F987} UI services registered successfully");
    } catch (error) {
      console.error("\u{1F987} Failed to register UI services:", error);
      throw new ServiceError(
        "UIRegistrations",
        "Failed to register UI services",
        error instanceof Error ? error : void 0
      );
    }
  });
}
function initializeUIServices() {
  return __async(this, null, function* () {
    const registry = ServiceRegistry.getInstance();
    try {
      const ui = registry.getService(uiStore.serviceId);
      const processing = registry.getService(processingStore.serviceId);
      yield ui.initialize();
      yield processing.initialize();
      console.log("\u{1F987} UI services initialized successfully");
    } catch (error) {
      console.error("\u{1F987} Failed to initialize UI services:", error);
      throw new ServiceError(
        "UIRegistrations",
        "Failed to initialize UI services",
        error instanceof Error ? error : void 0
      );
    }
  });
}
function destroyUIServices() {
  return __async(this, null, function* () {
    const registry = ServiceRegistry.getInstance();
    try {
      const ui = registry.getService(uiStore.serviceId);
      const processing = registry.getService(processingStore.serviceId);
      yield processing.destroy();
      yield ui.destroy();
      console.log("\u{1F987} UI services destroyed successfully");
    } catch (error) {
      console.error("\u{1F987} Failed to destroy UI services:", error);
    }
  });
}

// src/settings/GraphWeaverSettingTab.ts
var import_obsidian26 = require("obsidian");

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// src/components/accordions/ModelHookupAccordion.svelte
var import_obsidian12 = require("obsidian");

// src/components/accordions/BaseAccordion.svelte
function add_css(target) {
  append_styles(target, "svelte-1w24cbd", ".graphweaver-accordion.svelte-1w24cbd{border:1px solid var(--background-modifier-border);border-radius:var(--radius-m);margin-bottom:var(--size-4);overflow:hidden;background-color:var(--background-modifier-hover)}.graphweaver-accordion-header.svelte-1w24cbd{display:flex;justify-content:space-between;align-items:center;padding:var(--size-4) var(--size-6);cursor:pointer;user-select:none}.graphweaver-accordion-header.is-active.svelte-1w24cbd{background:var(--background-modifier-hover)}.graphweaver-accordion-toggle.svelte-1w24cbd{padding:var(--size-1);color:var(--text-muted);font-size:1.1em}.graphweaver-accordion-header.svelte-1w24cbd:focus{outline:2px solid var(--interactive-accent);outline-offset:-2px}.graphweaver-accordion-header.svelte-1w24cbd:hover{background-color:var(--background-modifier-hover)}.graphweaver-accordion-content.svelte-1w24cbd{padding:var(--size-4);background-color:var(--background-primary)}");
}
function create_if_block_1(ctx) {
  let div;
  let t;
  return {
    c() {
      div = element("div");
      t = text(
        /*description*/
        ctx[1]
      );
      attr(div, "class", "setting-item-description");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*description*/
      2)
        set_data(
          t,
          /*description*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "graphweaver-accordion-content svelte-1w24cbd");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment(ctx) {
  let div4;
  let div3;
  let div1;
  let div0;
  let t0;
  let t1;
  let t2;
  let div2;
  let span;
  let t3_value = (
    /*isOpen*/
    ctx[2] ? "\u2796" : "\u2795"
  );
  let t3;
  let t4;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*description*/
    ctx[1] && create_if_block_1(ctx)
  );
  let if_block1 = (
    /*isOpen*/
    ctx[2] && create_if_block(ctx)
  );
  return {
    c() {
      div4 = element("div");
      div3 = element("div");
      div1 = element("div");
      div0 = element("div");
      t0 = text(
        /*title*/
        ctx[0]
      );
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      div2 = element("div");
      span = element("span");
      t3 = text(t3_value);
      t4 = space();
      if (if_block1)
        if_block1.c();
      attr(div0, "class", "setting-item-heading");
      attr(div1, "class", "setting-item-info");
      attr(span, "class", "graphweaver-accordion-toggle svelte-1w24cbd");
      attr(div2, "class", "setting-item-control");
      attr(div3, "class", "graphweaver-accordion-header svelte-1w24cbd");
      attr(div3, "role", "button");
      attr(div3, "tabindex", "0");
      attr(
        div3,
        "aria-expanded",
        /*isOpen*/
        ctx[2]
      );
      toggle_class(
        div3,
        "is-active",
        /*isOpen*/
        ctx[2]
      );
      attr(div4, "class", "graphweaver-accordion svelte-1w24cbd");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div3);
      append(div3, div1);
      append(div1, div0);
      append(div0, t0);
      append(div1, t1);
      if (if_block0)
        if_block0.m(div1, null);
      append(div3, t2);
      append(div3, div2);
      append(div2, span);
      append(span, t3);
      append(div4, t4);
      if (if_block1)
        if_block1.m(div4, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div3,
            "click",
            /*toggleAccordion*/
            ctx[3]
          ),
          listen(
            div3,
            "keydown",
            /*keydown_handler*/
            ctx[6]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*title*/
      1)
        set_data(
          t0,
          /*title*/
          ctx2[0]
        );
      if (
        /*description*/
        ctx2[1]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          if_block0.m(div1, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if ((!current || dirty & /*isOpen*/
      4) && t3_value !== (t3_value = /*isOpen*/
      ctx2[2] ? "\u2796" : "\u2795"))
        set_data(t3, t3_value);
      if (!current || dirty & /*isOpen*/
      4) {
        attr(
          div3,
          "aria-expanded",
          /*isOpen*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*isOpen*/
      4) {
        toggle_class(
          div3,
          "is-active",
          /*isOpen*/
          ctx2[2]
        );
      }
      if (
        /*isOpen*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*isOpen*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div4, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { title } = $$props;
  let { description = "" } = $$props;
  let { isOpen = false } = $$props;
  const dispatch = createEventDispatcher();
  function toggleAccordion() {
    dispatch("toggle", { isOpen: !isOpen });
  }
  const keydown_handler = (e) => e.key === "Enter" && toggleAccordion();
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("description" in $$props2)
      $$invalidate(1, description = $$props2.description);
    if ("isOpen" in $$props2)
      $$invalidate(2, isOpen = $$props2.isOpen);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  return [title, description, isOpen, toggleAccordion, $$scope, slots, keydown_handler];
}
var BaseAccordion = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { title: 0, description: 1, isOpen: 2 }, add_css);
  }
};
var BaseAccordion_default = BaseAccordion;

// src/components/accordions/ModelHookupAccordion.svelte
function add_css2(target) {
  append_styles(target, "svelte-28mmqr", ".model-hookup-content.svelte-28mmqr{padding:var(--size-4)}");
}
function create_default_slot(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = ``;
      attr(div, "class", "model-hookup-content svelte-28mmqr");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[9](div);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      ctx[9](null);
    }
  };
}
function create_fragment2(ctx) {
  let baseaccordion;
  let current;
  baseaccordion = new BaseAccordion_default({
    props: {
      title: (
        /*title*/
        ctx[0]
      ),
      description: (
        /*description*/
        ctx[1]
      ),
      isOpen: (
        /*isOpen*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(baseaccordion.$$.fragment);
    },
    m(target, anchor) {
      mount_component(baseaccordion, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const baseaccordion_changes = {};
      if (dirty & /*title*/
      1)
        baseaccordion_changes.title = /*title*/
        ctx2[0];
      if (dirty & /*description*/
      2)
        baseaccordion_changes.description = /*description*/
        ctx2[1];
      if (dirty & /*isOpen*/
      4)
        baseaccordion_changes.isOpen = /*isOpen*/
        ctx2[2];
      if (dirty & /*$$scope, contentEl*/
      32776) {
        baseaccordion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      baseaccordion.$set(baseaccordion_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(baseaccordion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(baseaccordion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(baseaccordion, detaching);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let $state;
  var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  let { title } = $$props;
  let { description } = $$props;
  let { app } = $$props;
  let { settingsService } = $$props;
  let { aiService } = $$props;
  let { isOpen = false } = $$props;
  const state = writable({
    selectedProvider: "openai" /* OpenAI */,
    selectedModel: "",
    apiKey: "",
    isLoading: false
  });
  component_subscribe($$self, state, (value) => $$invalidate(8, $state = value));
  let contentEl;
  function handleProviderChange(provider) {
    return __awaiter(this, void 0, void 0, function* () {
      state.update((s) => Object.assign(Object.assign({}, s), { selectedProvider: provider }));
      const settings = settingsService.getSettings();
      yield settingsService.updateNestedSetting("aiProvider", "selected", provider);
      const apiKey = settings.aiProvider.apiKeys[provider] || "";
      state.update((s) => Object.assign(Object.assign({}, s), { apiKey }));
    });
  }
  function handleModelChange(modelApiName) {
    return __awaiter(this, void 0, void 0, function* () {
      state.update((s) => Object.assign(Object.assign({}, s), { selectedModel: modelApiName }));
      const settings = settingsService.getSettings();
      yield settingsService.updateNestedSetting("aiProvider", "selectedModels", Object.assign(Object.assign({}, settings.aiProvider.selectedModels), { [$state.selectedProvider]: modelApiName }));
    });
  }
  function handleApiKeyChange(value) {
    return __awaiter(this, void 0, void 0, function* () {
      state.update((s) => Object.assign(Object.assign({}, s), { apiKey: value }));
      const settings = settingsService.getSettings();
      yield settingsService.updateNestedSetting("aiProvider", "apiKeys", Object.assign(Object.assign({}, settings.aiProvider.apiKeys), { [$state.selectedProvider]: value }));
    });
  }
  function handleTestConnection() {
    return __awaiter(this, void 0, void 0, function* () {
      if ($state.isLoading)
        return;
      state.update((s) => Object.assign(Object.assign({}, s), { isLoading: true }));
      try {
        const result = yield aiService.testConnection($state.selectedProvider);
        const model = AIModelUtils.getModelByApiName($state.selectedModel);
        const modelName = (model === null || model === void 0 ? void 0 : model.name) || "selected model";
        new import_obsidian12.Notice(result ? `Successfully connected to ${modelName}` : `Failed to connect to ${modelName}. Please check your settings.`);
      } catch (error) {
        console.error("\u{1F987} Error testing connection:", error);
        new import_obsidian12.Notice(`Connection error: ${error instanceof Error ? error.message : "Unknown error"}`);
      } finally {
        state.update((s) => Object.assign(Object.assign({}, s), { isLoading: false }));
      }
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      contentEl = $$value;
      $$invalidate(3, contentEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("description" in $$props2)
      $$invalidate(1, description = $$props2.description);
    if ("app" in $$props2)
      $$invalidate(5, app = $$props2.app);
    if ("settingsService" in $$props2)
      $$invalidate(6, settingsService = $$props2.settingsService);
    if ("aiService" in $$props2)
      $$invalidate(7, aiService = $$props2.aiService);
    if ("isOpen" in $$props2)
      $$invalidate(2, isOpen = $$props2.isOpen);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*contentEl, $state*/
    264) {
      $:
        if (contentEl && $state) {
          contentEl.empty();
          new import_obsidian12.Setting(contentEl).setName("AI Provider").setDesc("Choose your AI service provider").addDropdown((dropdown) => {
            Object.values(AIProvider).forEach((provider) => {
              dropdown.addOption(provider, provider);
            });
            dropdown.setValue($state.selectedProvider);
            dropdown.onChange((value) => __awaiter(void 0, void 0, void 0, function* () {
              yield handleProviderChange(value);
            }));
            return dropdown;
          });
          new import_obsidian12.Setting(contentEl).setName("AI Model").setDesc("Select the AI model to use").addDropdown((dropdown) => {
            var _a;
            const models = AIModelUtils.getModelsForProvider($state.selectedProvider);
            models.forEach((model) => {
              dropdown.addOption(model.apiName, model.name);
            });
            dropdown.setValue($state.selectedModel || ((_a = models[0]) === null || _a === void 0 ? void 0 : _a.apiName));
            dropdown.onChange((value) => __awaiter(void 0, void 0, void 0, function* () {
              yield handleModelChange(value);
            }));
            return dropdown;
          });
          new import_obsidian12.Setting(contentEl).setName("API Key").setDesc("Enter your API key for the selected provider").addText((text2) => {
            text2.setPlaceholder("Enter API key").setValue($state.apiKey).onChange((value) => __awaiter(void 0, void 0, void 0, function* () {
              yield handleApiKeyChange(value);
            }));
            text2.inputEl.type = "password";
            return text2;
          });
          new import_obsidian12.Setting(contentEl).addButton((button) => {
            button.setButtonText($state.isLoading ? "Testing..." : "Test Connection").setCta().setDisabled($state.isLoading || !$state.apiKey).onClick(handleTestConnection);
            return button;
          });
        }
    }
  };
  return [
    title,
    description,
    isOpen,
    contentEl,
    state,
    app,
    settingsService,
    aiService,
    $state,
    div_binding
  ];
}
var ModelHookupAccordion = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        title: 0,
        description: 1,
        app: 5,
        settingsService: 6,
        aiService: 7,
        isOpen: 2
      },
      add_css2
    );
  }
};
var ModelHookupAccordion_default = ModelHookupAccordion;

// src/components/accordions/PropertyManagerAccordion.svelte
var import_obsidian15 = require("obsidian");

// src/components/modals/PropertiesEditor.ts
var import_obsidian14 = require("obsidian");

// src/components/modals/PropertiesEditor.svelte
var import_obsidian13 = require("obsidian");
function add_css3(target) {
  append_styles(target, "svelte-epbidv", ".properties-editor-content.svelte-epbidv{padding:var(--size-4)}.property-item{border:1px solid var(--background-modifier-border);border-radius:var(--radius-s);padding:var(--size-2) var(--size-4);margin-bottom:var(--size-2);display:flex;align-items:center}.property-item.drag-over{border-color:var(--interactive-accent)}.drag-handle{cursor:move;padding:0 var(--size-2);color:var(--text-muted);user-select:none}.dragging{opacity:0.5}.setting-item-control{flex-wrap:wrap;gap:var(--size-2)}.setting-item-info{display:none}.properties-editor-modal{z-index:var(--layer-modal)}.properties-editor-modal .setting-item-name,.properties-editor-modal .setting-item-description{color:var(--text-normal) !important;opacity:1 !important}.modal-active .properties-editor-modal{background-color:var(--background-primary);border:1px solid var(--background-modifier-border)}");
}
function create_fragment3(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = ``;
      attr(div, "class", "properties-editor-content svelte-epbidv");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[5](div);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      ctx[5](null);
    }
  };
}
function handleDragOver(event) {
  event.preventDefault();
}
function instance3($$self, $$props, $$invalidate) {
  let { app } = $$props;
  let { properties } = $$props;
  let { onSubmit } = $$props;
  let { onClose } = $$props;
  let contentEl;
  let localProperties = [...properties];
  let selectedIndices = /* @__PURE__ */ new Set();
  let draggedIndex = null;
  const propertyTypes = ["string", "number", "boolean", "array", "date"];
  onMount(() => {
    console.log("\u{1F987} PropertiesEditor.svelte mounted");
    console.log("\u{1F987} Initial properties:", properties);
    renderProperties();
  });
  function renderProperties() {
    console.log("\u{1F987} Rendering properties");
    if (!contentEl) {
      console.warn("\u{1F987} contentEl not found");
      return;
    }
    contentEl.empty();
    const table = contentEl.createEl("table", { cls: "property-table" });
    const thead = table.createEl("thead");
    const headerRow = thead.createEl("tr");
    const selectAllTh = headerRow.createEl("th");
    const selectAllCheckbox = selectAllTh.createEl("input", { type: "checkbox" });
    selectAllCheckbox.checked = selectedIndices.size === localProperties.length;
    selectAllCheckbox.onchange = () => handleSelectAll(selectAllCheckbox.checked);
    headerRow.createEl("th", { text: "Name" });
    headerRow.createEl("th", { text: "Description" });
    headerRow.createEl("th", { text: "Type" });
    const tbody = table.createEl("tbody");
    localProperties.forEach((property, index) => {
      const row = tbody.createEl("tr");
      row.draggable = true;
      row.addEventListener("dragstart", (e) => handleDragStart(e, index));
      row.addEventListener("dragover", handleDragOver);
      row.addEventListener("drop", (e) => handleDrop(e, index));
      const selectTd = row.createEl("td");
      const checkbox = selectTd.createEl("input", { type: "checkbox" });
      checkbox.checked = selectedIndices.has(index);
      checkbox.onchange = () => handleSelect(index, checkbox.checked);
      const nameTd = row.createEl("td");
      const nameInput = new import_obsidian13.TextComponent(nameTd);
      nameInput.setValue(property.name).onChange((value) => updateProperty(index, "name", value));
      const descTd = row.createEl("td");
      const descInput = new import_obsidian13.TextComponent(descTd);
      descInput.setValue(property.description).onChange((value) => updateProperty(index, "description", value));
      const typeTd = row.createEl("td");
      const typeDropdown = new import_obsidian13.DropdownComponent(typeTd);
      propertyTypes.forEach((type) => {
        typeDropdown.addOption(type, type);
      });
      typeDropdown.setValue(property.type).onChange((value) => updateProperty(index, "type", value));
    });
    new import_obsidian13.Setting(contentEl).addButton((button) => button.setButtonText("Delete Selected").setWarning().setDisabled(selectedIndices.size === 0).onClick(handleDelete)).addButton((button) => button.setButtonText("Save").setCta().onClick(handleSave)).addButton((button) => button.setButtonText("Cancel").onClick(onClose));
  }
  function updateProperty(index, key, value) {
    localProperties[index] = Object.assign(Object.assign({}, localProperties[index]), { [key]: value });
    localProperties = [...localProperties];
  }
  function handleSelect(index, selected) {
    if (selected) {
      selectedIndices.add(index);
    } else {
      selectedIndices.delete(index);
    }
    selectedIndices = new Set(selectedIndices);
  }
  function handleSelectAll(selected) {
    if (selected) {
      selectedIndices = new Set(localProperties.map((_, i) => i));
    } else {
      selectedIndices.clear();
    }
  }
  function handleDelete() {
    localProperties = localProperties.filter((_, index) => !selectedIndices.has(index));
    selectedIndices.clear();
    renderProperties();
  }
  function handleSave() {
    console.log("\u{1F987} Saving properties:", localProperties);
    const invalidProperty = localProperties.find((p) => !p.name || !p.description);
    if (invalidProperty) {
      new import_obsidian13.Notice("All properties must have a name and description");
      return;
    }
    onSubmit(localProperties);
    onClose();
  }
  function handleDragStart(event, index) {
    var _a;
    draggedIndex = index;
    (_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.setData("text/plain", index.toString());
  }
  function handleDrop(event, toIndex) {
    event.preventDefault();
    if (draggedIndex !== null && draggedIndex !== toIndex) {
      const [movedItem] = localProperties.splice(draggedIndex, 1);
      localProperties.splice(toIndex, 0, movedItem);
      localProperties = [...localProperties];
      renderProperties();
    }
    draggedIndex = null;
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      contentEl = $$value;
      $$invalidate(0, contentEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(1, app = $$props2.app);
    if ("properties" in $$props2)
      $$invalidate(2, properties = $$props2.properties);
    if ("onSubmit" in $$props2)
      $$invalidate(3, onSubmit = $$props2.onSubmit);
    if ("onClose" in $$props2)
      $$invalidate(4, onClose = $$props2.onClose);
  };
  return [contentEl, app, properties, onSubmit, onClose, div_binding];
}
var PropertiesEditor = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance3,
      create_fragment3,
      safe_not_equal,
      {
        app: 1,
        properties: 2,
        onSubmit: 3,
        onClose: 4
      },
      add_css3
    );
  }
};
var PropertiesEditor_default = PropertiesEditor;

// src/components/modals/PropertiesEditor.ts
var PropertiesEditor2 = class extends import_obsidian14.Modal {
  constructor(app) {
    console.log("\u{1F987} PropertiesEditor constructor called");
    super(app);
    this.contentComponent = null;
    this.properties = [];
    this.onSubmit = null;
    this.isClosing = false;
  }
  openWithProperties(properties, onSubmit) {
    console.log("\u{1F987} openWithProperties called with:", { propertiesCount: properties.length });
    this.properties = properties;
    this.onSubmit = onSubmit;
    this.open();
  }
  onOpen() {
    console.log("\u{1F50D} Modal onOpen called");
    const settingsContainer = document.querySelector(".graphweaver-plugin-settings");
    if (settingsContainer) {
      settingsContainer.classList.add("modal-active");
    }
    this.titleEl.setText("Edit Properties");
    this.containerEl.addClass("properties-editor-modal");
    try {
      console.log("\u{1F50D} Creating PropertiesEditorContent");
      this.contentComponent = new PropertiesEditor_default({
        target: this.contentEl,
        props: {
          app: this.app,
          properties: this.properties,
          onSubmit: (updatedProperties) => {
            if (this.onSubmit && !this.isClosing) {
              this.onSubmit(updatedProperties);
            }
            this.closeModal();
          },
          onClose: () => {
            this.closeModal();
          }
        }
      });
    } catch (error) {
      console.error("\u{1F50D} Error creating PropertiesEditorContent:", error);
    }
  }
  closeModal() {
    if (this.isClosing)
      return;
    console.log("\u{1F50D} Closing properties editor modal");
    this.isClosing = true;
    const settingsContainer = document.querySelector(".graphweaver-plugin-settings");
    if (settingsContainer) {
      settingsContainer.classList.remove("modal-active");
    }
    if (this.contentComponent) {
      try {
        console.log("\u{1F50D} Destroying Svelte component");
        this.contentComponent.$destroy();
        this.contentComponent = null;
      } catch (error) {
        console.error("\u{1F50D} Error destroying component:", error);
      }
    }
    this.close();
    uiStore.popModal();
    setTimeout(() => {
      this.isClosing = false;
    }, 100);
  }
  onClose() {
    if (!this.isClosing) {
      this.closeModal();
    }
  }
};

// src/components/accordions/PropertyManagerAccordion.svelte
function add_css4(target) {
  append_styles(target, "svelte-114vcxw", ".property-manager-content.svelte-114vcxw{padding:var(--size-4)}.setting-item-error{color:var(--color-red);font-size:var(--font-ui-smaller);margin-top:var(--size-1)}.has-error{border-color:var(--color-red) !important}.setting-item:first-child{padding-top:0}.setting-item:last-child{padding-bottom:0;border-bottom:none}");
}
function create_default_slot2(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = ``;
      attr(div, "class", "property-manager-content svelte-114vcxw");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[9](div);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      ctx[9](null);
    }
  };
}
function create_fragment4(ctx) {
  let baseaccordion;
  let current;
  baseaccordion = new BaseAccordion_default({
    props: {
      title: (
        /*title*/
        ctx[1]
      ),
      description: (
        /*description*/
        ctx[2]
      ),
      isOpen: (
        /*isOpen*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    }
  });
  baseaccordion.$on(
    "toggle",
    /*handleAccordionToggle*/
    ctx[5]
  );
  return {
    c() {
      create_component(baseaccordion.$$.fragment);
    },
    m(target, anchor) {
      mount_component(baseaccordion, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const baseaccordion_changes = {};
      if (dirty & /*title*/
      2)
        baseaccordion_changes.title = /*title*/
        ctx2[1];
      if (dirty & /*description*/
      4)
        baseaccordion_changes.description = /*description*/
        ctx2[2];
      if (dirty & /*isOpen*/
      1)
        baseaccordion_changes.isOpen = /*isOpen*/
        ctx2[0];
      if (dirty & /*$$scope, contentEl*/
      2097160) {
        baseaccordion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      baseaccordion.$set(baseaccordion_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(baseaccordion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(baseaccordion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(baseaccordion, detaching);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let $propertyState;
  var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  let { title } = $$props;
  let { description = "" } = $$props;
  let { app } = $$props;
  let { settingsService } = $$props;
  let { isOpen = false } = $$props;
  const propertyState = writable({
    isAddingProperty: false,
    formData: {
      name: "",
      description: "",
      type: "string",
      required: false,
      multipleValues: false
    },
    validationErrors: {}
  });
  component_subscribe($$self, propertyState, (value) => $$invalidate(11, $propertyState = value));
  let contentEl;
  let shouldRenderContent = false;
  let modal = null;
  const propertyTypes = {
    "string": {
      label: "Text",
      description: "Plain text values"
    },
    "number": {
      label: "Number",
      description: "Numeric values"
    },
    "boolean": {
      label: "True/False",
      description: "Boolean values"
    },
    "array": {
      label: "List",
      description: "Multiple values in a list"
    },
    "date": {
      label: "Date",
      description: "Date and time values"
    }
  };
  onDestroy(() => {
    if (modal) {
      modal.close();
      modal = null;
    }
    $$invalidate(3, contentEl = null);
  });
  function handleAccordionToggle(event) {
    $$invalidate(0, isOpen = event.detail.isOpen);
    if (isOpen) {
      $$invalidate(8, shouldRenderContent = true);
    }
  }
  function renderSettingsContent() {
    if (!contentEl || !contentEl.isConnected)
      return;
    contentEl.empty();
    new import_obsidian15.Setting(contentEl).setName("Property Name").setDesc("Enter a name for the property").addText((text2) => {
      text2.setPlaceholder("Enter property name").setValue($propertyState.formData.name).onChange((value) => handleFieldChange("name", value));
      return text2;
    });
    new import_obsidian15.Setting(contentEl).setName("Property Description").setDesc("Describe what this property is used for").addTextArea((text2) => {
      text2.setPlaceholder("Enter property description").setValue($propertyState.formData.description).onChange((value) => handleFieldChange("description", value));
      text2.inputEl.rows = 4;
      return text2;
    });
    new import_obsidian15.Setting(contentEl).addButton((button) => {
      button.setButtonText("Edit Properties").setCta().onClick(openEditModal);
      return button;
    });
    $$invalidate(8, shouldRenderContent = false);
  }
  function openEditModal() {
    if (modal)
      return;
    console.log("\u{1F50D} Opening properties editor modal");
    try {
      const properties = getCurrentPropertyState().customProperties;
      console.log("\u{1F50D} Current properties:", properties);
      modal = new PropertiesEditor2(app);
      modal.customCloseHandler = () => {
        console.log("\u{1F50D} Modal custom close handler");
        if (modal) {
          modal.close();
          modal = null;
        }
        uiStore.popModal();
      };
      const handleUpdate = (updatedProps) => __awaiter(this, void 0, void 0, function* () {
        console.log("\u{1F50D} Properties update handler");
        yield handlePropertiesUpdate(updatedProps);
        modal === null || modal === void 0 ? void 0 : modal.close();
        modal = null;
        uiStore.popModal();
      });
      uiStore.pushModal("properties-editor");
      modal.openWithProperties(properties, handleUpdate);
    } catch (error) {
      console.error("\u{1F50D} Error opening modal:", error);
      uiStore.popModal();
      modal === null || modal === void 0 ? void 0 : modal.close();
      modal = null;
      new import_obsidian15.Notice(`Failed to open properties editor: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  function handlePropertiesUpdate(updatedProperties) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        yield updatePropertyState({ customProperties: updatedProperties });
        new import_obsidian15.Notice("Properties updated successfully");
        $$invalidate(8, shouldRenderContent = true);
      } catch (error) {
        console.error("\u{1F987} Error updating properties:", error);
        new import_obsidian15.Notice(`Failed to update properties: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    });
  }
  function getCurrentPropertyState() {
    const settings = settingsService.getSettings();
    return {
      customProperties: settings.frontMatter.customProperties || []
    };
  }
  function updatePropertyState(state) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!settingsService.isReady()) {
        throw new Error("Settings service not ready");
      }
      const settings = settingsService.getSettings();
      yield settingsService.updateSettings(Object.assign(Object.assign({}, settings), {
        frontMatter: Object.assign(Object.assign({}, settings.frontMatter), { customProperties: state.customProperties })
      }));
    });
  }
  function validateField(field, value) {
    switch (field) {
      case "name":
        if (!(value === null || value === void 0 ? void 0 : value.trim()))
          return "Property name is required";
        if (value.trim().length < 2)
          return "Property name must be at least 2 characters";
        break;
      case "description":
        if (!(value === null || value === void 0 ? void 0 : value.trim()))
          return "Property description is required";
        if (value.trim().length < 10)
          return "Property description must be at least 10 characters";
        break;
      case "type":
        if (!value)
          return "Property type is required";
        if (!Object.keys(propertyTypes).includes(value))
          return "Invalid property type";
        break;
    }
    return null;
  }
  function handleFieldChange(field, value) {
    propertyState.update((s) => {
      const error = validateField(field, value);
      return Object.assign(Object.assign({}, s), {
        formData: Object.assign(Object.assign({}, s.formData), { [field]: value }),
        validationErrors: Object.assign(Object.assign({}, s.validationErrors), { [field]: error || "" })
      });
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      contentEl = $$value;
      $$invalidate(3, contentEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("description" in $$props2)
      $$invalidate(2, description = $$props2.description);
    if ("app" in $$props2)
      $$invalidate(6, app = $$props2.app);
    if ("settingsService" in $$props2)
      $$invalidate(7, settingsService = $$props2.settingsService);
    if ("isOpen" in $$props2)
      $$invalidate(0, isOpen = $$props2.isOpen);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*shouldRenderContent, isOpen, contentEl*/
    265) {
      $:
        if (shouldRenderContent && isOpen && contentEl) {
          renderSettingsContent();
        }
    }
  };
  return [
    isOpen,
    title,
    description,
    contentEl,
    propertyState,
    handleAccordionToggle,
    app,
    settingsService,
    shouldRenderContent,
    div_binding
  ];
}
var PropertyManagerAccordion = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance4,
      create_fragment4,
      safe_not_equal,
      {
        title: 1,
        description: 2,
        app: 6,
        settingsService: 7,
        isOpen: 0
      },
      add_css4
    );
  }
};
var PropertyManagerAccordion_default = PropertyManagerAccordion;

// src/components/accordions/TagManagerAccordion.svelte
var import_obsidian18 = require("obsidian");

// src/components/modals/TagEditor.svelte
var import_obsidian16 = require("obsidian");

// src/components/modals/EditTagsModal.svelte
var import_obsidian17 = require("obsidian");
function add_css5(target) {
  append_styles(target, "svelte-yi24wz", ".edit-tags-container.svelte-yi24wz{display:flex;flex-direction:column;gap:var(--size-2);padding:var(--size-4);max-height:70vh;overflow-y:auto}.tag-item{border:1px solid var(--background-modifier-border);border-radius:var(--radius-s);padding:var(--size-2) var(--size-4);margin-bottom:var(--size-2)}.setting-item-control{flex-wrap:wrap;gap:var(--size-2)}.setting-item-info{display:none}.search-input{width:200px}.tag-item textarea{min-height:60px;resize:vertical}");
}
function create_fragment5(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "edit-tags-container svelte-yi24wz");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[7](div);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      ctx[7](null);
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let filteredTags;
  let { tags } = $$props;
  let { onSubmit } = $$props;
  let { onClose } = $$props;
  let localTags = [...tags];
  let selectedIndices = /* @__PURE__ */ new Set();
  let searchQuery = "";
  let sortDirection = "asc";
  let containerEl;
  onMount(() => {
    renderTags();
  });
  function renderTags() {
    if (!containerEl)
      return;
    containerEl.empty();
    new import_obsidian17.Setting(containerEl).addSearch((search) => search.setPlaceholder("Search tags...").setValue(searchQuery).onChange((value) => {
      $$invalidate(5, searchQuery = value);
      renderTags();
    })).addExtraButton((button) => button.setIcon(sortDirection === "asc" ? "chevron-up" : "chevron-down").setTooltip(`Sort ${sortDirection === "asc" ? "descending" : "ascending"}`).onClick(() => {
      $$invalidate(6, sortDirection = sortDirection === "asc" ? "desc" : "asc");
      renderTags();
    }));
    new import_obsidian17.Setting(containerEl).addToggle((toggle) => toggle.setValue(selectedIndices.size === localTags.length).setTooltip("Select all").onChange((value) => handleSelectAll(value))).addButton((button) => button.setButtonText("Delete Selected").setWarning().setDisabled(selectedIndices.size === 0).onClick(handleDelete));
    filteredTags.forEach((tag, index) => {
      new import_obsidian17.Setting(containerEl).setClass("tag-item").addToggle((toggle) => toggle.setValue(selectedIndices.has(index)).onChange((value) => handleSelect(index, value))).addText((text2) => text2.setValue(tag.name).setPlaceholder("Tag name").onChange((value) => updateTag(index, "name", value))).addTextArea((text2) => text2.setValue(tag.description).setPlaceholder("Description").onChange((value) => updateTag(index, "description", value)));
    });
    new import_obsidian17.Setting(containerEl).addButton((button) => button.setButtonText("Save").setCta().onClick(handleSave)).addButton((button) => button.setButtonText("Cancel").onClick(onClose));
  }
  function updateTag(index, key, value) {
    const tagIndex = localTags.indexOf(filteredTags[index]);
    if (tagIndex !== -1) {
      $$invalidate(4, localTags[tagIndex] = Object.assign(Object.assign({}, localTags[tagIndex]), { [key]: value }), localTags);
      $$invalidate(4, localTags = [...localTags]);
      renderTags();
    }
  }
  function handleSelect(index, selected) {
    const tagIndex = localTags.indexOf(filteredTags[index]);
    if (tagIndex !== -1) {
      if (selected) {
        selectedIndices.add(tagIndex);
      } else {
        selectedIndices.delete(tagIndex);
      }
      selectedIndices = new Set(selectedIndices);
      renderTags();
    }
  }
  function handleSelectAll(selected) {
    if (selected) {
      selectedIndices = new Set(filteredTags.map((_, i) => i));
    } else {
      selectedIndices.clear();
    }
    renderTags();
  }
  function handleDelete() {
    const indicesToDelete = Array.from(selectedIndices);
    $$invalidate(4, localTags = localTags.filter((_, index) => !indicesToDelete.includes(index)));
    selectedIndices.clear();
    renderTags();
  }
  function handleSave() {
    const invalidTag = localTags.find((t) => !t.name || !t.description);
    if (invalidTag) {
      new import_obsidian17.Notice("All tags must have a name and description");
      return;
    }
    onSubmit(localTags);
    onClose();
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      containerEl = $$value;
      $$invalidate(0, containerEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("tags" in $$props2)
      $$invalidate(1, tags = $$props2.tags);
    if ("onSubmit" in $$props2)
      $$invalidate(2, onSubmit = $$props2.onSubmit);
    if ("onClose" in $$props2)
      $$invalidate(3, onClose = $$props2.onClose);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*localTags, searchQuery, sortDirection*/
    112) {
      $:
        filteredTags = localTags.filter((tag) => {
          if (!searchQuery)
            return true;
          const query = searchQuery.toLowerCase();
          return tag.name.toLowerCase().includes(query) || tag.description.toLowerCase().includes(query);
        }).sort((a, b) => {
          const comparison = a.name.localeCompare(b.name);
          return sortDirection === "asc" ? comparison : -comparison;
        });
    }
  };
  return [
    containerEl,
    tags,
    onSubmit,
    onClose,
    localTags,
    searchQuery,
    sortDirection,
    div_binding
  ];
}
var EditTagsModal_1 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, { tags: 1, onSubmit: 2, onClose: 3 }, add_css5);
  }
};
var EditTagsModal_default = EditTagsModal_1;

// src/services/tags/TagManagementService.ts
var TagManagementService = class {
  constructor(app, plugin) {
    this.app = app;
    this.isInitialized = false;
    this.plugin = plugin;
    this.metadataPath = `${this.plugin.manifest.dir}/tag-metadata.json`;
  }
  initialize() {
    return __async(this, null, function* () {
      try {
        yield this.ensureMetadataFile();
        this.isInitialized = true;
      } catch (error) {
        console.error("\u{1F987} Failed to initialize tag service:", error);
        yield this.saveMetadata({ tags: [], customTags: [] });
      }
    });
  }
  ensureMetadataFile() {
    return __async(this, null, function* () {
      try {
        const adapter = this.plugin.app.vault.adapter;
        const exists = yield adapter.exists(this.metadataPath);
        if (!exists) {
          yield this.saveMetadata({ tags: [], customTags: [] });
        }
      } catch (error) {
        console.error("\u{1F987} Error checking metadata file:", error);
        throw new Error("Failed to initialize tag service");
      }
    });
  }
  isReady() {
    return this.isInitialized;
  }
  updateTags(tags) {
    return __async(this, null, function* () {
      const currentData = yield this.loadMetadata();
      currentData.tags = tags;
      yield this.saveMetadata(currentData);
    });
  }
  getTags() {
    return __async(this, null, function* () {
      const metadata = yield this.loadMetadata();
      return metadata.tags;
    });
  }
  saveMetadata(data) {
    return __async(this, null, function* () {
      try {
        const adapter = this.app.vault.adapter;
        const dataString = JSON.stringify(data, null, 2);
        yield adapter.write(this.metadataPath, dataString);
      } catch (error) {
        console.error("\u{1F987} Failed to save metadata:", error);
        throw new Error("Failed to save metadata");
      }
    });
  }
  loadMetadata() {
    return __async(this, null, function* () {
      try {
        const adapter = this.app.vault.adapter;
        const dataString = yield adapter.read(this.metadataPath);
        return JSON.parse(dataString);
      } catch (error) {
        console.error("\u{1F987} Failed to load metadata:", error);
        throw new Error("Failed to load metadata");
      }
    });
  }
};

// src/components/accordions/TagManagerAccordion.svelte
function add_css6(target) {
  append_styles(target, "svelte-1rapyyn", ".tag-manager-content.svelte-1rapyyn{padding:var(--size-4)}.setting-item-error{color:var(--color-red);font-size:var(--font-ui-smaller);margin-top:var(--size-1)}.has-error{border-color:var(--color-red) !important}.setting-item:first-child{padding-top:0}.setting-item:last-child{padding-bottom:0;border-bottom:none}");
}
function create_default_slot3(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = ``;
      attr(div, "class", "tag-manager-content svelte-1rapyyn");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[9](div);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      ctx[9](null);
    }
  };
}
function create_fragment6(ctx) {
  let baseaccordion;
  let current;
  baseaccordion = new BaseAccordion_default({
    props: {
      title: (
        /*title*/
        ctx[0]
      ),
      description: (
        /*description*/
        ctx[1]
      ),
      isOpen: (
        /*isOpen*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(baseaccordion.$$.fragment);
    },
    m(target, anchor) {
      mount_component(baseaccordion, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const baseaccordion_changes = {};
      if (dirty & /*title*/
      1)
        baseaccordion_changes.title = /*title*/
        ctx2[0];
      if (dirty & /*description*/
      2)
        baseaccordion_changes.description = /*description*/
        ctx2[1];
      if (dirty & /*isOpen*/
      4)
        baseaccordion_changes.isOpen = /*isOpen*/
        ctx2[2];
      if (dirty & /*$$scope, contentEl*/
      524296) {
        baseaccordion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      baseaccordion.$set(baseaccordion_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(baseaccordion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(baseaccordion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(baseaccordion, detaching);
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let $tagState;
  var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  let { title } = $$props;
  let { description } = $$props;
  let { app } = $$props;
  let { settingsService } = $$props;
  let { isOpen = false } = $$props;
  let { tagManagementService = void 0 } = $$props;
  const settingsStore2 = getContext("settingsStore");
  const tagState = writable({
    isAddingTag: false,
    isServiceReady: false,
    formData: {
      name: "",
      description: "",
      type: "string",
      required: false,
      multipleValues: false
    },
    validationErrors: {},
    currentTags: []
  });
  component_subscribe($$self, tagState, (value) => $$invalidate(8, $tagState = value));
  const propertyTypes = {
    "string": {
      label: "Text",
      description: "Plain text value"
    },
    "number": {
      label: "Number",
      description: "Numeric value"
    },
    "boolean": {
      label: "True/False",
      description: "Boolean value"
    },
    "array": {
      label: "List",
      description: "Multiple values"
    },
    "date": {
      label: "Date",
      description: "Date/time value"
    }
  };
  let contentEl;
  onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    try {
      if (!app) {
        throw new Error("App instance not available");
      }
      if (!tagManagementService) {
        const plugin = getContext("plugin");
        $$invalidate(5, tagManagementService = new TagManagementService(app, plugin));
        yield tagManagementService.initialize();
      }
      const currentTags = yield tagManagementService.getTags();
      tagState.update((s) => Object.assign(Object.assign({}, s), { isServiceReady: true, currentTags }));
    } catch (error) {
      console.error("\u{1F987} Failed to initialize tag service:", error);
      new import_obsidian18.Notice("Failed to initialize tag management");
    }
  }));
  function validateField(field, value) {
    switch (field) {
      case "name":
        if (!(value === null || value === void 0 ? void 0 : value.trim()))
          return "Tag name is required";
        if (value.trim().length < 2)
          return "Tag name must be at least 2 characters";
        if (!/^[a-zA-Z0-9_-]+$/.test(value.trim()))
          return "Tag name can only contain letters, numbers, dashes, and underscores";
        if ($tagState.currentTags.some((t) => t.name.toLowerCase() === value.trim().toLowerCase()))
          return "Tag name already exists";
        break;
      case "description":
        if (!(value === null || value === void 0 ? void 0 : value.trim()))
          return "Tag description is required";
        if (value.trim().length < 5)
          return "Tag description must be at least 5 characters";
        break;
      case "type":
        if (!value)
          return "Tag type is required";
        if (!Object.keys(propertyTypes).includes(value))
          return "Invalid tag type";
        break;
    }
    return null;
  }
  function handleFieldChange(field, value) {
    tagState.update((s) => {
      const error = validateField(field, value);
      return Object.assign(Object.assign({}, s), {
        formData: Object.assign(Object.assign({}, s.formData), { [field]: value }),
        validationErrors: Object.assign(Object.assign({}, s.validationErrors), { [field]: error || "" })
      });
    });
  }
  function addTag() {
    return __awaiter(this, void 0, void 0, function* () {
      if ($tagState.isAddingTag || !$tagState.isServiceReady || !tagManagementService)
        return;
      try {
        tagState.update((s) => Object.assign(Object.assign({}, s), { isAddingTag: true }));
        const form = $tagState.formData;
        const newTag = {
          name: form.name.trim(),
          description: form.description.trim(),
          type: form.type,
          required: form.required,
          multipleValues: form.multipleValues
        };
        yield tagManagementService.updateTags([newTag]);
        tagState.update((s) => Object.assign(Object.assign({}, s), { currentTags: [...s.currentTags, newTag] }));
        new import_obsidian18.Notice(`Tag "${newTag.name}" added successfully!`);
        resetForm();
      } catch (error) {
        console.error("\u{1F987} Failed to add tag:", error);
        new import_obsidian18.Notice(`Error adding tag: ${error instanceof Error ? error.message : "Unknown error"}`);
      } finally {
        tagState.update((s) => Object.assign(Object.assign({}, s), { isAddingTag: false }));
      }
    });
  }
  function openEditModal() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        if (!$tagState.isServiceReady || !tagManagementService) {
          throw new Error("Tag service not ready");
        }
        let modalInstance = new EditTagsModal_default({
          target: document.body,
          props: {
            tags: $tagState.currentTags,
            onSubmit: handleTagsUpdate,
            onClose: () => modalInstance.$destroy()
          }
        });
      } catch (error) {
        console.error("\u{1F987} Error opening edit modal:", error);
        new import_obsidian18.Notice(`Failed to open edit modal: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    });
  }
  function handleTagsUpdate(updatedTags) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!tagManagementService)
        return;
      try {
        yield tagManagementService.updateTags(updatedTags);
        tagState.update((s) => Object.assign(Object.assign({}, s), { currentTags: updatedTags }));
        new import_obsidian18.Notice("Tags updated successfully");
      } catch (error) {
        console.error("\u{1F987} Error updating tags:", error);
        new import_obsidian18.Notice(`Failed to update tags: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    });
  }
  function resetForm() {
    tagState.update((s) => Object.assign(Object.assign({}, s), {
      formData: {
        name: "",
        description: "",
        type: "string",
        required: false,
        multipleValues: false
      },
      validationErrors: {}
    }));
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      contentEl = $$value;
      $$invalidate(3, contentEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("description" in $$props2)
      $$invalidate(1, description = $$props2.description);
    if ("app" in $$props2)
      $$invalidate(6, app = $$props2.app);
    if ("settingsService" in $$props2)
      $$invalidate(7, settingsService = $$props2.settingsService);
    if ("isOpen" in $$props2)
      $$invalidate(2, isOpen = $$props2.isOpen);
    if ("tagManagementService" in $$props2)
      $$invalidate(5, tagManagementService = $$props2.tagManagementService);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*contentEl, $tagState*/
    264) {
      $:
        if (contentEl && $tagState) {
          contentEl.empty();
          new import_obsidian18.Setting(contentEl).setHeading().setName("Add New Tag");
          new import_obsidian18.Setting(contentEl).setName("Tag Name").setDesc("Enter a name for the tag").addText((text2) => {
            var _a;
            text2.setPlaceholder("Enter tag name").setValue($tagState.formData.name).onChange((value) => handleFieldChange("name", value));
            if ($tagState.validationErrors.name) {
              text2.inputEl.addClass("has-error");
              const errorEl = contentEl.createEl("div", {
                cls: "setting-item-error",
                text: $tagState.validationErrors.name
              });
              (_a = text2.inputEl.parentElement) === null || _a === void 0 ? void 0 : _a.appendChild(errorEl);
            }
            return text2;
          });
          new import_obsidian18.Setting(contentEl).setName("Description").setDesc("Describe what this tag is used for").addTextArea((text2) => {
            var _a;
            text2.setPlaceholder("Enter tag description").setValue($tagState.formData.description).onChange((value) => handleFieldChange("description", value));
            text2.inputEl.rows = 4;
            if ($tagState.validationErrors.description) {
              text2.inputEl.addClass("has-error");
              const errorEl = contentEl.createEl("div", {
                cls: "setting-item-error",
                text: $tagState.validationErrors.description
              });
              (_a = text2.inputEl.parentElement) === null || _a === void 0 ? void 0 : _a.appendChild(errorEl);
            }
            return text2;
          });
          new import_obsidian18.Setting(contentEl).setName("Type").setDesc("Select the type of data this tag will store").addDropdown((dropdown) => {
            Object.entries(propertyTypes).forEach(([value, { label }]) => {
              dropdown.addOption(value, label);
            });
            dropdown.setValue($tagState.formData.type);
            dropdown.onChange((value) => handleFieldChange("type", value));
            return dropdown;
          });
          new import_obsidian18.Setting(contentEl).setName("Required").setDesc("Should this tag be required?").addToggle((toggle) => {
            toggle.setValue($tagState.formData.required).onChange((value) => {
              tagState.update((s) => Object.assign(Object.assign({}, s), {
                formData: Object.assign(Object.assign({}, s.formData), { required: value })
              }));
            });
            return toggle;
          });
          new import_obsidian18.Setting(contentEl).setName("Multiple Values").setDesc("Can this tag have multiple values?").addToggle((toggle) => {
            toggle.setValue($tagState.formData.multipleValues).onChange((value) => {
              tagState.update((s) => Object.assign(Object.assign({}, s), {
                formData: Object.assign(Object.assign({}, s.formData), { multipleValues: value })
              }));
            });
            return toggle;
          });
          new import_obsidian18.Setting(contentEl).addButton((button) => {
            button.setButtonText($tagState.isAddingTag ? "Adding..." : "Add Tag").setCta().setDisabled($tagState.isAddingTag || !$tagState.isServiceReady || Object.keys($tagState.validationErrors).length > 0).onClick(addTag);
            return button;
          }).addButton((button) => {
            button.setButtonText("Edit Tags").setDisabled(!$tagState.isServiceReady).onClick(openEditModal);
            return button;
          });
        }
    }
  };
  return [
    title,
    description,
    isOpen,
    contentEl,
    tagState,
    tagManagementService,
    app,
    settingsService,
    $tagState,
    div_binding
  ];
}
var TagManagerAccordion = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance6,
      create_fragment6,
      safe_not_equal,
      {
        title: 0,
        description: 1,
        app: 6,
        settingsService: 7,
        isOpen: 2,
        tagManagementService: 5
      },
      add_css6
    );
  }
};
var TagManagerAccordion_default = TagManagerAccordion;

// src/components/accordions/OntologyGenerationAccordion.svelte
var import_obsidian21 = require("obsidian");

// src/components/modals/OntologyGeneratorModal.svelte
var import_obsidian19 = require("obsidian");
var import_obsidian20 = require("obsidian");
function add_css7(target) {
  append_styles(target, "svelte-7cb176", ".ontology-generator-container.svelte-7cb176{display:flex;flex-direction:column;gap:var(--size-4);padding:var(--size-4)}.stats-container{display:grid;grid-template-columns:repeat(3, 1fr);gap:var(--size-4);margin-bottom:var(--size-4)}.stat-card{background-color:var(--background-secondary);border-radius:var(--radius-m);padding:var(--size-4);box-shadow:0 2px 4px rgba(0, 0, 0, 0.1)}.stat-card .setting-item-info{display:flex;flex-direction:column;align-items:center;text-align:center}.stat-card .setting-item-name{font-size:var(--font-ui-small);color:var(--text-muted)}.stat-card .setting-item-description{font-size:1.2em;font-weight:var(--font-bold);color:var(--text-normal)}.guided-questions{background-color:var(--background-secondary);border-radius:var(--radius-m);padding:var(--size-4);margin:var(--size-4) 0}.guided-questions h4{margin:0;margin-bottom:var(--size-2);color:var(--text-normal)}.guided-questions ul{margin:0;padding-left:var(--size-4);color:var(--text-muted)}.guided-questions li{margin-bottom:var(--size-2)}.setting-item textarea{min-height:100px;resize:vertical}");
}
function create_fragment7(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "ontology-generator-container svelte-7cb176");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[8](div);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      ctx[8](null);
    }
  };
}
function extractTags(content) {
  const tagRegex = /#(\w+)/g;
  const tags = [];
  let match;
  while ((match = tagRegex.exec(content)) !== null) {
    tags.push(match[1]);
  }
  return tags;
}
function instance7($$self, $$props, $$invalidate) {
  var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  let { app } = $$props;
  let { aiAdapter } = $$props;
  let { aiGenerationService } = $$props;
  let { tagManagementService } = $$props;
  let { adapterRegistry } = $$props;
  let { onGenerate } = $$props;
  let { onClose } = $$props;
  let containerEl;
  let isGenerating = false;
  let selectedModel = "";
  let userContext = "";
  let vaultStats = { files: [], folders: [], tags: [] };
  const availableModels = AIModelUtils.getModelsForProvider(aiAdapter.getProviderType()).map((model) => ({
    provider: aiAdapter.getProviderType(),
    model: model.name
  }));
  const guidedQuestions = [
    "What are the main themes or topics in your knowledge base?",
    "Are there any specific hierarchies or relationships between concepts that you want to emphasize?",
    "What are your goals for organizing your knowledge base?"
  ];
  onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    yield loadVaultStats();
    renderContent();
  }));
  function loadVaultStats() {
    return __awaiter(this, void 0, void 0, function* () {
      vaultStats.files = app.vault.getMarkdownFiles();
      vaultStats.folders = app.vault.getAllLoadedFiles().filter((file) => file instanceof import_obsidian19.TFolder);
      vaultStats.tags = yield getAllTags(vaultStats.files);
    });
  }
  function getAllTags(files) {
    return __awaiter(this, void 0, void 0, function* () {
      const tagSet = /* @__PURE__ */ new Set();
      for (const file of files) {
        const content = yield app.vault.read(file);
        extractTags(content).forEach((tag) => tagSet.add(tag));
      }
      return Array.from(tagSet);
    });
  }
  function renderContent() {
    if (!containerEl)
      return;
    containerEl.empty();
    const statsEl = containerEl.createDiv("stats-container");
    new import_obsidian19.Setting(statsEl).setClass("stat-card").setHeading().setName("Files").setDesc(vaultStats.files.length.toString()).addExtraButton((button) => button.setIcon("file").setDisabled(true));
    new import_obsidian19.Setting(statsEl).setClass("stat-card").setHeading().setName("Folders").setDesc(vaultStats.folders.length.toString()).addExtraButton((button) => button.setIcon("folder").setDisabled(true));
    new import_obsidian19.Setting(statsEl).setClass("stat-card").setHeading().setName("Tags").setDesc(vaultStats.tags.length.toString()).addExtraButton((button) => button.setIcon("tag").setDisabled(true));
    new import_obsidian19.Setting(containerEl).setName("AI Model").setDesc("Select the AI model to use for ontology generation").addDropdown((dropdown) => dropdown.addOptions(Object.fromEntries(availableModels.map((m) => [m.model, m.model]))).setValue(selectedModel).onChange((value) => selectedModel = value));
    new import_obsidian19.Setting(containerEl).setName("Additional Context").setDesc("Provide any additional context or information about your knowledge base.").addTextArea((text2) => text2.setValue(userContext).setPlaceholder("Enter additional context here...").onChange((value) => userContext = value));
    const questionsEl = containerEl.createDiv("guided-questions");
    questionsEl.createEl("h4", { text: "Consider These Questions" });
    const ul = questionsEl.createEl("ul");
    guidedQuestions.forEach((question) => {
      ul.createEl("li", { text: question });
    });
    new import_obsidian19.Setting(containerEl).addButton((button) => button.setButtonText(isGenerating ? "Generating..." : "Generate Ontology").setCta().setDisabled(isGenerating || !selectedModel).onClick(() => handleGenerate())).addButton((button) => button.setButtonText("Cancel").onClick(onClose));
  }
  function handleGenerate() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!selectedModel) {
        new import_obsidian19.Notice("Please select an AI model.");
        return;
      }
      isGenerating = true;
      renderContent();
      try {
        const input = {
          files: vaultStats.files,
          folders: vaultStats.folders,
          tags: vaultStats.tags,
          provider: aiAdapter.getProviderType(),
          modelApiName: selectedModel,
          userContext
        };
        const ontology = yield aiGenerationService.generateOntology(input);
        onGenerate(ontology);
        new import_obsidian19.Notice("Ontology generated successfully.");
        onClose();
      } catch (error) {
        console.error("Error generating ontology:", error);
        new import_obsidian19.Notice(`Error generating ontology: ${error instanceof Error ? error.message : "Unknown error"}`);
      } finally {
        isGenerating = false;
        renderContent();
      }
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      containerEl = $$value;
      $$invalidate(0, containerEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(1, app = $$props2.app);
    if ("aiAdapter" in $$props2)
      $$invalidate(2, aiAdapter = $$props2.aiAdapter);
    if ("aiGenerationService" in $$props2)
      $$invalidate(3, aiGenerationService = $$props2.aiGenerationService);
    if ("tagManagementService" in $$props2)
      $$invalidate(4, tagManagementService = $$props2.tagManagementService);
    if ("adapterRegistry" in $$props2)
      $$invalidate(5, adapterRegistry = $$props2.adapterRegistry);
    if ("onGenerate" in $$props2)
      $$invalidate(6, onGenerate = $$props2.onGenerate);
    if ("onClose" in $$props2)
      $$invalidate(7, onClose = $$props2.onClose);
  };
  return [
    containerEl,
    app,
    aiAdapter,
    aiGenerationService,
    tagManagementService,
    adapterRegistry,
    onGenerate,
    onClose,
    div_binding
  ];
}
var OntologyGeneratorModal_1 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance7,
      create_fragment7,
      safe_not_equal,
      {
        app: 1,
        aiAdapter: 2,
        aiGenerationService: 3,
        tagManagementService: 4,
        adapterRegistry: 5,
        onGenerate: 6,
        onClose: 7
      },
      add_css7
    );
  }
};
var OntologyGeneratorModal_default = OntologyGeneratorModal_1;

// src/components/accordions/OntologyGenerationAccordion.svelte
function add_css8(target) {
  append_styles(target, "svelte-1m31p3l", ".ontology-generation-container.svelte-1m31p3l{display:flex;flex-direction:column;gap:var(--size-4);padding:var(--size-4)}.error-message.svelte-1m31p3l{color:var(--color-red);font-size:var(--font-ui-small);padding:var(--size-2);background-color:var(--background-modifier-error);border-radius:var(--radius-s);margin-bottom:var(--size-2)}.description-content.svelte-1m31p3l{margin-bottom:var(--size-4)}.description-text.svelte-1m31p3l{color:var(--text-muted);font-size:var(--font-ui-small);margin:0;margin-bottom:var(--size-2)}.status-message.svelte-1m31p3l{font-size:var(--font-ui-small);color:var(--text-muted);margin-top:var(--size-2)}.tag-count.svelte-1m31p3l{font-weight:var(--font-medium);padding:var(--size-1) var(--size-2);border-radius:var(--radius-s);margin:0 var(--size-1)}.tag-count.new.svelte-1m31p3l{background-color:var(--color-green-rgb);color:var(--text-on-accent)}.tag-count.modified.svelte-1m31p3l{background-color:var(--color-yellow-rgb);color:var(--text-normal)}.button-container.svelte-1m31p3l{display:flex;justify-content:flex-start}button.mod-cta.svelte-1m31p3l{background-color:var(--interactive-accent);color:var(--text-on-accent);padding:var(--size-2) var(--size-4);border-radius:var(--radius-s);font-weight:var(--font-medium);border:none;cursor:pointer;transition:background-color 0.2s ease}button.mod-cta.svelte-1m31p3l:hover:not(:disabled){background-color:var(--interactive-accent-hover)}button.mod-cta.svelte-1m31p3l:disabled{opacity:0.5;cursor:not-allowed}.theme-dark .ontology-generation-container.svelte-1m31p3l{background-color:var(--background-primary-alt)}");
}
function create_if_block_3(ctx) {
  let div;
  let t_value = (
    /*$state*/
    ctx[3].error.message + ""
  );
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "error-message svelte-1m31p3l");
      attr(div, "role", "alert");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*$state*/
      8 && t_value !== (t_value = /*$state*/
      ctx2[3].error.message + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block2(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let if_block0 = (
    /*$state*/
    ctx[3].processedTags.new > 0 && create_if_block_2(ctx)
  );
  let if_block1 = (
    /*$state*/
    ctx[3].processedTags.modified > 0 && create_if_block_12(ctx)
  );
  return {
    c() {
      div = element("div");
      t0 = text("Last generation found:\r\n                  ");
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = text("\r\n                  tags");
      attr(div, "class", "status-message svelte-1m31p3l");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      append(div, t2);
    },
    p(ctx2, dirty) {
      if (
        /*$state*/
        ctx2[3].processedTags.new > 0
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*$state*/
        ctx2[3].processedTags.modified > 0
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_12(ctx2);
          if_block1.c();
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function create_if_block_2(ctx) {
  let span;
  let t0_value = (
    /*$state*/
    ctx[3].processedTags.new + ""
  );
  let t0;
  let t1;
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = text(" new");
      attr(span, "class", "tag-count new svelte-1m31p3l");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*$state*/
      8 && t0_value !== (t0_value = /*$state*/
      ctx2[3].processedTags.new + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_12(ctx) {
  let span;
  let t0_value = (
    /*$state*/
    ctx[3].processedTags.modified + ""
  );
  let t0;
  let t1;
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = text(" modified");
      attr(span, "class", "tag-count modified svelte-1m31p3l");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*$state*/
      8 && t0_value !== (t0_value = /*$state*/
      ctx2[3].processedTags.modified + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_default_slot4(ctx) {
  let div2;
  let t0;
  let div0;
  let p;
  let t2;
  let t3;
  let div1;
  let button;
  let t4_value = (
    /*$state*/
    ctx[3].isGenerating ? "Generating..." : "Generate Ontology"
  );
  let t4;
  let button_disabled_value;
  let button_aria_disabled_value;
  let mounted;
  let dispose;
  let if_block0 = (
    /*$state*/
    ctx[3].error && create_if_block_3(ctx)
  );
  let if_block1 = (
    /*$state*/
    (ctx[3].processedTags.new > 0 || /*$state*/
    ctx[3].processedTags.modified > 0) && create_if_block2(ctx)
  );
  return {
    c() {
      div2 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      p = element("p");
      p.textContent = "Generate and manage ontologies for your vault. This will analyze your notes \r\n              and suggest appropriate tags and relationships.";
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      div1 = element("div");
      button = element("button");
      t4 = text(t4_value);
      attr(p, "class", "description-text svelte-1m31p3l");
      attr(div0, "class", "description-content svelte-1m31p3l");
      attr(button, "class", "mod-cta svelte-1m31p3l");
      button.disabled = button_disabled_value = /*$state*/
      ctx[3].isGenerating || !/*$state*/
      ctx[3].isInitialized || /*$state*/
      ctx[3].lifecycle !== "ready" /* Ready */;
      attr(button, "aria-disabled", button_aria_disabled_value = /*$state*/
      ctx[3].isGenerating || !/*$state*/
      ctx[3].isInitialized || /*$state*/
      ctx[3].lifecycle !== "ready" /* Ready */);
      attr(div1, "class", "button-container svelte-1m31p3l");
      attr(div2, "class", "ontology-generation-container svelte-1m31p3l");
      attr(div2, "role", "region");
      attr(div2, "aria-label", "Ontology Generation");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if (if_block0)
        if_block0.m(div2, null);
      append(div2, t0);
      append(div2, div0);
      append(div0, p);
      append(div0, t2);
      if (if_block1)
        if_block1.m(div0, null);
      append(div2, t3);
      append(div2, div1);
      append(div1, button);
      append(button, t4);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*openOntologyGeneratorModal*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (
        /*$state*/
        ctx2[3].error
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_3(ctx2);
          if_block0.c();
          if_block0.m(div2, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*$state*/
        ctx2[3].processedTags.new > 0 || /*$state*/
        ctx2[3].processedTags.modified > 0
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block2(ctx2);
          if_block1.c();
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & /*$state*/
      8 && t4_value !== (t4_value = /*$state*/
      ctx2[3].isGenerating ? "Generating..." : "Generate Ontology"))
        set_data(t4, t4_value);
      if (dirty & /*$state*/
      8 && button_disabled_value !== (button_disabled_value = /*$state*/
      ctx2[3].isGenerating || !/*$state*/
      ctx2[3].isInitialized || /*$state*/
      ctx2[3].lifecycle !== "ready" /* Ready */)) {
        button.disabled = button_disabled_value;
      }
      if (dirty & /*$state*/
      8 && button_aria_disabled_value !== (button_aria_disabled_value = /*$state*/
      ctx2[3].isGenerating || !/*$state*/
      ctx2[3].isInitialized || /*$state*/
      ctx2[3].lifecycle !== "ready" /* Ready */)) {
        attr(button, "aria-disabled", button_aria_disabled_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
function create_fragment8(ctx) {
  let baseaccordion;
  let current;
  baseaccordion = new BaseAccordion_default({
    props: {
      title: (
        /*title*/
        ctx[0]
      ),
      description: (
        /*description*/
        ctx[1]
      ),
      isOpen: (
        /*isOpen*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(baseaccordion.$$.fragment);
    },
    m(target, anchor) {
      mount_component(baseaccordion, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const baseaccordion_changes = {};
      if (dirty & /*title*/
      1)
        baseaccordion_changes.title = /*title*/
        ctx2[0];
      if (dirty & /*description*/
      2)
        baseaccordion_changes.description = /*description*/
        ctx2[1];
      if (dirty & /*isOpen*/
      4)
        baseaccordion_changes.isOpen = /*isOpen*/
        ctx2[2];
      if (dirty & /*$$scope, $state*/
      134217736) {
        baseaccordion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      baseaccordion.$set(baseaccordion_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(baseaccordion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(baseaccordion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(baseaccordion, detaching);
    }
  };
}
function processOntologyTags(suggestedTags, existingTags) {
  const existingTagMap = new Map(existingTags.map((tag) => [tag.name.toLowerCase(), tag]));
  const newTags = [];
  const modifiedTags = [];
  const unchangedTags = [];
  suggestedTags.forEach((suggestedTag) => {
    const existingTag = existingTagMap.get(suggestedTag.name.toLowerCase());
    if (!existingTag) {
      newTags.push(createNewTag(suggestedTag));
    } else if (hasTagChanges(existingTag, suggestedTag)) {
      modifiedTags.push(mergeTagChanges(existingTag, suggestedTag));
    } else {
      unchangedTags.push(existingTag);
    }
  });
  return { newTags, modifiedTags, unchangedTags };
}
function createNewTag(suggestedTag) {
  return {
    name: suggestedTag.name,
    description: suggestedTag.description,
    type: "string",
    required: false,
    multipleValues: false,
    defaultValue: void 0,
    options: void 0
  };
}
function hasTagChanges(existingTag, suggestedTag) {
  return existingTag.description !== suggestedTag.description || existingTag.type !== suggestedTag.type || existingTag.multipleValues !== suggestedTag.multipleValues;
}
function mergeTagChanges(existingTag, suggestedTag) {
  var _a;
  return Object.assign(Object.assign({}, existingTag), {
    description: suggestedTag.description || existingTag.description,
    type: suggestedTag.type || existingTag.type,
    multipleValues: (_a = suggestedTag.multipleValues) !== null && _a !== void 0 ? _a : existingTag.multipleValues
  });
}
function mergeTags(currentTags, updatedTags) {
  const updatedTagMap = new Map(updatedTags.map((tag) => [tag.name.toLowerCase(), tag]));
  return currentTags.map((tag) => updatedTagMap.get(tag.name.toLowerCase()) || tag);
}
function instance8($$self, $$props, $$invalidate) {
  let $state;
  var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  let { title } = $$props;
  let { description } = $$props;
  let { app } = $$props;
  let { settingsService } = $$props;
  let { aiService } = $$props;
  let { aiAdapter } = $$props;
  let { generationService } = $$props;
  let { adapterRegistry } = $$props;
  let { tagManagementService } = $$props;
  let { isOpen = false } = $$props;
  let { onChange } = $$props;
  let { onBlur } = $$props;
  let { onFocus } = $$props;
  let { onClick } = $$props;
  let { onKeyDown } = $$props;
  const state = writable({
    isInitialized: false,
    isGenerating: false,
    processedTags: { new: 0, modified: 0, unchanged: 0 },
    currentModal: null,
    lifecycle: "uninitialized" /* Uninitialized */,
    error: null,
    validationResult: null,
    lastUpdated: Date.now()
  });
  component_subscribe($$self, state, (value) => $$invalidate(3, $state = value));
  let modal = null;
  onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    try {
      yield initializeComponent();
      state.update((s) => Object.assign(Object.assign({}, s), {
        lifecycle: "ready" /* Ready */,
        isInitialized: true
      }));
    } catch (error) {
      console.error("\u{1F987} Failed to initialize Ontology Generation:", error);
      handleError(error);
    }
  }));
  onDestroy(() => {
    modal === null || modal === void 0 ? void 0 : modal.$destroy();
    modal = null;
  });
  function initializeComponent() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!settingsService.isReady()) {
        throw new Error("Settings service not ready");
      }
      if (!tagManagementService) {
        throw new Error("Tag management service not provided");
      }
    });
  }
  function openOntologyGeneratorModal() {
    return __awaiter(this, void 0, void 0, function* () {
      if ($state.isGenerating || $state.currentModal)
        return;
      try {
        ensureServices();
        state.update((s) => Object.assign(Object.assign({}, s), {
          isGenerating: true,
          currentModal: "generator"
        }));
        modal = new OntologyGeneratorModal_default({
          target: document.body,
          props: {
            app,
            aiAdapter,
            aiGenerationService: generationService,
            tagManagementService,
            adapterRegistry,
            onGenerate: handleOntologyGenerated,
            onClose: handleModalClose
          }
        });
      } catch (error) {
        console.error("\u{1F987} Failed to open ontology generator:", error);
        handleError(error);
      }
    });
  }
  function ensureServices() {
    if (!settingsService.isReady()) {
      throw new Error("Settings service not ready");
    }
    if (!aiAdapter) {
      throw new Error("AI adapter not provided");
    }
    if (!generationService) {
      throw new Error("Generation service not provided");
    }
    if (!tagManagementService) {
      throw new Error("Tag management service not provided");
    }
  }
  function handleOntologyGenerated(ontology) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      try {
        if (!((_a = ontology === null || ontology === void 0 ? void 0 : ontology.tags) === null || _a === void 0 ? void 0 : _a.length)) {
          throw new Error("No tags suggested in ontology result");
        }
        const existingTags = settingsService.getSettings().tags.customTags;
        const result = processOntologyTags(ontology.tags, existingTags);
        state.update((s) => Object.assign(Object.assign({}, s), {
          processedTags: {
            new: result.newTags.length,
            modified: result.modifiedTags.length,
            unchanged: result.unchangedTags.length
          }
        }));
        if (result.newTags.length === 0 && result.modifiedTags.length === 0) {
          new import_obsidian21.Notice("No new or modified tags found in the ontology.");
          return;
        }
        yield openEditTagsModal([...result.newTags, ...result.modifiedTags]);
        new import_obsidian21.Notice(`Found ${result.newTags.length} new and ${result.modifiedTags.length} modified tags. Please review.`);
      } catch (error) {
        console.error("\u{1F987} Failed to handle generated ontology:", error);
        handleError(error);
      }
    });
  }
  function openEditTagsModal(tags) {
    return __awaiter(this, void 0, void 0, function* () {
      state.update((s) => Object.assign(Object.assign({}, s), { currentModal: "editor" }));
      new EditTagsModal_default({
        target: document.body,
        props: {
          tags,
          onSubmit: handleTagsUpdate,
          onClose: handleModalClose
        }
      });
    });
  }
  function handleTagsUpdate(updatedTags) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const currentTags = settingsService.getSettings().tags.customTags;
        const mergedTags = mergeTags(currentTags, updatedTags);
        yield settingsService.updateNestedSetting("tags", "customTags", mergedTags);
        new import_obsidian21.Notice("Tags updated successfully");
        onChange === null || onChange === void 0 ? void 0 : onChange(mergedTags);
      } catch (error) {
        console.error("\u{1F987} Failed to save tags:", error);
        handleError(error);
      }
    });
  }
  function handleModalClose() {
    modal === null || modal === void 0 ? void 0 : modal.$destroy();
    modal = null;
    state.update((s) => Object.assign(Object.assign({}, s), { isGenerating: false, currentModal: null }));
  }
  function handleError(error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    state.update((s) => Object.assign(Object.assign({}, s), {
      error: {
        message,
        timestamp: Date.now(),
        source: "OntologyGenerationAccordion",
        retryCount: 0
      },
      lifecycle: "error" /* Error */,
      lastUpdated: Date.now()
    }));
    new import_obsidian21.Notice(`Ontology Generation Error: ${message}`);
  }
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("description" in $$props2)
      $$invalidate(1, description = $$props2.description);
    if ("app" in $$props2)
      $$invalidate(6, app = $$props2.app);
    if ("settingsService" in $$props2)
      $$invalidate(7, settingsService = $$props2.settingsService);
    if ("aiService" in $$props2)
      $$invalidate(8, aiService = $$props2.aiService);
    if ("aiAdapter" in $$props2)
      $$invalidate(9, aiAdapter = $$props2.aiAdapter);
    if ("generationService" in $$props2)
      $$invalidate(10, generationService = $$props2.generationService);
    if ("adapterRegistry" in $$props2)
      $$invalidate(11, adapterRegistry = $$props2.adapterRegistry);
    if ("tagManagementService" in $$props2)
      $$invalidate(12, tagManagementService = $$props2.tagManagementService);
    if ("isOpen" in $$props2)
      $$invalidate(2, isOpen = $$props2.isOpen);
    if ("onChange" in $$props2)
      $$invalidate(13, onChange = $$props2.onChange);
    if ("onBlur" in $$props2)
      $$invalidate(14, onBlur = $$props2.onBlur);
    if ("onFocus" in $$props2)
      $$invalidate(15, onFocus = $$props2.onFocus);
    if ("onClick" in $$props2)
      $$invalidate(16, onClick = $$props2.onClick);
    if ("onKeyDown" in $$props2)
      $$invalidate(17, onKeyDown = $$props2.onKeyDown);
  };
  return [
    title,
    description,
    isOpen,
    $state,
    state,
    openOntologyGeneratorModal,
    app,
    settingsService,
    aiService,
    aiAdapter,
    generationService,
    adapterRegistry,
    tagManagementService,
    onChange,
    onBlur,
    onFocus,
    onClick,
    onKeyDown
  ];
}
var OntologyGenerationAccordion = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance8,
      create_fragment8,
      safe_not_equal,
      {
        title: 0,
        description: 1,
        app: 6,
        settingsService: 7,
        aiService: 8,
        aiAdapter: 9,
        generationService: 10,
        adapterRegistry: 11,
        tagManagementService: 12,
        isOpen: 2,
        onChange: 13,
        onBlur: 14,
        onFocus: 15,
        onClick: 16,
        onKeyDown: 17
      },
      add_css8
    );
  }
};
var OntologyGenerationAccordion_default = OntologyGenerationAccordion;

// src/components/accordions/KnowledgeBloomAccordion.svelte
var import_obsidian22 = require("obsidian");
function add_css9(target) {
  append_styles(target, "svelte-1jh8vo0", ".knowledge-bloom-settings.svelte-1jh8vo0{padding:var(--size-4);display:flex;flex-direction:column;gap:var(--size-4)}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i];
  return child_ctx;
}
function create_if_block3(ctx) {
  let div;
  let t_value = (
    /*$state*/
    ctx[3].error.message + ""
  );
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "error-message");
      attr(div, "role", "alert");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*$state*/
      8 && t_value !== (t_value = /*$state*/
      ctx2[3].error.message + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_each_block(ctx) {
  let option;
  let t0_value = (
    /*modelInfo*/
    ctx[26].model.name + ""
  );
  let t0;
  let t1;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t0 = text(t0_value);
      t1 = space();
      option.__value = option_value_value = /*modelInfo*/
      ctx[26].model.apiName;
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t0);
      append(option, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*$state*/
      8 && t0_value !== (t0_value = /*modelInfo*/
      ctx2[26].model.name + ""))
        set_data(t0, t0_value);
      if (dirty & /*$state*/
      8 && option_value_value !== (option_value_value = /*modelInfo*/
      ctx2[26].model.apiName)) {
        option.__value = option_value_value;
        set_input_value(option, option.__value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_default_slot5(ctx) {
  let form;
  let t0;
  let div1;
  let t2;
  let div5;
  let div3;
  let t6;
  let div4;
  let select;
  let select_disabled_value;
  let select_aria_disabled_value;
  let t7;
  let div9;
  let div7;
  let t11;
  let div8;
  let textarea;
  let textarea_disabled_value;
  let textarea_aria_disabled_value;
  let t12;
  let div11;
  let div10;
  let button;
  let t13_value = (
    /*$state*/
    ctx[3].isGenerating ? "Generating..." : "Generate Knowledge Bloom"
  );
  let t13;
  let button_disabled_value;
  let button_aria_disabled_value;
  let mounted;
  let dispose;
  let if_block = (
    /*$state*/
    ctx[3].error && create_if_block3(ctx)
  );
  let each_value = ensure_array_like(
    /*$state*/
    ctx[3].models
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      form = element("form");
      if (if_block)
        if_block.c();
      t0 = space();
      div1 = element("div");
      div1.innerHTML = `<div class="setting-item-description">Knowledge Bloom analyzes the current note, extracts wikilinks, and generates new notes for each link. 
              For best results, use Perplexity models for up-to-date information.</div>`;
      t2 = space();
      div5 = element("div");
      div3 = element("div");
      div3.innerHTML = `<label for="model-select" class="setting-item-name">AI Model</label> <div class="setting-item-description">Select the AI model to use for Knowledge Bloom</div>`;
      t6 = space();
      div4 = element("div");
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t7 = space();
      div9 = element("div");
      div7 = element("div");
      div7.innerHTML = `<label for="context-input" class="setting-item-name">Additional Context</label> <div class="setting-item-description">Provide any additional context or instructions for note generation (optional)</div>`;
      t11 = space();
      div8 = element("div");
      textarea = element("textarea");
      t12 = space();
      div11 = element("div");
      div10 = element("div");
      button = element("button");
      t13 = text(t13_value);
      attr(div1, "class", "setting-item description-item");
      attr(div3, "class", "setting-item-info");
      attr(select, "id", "model-select");
      select.disabled = select_disabled_value = !/*$state*/
      ctx[3].isInitialized || /*$state*/
      ctx[3].isGenerating;
      attr(select, "aria-disabled", select_aria_disabled_value = !/*$state*/
      ctx[3].isInitialized || /*$state*/
      ctx[3].isGenerating);
      if (
        /*$state*/
        ctx[3].selectedModel === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[17].call(select)
        ));
      attr(div4, "class", "setting-item-control");
      attr(div5, "class", "setting-item");
      attr(div7, "class", "setting-item-info");
      attr(textarea, "id", "context-input");
      attr(textarea, "placeholder", "Enter your prompts here...");
      textarea.disabled = textarea_disabled_value = /*$state*/
      ctx[3].isGenerating;
      attr(textarea, "aria-disabled", textarea_aria_disabled_value = /*$state*/
      ctx[3].isGenerating);
      attr(div8, "class", "setting-item-control");
      attr(div9, "class", "setting-item");
      attr(button, "type", "submit");
      attr(button, "class", "mod-cta");
      button.disabled = button_disabled_value = /*$state*/
      ctx[3].isGenerating || !/*$state*/
      ctx[3].isInitialized || /*$state*/
      ctx[3].lifecycle !== "ready" /* Ready */;
      attr(button, "aria-disabled", button_aria_disabled_value = /*$state*/
      ctx[3].isGenerating || !/*$state*/
      ctx[3].isInitialized || /*$state*/
      ctx[3].lifecycle !== "ready" /* Ready */);
      attr(div10, "class", "setting-item-control");
      attr(div11, "class", "setting-item");
      attr(form, "class", "knowledge-bloom-settings svelte-1jh8vo0");
      attr(form, "aria-label", "Knowledge Bloom Settings");
    },
    m(target, anchor) {
      insert(target, form, anchor);
      if (if_block)
        if_block.m(form, null);
      append(form, t0);
      append(form, div1);
      append(form, t2);
      append(form, div5);
      append(div5, div3);
      append(div5, t6);
      append(div5, div4);
      append(div4, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*$state*/
        ctx[3].selectedModel,
        true
      );
      append(form, t7);
      append(form, div9);
      append(div9, div7);
      append(div9, t11);
      append(div9, div8);
      append(div8, textarea);
      set_input_value(
        textarea,
        /*$state*/
        ctx[3].userPromptInput
      );
      append(form, t12);
      append(form, div11);
      append(div11, div10);
      append(div10, button);
      append(button, t13);
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[17]
          ),
          listen(
            select,
            "change",
            /*change_handler*/
            ctx[18]
          ),
          listen(
            textarea,
            "input",
            /*textarea_input_handler*/
            ctx[19]
          ),
          listen(
            textarea,
            "input",
            /*input_handler*/
            ctx[20]
          ),
          listen(form, "submit", prevent_default(
            /*handleGenerateKnowledgeBloom*/
            ctx[7]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (
        /*$state*/
        ctx2[3].error
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          if_block.m(form, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*$state*/
      8) {
        each_value = ensure_array_like(
          /*$state*/
          ctx2[3].models
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*$state*/
      8 && select_disabled_value !== (select_disabled_value = !/*$state*/
      ctx2[3].isInitialized || /*$state*/
      ctx2[3].isGenerating)) {
        select.disabled = select_disabled_value;
      }
      if (dirty & /*$state*/
      8 && select_aria_disabled_value !== (select_aria_disabled_value = !/*$state*/
      ctx2[3].isInitialized || /*$state*/
      ctx2[3].isGenerating)) {
        attr(select, "aria-disabled", select_aria_disabled_value);
      }
      if (dirty & /*$state*/
      8) {
        select_option(
          select,
          /*$state*/
          ctx2[3].selectedModel
        );
      }
      if (dirty & /*$state*/
      8 && textarea_disabled_value !== (textarea_disabled_value = /*$state*/
      ctx2[3].isGenerating)) {
        textarea.disabled = textarea_disabled_value;
      }
      if (dirty & /*$state*/
      8 && textarea_aria_disabled_value !== (textarea_aria_disabled_value = /*$state*/
      ctx2[3].isGenerating)) {
        attr(textarea, "aria-disabled", textarea_aria_disabled_value);
      }
      if (dirty & /*$state*/
      8) {
        set_input_value(
          textarea,
          /*$state*/
          ctx2[3].userPromptInput
        );
      }
      if (dirty & /*$state*/
      8 && t13_value !== (t13_value = /*$state*/
      ctx2[3].isGenerating ? "Generating..." : "Generate Knowledge Bloom"))
        set_data(t13, t13_value);
      if (dirty & /*$state*/
      8 && button_disabled_value !== (button_disabled_value = /*$state*/
      ctx2[3].isGenerating || !/*$state*/
      ctx2[3].isInitialized || /*$state*/
      ctx2[3].lifecycle !== "ready" /* Ready */)) {
        button.disabled = button_disabled_value;
      }
      if (dirty & /*$state*/
      8 && button_aria_disabled_value !== (button_aria_disabled_value = /*$state*/
      ctx2[3].isGenerating || !/*$state*/
      ctx2[3].isInitialized || /*$state*/
      ctx2[3].lifecycle !== "ready" /* Ready */)) {
        attr(button, "aria-disabled", button_aria_disabled_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(form);
      }
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment9(ctx) {
  let baseaccordion;
  let current;
  baseaccordion = new BaseAccordion_default({
    props: {
      title: (
        /*title*/
        ctx[0]
      ),
      description: (
        /*description*/
        ctx[1]
      ),
      isOpen: (
        /*isOpen*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(baseaccordion.$$.fragment);
    },
    m(target, anchor) {
      mount_component(baseaccordion, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const baseaccordion_changes = {};
      if (dirty & /*title*/
      1)
        baseaccordion_changes.title = /*title*/
        ctx2[0];
      if (dirty & /*description*/
      2)
        baseaccordion_changes.description = /*description*/
        ctx2[1];
      if (dirty & /*isOpen*/
      4)
        baseaccordion_changes.isOpen = /*isOpen*/
        ctx2[2];
      if (dirty & /*$$scope, $state*/
      536870920) {
        baseaccordion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      baseaccordion.$set(baseaccordion_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(baseaccordion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(baseaccordion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(baseaccordion, detaching);
    }
  };
}
function instance9($$self, $$props, $$invalidate) {
  let $state;
  var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  let { title } = $$props;
  let { description } = $$props;
  let { app } = $$props;
  let { settingsService } = $$props;
  let { aiService } = $$props;
  let { isOpen = false } = $$props;
  let { initialModel = "" } = $$props;
  let { onChange } = $$props;
  let { onBlur } = $$props;
  let { onFocus } = $$props;
  let { onClick } = $$props;
  let { onKeyDown } = $$props;
  const state = writable({
    isInitialized: false,
    models: [],
    selectedModel: initialModel,
    userPromptInput: "",
    isGenerating: false,
    lifecycle: "uninitialized" /* Uninitialized */,
    error: void 0,
    validationResult: void 0,
    lastUpdated: Date.now()
  });
  component_subscribe($$self, state, (value) => $$invalidate(3, $state = value));
  onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    try {
      yield initializeComponent();
      state.update((s) => Object.assign(Object.assign({}, s), {
        isInitialized: true,
        lifecycle: "ready" /* Ready */
      }));
    } catch (error) {
      console.error("\u{1F987} Failed to initialize Knowledge Bloom:", error);
      handleError(error);
    }
  }));
  function initializeModels() {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      if (!settingsService.isReady()) {
        throw new Error("Settings service not ready");
      }
      const modelList = Object.entries(AIModelMap).flatMap(([provider, models]) => models.map((model) => ({ provider, model })));
      const settings = settingsService.getSettings();
      const currentModel = ((_a = settings.knowledgeBloom) === null || _a === void 0 ? void 0 : _a.selectedModel) || (modelList.length > 0 ? modelList[0].model.apiName : "");
      state.update((s) => Object.assign(Object.assign({}, s), {
        models: modelList,
        selectedModel: currentModel,
        lastUpdated: Date.now()
      }));
      if (currentModel) {
        yield updateKnowledgeBloomSettings(currentModel);
      }
    });
  }
  function updateKnowledgeBloomSettings(model) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        yield settingsService.updateKnowledgeBloomSettings({ selectedModel: model });
        yield aiService.reinitialize();
        state.update((s) => Object.assign(Object.assign({}, s), {
          selectedModel: model,
          lastUpdated: Date.now()
        }));
        new import_obsidian22.Notice("AI Service reinitialized with the new model.");
        onChange === null || onChange === void 0 ? void 0 : onChange(model);
      } catch (error) {
        console.error("\u{1F987} Error updating settings:", error);
        handleError(error);
      }
    });
  }
  function updatePromptInput(value) {
    state.update((s) => Object.assign(Object.assign({}, s), {
      userPromptInput: value,
      lastUpdated: Date.now()
    }));
    onChange === null || onChange === void 0 ? void 0 : onChange(value);
  }
  function handleGenerateKnowledgeBloom() {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      if ($state.isGenerating)
        return;
      const activeFile = app.workspace.getActiveFile();
      if (!(activeFile instanceof import_obsidian22.TFile)) {
        new import_obsidian22.Notice("No active file found.");
        return;
      }
      try {
        state.update((s) => Object.assign(Object.assign({}, s), { isGenerating: true }));
        const generationService = aiService.getGenerationService();
        const result = yield generationService.generateKnowledgeBloom(activeFile, $state.userPromptInput);
        if ((_a = result === null || result === void 0 ? void 0 : result.generatedNotes) === null || _a === void 0 ? void 0 : _a.length) {
          yield createGeneratedNotes(result.generatedNotes);
          new import_obsidian22.Notice(`Generated ${result.generatedNotes.length} new notes!`);
        } else {
          new import_obsidian22.Notice("No notes were generated.");
        }
      } catch (error) {
        console.error("\u{1F987} Error generating Knowledge Bloom:", error);
        handleError(error);
      } finally {
        state.update((s) => Object.assign(Object.assign({}, s), {
          isGenerating: false,
          lastUpdated: Date.now()
        }));
      }
    });
  }
  function createGeneratedNotes(notes) {
    return __awaiter(this, void 0, void 0, function* () {
      for (const note of notes) {
        const filePath = `${note.title}.md`;
        const existingFile = app.vault.getAbstractFileByPath(filePath);
        try {
          if (existingFile instanceof import_obsidian22.TFile) {
            yield app.vault.modify(existingFile, note.content);
          } else {
            yield app.vault.create(filePath, note.content);
          }
        } catch (error) {
          console.error(`\u{1F987} Error creating/updating note ${filePath}:`, error);
          new import_obsidian22.Notice(`Failed to create/update note "${note.title}".`);
        }
      }
    });
  }
  function handleError(error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    state.update((s) => Object.assign(Object.assign({}, s), {
      error: {
        message,
        timestamp: Date.now(),
        source: "KnowledgeBloomAccordion"
      },
      lifecycle: "error" /* Error */
    }));
    new import_obsidian22.Notice(`Knowledge Bloom Error: ${message}`);
  }
  function initializeComponent() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        yield initializeModels();
      } catch (error) {
        handleError(
          error
        );
      }
    });
  }
  function select_change_handler() {
    $state.selectedModel = select_value(this);
    state.set($state);
  }
  const change_handler = (e) => updateKnowledgeBloomSettings(e.currentTarget.value);
  function textarea_input_handler() {
    $state.userPromptInput = this.value;
    state.set($state);
  }
  const input_handler = (e) => updatePromptInput(e.currentTarget.value);
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("description" in $$props2)
      $$invalidate(1, description = $$props2.description);
    if ("app" in $$props2)
      $$invalidate(8, app = $$props2.app);
    if ("settingsService" in $$props2)
      $$invalidate(9, settingsService = $$props2.settingsService);
    if ("aiService" in $$props2)
      $$invalidate(10, aiService = $$props2.aiService);
    if ("isOpen" in $$props2)
      $$invalidate(2, isOpen = $$props2.isOpen);
    if ("initialModel" in $$props2)
      $$invalidate(11, initialModel = $$props2.initialModel);
    if ("onChange" in $$props2)
      $$invalidate(12, onChange = $$props2.onChange);
    if ("onBlur" in $$props2)
      $$invalidate(13, onBlur = $$props2.onBlur);
    if ("onFocus" in $$props2)
      $$invalidate(14, onFocus = $$props2.onFocus);
    if ("onClick" in $$props2)
      $$invalidate(15, onClick = $$props2.onClick);
    if ("onKeyDown" in $$props2)
      $$invalidate(16, onKeyDown = $$props2.onKeyDown);
  };
  return [
    title,
    description,
    isOpen,
    $state,
    state,
    updateKnowledgeBloomSettings,
    updatePromptInput,
    handleGenerateKnowledgeBloom,
    app,
    settingsService,
    aiService,
    initialModel,
    onChange,
    onBlur,
    onFocus,
    onClick,
    onKeyDown,
    select_change_handler,
    change_handler,
    textarea_input_handler,
    input_handler
  ];
}
var KnowledgeBloomAccordion = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance9,
      create_fragment9,
      safe_not_equal,
      {
        title: 0,
        description: 1,
        app: 8,
        settingsService: 9,
        aiService: 10,
        isOpen: 2,
        initialModel: 11,
        onChange: 12,
        onBlur: 13,
        onFocus: 14,
        onClick: 15,
        onKeyDown: 16
      },
      add_css9
    );
  }
};
var KnowledgeBloomAccordion_default = KnowledgeBloomAccordion;

// src/components/accordions/BatchProcessorAccordion.svelte
var import_obsidian24 = require("obsidian");

// src/components/modals/BatchProcessorModal.svelte
var import_obsidian23 = require("obsidian");
function add_css10(target) {
  append_styles(target, "svelte-yunjq2", ".batch-processor-modal.svelte-yunjq2.svelte-yunjq2{display:flex;flex-direction:column;height:100%;padding:var(--size-4)}.modal-content.svelte-yunjq2.svelte-yunjq2{display:flex;flex-direction:column;height:100%;gap:var(--size-4)}.modal-header.svelte-yunjq2.svelte-yunjq2{border-bottom:1px solid var(--background-modifier-border);padding-bottom:var(--size-4)}.modal-header.svelte-yunjq2 h2.svelte-yunjq2{margin:0;color:var(--text-normal);font-size:var(--font-ui-large)}.modal-scrollable-content.svelte-yunjq2.svelte-yunjq2{flex:1;overflow-y:auto;padding:var(--size-2);min-height:200px}.processing-status.svelte-yunjq2.svelte-yunjq2{padding:var(--size-4);background-color:var(--background-secondary);border-radius:var(--radius-m)}.progress-bar.svelte-yunjq2.svelte-yunjq2{width:100%;height:4px;background-color:var(--background-modifier-border);border-radius:2px;margin-bottom:var(--size-2);overflow:hidden}.progress-fill.svelte-yunjq2.svelte-yunjq2{height:100%;background-color:var(--interactive-accent);transition:width 0.2s ease}.status-text.svelte-yunjq2.svelte-yunjq2{font-size:var(--font-ui-smaller);color:var(--text-muted);text-align:center}.file-tree-item{padding:var(--size-1) 0}.folder-item{font-weight:var(--font-medium)}.folder-children{border-left:1px solid var(--background-modifier-border)}.modal-footer.svelte-yunjq2.svelte-yunjq2{border-top:1px solid var(--background-modifier-border);padding-top:var(--size-4)}.footer-content.svelte-yunjq2.svelte-yunjq2{display:flex;justify-content:space-between;align-items:center}.selection-count.svelte-yunjq2.svelte-yunjq2{color:var(--text-muted);font-size:var(--font-ui-small)}.button-container.svelte-yunjq2.svelte-yunjq2{display:flex;gap:var(--size-4)}.setting-item{border-top:none !important;padding:var(--size-2) 0}");
}
function create_if_block4(ctx) {
  let div3;
  let div1;
  let div0;
  let t;
  let div2;
  function select_block_type(ctx2, dirty) {
    if (
      /*uiState*/
      ctx2[3].file
    )
      return create_if_block_13;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div3 = element("div");
      div1 = element("div");
      div0 = element("div");
      t = space();
      div2 = element("div");
      if_block.c();
      attr(div0, "class", "progress-fill svelte-yunjq2");
      set_style(
        div0,
        "width",
        /*uiState*/
        ctx[3].progress + "%"
      );
      attr(div1, "class", "progress-bar svelte-yunjq2");
      attr(div2, "class", "status-text svelte-yunjq2");
      attr(div3, "class", "processing-status svelte-yunjq2");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div1);
      append(div1, div0);
      append(div3, t);
      append(div3, div2);
      if_block.m(div2, null);
    },
    p(ctx2, dirty) {
      if (dirty & /*uiState*/
      8) {
        set_style(
          div0,
          "width",
          /*uiState*/
          ctx2[3].progress + "%"
        );
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div2, null);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      if_block.d();
    }
  };
}
function create_else_block(ctx) {
  let t_value = (
    /*processing*/
    ctx[4].state.state + ""
  );
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*processing*/
      16 && t_value !== (t_value = /*processing*/
      ctx2[4].state.state + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_13(ctx) {
  let t0;
  let t1_value = (
    /*uiState*/
    ctx[3].file + ""
  );
  let t1;
  return {
    c() {
      t0 = text("Processing: ");
      t1 = text(t1_value);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*uiState*/
      8 && t1_value !== (t1_value = /*uiState*/
      ctx2[3].file + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
    }
  };
}
function create_fragment10(ctx) {
  let div4;
  let div3;
  let header;
  let t1;
  let div0;
  let t2;
  let t3;
  let footer;
  let div2;
  let span;
  let t4_value = (
    /*selection*/
    ctx[1].paths.size + ""
  );
  let t4;
  let t5;
  let t6;
  let div1;
  let button0;
  let t7_value = (
    /*uiState*/
    ctx[3].isProcessing ? "Processing..." : "Process Selected"
  );
  let t7;
  let button0_disabled_value;
  let t8;
  let button1;
  let t9;
  let button1_disabled_value;
  let mounted;
  let dispose;
  let if_block = (
    /*uiState*/
    ctx[3].isProcessing && create_if_block4(ctx)
  );
  return {
    c() {
      div4 = element("div");
      div3 = element("div");
      header = element("header");
      header.innerHTML = `<h2 class="svelte-yunjq2">Select Files to Process</h2>`;
      t1 = space();
      div0 = element("div");
      t2 = space();
      if (if_block)
        if_block.c();
      t3 = space();
      footer = element("footer");
      div2 = element("div");
      span = element("span");
      t4 = text(t4_value);
      t5 = text(" items selected");
      t6 = space();
      div1 = element("div");
      button0 = element("button");
      t7 = text(t7_value);
      t8 = space();
      button1 = element("button");
      t9 = text("Cancel");
      attr(header, "class", "modal-header svelte-yunjq2");
      attr(div0, "class", "modal-scrollable-content svelte-yunjq2");
      attr(span, "class", "selection-count svelte-yunjq2");
      attr(button0, "class", "mod-cta");
      button0.disabled = button0_disabled_value = /*uiState*/
      ctx[3].isProcessing || /*selection*/
      ctx[1].paths.size === 0;
      attr(button1, "class", "mod-cancel");
      button1.disabled = button1_disabled_value = /*uiState*/
      ctx[3].isProcessing;
      attr(div1, "class", "button-container svelte-yunjq2");
      attr(div2, "class", "footer-content svelte-yunjq2");
      attr(footer, "class", "modal-footer svelte-yunjq2");
      attr(div3, "class", "modal-content svelte-yunjq2");
      attr(div4, "class", "batch-processor-modal svelte-yunjq2");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div3);
      append(div3, header);
      append(div3, t1);
      append(div3, div0);
      ctx[11](div0);
      append(div3, t2);
      if (if_block)
        if_block.m(div3, null);
      append(div3, t3);
      append(div3, footer);
      append(footer, div2);
      append(div2, span);
      append(span, t4);
      append(span, t5);
      append(div2, t6);
      append(div2, div1);
      append(div1, button0);
      append(button0, t7);
      append(div1, t8);
      append(div1, button1);
      append(button1, t9);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*handleProcess*/
            ctx[5]
          ),
          listen(button1, "click", function() {
            if (is_function(
              /*onClose*/
              ctx[0]
            ))
              ctx[0].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (
        /*uiState*/
        ctx[3].isProcessing
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block4(ctx);
          if_block.c();
          if_block.m(div3, t3);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*selection*/
      2 && t4_value !== (t4_value = /*selection*/
      ctx[1].paths.size + ""))
        set_data(t4, t4_value);
      if (dirty & /*uiState*/
      8 && t7_value !== (t7_value = /*uiState*/
      ctx[3].isProcessing ? "Processing..." : "Process Selected"))
        set_data(t7, t7_value);
      if (dirty & /*uiState, selection*/
      10 && button0_disabled_value !== (button0_disabled_value = /*uiState*/
      ctx[3].isProcessing || /*selection*/
      ctx[1].paths.size === 0)) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & /*uiState*/
      8 && button1_disabled_value !== (button1_disabled_value = /*uiState*/
      ctx[3].isProcessing)) {
        button1.disabled = button1_disabled_value;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      ctx[11](null);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance10($$self, $$props, $$invalidate) {
  var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  let { app } = $$props;
  let { settingsService } = $$props;
  let { aiService } = $$props;
  let { generationService } = $$props;
  let { onClose } = $$props;
  let { onProcessComplete } = $$props;
  let fileTree = [];
  let selection = { paths: /* @__PURE__ */ new Set(), expanded: /* @__PURE__ */ new Set() };
  let containerEl;
  let processor;
  let uiState2 = {
    isInitialized: true,
    darkMode: false,
    activeAccordion: null,
    notifications: [],
    lastInteraction: Date.now(),
    modalStack: [],
    lastUpdated: Date.now(),
    file: "",
    progress: 0,
    isProcessing: false
  };
  let processing = {
    state: {
      isProcessing: false,
      currentFile: null,
      queue: [],
      progress: 0,
      state: "idle" /* IDLE */,
      filesQueued: 0,
      filesProcessed: 0,
      filesRemaining: 0,
      errors: [],
      error: null,
      startTime: null,
      estimatedTimeRemaining: null
    },
    filesQueued: 0,
    filesProcessed: 0,
    filesRemaining: 0,
    currentFile: void 0,
    startTime: 0,
    errors: []
  };
  const statusBar = {
    updateFromState: (state) => {
      if (state.currentFile !== null) {
        $$invalidate(3, uiState2.file = state.currentFile, uiState2);
      }
      $$invalidate(3, uiState2.progress = state.progress, uiState2);
      $$invalidate(3, uiState2.isProcessing = state.status.state.isProcessing, uiState2);
      Object.assign(processing, state.status);
      $$invalidate(3, uiState2 = Object.assign({}, uiState2));
      $$invalidate(4, processing);
    }
  };
  onMount(() => {
    buildVaultStructure();
    initializeProcessor();
  });
  onDestroy(() => {
    processor === null || processor === void 0 ? void 0 : processor.removeAllListeners();
  });
  class ProcessorCoreService extends CoreService {
    initializeInternal() {
      return __awaiter(this, void 0, void 0, function* () {
      });
    }
    destroyInternal() {
      return __awaiter(this, void 0, void 0, function* () {
      });
    }
  }
  function initializeProcessor() {
    processor = new BatchProcessor(app, new ProcessorCoreService("batchProcessor", "Batch Processor"), statusBar);
    processor.on("stateChanged", ({ state, currentFile, progress }) => {
      $$invalidate(4, processing.state.state = state, processing);
      $$invalidate(
        4,
        processing.currentFile = currentFile !== null && currentFile !== void 0 ? currentFile : void 0,
        processing
      );
      $$invalidate(4, processing.state.progress = progress, processing);
      $$invalidate(3, uiState2.progress = progress, uiState2);
      $$invalidate(
        3,
        uiState2.file = currentFile !== null && currentFile !== void 0 ? currentFile : "",
        uiState2
      );
      $$invalidate(3, uiState2.lastUpdated = Date.now(), uiState2);
      $$invalidate(3, uiState2 = Object.assign({}, uiState2));
      $$invalidate(4, processing);
    });
    processor.on("error", ({ filePath, error }) => {
      new import_obsidian23.Notice(`Error processing ${filePath}: ${error}`);
    });
  }
  function buildVaultStructure() {
    const rootFolder = app.vault.getRoot();
    return rootFolder.children.filter((child) => child instanceof import_obsidian23.TFolder || child instanceof import_obsidian23.TFile).map((child) => createNode(child, 0));
  }
  function createNode(item, level) {
    if (item instanceof import_obsidian23.TFile) {
      return {
        name: item.name,
        path: item.path,
        type: "file",
        selected: false,
        level
      };
    }
    return {
      name: item.name,
      path: item.path,
      type: "folder",
      children: item.children.filter((child) => child instanceof import_obsidian23.TFolder || child instanceof import_obsidian23.TFile).map((child) => createNode(child, level + 1)),
      selected: false,
      expanded: selection.expanded.has(item.path),
      level
    };
  }
  function renderNodes(container, nodes) {
    nodes.forEach((node) => {
      const itemSetting = new import_obsidian23.Setting(container).setClass("file-tree-item").addToggle((toggle) => {
        toggle.setValue(node.selected).onChange((value) => handleSelection(node, value));
        return toggle;
      }).setName(node.name);
      if (node.type === "folder") {
        itemSetting.setClass("folder-item").setHeading().addExtraButton((button) => {
          button.setIcon(node.expanded ? "chevron-down" : "chevron-right").onClick(() => toggleFolder(node));
          return button;
        });
        if (node.expanded && node.children) {
          const childContainer = container.createDiv("folder-children");
          childContainer.style.marginLeft = "20px";
          renderNodes(childContainer, node.children);
        }
      }
    });
  }
  function renderFileTree() {
    if (!containerEl)
      return;
    containerEl.empty();
    const tree = buildVaultStructure();
    fileTree = tree;
    renderNodes(containerEl, tree);
  }
  function handleSelection(node, selected) {
    node.selected = selected;
    if (selected) {
      selection.paths.add(node.path);
    } else {
      selection.paths.delete(node.path);
    }
    $$invalidate(1, selection);
    if (node.type === "folder" && node.children) {
      node.children.forEach((child) => handleSelection(child, selected));
    }
    renderFileTree();
  }
  function toggleFolder(node) {
    if (node.type !== "folder")
      return;
    node.expanded = !node.expanded;
    if (node.expanded) {
      selection.expanded.add(node.path);
    } else {
      selection.expanded.delete(node.path);
    }
    $$invalidate(1, selection);
    renderFileTree();
  }
  function handleProcess() {
    return __awaiter(this, void 0, void 0, function* () {
      if (selection.paths.size === 0) {
        new import_obsidian23.Notice("No files selected for processing");
        return;
      }
      try {
        $$invalidate(3, uiState2.isProcessing = true, uiState2);
        $$invalidate(3, uiState2.lastUpdated = Date.now(), uiState2);
        $$invalidate(3, uiState2 = Object.assign({}, uiState2));
        const settings = settingsService.getSettings();
        const result = yield processor.process({
          files: Array.from(selection.paths),
          generateFrontMatter: settings.frontMatter.autoGenerate,
          generateWikilinks: settings.advanced.generateWikilinks
        });
        showProcessingResults(result);
        onClose();
      } catch (error) {
        console.error("Error processing files:", error);
        new import_obsidian23.Notice(`Error processing files: ${error instanceof Error ? error.message : "Unknown error"}`);
      } finally {
        $$invalidate(3, uiState2.isProcessing = false, uiState2);
        $$invalidate(3, uiState2.lastUpdated = Date.now(), uiState2);
        $$invalidate(3, uiState2 = Object.assign({}, uiState2));
      }
    });
  }
  function showProcessingResults(stats) {
    var _a;
    const duration = (((_a = stats.endTime) !== null && _a !== void 0 ? _a : Date.now() - stats.startTime) / 1e3).toFixed(1);
    new import_obsidian23.Notice(`Processing complete!
Processed: ${stats.processedFiles}
Errors: ${stats.errorFiles}
Duration: ${duration}s`);
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      containerEl = $$value;
      $$invalidate(2, containerEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(6, app = $$props2.app);
    if ("settingsService" in $$props2)
      $$invalidate(7, settingsService = $$props2.settingsService);
    if ("aiService" in $$props2)
      $$invalidate(8, aiService = $$props2.aiService);
    if ("generationService" in $$props2)
      $$invalidate(9, generationService = $$props2.generationService);
    if ("onClose" in $$props2)
      $$invalidate(0, onClose = $$props2.onClose);
    if ("onProcessComplete" in $$props2)
      $$invalidate(10, onProcessComplete = $$props2.onProcessComplete);
  };
  return [
    onClose,
    selection,
    containerEl,
    uiState2,
    processing,
    handleProcess,
    app,
    settingsService,
    aiService,
    generationService,
    onProcessComplete,
    div0_binding
  ];
}
var BatchProcessorModal = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance10,
      create_fragment10,
      safe_not_equal,
      {
        app: 6,
        settingsService: 7,
        aiService: 8,
        generationService: 9,
        onClose: 0,
        onProcessComplete: 10
      },
      add_css10
    );
  }
};
var BatchProcessorModal_default = BatchProcessorModal;

// src/components/accordions/BatchProcessorAccordion.svelte
function add_css11(target) {
  append_styles(target, "svelte-j5dgb1", ".batch-processor-settings.svelte-j5dgb1{padding:var(--size-4);display:flex;flex-direction:column;gap:var(--size-4)}.error-message.svelte-j5dgb1{color:var(--color-red);font-size:var(--font-ui-small);padding:var(--size-2);background-color:var(--background-modifier-error);border-radius:var(--radius-s);margin-bottom:var(--size-2)}.settings-form.svelte-j5dgb1{display:flex;flex-direction:column;gap:var(--size-4)}.setting-item.svelte-j5dgb1{display:flex;justify-content:space-between;align-items:flex-start;padding:var(--size-2) 0;border-top:none !important}.setting-item.svelte-j5dgb1:first-child{padding-top:0}.setting-item-info.svelte-j5dgb1{flex:1;margin-right:var(--size-4)}.setting-item-name.svelte-j5dgb1{font-weight:var(--font-medium);margin-bottom:var(--size-1)}.setting-item-description.svelte-j5dgb1{color:var(--text-muted);font-size:var(--font-ui-smaller)}.setting-item-control.svelte-j5dgb1{flex-shrink:0}button.mod-cta.svelte-j5dgb1{background-color:var(--interactive-accent);color:var(--text-on-accent);padding:var(--size-2) var(--size-4);border-radius:var (--radius-s);font-weight:var(--font-medium);border:none;cursor:pointer;transition:background-color 0.2s ease}button.mod-cta.svelte-j5dgb1:hover:not(:disabled){background-color:var(--interactive-accent-hover)}button.mod-cta.svelte-j5dgb1:disabled{opacity:0.5;cursor:not-allowed}");
}
function create_if_block5(ctx) {
  let div;
  let t_value = (
    /*$state*/
    ctx[8].error.message + ""
  );
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "error-message svelte-j5dgb1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*$state*/
      256 && t_value !== (t_value = /*$state*/
      ctx2[8].error.message + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_default_slot6(ctx) {
  let div8;
  let t0;
  let div7;
  let div5;
  let div2;
  let t4;
  let div4;
  let div3;
  let input;
  let input_checked_value;
  let input_disabled_value;
  let t5;
  let div6;
  let button;
  let t6_value = (
    /*$state*/
    ctx[8].isProcessing ? "Running..." : "Run Batch Processor"
  );
  let t6;
  let button_disabled_value;
  let mounted;
  let dispose;
  let if_block = (
    /*$state*/
    ctx[8].error && create_if_block5(ctx)
  );
  return {
    c() {
      div8 = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      div7 = element("div");
      div5 = element("div");
      div2 = element("div");
      div2.innerHTML = `<div class="setting-item-name svelte-j5dgb1">Auto-generate Front Matter</div> <div class="setting-item-description svelte-j5dgb1">Automatically generate front matter for new or unprocessed notes when you open your vault</div>`;
      t4 = space();
      div4 = element("div");
      div3 = element("div");
      input = element("input");
      t5 = space();
      div6 = element("div");
      button = element("button");
      t6 = text(t6_value);
      attr(div2, "class", "setting-item-info svelte-j5dgb1");
      attr(input, "type", "checkbox");
      input.checked = input_checked_value = /*$state*/
      ctx[8].autoGenerate;
      input.disabled = input_disabled_value = !/*$state*/
      ctx[8].isInitialized;
      attr(div3, "class", "checkbox-container");
      attr(div4, "class", "setting-item-control svelte-j5dgb1");
      attr(div5, "class", "setting-item svelte-j5dgb1");
      attr(button, "class", "mod-cta svelte-j5dgb1");
      button.disabled = button_disabled_value = /*$state*/
      ctx[8].isProcessing || !/*$state*/
      ctx[8].isInitialized;
      attr(div6, "class", "setting-item svelte-j5dgb1");
      attr(div7, "class", "settings-form svelte-j5dgb1");
      attr(div8, "class", "batch-processor-settings svelte-j5dgb1");
      attr(div8, "role", "region");
      attr(div8, "aria-label", "Batch Processor Settings");
    },
    m(target, anchor) {
      insert(target, div8, anchor);
      if (if_block)
        if_block.m(div8, null);
      append(div8, t0);
      append(div8, div7);
      append(div7, div5);
      append(div5, div2);
      append(div5, t4);
      append(div5, div4);
      append(div4, div3);
      append(div3, input);
      append(div7, t5);
      append(div7, div6);
      append(div6, button);
      append(button, t6);
      ctx[18](div8);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*change_handler*/
            ctx[17]
          ),
          listen(
            button,
            "click",
            /*runBatchProcessor*/
            ctx[11]
          ),
          listen(div8, "click", function() {
            if (is_function(
              /*onClick*/
              ctx[5]
            ))
              ctx[5].apply(this, arguments);
          }),
          listen(div8, "keydown", function() {
            if (is_function(
              /*onKeyDown*/
              ctx[6]
            ))
              ctx[6].apply(this, arguments);
          }),
          listen(div8, "focus", function() {
            if (is_function(
              /*onFocus*/
              ctx[4]
            ))
              ctx[4].apply(this, arguments);
          }),
          listen(div8, "blur", function() {
            if (is_function(
              /*onBlur*/
              ctx[3]
            ))
              ctx[3].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*$state*/
        ctx[8].error
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block5(ctx);
          if_block.c();
          if_block.m(div8, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*$state*/
      256 && input_checked_value !== (input_checked_value = /*$state*/
      ctx[8].autoGenerate)) {
        input.checked = input_checked_value;
      }
      if (dirty & /*$state*/
      256 && input_disabled_value !== (input_disabled_value = !/*$state*/
      ctx[8].isInitialized)) {
        input.disabled = input_disabled_value;
      }
      if (dirty & /*$state*/
      256 && t6_value !== (t6_value = /*$state*/
      ctx[8].isProcessing ? "Running..." : "Run Batch Processor"))
        set_data(t6, t6_value);
      if (dirty & /*$state*/
      256 && button_disabled_value !== (button_disabled_value = /*$state*/
      ctx[8].isProcessing || !/*$state*/
      ctx[8].isInitialized)) {
        button.disabled = button_disabled_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div8);
      }
      if (if_block)
        if_block.d();
      ctx[18](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment11(ctx) {
  let baseaccordion;
  let current;
  baseaccordion = new BaseAccordion_default({
    props: {
      title: (
        /*title*/
        ctx[0]
      ),
      description: (
        /*description*/
        ctx[1]
      ),
      isOpen: (
        /*isOpen*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(baseaccordion.$$.fragment);
    },
    m(target, anchor) {
      mount_component(baseaccordion, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const baseaccordion_changes = {};
      if (dirty & /*title*/
      1)
        baseaccordion_changes.title = /*title*/
        ctx2[0];
      if (dirty & /*description*/
      2)
        baseaccordion_changes.description = /*description*/
        ctx2[1];
      if (dirty & /*isOpen*/
      4)
        baseaccordion_changes.isOpen = /*isOpen*/
        ctx2[2];
      if (dirty & /*$$scope, settingsContainer, onClick, onKeyDown, onFocus, onBlur, $state*/
      134218232) {
        baseaccordion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      baseaccordion.$set(baseaccordion_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(baseaccordion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(baseaccordion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(baseaccordion, detaching);
    }
  };
}
function instance11($$self, $$props, $$invalidate) {
  let $state;
  var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  let { title } = $$props;
  let { description } = $$props;
  let { app } = $$props;
  let { settingsService } = $$props;
  let { aiService } = $$props;
  let { isOpen = false } = $$props;
  let { generationService = void 0 } = $$props;
  let { onChange } = $$props;
  let { onBlur } = $$props;
  let { onFocus } = $$props;
  let { onClick } = $$props;
  let { onKeyDown } = $$props;
  const state = writable({
    isInitialized: false,
    isProcessing: false,
    autoGenerate: false,
    lifecycle: "uninitialized" /* Uninitialized */,
    error: void 0,
    validationResult: void 0,
    lastUpdated: Date.now()
  });
  component_subscribe($$self, state, (value) => $$invalidate(8, $state = value));
  let modal = null;
  let settingsContainer;
  onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    try {
      yield initializeComponent();
      state.update((s) => Object.assign(Object.assign({}, s), {
        isInitialized: true,
        lifecycle: "ready" /* Ready */
      }));
    } catch (error) {
      console.error("Failed to initialize BatchProcessorAccordion:", error);
      handleError(error);
    }
  }));
  function initializeComponent() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!settingsService.isReady()) {
        throw new Error("Settings service not ready");
      }
      const settings = settingsService.getSettings();
      if (!settings.frontMatter) {
        throw new Error("Front Matter settings are missing");
      }
      state.update((s) => Object.assign(Object.assign({}, s), {
        autoGenerate: settings.frontMatter.autoGenerate,
        isInitialized: true,
        lastUpdated: Date.now()
      }));
    });
  }
  function handleAutoGenerateToggle(value) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!settingsService.isReady())
        return;
      try {
        yield settingsService.updateNestedSetting("frontMatter", "autoGenerate", value);
        state.update((s) => Object.assign(Object.assign({}, s), {
          autoGenerate: value,
          lastUpdated: Date.now()
        }));
        new import_obsidian24.Notice("Auto-generate Front Matter updated.");
        onChange === null || onChange === void 0 ? void 0 : onChange(value);
      } catch (error) {
        console.error("\u{1F987} Error updating auto-generate setting:", error);
        handleError(error);
        state.update((s) => Object.assign(Object.assign({}, s), { autoGenerate: !value }));
      }
    });
  }
  function openBatchProcessorModal() {
    if ($state.isProcessing)
      return;
    try {
      ensureRequiredServices();
      modal = new BatchProcessorModal_default({
        target: document.body,
        props: {
          app,
          settingsService,
          aiService,
          generationService,
          onClose: handleModalClose,
          onProcessComplete: handleProcessComplete
        }
      });
      state.update((s) => Object.assign(Object.assign({}, s), { isProcessing: true }));
    } catch (error) {
      console.error("\u{1F987} Error opening Batch Processor modal:", error);
      handleError(error);
    }
  }
  function ensureRequiredServices() {
    if (!settingsService.isReady()) {
      throw new Error("Settings service not ready");
    }
    if (!aiService.isReady()) {
      throw new Error("AI service not ready");
    }
    if (!generationService) {
      throw new Error("Generation service not provided");
    }
  }
  function handleModalClose() {
    modal === null || modal === void 0 ? void 0 : modal.$destroy();
    modal = null;
    state.update((s) => Object.assign(Object.assign({}, s), { isProcessing: false }));
  }
  function handleProcessComplete() {
    new import_obsidian24.Notice("Batch processing completed successfully.");
    state.update((s) => Object.assign(Object.assign({}, s), { isProcessing: false }));
  }
  function handleError(error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    state.update((s) => Object.assign(Object.assign({}, s), {
      error: {
        message,
        timestamp: Date.now(),
        source: "BatchProcessorAccordion"
      },
      lifecycle: "error" /* Error */
    }));
    new import_obsidian24.Notice(`Batch Processor Error: ${message}`);
  }
  function runBatchProcessor() {
    openBatchProcessorModal();
  }
  const change_handler = (e) => handleAutoGenerateToggle(e.currentTarget.checked);
  function div8_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      settingsContainer = $$value;
      $$invalidate(7, settingsContainer);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("description" in $$props2)
      $$invalidate(1, description = $$props2.description);
    if ("app" in $$props2)
      $$invalidate(12, app = $$props2.app);
    if ("settingsService" in $$props2)
      $$invalidate(13, settingsService = $$props2.settingsService);
    if ("aiService" in $$props2)
      $$invalidate(14, aiService = $$props2.aiService);
    if ("isOpen" in $$props2)
      $$invalidate(2, isOpen = $$props2.isOpen);
    if ("generationService" in $$props2)
      $$invalidate(15, generationService = $$props2.generationService);
    if ("onChange" in $$props2)
      $$invalidate(16, onChange = $$props2.onChange);
    if ("onBlur" in $$props2)
      $$invalidate(3, onBlur = $$props2.onBlur);
    if ("onFocus" in $$props2)
      $$invalidate(4, onFocus = $$props2.onFocus);
    if ("onClick" in $$props2)
      $$invalidate(5, onClick = $$props2.onClick);
    if ("onKeyDown" in $$props2)
      $$invalidate(6, onKeyDown = $$props2.onKeyDown);
  };
  return [
    title,
    description,
    isOpen,
    onBlur,
    onFocus,
    onClick,
    onKeyDown,
    settingsContainer,
    $state,
    state,
    handleAutoGenerateToggle,
    runBatchProcessor,
    app,
    settingsService,
    aiService,
    generationService,
    onChange,
    change_handler,
    div8_binding
  ];
}
var BatchProcessorAccordion = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance11,
      create_fragment11,
      safe_not_equal,
      {
        title: 0,
        description: 1,
        app: 12,
        settingsService: 13,
        aiService: 14,
        isOpen: 2,
        generationService: 15,
        onChange: 16,
        onBlur: 3,
        onFocus: 4,
        onClick: 5,
        onKeyDown: 6
      },
      add_css11
    );
  }
};
var BatchProcessorAccordion_default = BatchProcessorAccordion;

// src/components/accordions/AdvancedAccordion.svelte
var import_obsidian25 = require("obsidian");
function add_css12(target) {
  append_styles(target, "svelte-1uk2yp8", '.advanced-settings.svelte-1uk2yp8{padding:var(--size-4);display:flex;flex-direction:column;gap:var(--size-4)}.error-message.svelte-1uk2yp8{color:var(--color-red);font-size:var(--font-ui-small);padding:var(--size-2);background-color:var(--background-modifier-error);border-radius:var(--radius-s);margin-bottom:var(--size-2)}.setting-item.svelte-1uk2yp8{display:flex;justify-content:space-between;align-items:flex-start;padding:var(--size-2) 0;border-top:none !important}.setting-item.svelte-1uk2yp8:first-child{padding-top:0}.setting-item-info.svelte-1uk2yp8{flex:1;margin-right:var(--size-4)}.setting-item-name.svelte-1uk2yp8{font-weight:var(--font-medium);margin-bottom:var(--size-1)}.setting-item-description.svelte-1uk2yp8{color:var(--text-muted);font-size:var(--font-ui-smaller)}.setting-item-control.svelte-1uk2yp8{flex-shrink:0;display:flex;align-items:center;gap:var(--size-2)}input[type="range"].svelte-1uk2yp8{width:150px}input[type="number"].svelte-1uk2yp8{width:100px;padding:var(--size-2);border:1px solid var(--background-modifier-border);border-radius:var(--radius-s);background:var(--background-primary);color:var(--text-normal)}.value-display.svelte-1uk2yp8{min-width:2.5em;text-align:right;color:var (--text-muted)}.status-message.svelte-1uk2yp8{color:var(--text-muted);font-size:var(--font-ui-small);text-align:center;padding:var(--size-2);background-color:var(--background-secondary);border-radius:var(--radius-s)}button.mod-cta.svelte-1uk2yp8{background-color:var(--interactive-accent);color:var(--text-on-accent);padding:var(--size-2) var(--size-4);border-radius:var(--radius-s);font-weight:var(--font-medium);border:none;cursor:pointer;transition:background-color 0.2s ease}button.mod-cta.svelte-1uk2yp8:hover:not(:disabled){background-color:var(--interactive-accent-hover)}button.mod-cta.svelte-1uk2yp8:disabled{opacity:0.5;cursor:not-allowed}input.svelte-1uk2yp8:disabled{opacity:0.5;cursor:not-allowed}');
}
function create_if_block_14(ctx) {
  let div;
  let t_value = (
    /*$state*/
    ctx[3].error.message + ""
  );
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "error-message svelte-1uk2yp8");
      attr(div, "role", "alert");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*$state*/
      8 && t_value !== (t_value = /*$state*/
      ctx2[3].error.message + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block6(ctx) {
  let div;
  let t0;
  let t1_value = (
    /*$state*/
    ctx[3].generatedNotes + ""
  );
  let t1;
  let t2;
  return {
    c() {
      div = element("div");
      t0 = text("Last generation created ");
      t1 = text(t1_value);
      t2 = text(" new notes.");
      attr(div, "class", "status-message svelte-1uk2yp8");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      append(div, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$state*/
      8 && t1_value !== (t1_value = /*$state*/
      ctx2[3].generatedNotes + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_default_slot7(ctx) {
  let form;
  let t0;
  let div3;
  let div1;
  let t4;
  let div2;
  let input0;
  let input0_disabled_value;
  let t5;
  let div7;
  let div5;
  let t9;
  let div6;
  let input1;
  let input1_disabled_value;
  let t10;
  let span;
  let t11_value = (
    /*$state*/
    ctx[3].settings.temperature.toFixed(1) + ""
  );
  let t11;
  let t12;
  let div11;
  let div9;
  let t16;
  let div10;
  let input2;
  let input2_disabled_value;
  let t17;
  let div13;
  let div12;
  let button;
  let t18_value = (
    /*$state*/
    ctx[3].isGenerating ? "Generating..." : "Generate Knowledge Bloom"
  );
  let t18;
  let button_disabled_value;
  let button_aria_disabled_value;
  let t19;
  let mounted;
  let dispose;
  let if_block0 = (
    /*$state*/
    ctx[3].error && create_if_block_14(ctx)
  );
  let if_block1 = (
    /*$state*/
    ctx[3].generatedNotes > 0 && create_if_block6(ctx)
  );
  return {
    c() {
      form = element("form");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div3 = element("div");
      div1 = element("div");
      div1.innerHTML = `<label for="wikilinks-toggle" class="setting-item-name svelte-1uk2yp8">Generate Wikilinks</label> <div class="setting-item-description svelte-1uk2yp8">Automatically generate wikilinks for your notes</div>`;
      t4 = space();
      div2 = element("div");
      input0 = element("input");
      t5 = space();
      div7 = element("div");
      div5 = element("div");
      div5.innerHTML = `<label for="temperature-slider" class="setting-item-name svelte-1uk2yp8">Temperature</label> <div class="setting-item-description svelte-1uk2yp8">Set the temperature for AI responses (0.0 - 1.0)</div>`;
      t9 = space();
      div6 = element("div");
      input1 = element("input");
      t10 = space();
      span = element("span");
      t11 = text(t11_value);
      t12 = space();
      div11 = element("div");
      div9 = element("div");
      div9.innerHTML = `<label for="max-tokens-input" class="setting-item-name svelte-1uk2yp8">Max Tokens</label> <div class="setting-item-description svelte-1uk2yp8">Set the maximum number of tokens for AI responses</div>`;
      t16 = space();
      div10 = element("div");
      input2 = element("input");
      t17 = space();
      div13 = element("div");
      div12 = element("div");
      button = element("button");
      t18 = text(t18_value);
      t19 = space();
      if (if_block1)
        if_block1.c();
      attr(div1, "class", "setting-item-info svelte-1uk2yp8");
      attr(input0, "id", "wikilinks-toggle");
      attr(input0, "type", "checkbox");
      input0.disabled = input0_disabled_value = !/*$state*/
      ctx[3].isInitialized;
      attr(input0, "class", "svelte-1uk2yp8");
      attr(div2, "class", "setting-item-control svelte-1uk2yp8");
      attr(div3, "class", "setting-item svelte-1uk2yp8");
      attr(div5, "class", "setting-item-info svelte-1uk2yp8");
      attr(input1, "id", "temperature-slider");
      attr(input1, "type", "range");
      attr(input1, "min", "0");
      attr(input1, "max", "1");
      attr(input1, "step", "0.1");
      input1.disabled = input1_disabled_value = !/*$state*/
      ctx[3].isInitialized;
      attr(input1, "class", "svelte-1uk2yp8");
      attr(span, "class", "value-display svelte-1uk2yp8");
      attr(div6, "class", "setting-item-control svelte-1uk2yp8");
      attr(div7, "class", "setting-item svelte-1uk2yp8");
      attr(div9, "class", "setting-item-info svelte-1uk2yp8");
      attr(input2, "id", "max-tokens-input");
      attr(input2, "type", "number");
      attr(input2, "min", "1");
      attr(input2, "placeholder", "2048");
      input2.disabled = input2_disabled_value = !/*$state*/
      ctx[3].isInitialized;
      attr(input2, "class", "svelte-1uk2yp8");
      attr(div10, "class", "setting-item-control svelte-1uk2yp8");
      attr(div11, "class", "setting-item svelte-1uk2yp8");
      attr(button, "type", "submit");
      attr(button, "class", "mod-cta svelte-1uk2yp8");
      button.disabled = button_disabled_value = /*$state*/
      ctx[3].isGenerating || !/*$state*/
      ctx[3].isInitialized || /*$state*/
      ctx[3].lifecycle !== "ready" /* Ready */;
      attr(button, "aria-disabled", button_aria_disabled_value = /*$state*/
      ctx[3].isGenerating || !/*$state*/
      ctx[3].isInitialized || /*$state*/
      ctx[3].lifecycle !== "ready" /* Ready */);
      attr(div12, "class", "setting-item-control svelte-1uk2yp8");
      attr(div13, "class", "setting-item svelte-1uk2yp8");
      attr(form, "class", "advanced-settings svelte-1uk2yp8");
    },
    m(target, anchor) {
      insert(target, form, anchor);
      if (if_block0)
        if_block0.m(form, null);
      append(form, t0);
      append(form, div3);
      append(div3, div1);
      append(div3, t4);
      append(div3, div2);
      append(div2, input0);
      input0.checked = /*$state*/
      ctx[3].settings.generateWikilinks;
      append(form, t5);
      append(form, div7);
      append(div7, div5);
      append(div7, t9);
      append(div7, div6);
      append(div6, input1);
      set_input_value(
        input1,
        /*$state*/
        ctx[3].settings.temperature
      );
      append(div6, t10);
      append(div6, span);
      append(span, t11);
      append(form, t12);
      append(form, div11);
      append(div11, div9);
      append(div11, t16);
      append(div11, div10);
      append(div10, input2);
      set_input_value(
        input2,
        /*$state*/
        ctx[3].settings.maxTokens
      );
      append(form, t17);
      append(form, div13);
      append(div13, div12);
      append(div12, button);
      append(button, t18);
      append(form, t19);
      if (if_block1)
        if_block1.m(form, null);
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "change",
            /*input0_change_handler*/
            ctx[15]
          ),
          listen(
            input0,
            "change",
            /*change_handler*/
            ctx[16]
          ),
          listen(
            input1,
            "change",
            /*input1_change_input_handler*/
            ctx[17]
          ),
          listen(
            input1,
            "input",
            /*input1_change_input_handler*/
            ctx[17]
          ),
          listen(
            input1,
            "change",
            /*change_handler_1*/
            ctx[18]
          ),
          listen(
            input2,
            "input",
            /*input2_input_handler*/
            ctx[19]
          ),
          listen(
            input2,
            "change",
            /*change_handler_2*/
            ctx[20]
          ),
          listen(form, "submit", prevent_default(
            /*handleGenerateKnowledgeBloom*/
            ctx[6]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (
        /*$state*/
        ctx2[3].error
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_14(ctx2);
          if_block0.c();
          if_block0.m(form, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & /*$state*/
      8 && input0_disabled_value !== (input0_disabled_value = !/*$state*/
      ctx2[3].isInitialized)) {
        input0.disabled = input0_disabled_value;
      }
      if (dirty & /*$state*/
      8) {
        input0.checked = /*$state*/
        ctx2[3].settings.generateWikilinks;
      }
      if (dirty & /*$state*/
      8 && input1_disabled_value !== (input1_disabled_value = !/*$state*/
      ctx2[3].isInitialized)) {
        input1.disabled = input1_disabled_value;
      }
      if (dirty & /*$state*/
      8) {
        set_input_value(
          input1,
          /*$state*/
          ctx2[3].settings.temperature
        );
      }
      if (dirty & /*$state*/
      8 && t11_value !== (t11_value = /*$state*/
      ctx2[3].settings.temperature.toFixed(1) + ""))
        set_data(t11, t11_value);
      if (dirty & /*$state*/
      8 && input2_disabled_value !== (input2_disabled_value = !/*$state*/
      ctx2[3].isInitialized)) {
        input2.disabled = input2_disabled_value;
      }
      if (dirty & /*$state*/
      8 && to_number(input2.value) !== /*$state*/
      ctx2[3].settings.maxTokens) {
        set_input_value(
          input2,
          /*$state*/
          ctx2[3].settings.maxTokens
        );
      }
      if (dirty & /*$state*/
      8 && t18_value !== (t18_value = /*$state*/
      ctx2[3].isGenerating ? "Generating..." : "Generate Knowledge Bloom"))
        set_data(t18, t18_value);
      if (dirty & /*$state*/
      8 && button_disabled_value !== (button_disabled_value = /*$state*/
      ctx2[3].isGenerating || !/*$state*/
      ctx2[3].isInitialized || /*$state*/
      ctx2[3].lifecycle !== "ready" /* Ready */)) {
        button.disabled = button_disabled_value;
      }
      if (dirty & /*$state*/
      8 && button_aria_disabled_value !== (button_aria_disabled_value = /*$state*/
      ctx2[3].isGenerating || !/*$state*/
      ctx2[3].isInitialized || /*$state*/
      ctx2[3].lifecycle !== "ready" /* Ready */)) {
        attr(button, "aria-disabled", button_aria_disabled_value);
      }
      if (
        /*$state*/
        ctx2[3].generatedNotes > 0
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block6(ctx2);
          if_block1.c();
          if_block1.m(form, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(form);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment12(ctx) {
  let baseaccordion;
  let current;
  baseaccordion = new BaseAccordion_default({
    props: {
      title: (
        /*title*/
        ctx[0]
      ),
      description: (
        /*description*/
        ctx[1]
      ),
      isOpen: (
        /*isOpen*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot7] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(baseaccordion.$$.fragment);
    },
    m(target, anchor) {
      mount_component(baseaccordion, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const baseaccordion_changes = {};
      if (dirty & /*title*/
      1)
        baseaccordion_changes.title = /*title*/
        ctx2[0];
      if (dirty & /*description*/
      2)
        baseaccordion_changes.description = /*description*/
        ctx2[1];
      if (dirty & /*isOpen*/
      4)
        baseaccordion_changes.isOpen = /*isOpen*/
        ctx2[2];
      if (dirty & /*$$scope, $state*/
      67108872) {
        baseaccordion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      baseaccordion.$set(baseaccordion_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(baseaccordion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(baseaccordion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(baseaccordion, detaching);
    }
  };
}
function validateSetting(key, value) {
  switch (key) {
    case "temperature":
      if (value < 0 || value > 1) {
        throw new Error("Temperature must be between 0 and 1");
      }
      break;
    case "maxTokens":
      if (typeof value === "number" && (isNaN(value) || value <= 0)) {
        throw new Error("Max tokens must be a positive number");
      }
      break;
  }
}
function instance12($$self, $$props, $$invalidate) {
  let $state;
  var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  let { title } = $$props;
  let { description } = $$props;
  let { app } = $$props;
  let { settingsService } = $$props;
  let { aiService } = $$props;
  let { isOpen = false } = $$props;
  let { onChange } = $$props;
  let { onBlur } = $$props;
  let { onFocus } = $$props;
  let { onClick } = $$props;
  let { onKeyDown } = $$props;
  const DEFAULT_SETTINGS2 = {
    generateWikilinks: false,
    temperature: 0.7,
    maxTokens: 2048
  };
  const state = writable({
    isInitialized: false,
    settings: Object.assign({}, DEFAULT_SETTINGS2),
    isGenerating: false,
    lifecycle: "uninitialized" /* Uninitialized */,
    error: void 0,
    validationResult: void 0,
    generatedNotes: 0,
    lastUpdated: Date.now()
  });
  component_subscribe($$self, state, (value) => $$invalidate(3, $state = value));
  onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    try {
      yield initializeComponent();
      state.update((s) => Object.assign(Object.assign({}, s), {
        isInitialized: true,
        lifecycle: "ready" /* Ready */
      }));
    } catch (error) {
      console.error("Failed to initialize AdvancedAccordion:", error);
      handleError(error);
    }
  }));
  function initializeComponent() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!settingsService.isReady()) {
        throw new Error("Settings service not ready");
      }
      const currentSettings = settingsService.getSettings().advanced;
      state.update((s) => Object.assign(Object.assign({}, s), {
        settings: {
          generateWikilinks: currentSettings.generateWikilinks,
          temperature: currentSettings.temperature,
          maxTokens: currentSettings.maxTokens
        },
        lastUpdated: Date.now()
      }));
    });
  }
  function handleSettingChange(key, value) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        validateSetting(key, value);
        yield settingsService.updateNestedSetting("advanced", key, value);
        state.update((s) => Object.assign(Object.assign({}, s), {
          settings: Object.assign(Object.assign({}, s.settings), { [key]: value }),
          lastUpdated: Date.now()
        }));
        new import_obsidian25.Notice(`${key.charAt(0).toUpperCase() + key.slice(1)} setting updated.`);
        onChange === null || onChange === void 0 ? void 0 : onChange(value);
      } catch (error) {
        console.error(`\u{1F987} Error updating ${key} setting:`, error);
        handleError(error);
        state.update((s) => Object.assign(Object.assign({}, s), {
          settings: Object.assign(Object.assign({}, s.settings), {
            [key]: settingsService.getSettings().advanced[key]
          })
        }));
      }
    });
  }
  function handleGenerateKnowledgeBloom() {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      if ($state.isGenerating)
        return;
      const activeFile = app.workspace.getActiveFile();
      if (!(activeFile instanceof import_obsidian25.TFile)) {
        new import_obsidian25.Notice("No active file found.");
        return;
      }
      try {
        state.update((s) => Object.assign(Object.assign({}, s), { isGenerating: true }));
        const generationService = aiService.getGenerationService();
        const result = yield generationService.generateKnowledgeBloom(activeFile, $state.settings.generateWikilinks.toString());
        if ((_a = result === null || result === void 0 ? void 0 : result.generatedNotes) === null || _a === void 0 ? void 0 : _a.length) {
          yield createGeneratedNotes(result.generatedNotes);
          state.update((s) => Object.assign(Object.assign({}, s), {
            generatedNotes: result.generatedNotes.length,
            lastUpdated: Date.now()
          }));
          new import_obsidian25.Notice(`Generated ${result.generatedNotes.length} new notes!`);
        } else {
          new import_obsidian25.Notice("No notes were generated.");
        }
      } catch (error) {
        console.error("\u{1F987} Error generating knowledge bloom:", error);
        handleError(error);
      } finally {
        state.update((s) => Object.assign(Object.assign({}, s), { isGenerating: false }));
      }
    });
  }
  function createGeneratedNotes(notes) {
    return __awaiter(this, void 0, void 0, function* () {
      for (const note of notes) {
        const filePath = `${note.title}.md`;
        const existingFile = app.vault.getAbstractFileByPath(filePath);
        try {
          if (existingFile instanceof import_obsidian25.TFile) {
            yield app.vault.modify(existingFile, note.content);
          } else {
            yield app.vault.create(filePath, note.content);
          }
        } catch (error) {
          console.error(`\u{1F987} Error creating/updating note ${filePath}:`, error);
          new import_obsidian25.Notice(`Failed to create/update note "${note.title}"`);
        }
      }
    });
  }
  function handleError(error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    state.update((s) => Object.assign(Object.assign({}, s), {
      error: {
        message,
        timestamp: Date.now(),
        source: "AdvancedAccordion"
      },
      lifecycle: "error" /* Error */
    }));
    new import_obsidian25.Notice(`Advanced Settings Error: ${message}`);
  }
  function input0_change_handler() {
    $state.settings.generateWikilinks = this.checked;
    state.set($state);
  }
  const change_handler = (e) => handleSettingChange("generateWikilinks", e.currentTarget.checked);
  function input1_change_input_handler() {
    $state.settings.temperature = to_number(this.value);
    state.set($state);
  }
  const change_handler_1 = (e) => handleSettingChange("temperature", parseFloat(e.currentTarget.value));
  function input2_input_handler() {
    $state.settings.maxTokens = to_number(this.value);
    state.set($state);
  }
  const change_handler_2 = (e) => handleSettingChange("maxTokens", parseInt(e.currentTarget.value));
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("description" in $$props2)
      $$invalidate(1, description = $$props2.description);
    if ("app" in $$props2)
      $$invalidate(7, app = $$props2.app);
    if ("settingsService" in $$props2)
      $$invalidate(8, settingsService = $$props2.settingsService);
    if ("aiService" in $$props2)
      $$invalidate(9, aiService = $$props2.aiService);
    if ("isOpen" in $$props2)
      $$invalidate(2, isOpen = $$props2.isOpen);
    if ("onChange" in $$props2)
      $$invalidate(10, onChange = $$props2.onChange);
    if ("onBlur" in $$props2)
      $$invalidate(11, onBlur = $$props2.onBlur);
    if ("onFocus" in $$props2)
      $$invalidate(12, onFocus = $$props2.onFocus);
    if ("onClick" in $$props2)
      $$invalidate(13, onClick = $$props2.onClick);
    if ("onKeyDown" in $$props2)
      $$invalidate(14, onKeyDown = $$props2.onKeyDown);
  };
  return [
    title,
    description,
    isOpen,
    $state,
    state,
    handleSettingChange,
    handleGenerateKnowledgeBloom,
    app,
    settingsService,
    aiService,
    onChange,
    onBlur,
    onFocus,
    onClick,
    onKeyDown,
    input0_change_handler,
    change_handler,
    input1_change_input_handler,
    change_handler_1,
    input2_input_handler,
    change_handler_2
  ];
}
var AdvancedAccordion = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance12,
      create_fragment12,
      safe_not_equal,
      {
        title: 0,
        description: 1,
        app: 7,
        settingsService: 8,
        aiService: 9,
        isOpen: 2,
        onChange: 10,
        onBlur: 11,
        onFocus: 12,
        onClick: 13,
        onKeyDown: 14
      },
      add_css12
    );
  }
};
var AdvancedAccordion_default = AdvancedAccordion;

// src/components/modals/ModalContainer.svelte
function add_css13(target) {
  append_styles(target, "svelte-1o8gsxo", ".modal-container.svelte-1o8gsxo{position:fixed;top:0;left:0;right:0;bottom:0;z-index:999;display:none;align-items:center;justify-content:center;pointer-events:none}.modal-container.active.svelte-1o8gsxo{display:flex;pointer-events:auto}.modal-backdrop.svelte-1o8gsxo{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0, 0, 0, 0.3);z-index:-1}.modal-content.svelte-1o8gsxo{position:relative;z-index:1000;background:var(--background-primary);border-radius:var(--radius-m);box-shadow:0 4px 12px rgba(0, 0, 0, 0.25);min-width:400px;max-width:80vw;max-height:80vh;overflow-y:auto;pointer-events:auto}");
}
function create_fragment13(ctx) {
  let div2;
  let div0;
  let t;
  let div1;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "modal-backdrop svelte-1o8gsxo");
      attr(div0, "aria-hidden", "true");
      attr(div1, "class", "modal-content svelte-1o8gsxo");
      attr(div2, "class", "modal-container svelte-1o8gsxo");
      toggle_class(
        div2,
        "active",
        /*modalActive*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div2, t);
      append(div2, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(div0, "click", handleBackdropClick),
          listen(div2, "click", stop_propagation(
            /*click_handler*/
            ctx[4]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*modalActive*/
      1) {
        toggle_class(
          div2,
          "active",
          /*modalActive*/
          ctx2[0]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function handleBackdropClick(event) {
  event.stopPropagation();
}
function instance13($$self, $$props, $$invalidate) {
  let modalActive;
  let $hasActiveModal;
  component_subscribe($$self, hasActiveModal, ($$value) => $$invalidate(1, $hasActiveModal = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$hasActiveModal*/
    2) {
      $:
        $$invalidate(0, modalActive = $hasActiveModal);
    }
  };
  return [modalActive, $hasActiveModal, $$scope, slots, click_handler];
}
var ModalContainer = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance13, create_fragment13, safe_not_equal, {}, add_css13);
  }
};
var ModalContainer_default = ModalContainer;

// src/settings/SettingsTab.svelte
function add_css14(target) {
  append_styles(target, "svelte-na1rkd", ".graphweaver-plugin-settings.svelte-na1rkd.svelte-na1rkd{padding:var(--size-4-6);max-width:800px;margin:0 auto;width:100%;animation:svelte-na1rkd-fadeIn 0.3s ease-out;position:relative}.graphweaver-plugin-settings.has-modal.svelte-na1rkd.svelte-na1rkd{position:relative}.graphweaver-plugin-settings.svelte-na1rkd.svelte-na1rkd{position:relative;z-index:1}.accordion-wrapper.svelte-na1rkd.svelte-na1rkd{position:relative;z-index:1}.settings-header.svelte-na1rkd.svelte-na1rkd{position:relative;margin-bottom:var(--size-12);padding:var(--size-8) var(--size-4);background:var(--background-primary)}.header-content.svelte-na1rkd.svelte-na1rkd{position:relative;z-index:1}.header-title.svelte-na1rkd.svelte-na1rkd{display:flex;align-items:center;gap:var(--size-4);margin-bottom:var(--size-4)}.header-title.svelte-na1rkd h2.svelte-na1rkd{margin:0;color:var(--text-normal);font-size:var(--font-ui-xxl);font-weight:var(--font-bold);line-height:1.2}.plugin-version.svelte-na1rkd.svelte-na1rkd{padding:var(--size-1) var(--size-2);background:var(--background-modifier-success);color:var(--text-on-accent);border-radius:var(--radius-s);font-size:var(--font-ui-smaller);font-weight:var(--font-medium)}.header-divider.svelte-na1rkd.svelte-na1rkd{position:absolute;bottom:0;left:0;right:0;height:2px;background:linear-gradient(\r\n            to right,\r\n            var(--background-modifier-border),\r\n            var(--interactive-accent),\r\n            var(--background-modifier-border)\r\n        )}.settings-accordions.svelte-na1rkd.svelte-na1rkd{display:flex;flex-direction:column;gap:var(--size-4);padding:var(--size-4)}.accordion-wrapper.svelte-na1rkd.svelte-na1rkd{opacity:0;transform:translateY(10px);animation:svelte-na1rkd-slideIn 0.3s ease-out forwards;animation-delay:var(--animation-delay, 0)}.accordion-wrapper.active.svelte-na1rkd.svelte-na1rkd{z-index:1}@keyframes svelte-na1rkd-slideIn{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}@keyframes svelte-na1rkd-fadeIn{from{opacity:0}to{opacity:1}}.theme-dark .settings-header.svelte-na1rkd.svelte-na1rkd{background:linear-gradient(\r\n            180deg,\r\n            var(--background-primary) 0%,\r\n            var(--background-primary-alt) 100%\r\n        )}.theme-dark .accordion-wrapper.svelte-na1rkd.svelte-na1rkd{background-color:var(--background-primary-alt)}@media(max-width: 768px){.graphweaver-plugin-settings.svelte-na1rkd.svelte-na1rkd{padding:var(--size-2)}.settings-header.svelte-na1rkd.svelte-na1rkd{padding:var(--size-4);margin-bottom:var(--size-8)}.header-title.svelte-na1rkd h2.svelte-na1rkd{font-size:var(--font-ui-large)}}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  return child_ctx;
}
function create_if_block7(ctx) {
  let div5;
  let header;
  let div2;
  let div1;
  let h2;
  let t1;
  let div0;
  let t2;
  let t3_value = (
    /*plugin*/
    ctx[0].manifest.version + ""
  );
  let t3;
  let t4;
  let p;
  let t6;
  let div3;
  let t7;
  let div4;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t8;
  let modalcontainer;
  let current;
  let each_value = ensure_array_like(
    /*accordions*/
    ctx[5]
  );
  const get_key = (ctx2) => (
    /*accordion*/
    ctx2[19].id
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context2(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block2(key, child_ctx));
  }
  modalcontainer = new ModalContainer_default({});
  return {
    c() {
      div5 = element("div");
      header = element("header");
      div2 = element("div");
      div1 = element("div");
      h2 = element("h2");
      h2.textContent = "GraphWeaver Settings";
      t1 = space();
      div0 = element("div");
      t2 = text("v");
      t3 = text(t3_value);
      t4 = space();
      p = element("p");
      p.textContent = "Configure AI models, manage properties and tags, and customize your knowledge graph generation.";
      t6 = space();
      div3 = element("div");
      t7 = space();
      div4 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t8 = space();
      create_component(modalcontainer.$$.fragment);
      attr(h2, "class", "svelte-na1rkd");
      attr(div0, "class", "plugin-version svelte-na1rkd");
      attr(div1, "class", "header-title svelte-na1rkd");
      attr(div2, "class", "header-content svelte-na1rkd");
      attr(div3, "class", "header-divider svelte-na1rkd");
      attr(div3, "aria-hidden", "true");
      attr(header, "class", "settings-header svelte-na1rkd");
      attr(div4, "class", "settings-accordions svelte-na1rkd");
      attr(div4, "role", "list");
      attr(div5, "class", "graphweaver-plugin-settings svelte-na1rkd");
      attr(div5, "role", "region");
      attr(div5, "aria-label", "Plugin Settings");
      toggle_class(
        div5,
        "has-modal",
        /*modalActive*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, header);
      append(header, div2);
      append(div2, div1);
      append(div1, h2);
      append(div1, t1);
      append(div1, div0);
      append(div0, t2);
      append(div0, t3);
      append(div2, t4);
      append(div2, p);
      append(header, t6);
      append(header, div3);
      append(div5, t7);
      append(div5, div4);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div4, null);
        }
      }
      append(div5, t8);
      mount_component(modalcontainer, div5, null);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*plugin*/
      1) && t3_value !== (t3_value = /*plugin*/
      ctx2[0].manifest.version + ""))
        set_data(t3, t3_value);
      if (dirty & /*accordions, activeAccordionId, getAccordionProps, handleAccordionToggle*/
      228) {
        each_value = ensure_array_like(
          /*accordions*/
          ctx2[5]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div4, outro_and_destroy_block, create_each_block2, null, get_each_context2);
        check_outros();
      }
      if (!current || dirty & /*modalActive*/
      8) {
        toggle_class(
          div5,
          "has-modal",
          /*modalActive*/
          ctx2[3]
        );
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(modalcontainer.$$.fragment, local);
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(modalcontainer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div5);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      destroy_component(modalcontainer);
    }
  };
}
function create_each_block2(key_1, ctx) {
  let div;
  let switch_instance;
  let t;
  let current;
  const switch_instance_spread_levels = [
    /*getAccordionProps*/
    ctx[7](
      /*accordion*/
      ctx[19]
    )
  ];
  function click_handler() {
    return (
      /*click_handler*/
      ctx[13](
        /*accordion*/
        ctx[19]
      )
    );
  }
  var switch_value = (
    /*accordion*/
    ctx[19].component
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    if (dirty !== void 0 && dirty & /*getAccordionProps, accordions*/
    160) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*getAccordionProps*/
        ctx2[7](
          /*accordion*/
          ctx2[19]
        )
      )]));
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    switch_instance.$on("click", click_handler);
  }
  return {
    key: key_1,
    first: null,
    c() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t = space();
      attr(div, "class", "accordion-wrapper svelte-na1rkd");
      set_style(
        div,
        "--animation-delay",
        /*accordion*/
        ctx[19].priority * 100 + "ms"
      );
      attr(div, "role", "listitem");
      toggle_class(
        div,
        "active",
        /*activeAccordionId*/
        ctx[2] === /*accordion*/
        ctx[19].id
      );
      this.first = div;
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      append(div, t);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (switch_value !== (switch_value = /*accordion*/
      ctx[19].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
          switch_instance.$on("click", click_handler);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, t);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*getAccordionProps, accordions*/
        160 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*getAccordionProps*/
          ctx[7](
            /*accordion*/
            ctx[19]
          )
        )]) : {};
        switch_instance.$set(switch_instance_changes);
      }
      if (!current || dirty & /*activeAccordionId, accordions*/
      36) {
        toggle_class(
          div,
          "active",
          /*activeAccordionId*/
          ctx[2] === /*accordion*/
          ctx[19].id
        );
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
}
function create_fragment14(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*isInitialized*/
    ctx[1] && !/*destroyed*/
    ctx[4] && create_if_block7(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*isInitialized*/
        ctx2[1] && !/*destroyed*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*isInitialized, destroyed*/
          18) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block7(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance14($$self, $$props, $$invalidate) {
  let $hasActiveModal;
  component_subscribe($$self, hasActiveModal, ($$value) => $$invalidate(12, $hasActiveModal = $$value));
  var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  let { app } = $$props;
  let { plugin } = $$props;
  let { settingsService } = $$props;
  let { aiService } = $$props;
  let { tagManagementService } = $$props;
  let isInitialized2 = false;
  let activeAccordionId = null;
  let modalActive;
  let destroyed = false;
  const accordions = [
    {
      id: "modelHookup",
      component: ModelHookupAccordion_default,
      title: "\u{1F50C} Model Hookup",
      description: "Configure AI providers and models",
      priority: 1,
      enabled: true
    },
    {
      id: "propertyManager",
      component: PropertyManagerAccordion_default,
      title: "\u{1F4CA} Property Manager",
      description: "Create and manage custom properties for your notes.",
      priority: 2,
      enabled: true
    },
    {
      id: "tagManager",
      component: TagManagerAccordion_default,
      title: "\u{1F3F7}\uFE0F Tag Manager",
      description: "Manage custom tags",
      priority: 3,
      enabled: true
    },
    {
      id: "ontologyGenerator",
      component: OntologyGenerationAccordion_default,
      title: "\u{1F9E0} Ontology Generation",
      description: "Generate and manage ontologies for your vault.",
      priority: 4,
      enabled: (settingsService === null || settingsService === void 0 ? void 0 : settingsService.isReady()) && (aiService === null || aiService === void 0 ? void 0 : aiService.isReady())
    },
    {
      id: "knowledgeBloom",
      component: KnowledgeBloomAccordion_default,
      title: "\u{1F338} Knowledge Bloom",
      description: "Enhance your knowledge graph with Bloom features.",
      priority: 5,
      enabled: (settingsService === null || settingsService === void 0 ? void 0 : settingsService.isReady()) && (aiService === null || aiService === void 0 ? void 0 : aiService.isReady())
    },
    {
      id: "batchProcessor",
      component: BatchProcessorAccordion_default,
      title: "\u{1F504} Batch Processor",
      description: "Process multiple files to generate front matter and wikilinks.",
      priority: 6,
      enabled: settingsService === null || settingsService === void 0 ? void 0 : settingsService.isReady()
    },
    {
      id: "advanced",
      component: AdvancedAccordion_default,
      title: "\u2699\uFE0F Advanced",
      description: "Configuration options for the plugin.",
      priority: 7,
      enabled: true
    }
  ].sort((a, b) => a.priority - b.priority).filter((config) => config.enabled);
  let unsubscribeUI = null;
  function subscribeToUIStore() {
    unsubscribeUI = uiStore.subscribe((state) => {
      if (!destroyed) {
        $$invalidate(3, modalActive = state.modalStack.length > 0);
      }
    });
  }
  function initialize() {
    return __awaiter(this, void 0, void 0, function* () {
      console.log("\u{1F987} Initializing settings tab...");
      if (!app || !plugin || !settingsService || !aiService) {
        console.error("\u{1F987} Required dependencies not provided");
        return;
      }
      try {
        const servicesReady = settingsService.isReady() && aiService.isReady() && accordions.some((acc) => acc.enabled);
        if (servicesReady) {
          console.log("\u{1F987} Services ready, initializing UI...");
          $$invalidate(1, isInitialized2 = true);
          subscribeToUIStore();
        } else {
          console.log("\u{1F987} Waiting for services to be ready...");
          yield waitForServices();
        }
      } catch (error) {
        console.error("\u{1F987} Initialization error:", error);
        throw error;
      }
    });
  }
  function waitForServices(timeout = 5e3) {
    return __awaiter(this, void 0, void 0, function* () {
      const start = Date.now();
      while (Date.now() - start < timeout) {
        if (settingsService.isReady() && aiService.isReady()) {
          $$invalidate(1, isInitialized2 = true);
          subscribeToUIStore();
          return;
        }
        yield new Promise((resolve) => setTimeout(resolve, 100));
      }
      throw new Error("Services initialization timeout");
    });
  }
  function handleAccordionToggle(accordionId) {
    if (modalActive)
      return;
    $$invalidate(2, activeAccordionId = activeAccordionId === accordionId ? null : accordionId);
    uiStore.update((state) => Object.assign(Object.assign({}, state), {
      activeAccordion: activeAccordionId,
      lastInteraction: Date.now()
    }));
  }
  onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    if (!destroyed) {
      yield initialize();
    }
  }));
  onDestroy(() => {
    $$invalidate(4, destroyed = true);
    if (unsubscribeUI) {
      unsubscribeUI();
    }
    $$invalidate(1, isInitialized2 = false);
  });
  function getAccordionProps(accordion) {
    return {
      app,
      settingsService,
      aiService,
      tagManagementService,
      title: accordion.title,
      description: accordion.description,
      isOpen: activeAccordionId === accordion.id,
      plugin
    };
  }
  const click_handler = (accordion) => handleAccordionToggle(accordion.id);
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(8, app = $$props2.app);
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
    if ("settingsService" in $$props2)
      $$invalidate(9, settingsService = $$props2.settingsService);
    if ("aiService" in $$props2)
      $$invalidate(10, aiService = $$props2.aiService);
    if ("tagManagementService" in $$props2)
      $$invalidate(11, tagManagementService = $$props2.tagManagementService);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$hasActiveModal*/
    4096) {
      $:
        $$invalidate(3, modalActive = $hasActiveModal);
    }
  };
  return [
    plugin,
    isInitialized2,
    activeAccordionId,
    modalActive,
    destroyed,
    accordions,
    handleAccordionToggle,
    getAccordionProps,
    app,
    settingsService,
    aiService,
    tagManagementService,
    $hasActiveModal,
    click_handler
  ];
}
var SettingsTab = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance14,
      create_fragment14,
      safe_not_equal,
      {
        app: 8,
        plugin: 0,
        settingsService: 9,
        aiService: 10,
        tagManagementService: 11
      },
      add_css14
    );
  }
};
var SettingsTab_default = SettingsTab;

// src/settings/GraphWeaverSettingTab.ts
var import_lodash = __toESM(require_lodash(), 1);
var GraphWeaverSettingTab = class extends import_obsidian26.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.svelteComponent = null;
    this.mountElement = null;
    this.isInitialized = false;
    this.initializationAttempts = 0;
    this.MAX_INIT_ATTEMPTS = 3;
    this.INIT_RETRY_DELAY = 1e3;
    // ms
    // Debounced error handler to prevent error message spam
    this.debouncedError = (0, import_lodash.debounce)((message) => {
      new import_obsidian26.Notice(`Settings Error: ${message}`);
    }, 1e3, { leading: true, trailing: false });
    this.plugin = plugin;
    this.app = app;
  }
  /**
   * Safely initializes and displays the settings tab
   */
  display() {
    return __async(this, null, function* () {
      try {
        yield this.ensureInitialization();
        yield this.mountComponent();
      } catch (error) {
        console.error("\u{1F987} Settings initialization failed:", error);
        yield this.handleInitializationError(error);
      }
    });
  }
  /**
   * Ensures proper initialization of required services
   */
  ensureInitialization() {
    return __async(this, null, function* () {
      if (this.isInitialized)
        return;
      const { containerEl } = this;
      if (!containerEl) {
        throw new Error("Container element is not initialized");
      }
      if (!this.plugin.isReady()) {
        yield this.plugin.ensureInitialized();
      }
      containerEl.empty();
      this.isInitialized = true;
    });
  }
  /**
   * Safely mounts the Svelte component
   */
  mountComponent() {
    return __async(this, null, function* () {
      const { containerEl } = this;
      if (!containerEl || !this.isInitialized)
        return;
      try {
        const mountPoint = containerEl.createDiv();
        mountPoint.addClass("vertical-tab-content", "graphweaver-settings");
        this.mountElement = mountPoint;
        if (!this.svelteComponent && mountPoint) {
          this.svelteComponent = new SettingsTab_default({
            target: mountPoint,
            props: {
              app: this.app,
              plugin: this.plugin,
              settingsService: this.plugin.settings,
              aiService: this.plugin.ai,
              tagManagementService: this.plugin.tagManager
            }
          });
        }
      } catch (error) {
        throw new Error(`Failed to mount settings component: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    });
  }
  /**
   * Handles initialization errors with retry logic
   */
  handleInitializationError(error) {
    return __async(this, null, function* () {
      this.initializationAttempts++;
      if (this.initializationAttempts < this.MAX_INIT_ATTEMPTS) {
        console.log(`\u{1F987} Retrying initialization (${this.initializationAttempts}/${this.MAX_INIT_ATTEMPTS})...`);
        yield new Promise((resolve) => setTimeout(resolve, this.INIT_RETRY_DELAY));
        yield this.display();
      } else {
        this.handleError(error);
        this.showFallbackUI();
      }
    });
  }
  /**
   * Handles and displays errors
   */
  handleError(error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    console.error("\u{1F987} Settings error:", error);
    this.debouncedError(message);
  }
  /**
   * Shows fallback UI when initialization fails
   */
  showFallbackUI() {
    const { containerEl } = this;
    if (!containerEl)
      return;
    containerEl.empty();
    const errorEl = containerEl.createDiv();
    errorEl.addClass("settings-error");
    const messageEl = errorEl.createDiv();
    messageEl.setText("Failed to initialize settings. Please try reloading Obsidian.");
    const retryButton = errorEl.createEl("button");
    retryButton.setText("Retry");
    retryButton.onclick = () => __async(this, null, function* () {
      this.initializationAttempts = 0;
      this.isInitialized = false;
      yield this.display();
    });
  }
  /**
   * Safely cleans up the component and its resources
   */
  hide() {
    try {
      if (this.svelteComponent) {
        this.svelteComponent.$destroy();
        this.svelteComponent = null;
      }
      if (this.mountElement) {
        this.mountElement.empty();
        this.mountElement = null;
      }
      const { containerEl } = this;
      if (containerEl) {
        containerEl.empty();
      }
      this.isInitialized = false;
      this.initializationAttempts = 0;
    } catch (error) {
      console.error("\u{1F987} Error during cleanup:", error);
    }
  }
};

// src/managers/CommandManager.ts
var CommandManager = class extends TypedEventEmitter {
  constructor(plugin) {
    super();
    this.plugin = plugin;
    this.serviceId = "command-manager";
    this.serviceName = "Command Manager";
    this.state = "uninitialized" /* Uninitialized */;
    this.error = null;
    this.commands = /* @__PURE__ */ new Map();
  }
  /**
   * Initialize command manager
   */
  initialize() {
    return __async(this, null, function* () {
      try {
        if (this.state !== "uninitialized" /* Uninitialized */) {
          console.log("\u{1F987} [CommandManager] Already initialized");
          return;
        }
        console.log("\u{1F987} [CommandManager] Starting initialization...");
        this.state = "initializing" /* Initializing */;
        const registry = ServiceRegistry.getInstance();
        if (!registry.hasRegisteredServices()) {
          throw new ServiceError(
            this.serviceName,
            "Service registry must be initialized before command manager"
          );
        }
        yield this.registerDefaultCommands();
        console.log("\u{1F987} [CommandManager] Initialization complete");
        this.state = "ready" /* Ready */;
      } catch (error) {
        this.state = "error" /* Error */;
        this.error = ServiceError.from(this.serviceName, error);
        console.error("\u{1F987} [CommandManager] Initialization failed:", this.error);
        throw this.error;
      }
    });
  }
  /**
   * Register a new command
   */
  registerCommand(command) {
    if (this.commands.has(command.id)) {
      throw new ServiceError(this.serviceName, `Command ${command.id} already registered`);
    }
    const wrappedCommand = this.wrapCommand(command);
    this.plugin.addCommand(wrappedCommand);
    this.commands.set(command.id, wrappedCommand);
    this.emit("commandRegistered", wrappedCommand);
  }
  /**
   * Execute a command by ID
   */
  executeCommand(_0) {
    return __async(this, arguments, function* (id, context = {}) {
      const command = this.commands.get(id);
      if (!command) {
        throw new ServiceError(this.serviceName, `Command ${id} not found`);
      }
      const execContext = {
        source: context.source || "command-palette",
        timestamp: Date.now(),
        data: context.data
      };
      const startTime = performance.now();
      try {
        if (command.checkCallback) {
          if (!command.checkCallback(false)) {
            throw new Error("Command preconditions not met");
          }
        }
        if (command.callback) {
          yield command.callback();
        }
        const result = {
          success: true,
          duration: performance.now() - startTime
        };
        this.emit("commandExecuted", id, result, execContext);
      } catch (error) {
        const result = {
          success: false,
          error: error instanceof Error ? error : new Error(String(error)),
          duration: performance.now() - startTime
        };
        this.emit("commandFailed", id, result.error, execContext);
        throw error;
      }
    });
  }
  /**
   * Check if manager is ready
   */
  isReady() {
    return this.state === "ready" /* Ready */;
  }
  /**
   * Get current state
   */
  getState() {
    return { state: this.state, error: this.error };
  }
  /**
   * Clean up resources
   */
  destroy() {
    return __async(this, null, function* () {
      this.commands.clear();
      this.state = "destroyed" /* Destroyed */;
    });
  }
  /**
   * Validate active file existence
   */
  validateActiveFile(checking) {
    const activeFile = this.plugin.app.workspace.getActiveFile();
    if (checking)
      return !!activeFile;
    if (!activeFile) {
      if (!checking) {
        console.error("\u{1F987} [CommandManager] No active file");
      }
      return false;
    }
    return true;
  }
  /**
   * Register default plugin commands
   */
  registerDefaultCommands() {
    return __async(this, null, function* () {
      try {
        console.log("\u{1F987} [CommandManager] Registering default commands...");
        const defaultCommands = [
          {
            id: "generate-frontmatter",
            name: "Generate Front Matter",
            checkCallback: (checking) => this.validateActiveFile(checking)
          },
          {
            id: "generate-wikilinks",
            name: "Generate Wikilinks",
            checkCallback: (checking) => this.validateActiveFile(checking)
          },
          {
            id: "generate-knowledge-bloom",
            name: "Generate Knowledge Bloom",
            checkCallback: (checking) => {
              if (!this.validateActiveFile(checking))
                return false;
              return true;
            }
          },
          {
            id: "batch-process-files",
            name: "Batch Process Files",
            checkCallback: (checking) => {
              return true;
            }
          }
        ];
        for (const command of defaultCommands) {
          try {
            this.registerCommand(command);
          } catch (error) {
            console.error(`\uFFFD\uFFFD [CommandManager] Failed to register command ${command.id}:`, error);
            throw error;
          }
        }
        console.log("\u{1F987} [CommandManager] Default commands registered successfully");
      } catch (error) {
        throw new ServiceError(
          this.serviceName,
          "Failed to register default commands",
          error instanceof Error ? error : new Error(String(error))
        );
      }
    });
  }
  /**
   * Wrap command with error handling and events
   */
  wrapCommand(command) {
    return __spreadProps(__spreadValues({}, command), {
      callback: () => __async(this, null, function* () {
        const context = {
          source: "command-palette",
          timestamp: Date.now()
        };
        try {
          yield this.executeCommand(command.id, context);
        } catch (error) {
          console.error(`\u{1F987} [CommandManager] Error executing ${command.id}:`, error);
          throw error;
        }
      }),
      checkCallback: command.checkCallback
    });
  }
  /**
   * Helper to get active file with type checking
   */
  getActiveFile() {
    const file = this.plugin.app.workspace.getActiveFile();
    if (!file) {
      throw new ServiceError(this.serviceName, "No active file");
    }
    return file;
  }
};

// main.ts
var GraphWeaverPlugin = class extends import_obsidian27.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    this.CONFIG = {
      INIT_RETRY_MS: 5e3,
      MAX_INIT_RETRIES: 3,
      SAVE_INTERVAL_MS: 1e3
    };
    this.initRetryCount = 0;
    this.isInitialized = false;
    this.initializedServices = /* @__PURE__ */ new Set();
    this.initializationPromise = null;
    this.settingTab = null;
    this.commandManager = new CommandManager(this);
    this.serviceRegistry = ServiceRegistry.getInstance();
  }
  /**
   * Plugin load lifecycle method
   */
  onload() {
    return __async(this, null, function* () {
      try {
        console.log("\u{1F987} Starting GraphWeaver initialization...");
        yield this.initializeCore();
        this.settings = new SettingsService(this);
        yield this.settings.initialize();
        const jsonValidationService = new JsonValidationService();
        yield jsonValidationService.initialize();
        const databaseService = new DatabaseService(this);
        yield databaseService.initialize();
        const wikilinkProcessor = new WikilinkTextProcessor();
        yield wikilinkProcessor.initialize();
        const adapterRegistry = new AdapterRegistry(this.settings, jsonValidationService);
        yield adapterRegistry.initialize();
        const generatorFactory = new GeneratorFactory(
          this.app,
          this.settings,
          adapterRegistry,
          wikilinkProcessor
        );
        yield generatorFactory.initialize();
        const operationManager = new AIOperationManager(adapterRegistry, generatorFactory);
        yield operationManager.initialize();
        this.ai = new AIService(
          this.app,
          operationManager,
          this.settings,
          jsonValidationService,
          databaseService,
          wikilinkProcessor
        );
        yield this.ai.initialize();
        this.tagManager = new TagManagementService(this.app, this);
        yield this.tagManager.initialize();
        yield this.initializeServices();
        yield this.registerFeatures();
        this.isInitialized = true;
        console.log("\u{1F987} GraphWeaver initialization complete!");
        new import_obsidian27.Notice("GraphWeaver initialized successfully! \u{1F680}");
      } catch (error) {
        yield this.handleInitializationError(error);
      }
    });
  }
  /**
   * Initialize core plugin components
   */
  initializeCore() {
    return __async(this, null, function* () {
      try {
        console.log("\u{1F987} Initializing core components...");
        const savedData = yield this.loadData();
        yield initializeStores({
          plugin: this,
          data: savedData
        });
        yield this.serviceRegistry.initializeRegistry();
        yield initializeCoreServices(this);
        console.log("\u{1F987} Core initialization complete");
      } catch (error) {
        throw new ServiceError("Core Initialization", "Failed to initialize core components", error);
      }
    });
  }
  /**
   * Initialize and register all services
   */
  initializeServices() {
    return __async(this, null, function* () {
      try {
        console.log("\u{1F987} Starting service initialization...");
        const ServiceIds = {
          SETTINGS: "settingsService",
          JSON_VALIDATION: "jsonValidationService",
          DATABASE: "databaseService",
          WIKILINK: "wikilinkProcessor",
          ADAPTER_REGISTRY: "adapterRegistry",
          GENERATOR_FACTORY: "generatorFactory",
          AI_OPERATION: "aiOperationManager",
          AI_SERVICE: "aiService",
          FILE_PROCESSOR: "fileProcessorService"
        };
        this.initializedServices.clear();
        console.log("\u{1F987} Initializing Core Services (Group 1)...");
        this.settingsService = new SettingsService(this);
        yield this.settingsService.initialize();
        yield this.verifyServiceReady(this.settingsService, "Settings Service");
        yield this.serviceRegistry.registerService(ServiceIds.SETTINGS, this.settingsService);
        this.initializedServices.add(ServiceIds.SETTINGS);
        const jsonValidationService = new JsonValidationService();
        yield jsonValidationService.initialize();
        yield this.verifyServiceReady(jsonValidationService, "JSON Validation Service");
        yield this.serviceRegistry.registerService(ServiceIds.JSON_VALIDATION, jsonValidationService);
        this.initializedServices.add(ServiceIds.JSON_VALIDATION);
        const databaseService = new DatabaseService(this);
        yield databaseService.initialize();
        yield this.verifyServiceReady(databaseService, "Database Service");
        yield this.serviceRegistry.registerService(ServiceIds.DATABASE, databaseService);
        this.initializedServices.add(ServiceIds.DATABASE);
        console.log("\u{1F987} Initializing Processing Services (Group 2)...");
        const wikilinkProcessor = new WikilinkTextProcessor();
        yield wikilinkProcessor.initialize();
        yield this.verifyServiceReady(wikilinkProcessor, "Wikilink Processor");
        yield this.serviceRegistry.registerService(ServiceIds.WIKILINK, wikilinkProcessor);
        this.initializedServices.add(ServiceIds.WIKILINK);
        console.log("\u{1F987} Initializing Registry Services (Group 3)...");
        const adapterRegistry = new AdapterRegistry(this.settingsService, jsonValidationService);
        yield adapterRegistry.initialize();
        yield this.verifyServiceReady(adapterRegistry, "Adapter Registry");
        yield this.serviceRegistry.registerService(ServiceIds.ADAPTER_REGISTRY, adapterRegistry);
        this.initializedServices.add(ServiceIds.ADAPTER_REGISTRY);
        const generatorFactory = new GeneratorFactory(
          this.app,
          this.settingsService,
          adapterRegistry,
          wikilinkProcessor
        );
        yield generatorFactory.initialize();
        yield this.verifyServiceReady(generatorFactory, "Generator Factory");
        yield this.serviceRegistry.registerService(ServiceIds.GENERATOR_FACTORY, generatorFactory);
        this.initializedServices.add(ServiceIds.GENERATOR_FACTORY);
        console.log("\u{1F987} Initializing AI Services (Group 4)...");
        const operationManager = new AIOperationManager(adapterRegistry, generatorFactory);
        yield operationManager.initialize();
        yield this.verifyServiceReady(operationManager, "AI Operation Manager");
        yield this.serviceRegistry.registerService(ServiceIds.AI_OPERATION, operationManager);
        this.initializedServices.add(ServiceIds.AI_OPERATION);
        this.aiService = new AIService(
          this.app,
          operationManager,
          this.settingsService,
          jsonValidationService,
          databaseService,
          wikilinkProcessor
        );
        yield this.aiService.initialize();
        yield this.verifyServiceReady(this.aiService, "AI Service");
        yield this.serviceRegistry.registerService(ServiceIds.AI_SERVICE, this.aiService);
        this.initializedServices.add(ServiceIds.AI_SERVICE);
        console.log("\u{1F987} Initializing File Services (Group 5)...");
        let fileScannerService;
        if (!this.initializedServices.has("fileScannerService")) {
          console.log("\u{1F987} Creating new FileScannerService instance");
          fileScannerService = new FileScannerService(this.app.vault);
          yield fileScannerService.initialize();
          yield this.verifyServiceReady(fileScannerService, "File Scanner Service");
          yield this.serviceRegistry.registerService("fileScannerService", fileScannerService);
          this.initializedServices.add("fileScannerService");
        } else {
          console.log("\u{1F987} Reusing existing FileScannerService instance");
          fileScannerService = this.serviceRegistry.getService("fileScannerService");
        }
        const processingStateStore = writable({
          isProcessing: false,
          currentFile: null,
          progress: 0,
          error: null,
          queue: [],
          state: "idle" /* IDLE */,
          filesQueued: 0,
          filesProcessed: 0,
          filesRemaining: 0,
          errors: [],
          startTime: null,
          estimatedTimeRemaining: null
        });
        let fileProcessorService = null;
        if (!this.initializedServices.has(ServiceIds.FILE_PROCESSOR)) {
          console.log("\u{1F987} Creating new FileProcessorService instance");
          fileProcessorService = new FileProcessorService(
            this.app,
            this.aiService,
            this.settingsService,
            databaseService,
            fileScannerService,
            generatorFactory,
            processingStateStore
          );
          yield fileProcessorService.initialize();
          yield this.verifyServiceReady(fileProcessorService, "File Processor Service");
          yield this.serviceRegistry.registerService(ServiceIds.FILE_PROCESSOR, fileProcessorService);
          this.initializedServices.add(ServiceIds.FILE_PROCESSOR);
        }
        console.log("\u{1F987} Registering remaining services...");
        yield registerFileServices(this.app);
        yield registerUIServices();
        console.log("\u{1F987} Initializing UI services...");
        yield initializeUIServices();
        yield this.verifyAllServices();
        console.log("\u{1F987} Service initialization complete");
      } catch (error) {
        console.error("\u{1F987} Service initialization failed:", error);
        throw new ServiceError(
          "Service Initialization",
          "Failed to initialize services",
          error instanceof Error ? error : void 0
        );
      }
    });
  }
  waitForDependencies(services, context) {
    return __async(this, null, function* () {
      console.log(`\u{1F987} Waiting for dependencies: ${context}...`);
      const timeout = 3e4;
      const startTime = Date.now();
      while (services.some((service) => !service.isReady())) {
        if (Date.now() - startTime > timeout) {
          const notReady = services.filter((s) => !s.isReady()).map((s) => s.serviceName);
          throw new Error(`Timeout waiting for dependencies: ${notReady.join(", ")}`);
        }
        yield new Promise((resolve) => setTimeout(resolve, 100));
      }
      console.log(`\u{1F987} All dependencies ready for: ${context}`);
    });
  }
  /**
   * Verify that a specific service is ready
   */
  verifyServiceReady(service, serviceName) {
    return __async(this, null, function* () {
      console.log(`\u{1F987} Verifying ${serviceName}...`);
      if (service.isReady()) {
        console.log(`\u{1F987} ${serviceName} is ready`);
        return;
      }
      for (let i = 0; i < 50; i++) {
        yield new Promise((resolve) => setTimeout(resolve, 100));
        if (service.isReady()) {
          console.log(`\u{1F987} ${serviceName} is ready after waiting`);
          return;
        }
      }
      throw new ServiceError(
        serviceName,
        `Service failed to reach ready state after initialization`
      );
    });
  }
  /**
   * Verify all services are ready
   */
  verifyAllServices() {
    return __async(this, null, function* () {
      console.log("\u{1F987} Verifying all services...");
      const services = this.serviceRegistry.getRegisteredServices();
      const notReady = services.filter((s) => !s.service.isReady());
      if (notReady.length > 0) {
        const names = notReady.map((s) => s.name).join(", ");
        console.error("\u{1F987} Services not ready:", names);
        throw new ServiceError(
          "Service Verification",
          `Services not ready: ${names}`
        );
      }
      console.log("\u{1F987} All services verified and ready");
    });
  }
  /**
   * Register plugin features
   */
  registerFeatures() {
    return __async(this, null, function* () {
      try {
        console.log("\u{1F987} Registering features...");
        yield this.commandManager.initialize();
        if (!this.settingTab) {
          this.settingTab = new GraphWeaverSettingTab(this.app, this);
          this.addSettingTab(this.settingTab);
        }
        this.registerInterval(
          window.setInterval(
            () => this.saveData(pluginStore.getSnapshot()),
            this.CONFIG.SAVE_INTERVAL_MS
          )
        );
        console.log("\u{1F987} Feature registration complete");
      } catch (error) {
        throw new ServiceError("Feature Registration", "Failed to register features", error);
      }
    });
  }
  /**
   * Handle initialization errors with retry logic
   */
  handleInitializationError(error) {
    return __async(this, null, function* () {
      console.error("\u{1F987} Initialization error:", error);
      if (this.initRetryCount < this.CONFIG.MAX_INIT_RETRIES) {
        this.initRetryCount++;
        new import_obsidian27.Notice(`Initialization failed. Retrying... (${this.initRetryCount}/${this.CONFIG.MAX_INIT_RETRIES})`);
        setTimeout(() => this.onload(), this.CONFIG.INIT_RETRY_MS);
      } else {
        new import_obsidian27.Notice("Failed to initialize plugin. Please restart Obsidian.");
        throw error instanceof Error ? error : new Error(String(error));
      }
    });
  }
  /**
   * Plugin unload lifecycle method
   */
  onunload() {
    return __async(this, null, function* () {
      var _a;
      try {
        console.log("\u{1F987} Unloading GraphWeaver...");
        yield (_a = this.commandManager) == null ? void 0 : _a.destroy();
        yield destroyUIServices();
        yield this.serviceRegistry.destroyAll();
        if (this.settingTab) {
          this.settingTab = null;
        }
        console.log("\u{1F987} GraphWeaver unloaded successfully");
      } catch (error) {
        console.error("\u{1F987} Error during plugin unload:", error);
      }
    });
  }
  /**
   * Public getter for initialization state
   */
  isReady() {
    var _a, _b, _c;
    return this.isInitialized && !this.initializationPromise && ((_a = this.settingsService) == null ? void 0 : _a.isReady()) && ((_b = this.aiService) == null ? void 0 : _b.isReady()) && ((_c = this.tagManager) == null ? void 0 : _c.isReady());
  }
  getAIService() {
    if (!this.isReady()) {
      throw new ServiceError("Plugin", "Plugin not ready. Services still initializing.");
    }
    return this.aiService;
  }
  getSettingsService() {
    if (!this.isReady()) {
      throw new ServiceError("Plugin", "Plugin not ready. Services still initializing.");
    }
    return this.settingsService;
  }
  ensureInitialized() {
    return __async(this, null, function* () {
      if (!this.initializationPromise) {
        this.initializationPromise = this.initializeServices().finally(() => {
          this.initializationPromise = null;
        });
      }
      return this.initializationPromise;
    });
  }
};
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
