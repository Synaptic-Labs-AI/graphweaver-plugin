/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GraphWeaverPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian19 = require("obsidian");

// src/models/AIModels.ts
var AIProvider = /* @__PURE__ */ ((AIProvider2) => {
  AIProvider2["OpenAI"] = "openai";
  AIProvider2["Anthropic"] = "anthropic";
  AIProvider2["Google"] = "google";
  AIProvider2["Groq"] = "groq";
  AIProvider2["OpenRouter"] = "openrouter";
  AIProvider2["LMStudio"] = "lmstudio";
  return AIProvider2;
})(AIProvider || {});
var AIModelMap = {
  ["openai" /* OpenAI */]: [
    { name: "GPT 4o mini", apiName: "gpt-4o-mini" },
    { name: "GPT 4o", apiName: "gpt-4o" },
    { name: "GPT o1 Preview", apiName: "o1-preview" },
    { name: "GPT o1 Mini", apiName: "o1-mini" }
  ],
  ["anthropic" /* Anthropic */]: [
    { name: "Claude 3 Haiku", apiName: "claude-3-haiku-20240307" },
    { name: "Claude 3 Sonnet", apiName: "claude-3-sonnet-20240229" },
    { name: "Claude 3 Opus", apiName: "claude-3-opus-20240229" },
    { name: "Claude 3.5 Sonnet", apiName: "claude-3-5-sonnet-20240620" }
  ],
  ["google" /* Google */]: [
    { name: "Gemini 1.5 Flash", apiName: "gemini-1.5-flash" },
    { name: "Gemini 1.5 Flash 8B", apiName: "gemini-1.5-flash-8b" },
    { name: "Gemini 1.5 Pro", apiName: "gemini-1.5-pro" }
  ],
  ["groq" /* Groq */]: [
    { name: "Llama 3.1 70B", apiName: "llama-3.1-70b-versatile" },
    { name: "Llama 3.1 8B", apiName: "llama-3.1-8b-instant" },
    { name: "Llama 3.2 1B (Preview)", apiName: "llama-3.2-1b-preview" },
    { name: "Llama 3.2 3B (Preview)", apiName: "llama-3.2-3b-preview" }
  ],
  ["openrouter" /* OpenRouter */]: [
    { name: "Anthropic Claude 3 Haiku", apiName: "anthropic/claude-3-haiku" },
    { name: "Anthropic Claude 3 Opus", apiName: "anthropic/claude-3-opus" },
    { name: "Anthropic Claude 3.5 Sonnet", apiName: "anthropic/claude-3.5-sonnet" },
    { name: "Google Gemini Flash 1.5", apiName: "google/gemini-flash-1.5" },
    { name: "Google Gemini Flash 1.5 8B", apiName: "google/gemini-flash-1.5-8b" },
    { name: "Google Gemini Pro 1.5", apiName: "google/gemini-pro-1.5" },
    { name: "Mistralai Mistral Large", apiName: "mistralai/mistral-large" },
    { name: "Mistralai Mistral Nemo", apiName: "mistralai/mistral-nemo" },
    { name: "OpenAI GPT 4o", apiName: "openai/gpt-4o" },
    { name: "OpenAI GPT 4o Mini", apiName: "openai/gpt-4o-mini" },
    { name: "OpenAI o1 Mini", apiName: "openai/o1-mini" },
    { name: "OpenAI o1 Preview", apiName: "openai/o1-preview" }
  ],
  ["lmstudio" /* LMStudio */]: [
    { name: "Custom", apiName: "custom" }
  ]
};

// src/models/Settings.ts
var DEFAULT_SETTINGS = {
  aiProvider: {
    selected: "openai" /* OpenAI */,
    apiKeys: {},
    selectedModels: {
      ["openai" /* OpenAI */]: "gpt-4o-mini"
    }
  },
  frontMatter: {
    customProperties: [],
    autoGenerate: false
  },
  tags: {
    customTags: []
  },
  localLMStudio: {
    enabled: false,
    port: 1234,
    modelName: ""
  },
  advanced: {
    maxTokens: 4096,
    temperature: 0.3,
    generateWikilinks: false,
    minWordCount: 5,
    maxLinksPerNote: 10
  },
  ontology: {
    lastGenerated: ""
  }
};

// src/adapters/OpenAIAdapter.ts
var import_obsidian = require("obsidian");
var OpenAIAdapter = class {
  constructor(settingsService, jsonValidationService) {
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    const aiProviderSettings = this.settingsService.getSetting("aiProvider");
    this.apiKey = aiProviderSettings.apiKeys["openai" /* OpenAI */] || "";
    this.models = AIModelMap["openai" /* OpenAI */];
  }
  async generateResponse(prompt, modelApiName) {
    try {
      const apiModel = this.getApiModelName(modelApiName);
      if (!apiModel) {
        throw new Error(`No valid model found for ${this.getProviderType()}`);
      }
      const settings = this.settingsService.getSettings();
      const temperature = this.getTemperature(settings);
      const maxTokens = this.getMaxTokens(settings);
      const response = await this.makeApiRequest(apiModel, prompt, temperature, maxTokens);
      const content = this.extractContentFromResponse(response);
      const validatedContent = await this.jsonValidationService.validateAndCleanJson(content);
      return { success: true, data: validatedContent };
    } catch (error) {
      return this.handleError(error);
    }
  }
  async testConnection(prompt, modelApiName) {
    try {
      if (!this.apiKey) {
        throw new Error("OpenAI API key is not set");
      }
      const apiModel = this.getApiModelName(modelApiName);
      const response = await this.makeApiRequest(apiModel, prompt, 0.7, 50, false);
      const content = this.extractContentFromResponse(response);
      return content.toLowerCase().includes("ok");
    } catch (error) {
      console.error("Error in OpenAI test connection:", error);
      return false;
    }
  }
  getTemperature(settings) {
    return settings.advanced.temperature >= 0 && settings.advanced.temperature <= 1 ? settings.advanced.temperature : 0.7;
  }
  getMaxTokens(settings) {
    return settings.advanced.maxTokens > 0 ? settings.advanced.maxTokens : 1e3;
  }
  async makeApiRequest(apiModel, prompt, temperature, maxTokens, jsonResponse = true) {
    const response = await (0, import_obsidian.requestUrl)({
      url: "https://api.openai.com/v1/chat/completions",
      method: "POST",
      headers: {
        "Authorization": `Bearer ${this.apiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: apiModel,
        messages: [
          { role: "system", content: "You are a helpful assistant designed to output JSON." },
          { role: "user", content: prompt }
        ],
        temperature,
        max_tokens: maxTokens,
        response_format: jsonResponse ? { type: "json_object" } : void 0
      })
    });
    if (response.status !== 200) {
      throw new Error(`API request failed with status ${response.status}`);
    }
    return response;
  }
  extractContentFromResponse(response) {
    return response.json.choices[0].message.content;
  }
  handleError(error) {
    console.error("Error in OpenAI API call:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    new import_obsidian.Notice(`OpenAI API Error: ${errorMessage}`);
    return { success: false, error: errorMessage };
  }
  async validateApiKey() {
    try {
      if (!this.apiKey) {
        throw new Error("OpenAI API key is not set");
      }
      const response = await this.testConnection("Return the word 'OK'.", this.models[0].apiName);
      if (response) {
        new import_obsidian.Notice("OpenAI API key validated successfully");
        return true;
      } else {
        throw new Error("Failed to validate API key");
      }
    } catch (error) {
      console.error("Error validating OpenAI API key:", error);
      new import_obsidian.Notice(`Failed to validate OpenAI API key: ${error instanceof Error ? error.message : "Unknown error occurred"}`);
      return false;
    }
  }
  getAvailableModels() {
    return this.models.map((model) => model.apiName);
  }
  getProviderType() {
    return "openai" /* OpenAI */;
  }
  setApiKey(apiKey) {
    this.apiKey = apiKey;
  }
  getApiKey() {
    return this.apiKey;
  }
  configure(config) {
  }
  isReady() {
    return !!this.apiKey;
  }
  getApiModelName(modelApiName) {
    var _a;
    const model = this.models.find((m) => m.apiName === modelApiName);
    if (!model) {
      console.warn(`Model ${modelApiName} not found for ${this.getProviderType()}. Using first available model.`);
      return ((_a = this.models[0]) == null ? void 0 : _a.apiName) || modelApiName;
    }
    return model.apiName;
  }
};

// src/adapters/AnthropicAdapter.ts
var import_obsidian2 = require("obsidian");
var AnthropicAdapter = class {
  constructor(settingsService, jsonValidationService) {
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    const aiProviderSettings = this.settingsService.getSetting("aiProvider");
    this.apiKey = aiProviderSettings.apiKeys["anthropic" /* Anthropic */] || "";
    this.models = AIModelMap["anthropic" /* Anthropic */];
  }
  async generateResponse(prompt, modelApiName) {
    try {
      const apiModel = this.getApiModelName(modelApiName);
      if (!apiModel) {
        throw new Error(`Invalid model: ${modelApiName} for ${this.getProviderType()}`);
      }
      if (!this.apiKey) {
        throw new Error("Anthropic API key is not set");
      }
      const settings = this.settingsService.getSettings();
      const temperature = this.getTemperature(settings);
      const maxTokens = this.getMaxTokens(settings);
      const response = await this.makeApiRequest(apiModel, prompt, temperature, maxTokens);
      const content = this.extractContentFromResponse(response);
      const validatedContent = await this.jsonValidationService.validateAndCleanJson(content);
      return { success: true, data: validatedContent };
    } catch (error) {
      return this.handleError(error);
    }
  }
  async testConnection(prompt, modelApiName) {
    try {
      if (!this.apiKey) {
        throw new Error("Anthropic API key is not set");
      }
      const apiModel = this.getApiModelName(modelApiName);
      const response = await this.makeApiRequest(apiModel, prompt, 0.7, 50);
      const content = this.extractContentFromResponse(response);
      return content.toLowerCase().includes("ok");
    } catch (error) {
      console.error("Error in Anthropic test connection:", error);
      return false;
    }
  }
  getTemperature(settings) {
    return settings.advanced.temperature >= 0 && settings.advanced.temperature <= 1 ? settings.advanced.temperature : 0.7;
  }
  getMaxTokens(settings) {
    return settings.advanced.maxTokens > 0 ? settings.advanced.maxTokens : 1e3;
  }
  async makeApiRequest(apiModel, prompt, temperature, maxTokens) {
    const requestBody = {
      model: apiModel,
      messages: [{ role: "user", content: prompt }],
      max_tokens: maxTokens,
      temperature
    };
    const response = await (0, import_obsidian2.requestUrl)({
      url: "https://api.anthropic.com/v1/messages",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.apiKey,
        "anthropic-version": "2023-06-01"
      },
      body: JSON.stringify(requestBody)
    });
    if (response.status !== 200) {
      throw new Error(`API request failed with status ${response.status}: ${response.text}`);
    }
    return response;
  }
  extractContentFromResponse(response) {
    return response.json.content[0].text;
  }
  handleError(error) {
    console.error("Error in Anthropic API call:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    new import_obsidian2.Notice(`Anthropic API Error: ${errorMessage}`);
    return { success: false, error: errorMessage };
  }
  async validateApiKey() {
    try {
      if (!this.apiKey) {
        throw new Error("Anthropic API key is not set");
      }
      const response = await this.testConnection("Return the word 'OK'.", this.models[0].apiName);
      if (response) {
        new import_obsidian2.Notice("Anthropic API key validated successfully");
        return true;
      } else {
        throw new Error("Failed to validate API key");
      }
    } catch (error) {
      console.error("Error validating Anthropic API key:", error);
      new import_obsidian2.Notice(`Failed to validate Anthropic API key: ${error instanceof Error ? error.message : "Unknown error occurred"}`);
      return false;
    }
  }
  getAvailableModels() {
    return this.models.map((model) => model.apiName);
  }
  getProviderType() {
    return "anthropic" /* Anthropic */;
  }
  setApiKey(apiKey) {
    this.apiKey = apiKey;
  }
  getApiKey() {
    return this.apiKey;
  }
  configure(config) {
  }
  isReady() {
    return !!this.apiKey;
  }
  getApiModelName(modelApiName) {
    const model = this.models.find((m) => m.apiName === modelApiName);
    if (!model) {
      throw new Error(`Model ${modelApiName} not found for ${this.getProviderType()}`);
    }
    return model.apiName;
  }
};

// src/adapters/GeminiAdapter.ts
var import_obsidian3 = require("obsidian");
var GeminiAdapter = class {
  constructor(settingsService, jsonValidationService) {
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    const aiProviderSettings = this.settingsService.getSetting("aiProvider");
    this.apiKey = aiProviderSettings.apiKeys["google" /* Google */] || "";
    this.models = AIModelMap["google" /* Google */];
  }
  async generateResponse(prompt, modelApiName) {
    try {
      const apiModel = this.getApiModelName(modelApiName);
      if (!apiModel) {
        throw new Error(`No valid model found for ${this.getProviderType()}`);
      }
      if (!this.apiKey) {
        throw new Error("Google API key is not set");
      }
      const settings = this.settingsService.getSettings();
      const temperature = this.getTemperature(settings);
      const maxTokens = this.getMaxTokens(settings);
      const response = await this.makeApiRequest(apiModel, prompt, temperature, maxTokens);
      const content = this.extractContentFromResponse(response);
      const validatedContent = await this.jsonValidationService.validateAndCleanJson(content);
      return { success: true, data: validatedContent };
    } catch (error) {
      return this.handleError(error);
    }
  }
  async testConnection(prompt, modelApiName) {
    try {
      if (!this.apiKey) {
        throw new Error("Google API key is not set");
      }
      const apiModel = this.getApiModelName(modelApiName);
      const response = await this.makeApiRequest(apiModel, prompt, 0.7, 50);
      const content = this.extractContentFromResponse(response);
      return content.toLowerCase().includes("ok");
    } catch (error) {
      console.error("Error in Gemini test connection:", error);
      return false;
    }
  }
  getTemperature(settings) {
    return settings.advanced.temperature >= 0 && settings.advanced.temperature <= 1 ? settings.advanced.temperature : 0.7;
  }
  getMaxTokens(settings) {
    return settings.advanced.maxTokens > 0 ? settings.advanced.maxTokens : 1e3;
  }
  async makeApiRequest(apiModel, prompt, temperature, maxTokens) {
    const requestBody = {
      contents: [{
        parts: [{ text: prompt }]
      }],
      generationConfig: {
        temperature,
        maxOutputTokens: maxTokens,
        topK: 40,
        topP: 0.95
      }
    };
    const response = await (0, import_obsidian3.requestUrl)({
      url: `https://generativelanguage.googleapis.com/v1/models/${apiModel}:generateContent`,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-goog-api-key": this.apiKey
      },
      body: JSON.stringify(requestBody)
    });
    if (response.status !== 200) {
      throw new Error(`API request failed with status ${response.status}: ${response.text}`);
    }
    return response;
  }
  extractContentFromResponse(response) {
    const content = response.json.candidates[0].content;
    return content.parts[0].text;
  }
  handleError(error) {
    console.error("Error in Gemini API call:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    new import_obsidian3.Notice(`Gemini API Error: ${errorMessage}`);
    return { success: false, error: errorMessage };
  }
  async validateApiKey() {
    try {
      if (!this.apiKey) {
        throw new Error("Google API key is not set");
      }
      const response = await this.testConnection("Return the word 'OK'.", this.models[0].apiName);
      if (response) {
        new import_obsidian3.Notice("Gemini API key validated successfully");
        return true;
      } else {
        throw new Error("Failed to validate API key");
      }
    } catch (error) {
      console.error("Error validating Gemini API key:", error);
      new import_obsidian3.Notice(`Failed to validate Gemini API key: ${error instanceof Error ? error.message : "Unknown error occurred"}`);
      return false;
    }
  }
  getAvailableModels() {
    return this.models.map((model) => model.apiName);
  }
  getProviderType() {
    return "google" /* Google */;
  }
  setApiKey(apiKey) {
    this.apiKey = apiKey;
  }
  getApiKey() {
    return this.apiKey;
  }
  configure(config) {
  }
  isReady() {
    return !!this.apiKey;
  }
  getApiModelName(modelApiName) {
    var _a;
    const model = this.models.find((m) => m.apiName === modelApiName);
    if (!model) {
      console.warn(`Model ${modelApiName} not found for ${this.getProviderType()}. Using first available model.`);
      return ((_a = this.models[0]) == null ? void 0 : _a.apiName) || modelApiName;
    }
    return model.apiName;
  }
};

// src/adapters/GroqAdapter.ts
var import_obsidian4 = require("obsidian");
var GroqAdapter = class {
  constructor(settingsService, jsonValidationService) {
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    const aiProviderSettings = this.settingsService.getSetting("aiProvider");
    this.apiKey = aiProviderSettings.apiKeys["groq" /* Groq */] || "";
    this.models = AIModelMap["groq" /* Groq */];
  }
  async generateResponse(prompt, modelApiName) {
    try {
      const apiModel = this.getApiModelName(modelApiName);
      if (!apiModel) {
        throw new Error(`No valid model found for ${this.getProviderType()}`);
      }
      if (!this.apiKey) {
        throw new Error("Groq API key is not set");
      }
      const settings = this.settingsService.getSettings();
      const temperature = this.getTemperature(settings);
      const maxTokens = this.getMaxTokens(settings);
      const response = await this.makeApiRequest(apiModel, prompt, temperature, maxTokens);
      const content = this.extractContentFromResponse(response);
      const validatedContent = await this.jsonValidationService.validateAndCleanJson(content);
      return { success: true, data: validatedContent };
    } catch (error) {
      return this.handleError(error);
    }
  }
  async testConnection(prompt, modelApiName) {
    try {
      if (!this.apiKey) {
        throw new Error("Groq API key is not set");
      }
      const apiModel = this.getApiModelName(modelApiName);
      const response = await this.makeApiRequest(apiModel, prompt, 0.7, 50);
      const content = this.extractContentFromResponse(response);
      return content.toLowerCase().includes("ok");
    } catch (error) {
      console.error("Error in Groq test connection:", error);
      return false;
    }
  }
  getTemperature(settings) {
    return settings.advanced.temperature >= 0 && settings.advanced.temperature <= 1 ? settings.advanced.temperature : 0.7;
  }
  getMaxTokens(settings) {
    return settings.advanced.maxTokens > 0 ? settings.advanced.maxTokens : 1e3;
  }
  async makeApiRequest(apiModel, prompt, temperature, maxTokens) {
    const response = await (0, import_obsidian4.requestUrl)({
      url: "https://api.groq.com/openai/v1/chat/completions",
      method: "POST",
      headers: {
        "Authorization": `Bearer ${this.apiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: apiModel,
        messages: [
          { role: "system", content: "You are a helpful assistant that responds in JSON format." },
          { role: "user", content: prompt }
        ],
        temperature,
        max_tokens: maxTokens,
        response_format: { type: "json_object" }
      })
    });
    if (response.status !== 200) {
      throw new Error(`API request failed with status ${response.status}`);
    }
    return response;
  }
  extractContentFromResponse(response) {
    return response.json.choices[0].message.content;
  }
  handleError(error) {
    console.error("Error in Groq API call:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    new import_obsidian4.Notice(`Groq API Error: ${errorMessage}`);
    return { success: false, error: errorMessage };
  }
  async validateApiKey() {
    try {
      if (!this.apiKey) {
        throw new Error("Groq API key is not set");
      }
      const response = await this.testConnection("Return the word 'OK'.", this.models[0].apiName);
      if (response) {
        new import_obsidian4.Notice("Groq API key validated successfully");
        return true;
      } else {
        throw new Error("Failed to validate API key");
      }
    } catch (error) {
      console.error("Error validating Groq API key:", error);
      new import_obsidian4.Notice(`Failed to validate Groq API key: ${error instanceof Error ? error.message : "Unknown error occurred"}`);
      return false;
    }
  }
  getAvailableModels() {
    return this.models.map((model) => model.apiName);
  }
  getProviderType() {
    return "groq" /* Groq */;
  }
  setApiKey(apiKey) {
    this.apiKey = apiKey;
  }
  getApiKey() {
    return this.apiKey;
  }
  configure(config) {
  }
  isReady() {
    return !!this.apiKey;
  }
  getApiModelName(modelApiName) {
    var _a;
    const model = this.models.find((m) => m.apiName === modelApiName);
    if (!model) {
      console.warn(`Model ${modelApiName} not found for ${this.getProviderType()}. Using first available model.`);
      return ((_a = this.models[0]) == null ? void 0 : _a.apiName) || modelApiName;
    }
    return model.apiName;
  }
};

// src/adapters/OpenRouterAdapter.ts
var import_obsidian5 = require("obsidian");
var OpenRouterAdapter = class {
  constructor(settingsService, jsonValidationService) {
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    const aiProviderSettings = this.settingsService.getSetting("aiProvider");
    this.apiKey = aiProviderSettings.apiKeys["openrouter" /* OpenRouter */] || "";
    this.models = AIModelMap["openrouter" /* OpenRouter */];
  }
  async generateResponse(prompt, modelApiName) {
    try {
      const apiModel = this.getApiModelName(modelApiName);
      if (!apiModel) {
        throw new Error(`No valid model found for ${this.getProviderType()}`);
      }
      if (!this.apiKey) {
        throw new Error("OpenRouter API key is not set");
      }
      const settings = this.settingsService.getSettings();
      const temperature = this.getTemperature(settings);
      const maxTokens = this.getMaxTokens(settings);
      const response = await this.makeApiRequest(apiModel, prompt, temperature, maxTokens);
      const content = this.extractContentFromResponse(response);
      const validatedContent = await this.jsonValidationService.validateAndCleanJson(content);
      return { success: true, data: validatedContent };
    } catch (error) {
      return this.handleError(error);
    }
  }
  async testConnection(prompt, modelApiName) {
    try {
      if (!this.apiKey) {
        throw new Error("OpenRouter API key is not set");
      }
      const apiModel = this.getApiModelName(modelApiName);
      const response = await this.makeApiRequest(apiModel, prompt, 0.7, 50);
      const content = this.extractContentFromResponse(response);
      return content.toLowerCase().includes("ok");
    } catch (error) {
      console.error("Error in OpenRouter test connection:", error);
      return false;
    }
  }
  getTemperature(settings) {
    return settings.advanced.temperature >= 0 && settings.advanced.temperature <= 1 ? settings.advanced.temperature : 0.7;
  }
  getMaxTokens(settings) {
    return settings.advanced.maxTokens > 0 ? settings.advanced.maxTokens : 1e3;
  }
  async makeApiRequest(apiModel, prompt, temperature, maxTokens) {
    const response = await (0, import_obsidian5.requestUrl)({
      url: `https://openrouter.ai/api/v1/chat/completions`,
      method: "POST",
      headers: {
        "Authorization": `Bearer ${this.apiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: apiModel,
        messages: [{ role: "user", content: prompt }],
        temperature,
        max_tokens: maxTokens
      })
    });
    if (response.status !== 200) {
      throw new Error(`API request failed with status ${response.status}`);
    }
    return response;
  }
  extractContentFromResponse(response) {
    return response.json.choices[0].message.content;
  }
  handleError(error) {
    console.error("Error in OpenRouter API call:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    new import_obsidian5.Notice(`OpenRouter API Error: ${errorMessage}`);
    return { success: false, error: errorMessage };
  }
  async validateApiKey() {
    try {
      if (!this.apiKey) {
        throw new Error("OpenRouter API key is not set");
      }
      const response = await this.testConnection("Return the word 'OK'.", this.models[0].apiName);
      if (response) {
        new import_obsidian5.Notice("OpenRouter API key validated successfully");
        return true;
      } else {
        throw new Error("Failed to validate API key");
      }
    } catch (error) {
      console.error("Error validating OpenRouter API key:", error);
      new import_obsidian5.Notice(`Failed to validate OpenRouter API key: ${error instanceof Error ? error.message : "Unknown error occurred"}`);
      return false;
    }
  }
  getAvailableModels() {
    return this.models.map((model) => model.apiName);
  }
  getProviderType() {
    return "openrouter" /* OpenRouter */;
  }
  setApiKey(apiKey) {
    this.apiKey = apiKey;
  }
  getApiKey() {
    return this.apiKey;
  }
  configure(config) {
  }
  isReady() {
    return !!this.apiKey;
  }
  getApiModelName(modelApiName) {
    var _a;
    const model = this.models.find((m) => m.apiName === modelApiName);
    if (!model) {
      console.warn(`Model ${modelApiName} not found for ${this.getProviderType()}. Using first available model.`);
      return ((_a = this.models[0]) == null ? void 0 : _a.apiName) || modelApiName;
    }
    return model.apiName;
  }
};

// src/adapters/LMStudioAdapter.ts
var import_obsidian6 = require("obsidian");
var LMStudioAdapter = class {
  constructor(settingsService, jsonValidationService) {
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    this.updateSettings();
  }
  async generateResponse(prompt, model = "default") {
    try {
      if (!this.isReady()) {
        throw new Error("LM Studio settings are not properly configured");
      }
      const jsonSchema = this.createJsonSchema();
      const response = await (0, import_obsidian6.requestUrl)({
        url: `http://localhost:${this.port}/v1/chat/completions`,
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          model: this.model,
          messages: [
            {
              role: "system",
              content: "You are a helpful assistant that responds in JSON format."
            },
            {
              role: "user",
              content: prompt
            }
          ],
          response_format: {
            type: "json_schema",
            json_schema: jsonSchema
          },
          temperature: 0.7,
          max_tokens: 1e3,
          stream: false
        })
      });
      if (response.status !== 200) {
        throw new Error(`API request failed with status ${response.status}`);
      }
      const content = response.json.choices[0].message.content;
      const validatedContent = await this.jsonValidationService.validateAndCleanJson(content);
      return {
        success: true,
        data: validatedContent
      };
    } catch (error) {
      console.error("Error in LM Studio API call:", error);
      new import_obsidian6.Notice(`LM Studio API Error: ${error instanceof Error ? error.message : "Unknown error occurred"}`);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error occurred"
      };
    }
  }
  createJsonSchema() {
    return {
      name: "assistant_response",
      strict: "true",
      schema: {
        type: "object",
        properties: {
          response: {
            type: "string"
          }
        },
        required: ["response"]
      }
    };
  }
  async testConnection(prompt, model = "default") {
    try {
      if (!this.isReady()) {
        return false;
      }
      const response = await this.generateResponse("Return the word 'OK'.", model);
      return response.success && response.data && typeof response.data === "object" && "response" in response.data && typeof response.data.response === "string" && response.data.response.toLowerCase().includes("ok");
    } catch (error) {
      console.error("Error in LM Studio test connection:", error);
      return false;
    }
  }
  async validateApiKey() {
    return this.isReady();
  }
  getAvailableModels() {
    return [this.model];
  }
  getProviderType() {
    return "lmstudio" /* LMStudio */;
  }
  setApiKey(apiKey) {
  }
  getApiKey() {
    return "";
  }
  configure(config) {
    if (config.model) {
      this.model = config.model;
    }
    if (config.port) {
      this.port = config.port.toString();
    }
    this.settingsService.updateNestedSetting("localLMStudio", "modelName", this.model);
    this.settingsService.updateNestedSetting("localLMStudio", "port", parseInt(this.port, 10));
  }
  isReady() {
    return !!this.model && !!this.port;
  }
  getApiModelName(modelName) {
    return modelName;
  }
  updateSettings() {
    const localLMStudioSettings = this.settingsService.getSetting("localLMStudio");
    this.model = localLMStudioSettings.modelName;
    this.port = localLMStudioSettings.port.toString();
  }
};

// src/generators/BaseGenerator.ts
var BaseGenerator = class {
  constructor(aiAdapter, settingsService) {
    this.aiAdapter = aiAdapter;
    this.settingsService = settingsService;
  }
  /**
   * Get the current settings for this generator.
   * @returns The relevant settings for this generator
   */
  getSettings() {
    return this.settingsService.getSettings();
  }
  /**
   * Validate the input before generation.
   * @param input The input to validate
   * @returns True if the input is valid, false otherwise
   */
  validateInput(input) {
    return true;
  }
  /**
   * Handle errors that occur during generation.
   * @param error The error that occurred
   * @throws A custom error with additional context
   */
  handleError(error) {
    throw new Error(`Generation error in ${this.constructor.name}: ${error.message}`);
  }
};

// src/generators/FrontMatterGenerator.ts
var FrontMatterGenerator = class extends BaseGenerator {
  constructor(aiAdapter, settingsService, jsonSchemaGenerator) {
    super(aiAdapter, settingsService);
    this.jsonSchemaGenerator = jsonSchemaGenerator;
  }
  async generate(noteContent) {
    console.log("FrontMatterGenerator: Starting generation");
    const settings = this.getSettings();
    const customProperties = settings.frontMatter.customProperties;
    const customTags = settings.tags.customTags;
    const input = { noteContent, customProperties, customTags };
    const prompt = this.preparePrompt(input);
    const modelApiName = this.getCurrentModel();
    console.log("FrontMatterGenerator: Sending request to AI");
    const aiResponse = await this.aiAdapter.generateResponse(prompt, modelApiName);
    console.log("FrontMatterGenerator: Received AI response:", JSON.stringify(aiResponse, null, 2));
    if (!aiResponse.success || !aiResponse.data) {
      console.error("FrontMatterGenerator: AI response was unsuccessful or empty");
      return noteContent;
    }
    const formattedContent = this.formatOutput(aiResponse.data, noteContent);
    console.log("FrontMatterGenerator: Formatted output:", formattedContent);
    return formattedContent;
  }
  preparePrompt(input) {
    const schema = this.jsonSchemaGenerator.generateSchema();
    const propertyPrompt = input.customProperties.map(
      (prop) => `${prop.name} (${prop.type}): ${prop.description}`
    ).join("\n");
    const tagPrompt = input.customTags.map((tag) => tag.name).join(", ");
    return `
            Generate front matter for the following note content.
            Use the provided JSON schema to structure your response.
            Include relevant custom properties and tags.

            Custom Properties:
            ${propertyPrompt}

            Available Tags:
            ${tagPrompt}

            JSON Schema:
            ${JSON.stringify(schema, null, 2)}

            Note Content:
            ${input.noteContent}

            Provide the filled out JSON object as your response, with no additional text.
            Only include fields that are relevant to the content.
        `;
  }
  formatOutput(aiResponse, originalContent) {
    console.log("Raw AI Response:", JSON.stringify(aiResponse, null, 2));
    let parsedResponse;
    if (typeof aiResponse === "object" && aiResponse !== null) {
      parsedResponse = aiResponse;
    } else {
      try {
        parsedResponse = JSON.parse(aiResponse);
      } catch (error) {
        console.error("Error parsing AI response:", error);
        return originalContent;
      }
    }
    console.log("Parsed AI Response:", JSON.stringify(parsedResponse, null, 2));
    if (typeof parsedResponse !== "object" || parsedResponse === null) {
      console.error("Invalid AI response format: Not an object after parsing");
      return originalContent;
    }
    const hasFrontMatter = originalContent.trim().startsWith("---");
    let newFrontMatter = Object.entries(parsedResponse).map(([key, value]) => {
      if (Array.isArray(value)) {
        return `${key}:
  - ${value.join("\n  - ")}`;
      } else if (typeof value === "object" && value !== null) {
        return `${key}: ${JSON.stringify(value)}`;
      } else {
        return `${key}: ${value}`;
      }
    }).join("\n");
    let result;
    if (hasFrontMatter) {
      const [existingFrontMatter, ...contentParts] = originalContent.split("---");
      result = `---
${existingFrontMatter.trim()}
${newFrontMatter}
---
${contentParts.join("---").trim()}`;
    } else {
      result = `---
${newFrontMatter}
---

${originalContent.trim()}`;
    }
    console.log("Formatted output:", result);
    return result;
  }
  validateInput(input) {
    return typeof input === "string" && input.trim().length > 0;
  }
  getCurrentModel() {
    var _a, _b;
    const settings = this.getSettings();
    const providerType = this.aiAdapter.getProviderType();
    const modelApiName = (_b = (_a = settings.aiProvider) == null ? void 0 : _a.selectedModels) == null ? void 0 : _b[providerType];
    if (!modelApiName) {
      throw new Error(`No model selected for provider: ${providerType}`);
    }
    return modelApiName;
  }
};

// src/generators/WikilinkGenerator.ts
var WikilinkGenerator = class extends BaseGenerator {
  constructor(aiAdapter, settingsService) {
    super(aiAdapter, settingsService);
    this.WIKILINK_REGEX = /\[\[([^\]]+)\]\]/g;
  }
  async generate(input) {
    if (!this.validateInput(input)) {
      throw new Error("Invalid input for wikilink generation");
    }
    try {
      const prompt = this.preparePrompt(input);
      const aiResponse = await this.aiAdapter.generateResponse(prompt, this.getCurrentModel());
      return this.formatOutput(aiResponse.data, input);
    } catch (error) {
      this.handleError(error);
    }
  }
  preparePrompt(input) {
    const settings = this.getSettings();
    const customTags = settings.tags.customTags.map((tag) => tag.name).join(", ") || "";
    return `
            Analyze the following content and suggest key phrases that could be turned into wikilinks.
            Consider the existing pages in the vault and prioritize linking to them.
            Also consider the following custom tags used in this knowledge base: ${customTags}

            Content:
            ${input.content}

            Existing pages:
            ${input.existingPages.join(", ")}

            Provide your suggestions as a JSON array of strings.
        `;
  }
  formatOutput(aiResponse, originalInput) {
    const suggestedLinks = this.parseSuggestedLinks(aiResponse);
    let content = originalInput.content;
    const existingWikilinks = this.extractExistingWikilinks(content);
    suggestedLinks.sort((a, b) => b.length - a.length);
    suggestedLinks.forEach((phrase) => {
      if (!existingWikilinks.includes(phrase.toLowerCase())) {
        const regex = new RegExp(`\\b${this.escapeRegExp(phrase)}\\b`, "gi");
        content = content.replace(regex, (match) => {
          const prevChar = content[content.indexOf(match) - 1];
          const nextChar = content[content.indexOf(match) + match.length];
          if (prevChar === "[" && nextChar === "]") {
            return match;
          }
          return `[[${match}]]`;
        });
      }
    });
    return content;
  }
  extractExistingWikilinks(content) {
    const matches = content.match(this.WIKILINK_REGEX) || [];
    return matches.map((match) => match.slice(2, -2).toLowerCase());
  }
  parseSuggestedLinks(aiResponse) {
    console.log("AI Response:", JSON.stringify(aiResponse, null, 2));
    if (typeof aiResponse === "string") {
      try {
        aiResponse = JSON.parse(aiResponse);
      } catch (error) {
        console.error("Failed to parse AI response as JSON:", error);
        return [];
      }
    }
    if (Array.isArray(aiResponse)) {
      return aiResponse.filter((item) => typeof item === "string");
    }
    if (typeof aiResponse === "object" && aiResponse !== null) {
      const arrayValues = Object.values(aiResponse).find(Array.isArray);
      if (arrayValues) {
        return arrayValues.filter((item) => typeof item === "string");
      }
    }
    console.error("Unexpected AI response format:", aiResponse);
    return [];
  }
  validateInput(input) {
    return typeof input.content === "string" && input.content.trim().length > 0 && Array.isArray(input.existingPages);
  }
  getCurrentModel() {
    var _a, _b;
    const settings = this.getSettings();
    const providerType = this.aiAdapter.getProviderType();
    const selectedModel = (_b = (_a = settings.aiProvider) == null ? void 0 : _a.selectedModels) == null ? void 0 : _b[providerType];
    if (!selectedModel) {
      throw new Error(`No model selected for provider type: ${providerType}`);
    }
    return selectedModel;
  }
  escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  handleError(error) {
    console.error(`Wikilink generation error: ${error.message}`);
    throw new Error(`Wikilink generation failed: ${error.message}`);
  }
};

// src/generators/OntologyGenerator.ts
var OntologyGenerator = class extends BaseGenerator {
  constructor(aiAdapter, settingsService) {
    super(aiAdapter, settingsService);
  }
  async generate(input) {
    if (!this.validateInput(input)) {
      throw new Error("Invalid input for ontology generation");
    }
    try {
      const prompt = this.preparePrompt(input);
      const aiResponse = await this.aiAdapter.generateResponse(prompt, input.modelApiName);
      return this.formatOutput(aiResponse.data);
    } catch (error) {
      this.handleError(error);
    }
  }
  preparePrompt(input) {
    const fileNames = input.files.map((file) => file.basename).join(", ");
    const folderNames = input.folders.map((folder) => folder.name).join(", ");
    const tags = input.tags.join(", ");
    return `
            Analyze the following information about a knowledge base and synthesize an ontology.
            Based on the overall structure and content, suggest a set of tags that would create a cohesive and useful ontology for this knowledge base.

            Files: ${fileNames}
            Folders: ${folderNames}
            Existing Tags: ${tags}

            For each suggested tag in the ontology, provide:
            {
                "Name": {
                    "description": "a brief but robust instruction on what this tag represents"
                }
            }

            Consider the following when creating the ontology:
            1. Identify overarching themes and concepts present in the knowledge base.
            2. Suggest tags that would help categorize and connect information across different files and folders.
            3. Build upon existing tags, either by refining them or suggesting complementary tags.
            4. Aim for a balance between specificity and generality in the suggested tags.
            5. Consider the hierarchical structure implied by the folder organization.

            Provide your response as a JSON object where the keys are the tag names and the values are objects containing the description.
            Aim to suggest between 10 to 20 tags that would form a comprehensive ontology for this knowledge base.
        `;
  }
  formatOutput(aiResponse) {
    let parsedResponse;
    if (typeof aiResponse === "string") {
      try {
        const fixedJson = this.fixIncompleteJson(aiResponse);
        parsedResponse = JSON.parse(fixedJson);
      } catch (error) {
        console.error("Failed to parse AI response as JSON:", error);
        throw new Error("Invalid AI response: unable to parse as JSON");
      }
    } else if (typeof aiResponse === "object" && aiResponse !== null) {
      parsedResponse = aiResponse;
    } else {
      console.error("Unexpected AI response format:", aiResponse);
      throw new Error("Invalid AI response format: expected an object or valid JSON string");
    }
    if (typeof parsedResponse !== "object" || parsedResponse === null) {
      throw new Error("Invalid AI response format: expected an object after parsing");
    }
    const suggestedTags = Object.entries(parsedResponse).map(([name, value]) => {
      if (typeof value === "object" && value !== null && "description" in value) {
        return {
          name: String(name).trim(),
          description: String(value.description).trim()
        };
      } else {
        console.warn(`Unexpected format for tag ${name}:`, value);
        return null;
      }
    }).filter(
      (tag) => tag !== null && typeof tag.name === "string" && tag.name.length > 0 && typeof tag.description === "string" && tag.description.length > 0
    );
    if (suggestedTags.length === 0) {
      throw new Error("No valid tags found in AI response");
    }
    return { suggestedTags };
  }
  fixIncompleteJson(json) {
    let fixedJson = json.trim();
    if (!fixedJson.endsWith("}")) {
      fixedJson += "}}";
    }
    fixedJson = fixedJson.replace(/,\s*}$/, "}");
    return fixedJson;
  }
  validateInput(input) {
    return Array.isArray(input.files) && Array.isArray(input.folders) && Array.isArray(input.tags);
  }
  getCurrentModel() {
    var _a, _b;
    const settings = this.settingsService.getSettings();
    const providerType = this.aiAdapter.getProviderType();
    const selectedModel = (_b = (_a = settings.aiProvider) == null ? void 0 : _a.selectedModels) == null ? void 0 : _b[providerType];
    if (!selectedModel) {
      throw new Error(`No model selected for provider type: ${providerType}`);
    }
    return selectedModel;
  }
  handleError(error) {
    console.error(`Ontology generation error: ${error.message}`, error);
    throw new Error(`Ontology generation failed: ${error.message}`);
  }
};

// src/generators/BatchProcessor.ts
var BatchProcessor = class extends BaseGenerator {
  constructor(aiAdapter, settingsService, frontMatterGenerator, wikilinkGenerator, app) {
    super(aiAdapter, settingsService);
    this.frontMatterGenerator = frontMatterGenerator;
    this.wikilinkGenerator = wikilinkGenerator;
    this.app = app;
    console.log(
      "BatchProcessor: Initialized with:",
      {
        aiAdapter: aiAdapter.constructor.name,
        settingsService: settingsService.constructor.name,
        frontMatterGenerator: frontMatterGenerator.constructor.name,
        wikilinkGenerator: wikilinkGenerator.constructor.name
      }
    );
  }
  async generate(input) {
    console.log("BatchProcessor: Starting batch processing with input:", input);
    if (!this.validateInput(input)) {
      console.error("BatchProcessor: Invalid input for batch processing");
      throw new Error("Invalid input for batch processing");
    }
    const results = { fileResults: [] };
    for (const file of input.files) {
      console.log(`BatchProcessor: Processing file: ${file.path}`);
      let content = await this.app.vault.read(file);
      console.log(`BatchProcessor: Original content length: ${content.length}`);
      let frontMatterGenerated = false;
      let wikilinksGenerated = false;
      try {
        if (input.generateFrontMatter) {
          console.log("BatchProcessor: Attempting to generate front matter");
          console.log("BatchProcessor: FrontMatterGenerator instance:", this.frontMatterGenerator);
          const frontMatterResult = await this.frontMatterGenerator.generate(content);
          console.log("BatchProcessor: Front matter generation result length:", frontMatterResult.length);
          if (frontMatterResult !== content) {
            content = frontMatterResult;
            frontMatterGenerated = true;
            console.log("BatchProcessor: Front matter successfully generated");
          } else {
            console.log("BatchProcessor: No new front matter generated");
          }
        } else {
          console.log("BatchProcessor: Front matter generation skipped");
        }
        if (input.generateWikilinks) {
          console.log("BatchProcessor: Generating wikilinks");
          const existingPages = this.getExistingPages();
          const wikilinksResult = await this.wikilinkGenerator.generate({ content, existingPages });
          console.log("BatchProcessor: Wikilinks generation result length:", wikilinksResult.length);
          if (wikilinksResult !== content) {
            content = wikilinksResult;
            wikilinksGenerated = true;
            console.log("BatchProcessor: Wikilinks successfully generated");
          } else {
            console.log("BatchProcessor: No new wikilinks generated");
          }
        } else {
          console.log("BatchProcessor: Wikilinks generation skipped");
        }
        console.log("BatchProcessor: Modifying file");
        await this.app.vault.modify(file, content);
        results.fileResults.push({
          file,
          success: true,
          frontMatterGenerated,
          wikilinksGenerated
        });
        console.log(`BatchProcessor: File processed successfully. Front matter generated: ${frontMatterGenerated}, Wikilinks generated: ${wikilinksGenerated}`);
      } catch (error) {
        console.error(`BatchProcessor: Error processing file ${file.path}:`, error);
        results.fileResults.push({
          file,
          success: false,
          error: error.message,
          frontMatterGenerated,
          wikilinksGenerated
        });
      }
    }
    console.log("BatchProcessor: Batch processing completed. Results:", results);
    return results;
  }
  validateInput(input) {
    const isValid = Array.isArray(input.files) && input.files.length > 0 && typeof input.generateFrontMatter === "boolean" && typeof input.generateWikilinks === "boolean";
    console.log("BatchProcessor: Input validation result:", isValid);
    return isValid;
  }
  getExistingPages() {
    const pages = this.app.vault.getMarkdownFiles().map((file) => file.basename);
    console.log("BatchProcessor: Existing pages:", pages);
    return pages;
  }
  // Implement the abstract methods from BaseGenerator
  preparePrompt(input) {
    console.log("BatchProcessor: preparePrompt called, but not used in this class");
    return "";
  }
  formatOutput(aiResponse) {
    console.log("BatchProcessor: formatOutput called, but not used in this class");
    return aiResponse;
  }
};

// src/generators/JsonSchemaGenerator.ts
var JsonSchemaGenerator = class {
  constructor(settingsService) {
    this.settingsService = settingsService;
  }
  generateSchema() {
    const settings = this.settingsService.getSettings();
    const schema = {
      type: "object",
      properties: {},
      required: []
    };
    settings.frontMatter.customProperties.forEach((property) => {
      schema.properties[property.name] = {
        type: this.getJsonSchemaType(property.type),
        description: `Create ${property.description}`
      };
      if (property.required) {
        schema.required.push(property.name);
      }
    });
    schema.properties.tags = {
      type: "array",
      items: {
        type: "string",
        enum: settings.tags.customTags.map((tag) => tag.name)
      },
      description: "Select appropriate tags for the document from the provided list"
    };
    return schema;
  }
  getJsonSchemaType(propertyType) {
    switch (propertyType) {
      case "number":
        return "number";
      case "boolean":
        return "boolean";
      case "array":
        return "array";
      default:
        return "string";
    }
  }
};

// src/services/AIService.ts
var AIService = class {
  constructor(app, settingsService, jsonValidationService) {
    this.app = app;
    this.settingsService = settingsService;
    this.jsonValidationService = jsonValidationService;
    this.initializeAdapters();
    this.initializeGenerators();
  }
  initializeAdapters() {
    this.adapters = /* @__PURE__ */ new Map([
      ["openai" /* OpenAI */, new OpenAIAdapter(this.settingsService, this.jsonValidationService)],
      ["anthropic" /* Anthropic */, new AnthropicAdapter(this.settingsService, this.jsonValidationService)],
      ["google" /* Google */, new GeminiAdapter(this.settingsService, this.jsonValidationService)],
      ["groq" /* Groq */, new GroqAdapter(this.settingsService, this.jsonValidationService)],
      ["openrouter" /* OpenRouter */, new OpenRouterAdapter(this.settingsService, this.jsonValidationService)],
      ["lmstudio" /* LMStudio */, new LMStudioAdapter(this.settingsService, this.jsonValidationService)]
    ]);
  }
  /**
   * Initializes all generators required for AI operations.
   */
  initializeGenerators() {
    const currentProvider = this.getCurrentProvider();
    const currentAdapter = this.getAdapterForProvider(currentProvider);
    this.jsonSchemaGenerator = new JsonSchemaGenerator(this.settingsService);
    this.frontMatterGenerator = new FrontMatterGenerator(currentAdapter, this.settingsService, this.jsonSchemaGenerator);
    this.wikilinkGenerator = new WikilinkGenerator(currentAdapter, this.settingsService);
    this.ontologyGenerator = new OntologyGenerator(currentAdapter, this.settingsService);
    this.batchProcessor = new BatchProcessor(
      currentAdapter,
      this.settingsService,
      this.frontMatterGenerator,
      this.wikilinkGenerator,
      this.app
    );
  }
  /**
   * Reinitializes adapters and generators. Useful after updating settings.
   */
  reinitialize() {
    this.initializeAdapters();
    this.initializeGenerators();
  }
  /**
   * Retrieves the current AI provider selected in settings.
   */
  getCurrentProvider() {
    return this.settingsService.getAIProviderSettings().selected;
  }
  /**
   * Retrieves the current model API name for a given provider.
   * @param provider - The AI provider.
   */
  getCurrentModel(provider) {
    const aiProviderSettings = this.settingsService.getAIProviderSettings();
    const modelApiName = aiProviderSettings.selectedModels[provider];
    if (!modelApiName) {
      throw new Error(`No model selected for provider: ${provider}`);
    }
    return modelApiName;
  }
  /**
   * Retrieves the default model API name based on the current provider.
   */
  getDefaultModel() {
    const provider = this.getCurrentProvider();
    return this.getCurrentModel(provider);
  }
  /**
   * Sets the default model API name for the current provider.
   * @param modelApiName - The model API name to set as default.
   */
  async setDefaultModel(modelApiName) {
    const provider = this.getCurrentProvider();
    const aiProviderSettings = this.settingsService.getAIProviderSettings();
    aiProviderSettings.selectedModels[provider] = modelApiName;
    await this.settingsService.updateAIProviderSettings(provider, { selectedModels: aiProviderSettings.selectedModels });
    this.reinitialize();
  }
  /**
   * Retrieves all available models for a given provider.
   * @param provider - The AI provider.
   */
  getAvailableModels(provider) {
    const adapter = this.getAdapterForProvider(provider);
    return adapter.getAvailableModels();
  }
  /**
   * Retrieves all supported AI providers.
   */
  getSupportedProviders() {
    return Array.from(this.adapters.keys());
  }
  /**
   * Retrieves the adapter corresponding to a given provider.
   * @param provider - The AI provider.
   */
  getAdapterForProvider(provider) {
    const adapter = this.adapters.get(provider);
    if (!adapter) {
      throw new Error(`No adapter found for provider: ${provider}`);
    }
    return adapter;
  }
  /**
   * Validates the API key for a given provider.
   * @param provider - The AI provider.
   */
  async validateApiKey(provider) {
    const adapter = this.getAdapterForProvider(provider);
    try {
      return await adapter.validateApiKey();
    } catch (error) {
      console.error(`Error validating API key for ${provider}:`, error);
      return false;
    }
  }
  /**
   * Updates plugin settings and reinitializes services.
   * @param newSettings - Partial plugin settings to update.
   */
  async updateSettings(newSettings) {
    await this.settingsService.updateSettings(newSettings);
    this.reinitialize();
  }
  /**
   * Retrieves the root folder of the vault.
   */
  getVaultRoot() {
    return this.app.vault.getRoot();
  }
  /**
   * Retrieves a list of existing markdown pages in the vault.
   */
  getExistingPages() {
    return this.app.vault.getMarkdownFiles().map((file) => file.basename);
  }
  /**
   * Tests the connection to a given AI provider by validating the API key and making a test request.
   * @param provider - The AI provider to test.
   */
  async testConnection(provider) {
    try {
      const adapter = this.getAdapterForProvider(provider);
      const modelApiName = this.getCurrentModel(provider);
      const testPrompt = "This is a test prompt. Please respond with the word 'OK'.";
      return await adapter.testConnection(testPrompt, modelApiName);
    } catch (error) {
      console.error(`Error testing connection to ${provider}:`, error);
      return false;
    }
  }
  /**
   * Generates a response from the AI based on the provided prompt.
   * @param prompt - The input prompt for the AI.
   */
  async generateResponse(prompt) {
    const provider = this.getCurrentProvider();
    const modelApiName = this.getCurrentModel(provider);
    const adapter = this.getAdapterForProvider(provider);
    try {
      return await adapter.generateResponse(prompt, modelApiName);
    } catch (error) {
      console.error("Error generating response:", error);
      throw new Error(`Failed to generate response: ${error.message}`);
    }
  }
  /**
   * Retrieves a list of AI providers that have valid API keys set.
   */
  getProvidersWithApiKeys() {
    const aiProviderSettings = this.settingsService.getAIProviderSettings();
    return Object.entries(aiProviderSettings.apiKeys).filter(([_, apiKey]) => apiKey && apiKey.trim() !== "").map(([provider, _]) => provider);
  }
  /**
   * Generates front matter for the given content.
   * @param content - The content for which to generate front matter.
   */
  async generateFrontMatter(content) {
    try {
      return await this.frontMatterGenerator.generate(content);
    } catch (error) {
      console.error("Error generating front matter:", error);
      throw new Error(`Failed to generate front matter: ${error.message}`);
    }
  }
  /**
   * Generates wikilinks for the given content.
   * @param content - The content for which to generate wikilinks.
   */
  async generateWikilinks(content) {
    const existingPages = this.getExistingPages();
    try {
      return await this.wikilinkGenerator.generate({ content, existingPages });
    } catch (error) {
      console.error("Error generating wikilinks:", error);
      throw new Error(`Failed to generate wikilinks: ${error.message}`);
    }
  }
  /**
   * Generates an ontology based on the provided input.
   * @param input - The input parameters for ontology generation.
   */
  async generateOntology(input) {
    try {
      const adapter = this.getAdapterForProvider(input.provider);
      const generator = new OntologyGenerator(adapter, this.settingsService);
      return await generator.generate(input);
    } catch (error) {
      console.error("Error generating ontology:", error);
      throw new Error(`Failed to generate ontology: ${error.message}`);
    }
  }
  /**
   * Updates tags based on suggested tags.
   * @param suggestedTags - An array of suggested tags with name and description.
   */
  async updateTags(suggestedTags) {
    try {
      const newTags = suggestedTags.map((tag) => ({
        name: tag.name,
        description: tag.description,
        type: "string",
        required: false,
        multipleValues: false
      }));
      await this.settingsService.updateTags(newTags);
    } catch (error) {
      console.error("Error updating tags:", error);
      throw new Error(`Failed to update tags: ${error.message}`);
    }
  }
  /**
   * Processes a batch of files based on the provided options.
   * @param files - An array of files to process.
   * @param options - Options specifying which generators to run.
   */
  async batchProcess(files, options) {
    try {
      return await this.batchProcessor.generate({ files, ...options });
    } catch (error) {
      console.error("Error in batch processing:", error);
      throw new Error(`Batch processing failed: ${error.message}`);
    }
  }
  /**
   * Retrieves all available AI models across all providers.
   */
  getAllAvailableModels() {
    const availableModels = [];
    for (const provider of Object.values(AIProvider)) {
      const adapter = this.getAdapterForProvider(provider);
      if (adapter.isReady()) {
        const models = this.getAvailableModels(provider);
        models.forEach((modelName) => {
          const model = this.getModelDetails(provider, modelName);
          if (model) {
            availableModels.push({ provider, model });
          }
        });
      }
    }
    const localLMStudioSettings = this.settingsService.getLocalLMStudioSettings();
    if (localLMStudioSettings.enabled && localLMStudioSettings.modelName) {
      availableModels.push({
        provider: "lmstudio" /* LMStudio */,
        model: { name: localLMStudioSettings.modelName, apiName: "custom" }
      });
    }
    return availableModels;
  }
  /**
   * Retrieves model details based on provider and model name.
   * @param provider - The AI provider.
   * @param modelName - The name of the model.
   */
  getModelDetails(provider, modelName) {
    const models = AIModelMap[provider];
    return models.find((model) => model.apiName === modelName);
  }
};

// src/services/SettingsService.ts
var import_events = require("events");
var SettingsService = class {
  constructor(plugin, initialSettings) {
    this.plugin = plugin;
    this.settings = initialSettings;
    this.emitter = new import_events.EventEmitter();
  }
  async loadSettings() {
    const data = await this.plugin.loadData();
    this.settings = this.deepMerge(DEFAULT_SETTINGS, data);
    this.settings = this.deepMerge(DEFAULT_SETTINGS, data);
  }
  getSettings() {
    return this.settings;
  }
  getSetting(key) {
    return this.settings[key];
  }
  getNestedSetting(key, nestedKey) {
    return this.settings[key][nestedKey];
  }
  async updateSettings(newSettings) {
    this.settings = this.deepMerge(this.settings, newSettings);
    await this.saveSettings();
    this.emitter.emit("settingsChanged", this.settings);
  }
  async updateSetting(key, value) {
    this.settings[key] = value;
    await this.saveSettings();
    this.emitter.emit("settingsChanged", { [key]: value });
  }
  async updateNestedSetting(key, nestedKey, value) {
    this.settings[key][nestedKey] = value;
    await this.saveSettings();
    this.emitter.emit("settingsChanged", { [key]: { [nestedKey]: value } });
  }
  async updateAIProviderSettings(provider, settings) {
    this.settings.aiProvider = this.deepMerge(this.settings.aiProvider, settings);
    await this.saveSettings();
    this.emitter.emit("settingsChanged", { aiProvider: this.settings.aiProvider });
  }
  getAIProviderSettings() {
    return this.settings.aiProvider;
  }
  async updateLocalLMStudioSettings(settings) {
    this.settings.localLMStudio = this.deepMerge(this.settings.localLMStudio, settings);
    await this.saveSettings();
    this.emitter.emit("settingsChanged", { localLMStudio: this.settings.localLMStudio });
  }
  getLocalLMStudioSettings() {
    return this.settings.localLMStudio;
  }
  async updateTags(newTags) {
    const existingTags = this.settings.tags.customTags || [];
    const mergedTags = [...existingTags];
    for (const newTag of newTags) {
      const existingIndex = mergedTags.findIndex((t) => t.name === newTag.name);
      if (existingIndex !== -1) {
        mergedTags[existingIndex] = { ...mergedTags[existingIndex], ...newTag };
      } else {
        mergedTags.push(newTag);
      }
    }
    this.settings.tags.customTags = mergedTags;
    await this.saveSettings();
    this.emitter.emit("settingsChanged", { tags: { customTags: mergedTags } });
  }
  async resetToDefault() {
    this.settings = { ...DEFAULT_SETTINGS };
    await this.saveSettings();
    this.emitter.emit("settingsReset");
  }
  onSettingsChanged(listener) {
    this.emitter.on("settingsChanged", listener);
  }
  onSettingsReset(listener) {
    this.emitter.on("settingsReset", listener);
  }
  async saveSettings() {
    await this.plugin.saveData(this.settings);
  }
  deepMerge(target, source) {
    if (!this.isObject(target) || !this.isObject(source)) {
      return source;
    }
    const output = { ...target };
    for (const key in source) {
      if (source.hasOwnProperty(key)) {
        if (this.isObject(source[key]) && this.isObject(target[key])) {
          output[key] = this.deepMerge(
            target[key],
            source[key]
          );
        } else if (source[key] !== void 0) {
          output[key] = source[key];
        }
      }
    }
    return output;
  }
  isObject(item) {
    return item !== null && typeof item === "object" && !Array.isArray(item);
  }
};

// src/services/DatabaseService.ts
var DatabaseService = class {
  constructor() {
    this.processedFiles = [];
  }
  async load(loadData) {
    const data = await loadData();
    this.processedFiles = (data == null ? void 0 : data.processedFiles) || [];
  }
  async save(saveData) {
    await saveData({ processedFiles: this.processedFiles });
  }
  markFileAsProcessed(file) {
    const existingIndex = this.processedFiles.findIndex((f) => f.path === file.path);
    if (existingIndex !== -1) {
      this.processedFiles[existingIndex].lastProcessed = Date.now();
    } else {
      this.processedFiles.push({ path: file.path, lastProcessed: Date.now() });
    }
  }
  isFileProcessed(file) {
    return this.processedFiles.some((f) => f.path === file.path);
  }
  getUnprocessedFiles(allFiles) {
    return allFiles.filter((file) => !this.isFileProcessed(file));
  }
};

// src/services/AutoGenerateService.ts
var AutoGenerateService = class {
  constructor(vault, aiService, settingsService, databaseService) {
    this.vault = vault;
    this.aiService = aiService;
    this.settingsService = settingsService;
    this.databaseService = databaseService;
  }
  async runAutoGenerate() {
    console.log("AutoGenerateService: Starting auto-generate process");
    const settings = this.settingsService.getSettings();
    if (!settings.frontMatter.autoGenerate) {
      console.log("AutoGenerateService: Auto-generate is disabled");
      return;
    }
    const allFiles = this.vault.getMarkdownFiles();
    const unprocessedFiles = this.databaseService.getUnprocessedFiles(allFiles);
    for (const file of unprocessedFiles) {
      if (await this.needsFrontMatter(file)) {
        await this.generateFrontMatter(file);
        this.databaseService.markFileAsProcessed(file);
      }
    }
    console.log("AutoGenerateService: Auto-generate process completed");
  }
  async needsFrontMatter(file) {
    const content = await this.vault.read(file);
    return !content.startsWith("---\n");
  }
  async generateFrontMatter(file) {
    console.log(`AutoGenerateService: Generating front matter for ${file.path}`);
    const content = await this.vault.read(file);
    const frontMatter = await this.aiService.generateFrontMatter(content);
    const updatedContent = this.addOrUpdateFrontMatter(content, frontMatter);
    await this.vault.modify(file, updatedContent);
  }
  addOrUpdateFrontMatter(content, newFrontMatter) {
    if (content.startsWith("---\n")) {
      return content.replace(/^---\n[\s\S]*?\n---\n/, newFrontMatter);
    } else {
      return `${newFrontMatter}

${content}`;
    }
  }
};

// src/components/accordions/ModelHookupAccordion.ts
var import_obsidian8 = require("obsidian");

// src/components/accordions/BaseAccordion.ts
var import_obsidian7 = require("obsidian");
var BaseAccordion = class {
  constructor(containerEl) {
    this.isOpen = false;
    this.containerEl = containerEl;
  }
  createAccordion(title, description) {
    this.accordionEl = this.containerEl.createDiv({ cls: "gw-accordion" });
    this.headerEl = this.accordionEl.createDiv({ cls: "gw-accordion-header" });
    const titleWrapper = this.headerEl.createDiv({ cls: "gw-accordion-title-wrapper" });
    titleWrapper.createSpan({ text: title, cls: "gw-accordion-title" });
    this.toggleIcon = this.headerEl.createSpan({ cls: "gw-accordion-toggle" });
    this.updateToggleIcon();
    const descriptionEl = this.accordionEl.createDiv({ cls: "gw-accordion-description" });
    descriptionEl.createSpan({ text: description });
    this.contentEl = this.accordionEl.createDiv({ cls: "gw-accordion-content" });
    this.contentEl.style.display = "none";
    this.headerEl.addEventListener("click", () => this.toggleAccordion());
    return this.contentEl;
  }
  toggleAccordion() {
    this.isOpen = !this.isOpen;
    this.contentEl.style.display = this.isOpen ? "block" : "none";
    this.updateToggleIcon();
    this.accordionEl.classList.toggle("gw-accordion-open", this.isOpen);
  }
  updateToggleIcon() {
    this.toggleIcon.empty();
    const iconText = document.createTextNode(this.isOpen ? "\u2796" : "\u2795");
    this.toggleIcon.appendChild(iconText);
  }
  createSettingItem(name, desc) {
    const setting = new import_obsidian7.Setting(this.contentEl);
    setting.setName(name).setDesc(desc);
    setting.settingEl.classList.add("gw-setting-item");
    return setting;
  }
};

// src/components/accordions/ModelHookupAccordion.ts
var ModelHookupAccordion = class extends BaseAccordion {
  constructor(app, containerEl, settingsService, aiService) {
    super(containerEl);
    this.app = app;
    this.settingsService = settingsService;
    this.aiService = aiService;
  }
  render() {
    const contentEl = this.createAccordion(
      "\u{1F50C} Model Hookup",
      "Configure AI providers and models."
    );
    this.createProviderDropdown(contentEl);
    this.settingsContainer = contentEl.createDiv({ cls: "provider-settings" });
    this.renderProviderSettings();
  }
  createProviderDropdown(containerEl) {
    const settings = this.settingsService.getSettings();
    new import_obsidian8.Setting(containerEl).setName("AI Provider").setDesc("Select the AI provider to use").addDropdown((dropdown) => {
      this.providerDropdown = dropdown;
      Object.values(AIProvider).forEach((provider) => {
        dropdown.addOption(provider, this.getFormattedProviderName(provider));
      });
      dropdown.setValue(settings.aiProvider.selected).onChange(async (value) => {
        await this.settingsService.updateNestedSetting("aiProvider", "selected", value);
        this.aiService.reinitialize();
        this.renderProviderSettings();
      });
    });
  }
  renderProviderSettings() {
    const provider = this.providerDropdown.getValue();
    this.settingsContainer.empty();
    if (provider === "lmstudio" /* LMStudio */) {
      this.renderLocalSettings();
    } else {
      this.renderCloudSettings(provider);
      this.createModelDropdown(this.settingsContainer, provider);
    }
    this.createTestButton(this.settingsContainer, provider);
  }
  renderCloudSettings(provider) {
    this.createProviderLink(this.settingsContainer, provider);
    this.createApiKeyInput(this.settingsContainer, provider);
  }
  renderLocalSettings() {
    this.createPortInput(this.settingsContainer);
    this.createModelNameInput(this.settingsContainer);
  }
  createApiKeyInput(containerEl, provider) {
    const settings = this.settingsService.getSettings();
    new import_obsidian8.Setting(containerEl).setName("API Key").setDesc(`Enter your API key for ${this.getFormattedProviderName(provider)}`).addText((text) => {
      text.setPlaceholder("Enter API Key").setValue(settings.aiProvider.apiKeys[provider] || "").onChange(async (value) => {
        const currentApiKeys = this.settingsService.getNestedSetting("aiProvider", "apiKeys");
        const updatedApiKeys = { ...currentApiKeys, [provider]: value };
        await this.settingsService.updateNestedSetting("aiProvider", "apiKeys", updatedApiKeys);
        this.aiService.reinitialize();
      });
    });
  }
  createPortInput(containerEl) {
    const settings = this.settingsService.getSettings();
    new import_obsidian8.Setting(containerEl).setName("LM Studio Port").setDesc("Enter the port number for your local LM Studio instance").addText((text) => {
      text.setPlaceholder("Enter port number").setValue(settings.localLMStudio.port.toString()).onChange(async (value) => {
        const port = parseInt(value, 10);
        if (!isNaN(port)) {
          await this.settingsService.updateNestedSetting("localLMStudio", "port", port);
          this.aiService.reinitialize();
        }
      });
    });
  }
  createModelNameInput(containerEl) {
    const settings = this.settingsService.getSettings();
    new import_obsidian8.Setting(containerEl).setName("Model Name").setDesc("Enter the name of the local model you want to use").addText((text) => {
      text.setPlaceholder("Enter model name").setValue(settings.localLMStudio.modelName).onChange(async (value) => {
        await this.settingsService.updateNestedSetting("localLMStudio", "modelName", value);
        await this.settingsService.updateNestedSetting("aiProvider", "selectedModels", {
          ...this.settingsService.getNestedSetting("aiProvider", "selectedModels"),
          ["lmstudio" /* LMStudio */]: value
        });
        this.aiService.reinitialize();
      });
    });
  }
  createModelDropdown(containerEl, provider) {
    const settings = this.settingsService.getSettings();
    const models = AIModelMap[provider];
    new import_obsidian8.Setting(containerEl).setName("Model").setDesc(`Select the AI model for ${this.getFormattedProviderName(provider)}`).addDropdown((dropdown) => {
      var _a;
      models.forEach((model) => {
        dropdown.addOption(model.apiName, model.name);
      });
      const currentModel = settings.aiProvider.selectedModels[provider] || (((_a = models[0]) == null ? void 0 : _a.apiName) || "");
      dropdown.setValue(currentModel).onChange(async (value) => {
        const currentSelectedModels = this.settingsService.getNestedSetting("aiProvider", "selectedModels");
        const updatedSelectedModels = { ...currentSelectedModels, [provider]: value };
        await this.settingsService.updateNestedSetting("aiProvider", "selectedModels", updatedSelectedModels);
      });
    });
  }
  createTestButton(containerEl, provider) {
    new import_obsidian8.Setting(containerEl).addButton((button) => {
      button.setButtonText("Test Connection").onClick(async () => {
        button.setDisabled(true);
        button.setButtonText("Testing...");
        const result = await this.aiService.testConnection(provider);
        button.setDisabled(false);
        button.setButtonText("Test Connection");
        if (result) {
          new import_obsidian8.Notice(`Successfully connected to ${this.getFormattedProviderName(provider)}`);
        } else {
          new import_obsidian8.Notice(`Failed to connect to ${this.getFormattedProviderName(provider)}. Please check your settings and try again.`);
        }
      });
    });
  }
  createProviderLink(containerEl, provider) {
    const websiteUrl = this.getProviderWebsite(provider);
    const linkText = provider === "lmstudio" /* LMStudio */ ? "LM Studio Documentation" : "Get API Key";
    const linkEl = containerEl.createEl("a", {
      text: linkText,
      href: websiteUrl,
      cls: "provider-link"
    });
    linkEl.setAttribute("target", "_blank");
    const providerLabel = containerEl.createEl("span", {
      text: ` for ${this.getFormattedProviderName(provider)}`,
      cls: "provider-label"
    });
  }
  getProviderWebsite(provider) {
    const websiteMap = {
      ["openai" /* OpenAI */]: "https://platform.openai.com/api-keys",
      ["anthropic" /* Anthropic */]: "https://console.anthropic.com/settings/keys",
      ["google" /* Google */]: "https://aistudio.google.com/apikey",
      ["groq" /* Groq */]: "https://console.groq.com/keys",
      ["openrouter" /* OpenRouter */]: "https://openrouter.ai/settings/keys",
      ["lmstudio" /* LMStudio */]: "https://lmstudio.ai/docs/basics/server"
    };
    return websiteMap[provider] || "#";
  }
  getFormattedProviderName(provider) {
    const formattedNames = {
      ["openai" /* OpenAI */]: "OpenAI",
      ["anthropic" /* Anthropic */]: "Anthropic",
      ["google" /* Google */]: "Google Gemini",
      ["groq" /* Groq */]: "Groq",
      ["openrouter" /* OpenRouter */]: "OpenRouter",
      ["lmstudio" /* LMStudio */]: "LM Studio"
    };
    return formattedNames[provider] || provider;
  }
};

// src/components/accordions/PropertyManagerAccordion.ts
var import_obsidian10 = require("obsidian");

// src/components/modals/EditPropertiesModal.ts
var import_obsidian9 = require("obsidian");
var EditPropertiesModal = class extends import_obsidian9.Modal {
  constructor(app, properties, onSubmit) {
    super(app);
    this.properties = [...properties];
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Edit Properties" });
    this.createSelectAllCheckbox(contentEl);
    this.propertyListEl = contentEl.createDiv({ cls: "gw-modal-property-list" });
    this.renderPropertyList();
    const buttonContainer = contentEl.createDiv({ cls: "gw-modal-button-container" });
    new import_obsidian9.Setting(buttonContainer).addButton((btn) => btn.setButtonText("Delete Selected").setWarning().onClick(() => this.deleteSelectedProperties())).addButton((btn) => btn.setButtonText("Save").setCta().onClick(() => {
      this.onSubmit(this.properties);
      this.close();
    })).addButton((btn) => btn.setButtonText("Cancel").onClick(() => this.close()));
  }
  createSelectAllCheckbox(containerEl) {
    const selectAllContainer = containerEl.createDiv({ cls: "gw-select-all-container" });
    this.selectAllCheckbox = selectAllContainer.createEl("input", { type: "checkbox" });
    selectAllContainer.createEl("span", { text: "Select All" });
    this.selectAllCheckbox.addEventListener("change", () => {
      const checkboxes = this.propertyListEl.querySelectorAll('input[type="checkbox"]');
      checkboxes.forEach((checkbox) => {
        checkbox.checked = this.selectAllCheckbox.checked;
      });
    });
  }
  renderPropertyList() {
    this.propertyListEl.empty();
    const table = this.propertyListEl.createEl("table", { cls: "gw-modal-property-table" });
    const headerRow = table.createEl("tr");
    headerRow.createEl("th", { text: "Drag" });
    headerRow.createEl("th", { text: "Name" });
    headerRow.createEl("th", { text: "Description" });
    headerRow.createEl("th", { text: "Type" });
    headerRow.createEl("th", { text: "Delete" });
    this.properties.forEach((property, index) => {
      const row = table.createEl("tr", { attr: { draggable: "true", "data-index": index.toString() } });
      row.addEventListener("dragstart", this.onDragStart.bind(this));
      row.addEventListener("dragover", this.onDragOver.bind(this));
      row.addEventListener("drop", this.onDrop.bind(this));
      row.createEl("td", { text: "\u2261", cls: "gw-drag-handle" });
      this.createEditableCell(row, property, "name", index);
      this.createEditableCell(row, property, "description", index);
      this.createTypeDropdown(row, property, index);
      const deleteCell = row.createEl("td");
      const deleteCheckbox = deleteCell.createEl("input", { type: "checkbox" });
      deleteCheckbox.dataset.index = index.toString();
      deleteCheckbox.addEventListener("change", () => this.updateSelectAllCheckbox());
    });
  }
  updateSelectAllCheckbox() {
    const checkboxes = this.propertyListEl.querySelectorAll('input[type="checkbox"]');
    const allChecked = Array.from(checkboxes).every((checkbox) => checkbox.checked);
    this.selectAllCheckbox.checked = allChecked;
  }
  createEditableCell(row, property, field, index) {
    const cell = row.createEl("td");
    const input = new import_obsidian9.TextComponent(cell);
    input.setValue(property[field]).onChange((value) => {
      this.properties[index][field] = value;
    });
  }
  createTypeDropdown(row, property, index) {
    const cell = row.createEl("td");
    const dropdown = new import_obsidian9.DropdownComponent(cell);
    const types = ["string", "number", "boolean", "array", "date"];
    types.forEach((type) => {
      dropdown.addOption(type, type);
    });
    dropdown.setValue(property.type).onChange((value) => {
      this.properties[index].type = value;
    });
  }
  deleteSelectedProperties() {
    const checkboxes = this.propertyListEl.querySelectorAll('input[type="checkbox"]:checked');
    const indicesToDelete = Array.from(checkboxes).map((cb) => parseInt(cb.dataset.index || "", 10)).sort((a, b) => b - a);
    indicesToDelete.forEach((index) => {
      this.properties.splice(index, 1);
    });
    this.renderPropertyList();
    this.updateSelectAllCheckbox();
  }
  onDragStart(e) {
    var _a;
    const target = e.target;
    (_a = e.dataTransfer) == null ? void 0 : _a.setData("text/plain", target.dataset.index || "");
  }
  onDragOver(e) {
    e.preventDefault();
  }
  onDrop(e) {
    var _a, _b;
    e.preventDefault();
    const fromIndex = parseInt(((_a = e.dataTransfer) == null ? void 0 : _a.getData("text/plain")) || "", 10);
    const toIndex = parseInt(((_b = e.target.closest("tr")) == null ? void 0 : _b.dataset.index) || "", 10);
    if (!isNaN(fromIndex) && !isNaN(toIndex)) {
      const [reorderedItem] = this.properties.splice(fromIndex, 1);
      this.properties.splice(toIndex, 0, reorderedItem);
      this.renderPropertyList();
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/components/accordions/PropertyManagerAccordion.ts
var PropertyManagerAccordion = class extends BaseAccordion {
  constructor(app, containerEl, settingsService, aiService) {
    super(containerEl);
    this.app = app;
    this.settingsService = settingsService;
    this.aiService = aiService;
  }
  render() {
    const contentEl = this.createAccordion(
      "\u{1F4CA} Property Management",
      "Create and manage custom properties for your notes."
    );
    this.createPropertyEditor(contentEl);
    this.createButtonRow(contentEl);
  }
  createPropertyEditor(containerEl) {
    const editorContainer = containerEl.createDiv({ cls: "gw-property-editor" });
    new import_obsidian10.Setting(editorContainer).setName("Property Name").addText((text) => {
      this.nameInput = text;
      text.setPlaceholder("Enter property name");
    });
    new import_obsidian10.Setting(editorContainer).setName("Property Description").addTextArea((textarea) => {
      this.descriptionInput = textarea;
      textarea.setPlaceholder("Enter property description");
    });
    new import_obsidian10.Setting(editorContainer).setName("Property Type").addDropdown((dropdown) => {
      this.typeDropdown = dropdown;
      dropdown.addOption("string", "String").addOption("number", "Number").addOption("boolean", "Boolean").addOption("array", "Array").addOption("date", "Date").setValue("string");
    });
  }
  createButtonRow(containerEl) {
    const buttonContainer = containerEl.createDiv({ cls: "gw-button-container" });
    new import_obsidian10.Setting(buttonContainer).addButton((button) => button.setButtonText("Edit Properties").onClick(() => this.openEditModal())).addButton((button) => button.setButtonText("Add Property").setCta().onClick(() => this.addProperty()));
  }
  addProperty() {
    const name = this.nameInput.getValue().trim();
    const description = this.descriptionInput.getValue().trim();
    const type = this.typeDropdown.getValue();
    if (!name) {
      new import_obsidian10.Notice("Property name cannot be empty.");
      return;
    }
    if (!description) {
      new import_obsidian10.Notice("Property description cannot be empty.");
      return;
    }
    const newProperty = {
      name,
      description,
      type,
      required: false,
      multipleValues: false
    };
    const settings = this.settingsService.getSettings();
    settings.frontMatter.customProperties.push(newProperty);
    this.settingsService.updateSettings(settings);
    new import_obsidian10.Notice(`Property "${name}" has been added.`);
    this.nameInput.setValue("");
    this.descriptionInput.setValue("");
    this.typeDropdown.setValue("string");
  }
  openEditModal() {
    const modal = new EditPropertiesModal(
      this.app,
      this.settingsService.getSettings().frontMatter.customProperties,
      (updatedProperties) => {
        const settings = this.settingsService.getSettings();
        settings.frontMatter.customProperties = updatedProperties;
        this.settingsService.updateSettings(settings);
      }
    );
    modal.open();
  }
};

// src/components/accordions/TagManagerAccordion.ts
var import_obsidian12 = require("obsidian");

// src/components/modals/EditTagsModal.ts
var import_obsidian11 = require("obsidian");
var EditTagsModal = class extends import_obsidian11.Modal {
  constructor(app, tags, onSubmit) {
    super(app);
    this.tags = [...tags];
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Edit Tags" });
    this.createSelectAllCheckbox(contentEl);
    this.tagListEl = contentEl.createDiv({ cls: "gw-modal-tag-list" });
    this.renderTagList();
    const buttonContainer = contentEl.createDiv({ cls: "gw-modal-button-container" });
    new import_obsidian11.Setting(buttonContainer).addButton((btn) => btn.setButtonText("Delete Selected").setWarning().onClick(() => this.deleteSelectedTags())).addButton((btn) => btn.setButtonText("Save").setCta().onClick(() => {
      this.onSubmit(this.tags);
      this.close();
    })).addButton((btn) => btn.setButtonText("Cancel").onClick(() => this.close()));
  }
  createSelectAllCheckbox(containerEl) {
    const selectAllContainer = containerEl.createDiv({ cls: "gw-select-all-container" });
    this.selectAllCheckbox = selectAllContainer.createEl("input", { type: "checkbox" });
    selectAllContainer.createEl("span", { text: "Select All" });
    this.selectAllCheckbox.addEventListener("change", () => {
      const checkboxes = this.tagListEl.querySelectorAll('input[type="checkbox"]');
      checkboxes.forEach((checkbox) => {
        checkbox.checked = this.selectAllCheckbox.checked;
      });
    });
  }
  renderTagList() {
    this.tagListEl.empty();
    const table = this.tagListEl.createEl("table", { cls: "gw-modal-tag-table" });
    const headerRow = table.createEl("tr");
    headerRow.createEl("th", { text: "Name" });
    headerRow.createEl("th", { text: "Description" });
    headerRow.createEl("th", { text: "Delete" });
    this.tags.forEach((tag, index) => {
      const row = table.createEl("tr");
      this.createEditableCell(row, tag, "name", index);
      this.createEditableCell(row, tag, "description", index);
      const deleteCell = row.createEl("td");
      const deleteCheckbox = deleteCell.createEl("input", { type: "checkbox" });
      deleteCheckbox.dataset.index = index.toString();
      deleteCheckbox.addEventListener("change", () => this.updateSelectAllCheckbox());
    });
  }
  updateSelectAllCheckbox() {
    const checkboxes = this.tagListEl.querySelectorAll('input[type="checkbox"]');
    const allChecked = Array.from(checkboxes).every((checkbox) => checkbox.checked);
    this.selectAllCheckbox.checked = allChecked;
  }
  createEditableCell(row, tag, field, index) {
    const cell = row.createEl("td");
    const input = field === "name" ? new import_obsidian11.TextComponent(cell) : new import_obsidian11.TextAreaComponent(cell);
    input.setValue(tag[field]).onChange((value) => {
      this.tags[index][field] = value;
    });
  }
  deleteSelectedTags() {
    const checkboxes = this.tagListEl.querySelectorAll('input[type="checkbox"]:checked');
    const indicesToDelete = Array.from(checkboxes).map((cb) => parseInt(cb.dataset.index || "", 10)).sort((a, b) => b - a);
    indicesToDelete.forEach((index) => {
      this.tags.splice(index, 1);
    });
    this.renderTagList();
    this.updateSelectAllCheckbox();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/components/accordions/TagManagerAccordion.ts
var TagManagerAccordion = class extends BaseAccordion {
  constructor(app, containerEl, settingsService, aiService) {
    super(containerEl);
    this.app = app;
    this.settingsService = settingsService;
    this.aiService = aiService;
  }
  render() {
    const contentEl = this.createAccordion(
      "\u{1F3F7}\uFE0F Tag Management",
      "Create and manage custom tags for your notes."
    );
    this.createTagEditor(contentEl);
    this.createButtonRow(contentEl);
  }
  createTagEditor(containerEl) {
    const editorContainer = containerEl.createDiv({ cls: "gw-tag-editor" });
    new import_obsidian12.Setting(editorContainer).setName("Tag Name").addText((text) => {
      this.nameInput = text;
      text.setPlaceholder("Enter tag name");
    });
    new import_obsidian12.Setting(editorContainer).setName("Tag Description").addTextArea((textarea) => {
      this.descriptionInput = textarea;
      textarea.setPlaceholder("Enter tag description");
    });
  }
  createButtonRow(containerEl) {
    const buttonContainer = containerEl.createDiv({ cls: "gw-button-container" });
    new import_obsidian12.Setting(buttonContainer).addButton((button) => button.setButtonText("Edit Tags").onClick(() => this.openEditModal())).addButton((button) => button.setButtonText("Add Tag").setCta().onClick(() => this.addTag()));
  }
  addTag() {
    const name = this.nameInput.getValue().trim();
    const description = this.descriptionInput.getValue().trim();
    if (!name) {
      new import_obsidian12.Notice("Tag name cannot be empty.");
      return;
    }
    const newTag = {
      name,
      description,
      type: "string",
      required: false,
      multipleValues: false
    };
    const settings = this.settingsService.getSettings();
    settings.tags.customTags.push(newTag);
    this.settingsService.updateSettings(settings);
    new import_obsidian12.Notice(`Tag "${name}" has been added.`);
    this.nameInput.setValue("");
    this.descriptionInput.setValue("");
  }
  openEditModal() {
    const modal = new EditTagsModal(
      this.app,
      this.settingsService.getSettings().tags.customTags,
      (updatedTags) => {
        const settings = this.settingsService.getSettings();
        settings.tags.customTags = updatedTags;
        this.settingsService.updateSettings(settings);
      }
    );
    modal.open();
  }
};

// src/components/accordions/OntologyGenerationAccordion.ts
var import_obsidian14 = require("obsidian");

// src/components/modals/OntologyGeneratorModal.ts
var import_obsidian13 = require("obsidian");
var OntologyGeneratorModal = class extends import_obsidian13.Modal {
  constructor(app, aiService, onGenerate) {
    super(app);
    this.aiService = aiService;
    this.onGenerate = onGenerate;
    this.vaultStats = { files: [], folders: [], tags: [] };
    this.availableModels = [];
  }
  async onOpen() {
    this.contentEl.empty();
    this.contentEl.addClass("ontology-generator-modal");
    this.loadingEl = this.contentEl.createDiv("loading-container");
    this.loadingEl.innerHTML = '<div class="spinner"></div><p>Retrieving vault statistics and available models...</p>';
    try {
      await this.loadVaultStats();
      this.availableModels = this.aiService.getAllAvailableModels();
      this.renderContent();
    } catch (error) {
      console.error("Error loading data:", error);
      this.showError("An error occurred while retrieving data.");
    }
  }
  async loadVaultStats() {
    this.vaultStats.files = this.app.vault.getMarkdownFiles();
    this.vaultStats.folders = this.app.vault.getAllLoadedFiles().filter((file) => file instanceof import_obsidian13.TFolder);
    this.vaultStats.tags = await this.getAllTags(this.vaultStats.files);
  }
  async getAllTags(files) {
    const tagSet = /* @__PURE__ */ new Set();
    for (const file of files) {
      const content = await this.app.vault.read(file);
      const tags = content.match(/#[\w-]+/g);
      if (tags) {
        tags.forEach((tag) => tagSet.add(tag));
      }
    }
    return Array.from(tagSet);
  }
  renderContent() {
    this.loadingEl.hide();
    this.contentEl.empty();
    this.contentEl.createEl("h2", { text: "Generate Ontology" });
    this.renderVaultStats();
    this.renderModelSelection();
    this.renderUserContextInput();
    this.renderGuidedQuestions();
    this.renderButtons();
  }
  renderVaultStats() {
    const statsEl = this.contentEl.createDiv("vault-stats");
    statsEl.createEl("h3", { text: "Vault Statistics" });
    const listEl = statsEl.createEl("ul");
    listEl.createEl("li", { text: `Files: ${this.vaultStats.files.length}` });
    listEl.createEl("li", { text: `Folders: ${this.vaultStats.folders.length}` });
    listEl.createEl("li", { text: `Tags: ${this.vaultStats.tags.length}` });
  }
  renderModelSelection() {
    const modelSetting = new import_obsidian13.Setting(this.contentEl).setName("AI Model").setDesc("Select the AI model to use for ontology generation");
    if (this.availableModels.length === 0) {
      modelSetting.setDesc("No AI models available. Please add API keys in the API Integration settings.");
      return;
    }
    modelSetting.addDropdown((dropdown) => {
      this.modelSelect = dropdown;
      this.availableModels.forEach(({ provider, model }) => {
        const optionText = `${provider} - ${model.name}`;
        dropdown.addOption(`${provider}:${model.apiName}`, optionText);
      });
      if (this.availableModels.length > 0) {
        const firstModel = this.availableModels[0];
        dropdown.setValue(`${firstModel.provider}:${firstModel.model.apiName}`);
      }
    });
  }
  renderUserContextInput() {
    const contextSetting = new import_obsidian13.Setting(this.contentEl).setName("Additional Context").setDesc("Provide any additional context or information about your knowledge base that might help in generating a more accurate ontology.").addTextArea((text) => {
      this.userContextInput = text;
      text.inputEl.rows = 4;
      text.inputEl.cols = 50;
      return text;
    });
  }
  renderGuidedQuestions() {
    const questionsEl = this.contentEl.createDiv("guided-questions");
    questionsEl.createEl("h4", { text: "Guided Questions" });
    questionsEl.createEl("p", { text: "Consider the following questions when providing additional context:" });
    const questionsList = questionsEl.createEl("ul");
    [
      "What are the main themes or topics in your knowledge base?",
      "Are there any specific hierarchies or relationships between concepts that you want to emphasize?",
      "What are your goals for organizing your knowledge base?"
    ].forEach((question) => {
      questionsList.createEl("li", { text: question });
    });
  }
  renderButtons() {
    const buttonContainer = this.contentEl.createDiv("button-container");
    this.generateButton = new import_obsidian13.ButtonComponent(buttonContainer).setButtonText("Generate Ontology").setCta().setDisabled(this.availableModels.length === 0).onClick(() => this.generateOntology());
    new import_obsidian13.ButtonComponent(buttonContainer).setButtonText("Cancel").onClick(() => this.close());
  }
  async generateOntology() {
    const modelValue = this.modelSelect.getValue();
    if (!modelValue) {
      new import_obsidian13.Notice("Please select an AI model first.");
      return;
    }
    const [provider, modelApiName] = modelValue.split(":");
    this.generateButton.setDisabled(true);
    const loadingNotice = new import_obsidian13.Notice("Generating ontology...", 0);
    try {
      const input = {
        ...this.vaultStats,
        provider,
        modelApiName,
        userContext: this.userContextInput.getValue()
      };
      const ontology = await this.aiService.generateOntology(input);
      await this.aiService.updateTags(ontology.suggestedTags);
      loadingNotice.hide();
      new import_obsidian13.Notice("Ontology generated and tags updated successfully!", 3e3);
      this.onGenerate(ontology);
      this.close();
    } catch (error) {
      console.error("Error generating ontology:", error);
      loadingNotice.hide();
      new import_obsidian13.Notice(`Failed to generate ontology: ${error.message}`, 5e3);
    } finally {
      this.generateButton.setDisabled(false);
    }
  }
  showError(message) {
    this.loadingEl.hide();
    this.contentEl.empty();
    this.contentEl.createEl("p", { text: message, cls: "error-message" });
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/components/accordions/OntologyGenerationAccordion.ts
var OntologyGenerationAccordion = class extends BaseAccordion {
  constructor(app, containerEl, settingsService, aiService) {
    super(containerEl);
    this.app = app;
    this.settingsService = settingsService;
    this.aiService = aiService;
  }
  render() {
    const contentEl = this.createAccordion(
      "\u{1F578} Ontology Generator",
      "Generate ontology tags for your knowledge base."
    );
    this.createDescription(contentEl);
    this.createGenerateButton(contentEl);
  }
  createDescription(containerEl) {
    const descEl = containerEl.createDiv({ cls: "ontology-description" });
    descEl.createEl("p", { text: "The Ontology Generator analyzes your vault's structure, including tags, file names, and folder names, to create a comprehensive set of suggested tags. This tool helps you:" });
    const listEl = descEl.createEl("ul");
    [
      "Discover new connections in your knowledge base",
      "Improve note categorization and searchability",
      "Save time on manual tagging",
      "Gain insights into your collected information"
    ].forEach((item) => {
      listEl.createEl("li", { text: item });
    });
  }
  createGenerateButton(containerEl) {
    new import_obsidian14.Setting(containerEl).addButton((button) => this.setupGenerateButton(button));
  }
  setupGenerateButton(button) {
    button.setButtonText("Generate Ontology").setCta().onClick(() => this.openGeneratorModal());
  }
  openGeneratorModal() {
    new OntologyGeneratorModal(
      this.app,
      this.aiService,
      this.handleGeneratedOntology.bind(this)
    ).open();
  }
  async handleGeneratedOntology(generatedOntology) {
    console.log("Ontology generated:", generatedOntology);
    const currentSettings = this.settingsService.getSettings();
    const updatedSettings = {
      ...currentSettings,
      ontology: {
        ...currentSettings.ontology,
        lastGenerated: JSON.stringify(generatedOntology)
      }
    };
    await this.settingsService.updateSettings(updatedSettings);
    new import_obsidian14.Notice("Ontology has been successfully generated and saved to your settings.");
  }
};

// src/components/accordions/BatchProcessorAccordion.ts
var import_obsidian16 = require("obsidian");

// src/components/modals/BatchProcessorModal.ts
var import_obsidian15 = require("obsidian");
var BatchProcessorModal = class extends import_obsidian15.Modal {
  constructor(app, aiService, settingsService) {
    super(app);
    this.aiService = aiService;
    this.settingsService = settingsService;
  }
  onOpen() {
    this.renderContent();
  }
  onClose() {
    this.contentEl.empty();
  }
  renderContent() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Select Files/Folders to Process" });
    const fileExplorer = contentEl.createDiv({ cls: "file-explorer" });
    this.renderVaultStructure(fileExplorer);
    this.createButtons(contentEl);
  }
  renderVaultStructure(containerEl) {
    const rootFolder = this.app.vault.getRoot();
    rootFolder.children.forEach((child) => {
      if (child instanceof import_obsidian15.TFolder) {
        this.renderFolder(containerEl, child);
      } else if (child instanceof import_obsidian15.TFile) {
        containerEl.appendChild(this.createFileElement(child));
      }
    });
  }
  renderFolder(containerEl, folder) {
    const folderEl = this.createFolderElement(folder);
    containerEl.appendChild(folderEl);
    const contentEl = folderEl.querySelector(".folder-content");
    folder.children.forEach((child) => {
      if (child instanceof import_obsidian15.TFolder) {
        this.renderFolder(contentEl, child);
      } else if (child instanceof import_obsidian15.TFile) {
        contentEl.appendChild(this.createFileElement(child));
      }
    });
  }
  createFolderElement(folder) {
    const folderEl = document.createElement("div");
    folderEl.className = "folder";
    const nameEl = folderEl.createDiv({ cls: "folder-name" });
    nameEl.createSpan({ cls: "icon folder-icon", text: "\u{1F4C1}" });
    const checkbox = nameEl.createEl("input", { type: "checkbox" });
    checkbox.className = "folder-checkbox";
    nameEl.createSpan({ text: folder.name });
    const contentEl = folderEl.createDiv({ cls: "folder-content" });
    folderEl.setAttribute("data-path", folder.path);
    nameEl.addEventListener("click", (e) => {
      if (e.target !== checkbox) {
        folderEl.classList.toggle("open");
      }
    });
    checkbox.addEventListener("change", () => this.handleFolderCheckboxChange(checkbox));
    return folderEl;
  }
  createFileElement(file) {
    const fileEl = document.createElement("div");
    fileEl.className = "file";
    fileEl.createSpan({ cls: "icon file-icon", text: "\u{1F4C4}" });
    const checkbox = fileEl.createEl("input", { type: "checkbox" });
    checkbox.className = "file-checkbox";
    fileEl.createSpan({ text: file.name });
    fileEl.setAttribute("data-path", file.path);
    checkbox.addEventListener("change", () => this.handleFileCheckboxChange(checkbox));
    return fileEl;
  }
  handleFolderCheckboxChange(checkbox) {
    const folderEl = checkbox.closest(".folder");
    if (!folderEl)
      return;
    const descendantCheckboxes = folderEl.querySelectorAll("input[type='checkbox']");
    descendantCheckboxes.forEach((childCheckbox) => {
      childCheckbox.checked = checkbox.checked;
      childCheckbox.indeterminate = false;
    });
    this.updateParentCheckboxes(checkbox);
  }
  handleFileCheckboxChange(checkbox) {
    this.updateParentCheckboxes(checkbox);
  }
  updateParentCheckboxes(checkbox) {
    var _a, _b, _c;
    let parentFolderEl = (_b = (_a = checkbox.closest(".folder")) == null ? void 0 : _a.parentElement) == null ? void 0 : _b.closest(".folder");
    while (parentFolderEl) {
      const parentCheckbox = parentFolderEl.querySelector(".folder-checkbox");
      const childCheckboxes = parentFolderEl.querySelectorAll(":scope > .folder-content .folder > .folder-name > .folder-checkbox, :scope > .folder-content .file > .file-checkbox");
      const allChecked = Array.from(childCheckboxes).every((cb) => cb.checked);
      const someChecked = Array.from(childCheckboxes).some((cb) => cb.checked);
      parentCheckbox.checked = allChecked;
      parentCheckbox.indeterminate = !allChecked && someChecked;
      parentFolderEl = (_c = parentFolderEl.parentElement) == null ? void 0 : _c.closest(".folder");
    }
  }
  createButtons(containerEl) {
    const buttonContainer = containerEl.createDiv({ cls: "button-container" });
    buttonContainer.createEl("button", { text: "Cancel", cls: "mod-cancel" }).addEventListener("click", () => this.close());
    buttonContainer.createEl("button", { text: "Confirm", cls: "mod-cta" }).addEventListener("click", () => this.confirmUpdate());
  }
  async confirmUpdate() {
    const selectedPaths = this.getSelectedPaths();
    if (selectedPaths.length === 0) {
      new import_obsidian15.Notice("No files selected for processing. Please select files or folders to update.");
      return;
    }
    this.close();
    await this.processSelectedFiles(selectedPaths);
  }
  getSelectedPaths() {
    const selectedPaths = [];
    const fileCheckboxes = this.contentEl.querySelectorAll(".file-checkbox:checked");
    fileCheckboxes.forEach((checkbox) => {
      const fileEl = checkbox.closest(".file");
      if (fileEl) {
        const path = fileEl.getAttribute("data-path");
        if (path) {
          selectedPaths.push(path);
        }
      }
    });
    return selectedPaths;
  }
  async processSelectedFiles(selectedPaths) {
    const totalFiles = selectedPaths.length;
    let updatedCount = 0;
    let errorCount = 0;
    const progressNotice = new import_obsidian15.Notice(`Processing 0/${totalFiles} files...`, 0);
    for (const path of selectedPaths) {
      try {
        const file = this.app.vault.getAbstractFileByPath(path);
        if (file instanceof import_obsidian15.TFile) {
          await this.updateFile(file);
          updatedCount++;
          progressNotice.setMessage(`Processing ${updatedCount}/${totalFiles} files...`);
        }
      } catch (error) {
        console.error(`Error updating file ${path}:`, error);
        errorCount++;
      }
    }
    progressNotice.hide();
    let message = `Updated ${updatedCount} file${updatedCount !== 1 ? "s" : ""} successfully.`;
    if (errorCount > 0) {
      message += ` Encountered errors in ${errorCount} file${errorCount !== 1 ? "s" : ""}.`;
    }
    new import_obsidian15.Notice(message, 5e3);
  }
  async updateFile(file) {
    const content = await this.app.vault.read(file);
    const updatedContent = await this.processContent(content);
    await this.app.vault.modify(file, updatedContent);
  }
  async processContent(content) {
    console.log("BatchProcessorModal: Starting content processing");
    let processedContent = content;
    console.log("BatchProcessorModal: Generating front matter");
    const frontMatter = await this.aiService.generateFrontMatter(processedContent);
    processedContent = this.addOrUpdateFrontMatter(processedContent, frontMatter);
    const settings = this.settingsService.getSettings();
    if (settings.advanced.generateWikilinks) {
      console.log("BatchProcessorModal: Generating wikilinks");
      processedContent = await this.aiService.generateWikilinks(processedContent);
    }
    return processedContent;
  }
  addOrUpdateFrontMatter(content, newFrontMatter) {
    const frontMatterRegex = /^---\n[\s\S]*?\n---\n*/;
    if (frontMatterRegex.test(content)) {
      return content.replace(frontMatterRegex, `${newFrontMatter}

`);
    } else {
      return `${newFrontMatter}

${content}`;
    }
  }
};

// src/components/accordions/BatchProcessorAccordion.ts
var BatchProcessorAccordion = class extends BaseAccordion {
  constructor(app, containerEl, settingsService, aiService) {
    super(containerEl);
    this.app = app;
    this.settingsService = settingsService;
    this.aiService = aiService;
  }
  render() {
    const contentEl = this.createAccordion(
      "\u{1F504} Batch Processor",
      "Process multiple files to generate front matter and wikilinks."
    );
    this.createAutoGenerateToggle(contentEl);
    this.createRunBatchProcessorButton(contentEl);
  }
  createAutoGenerateToggle(containerEl) {
    new import_obsidian16.Setting(containerEl).setName("Auto-generate Front Matter").setDesc("Automatically generate front matter for new or unprocessed notes when you open your vault.").addToggle((toggle) => this.setupAutoGenerateToggle(toggle));
  }
  setupAutoGenerateToggle(toggle) {
    const settings = this.settingsService.getSettings();
    toggle.setValue(settings.frontMatter.autoGenerate).onChange(async (value) => {
      await this.settingsService.updateNestedSetting("frontMatter", "autoGenerate", value);
    });
  }
  createRunBatchProcessorButton(containerEl) {
    new import_obsidian16.Setting(containerEl).setName("Run Batch Processor").setDesc("Manually process multiple files to generate front matter and wikilinks.").addButton((button) => this.setupRunBatchProcessorButton(button));
  }
  setupRunBatchProcessorButton(button) {
    button.setButtonText("Run Batch Processor").setCta().onClick(() => {
      const modal = new BatchProcessorModal(this.app, this.aiService, this.settingsService);
      modal.open();
    });
  }
};

// src/components/accordions/AdvancedAccordion.ts
var import_obsidian17 = require("obsidian");
var AdvancedAccordion = class extends BaseAccordion {
  constructor(containerEl, settingsService) {
    super(containerEl);
    this.settingsService = settingsService;
  }
  render() {
    const contentEl = this.createAccordion(
      "\u2699\uFE0F Advanced",
      "Configuration options for the plugin."
    );
    this.createWikilinksToggle(contentEl);
    this.createAIParameterOverrides(contentEl);
  }
  createWikilinksToggle(containerEl) {
    new import_obsidian17.Setting(containerEl).setName("Generate Wikilinks").addToggle((toggle) => this.setupWikilinksToggle(toggle));
  }
  createAIParameterOverrides(containerEl) {
    new import_obsidian17.Setting(containerEl).setName("Temperature").addText((text) => this.setupTemperatureOverride(text));
    new import_obsidian17.Setting(containerEl).setName("Max Tokens").addText((text) => this.setupMaxTokensOverride(text));
  }
  setupWikilinksToggle(toggle) {
    const settings = this.settingsService.getSettings();
    toggle.setValue(settings.advanced.generateWikilinks).onChange(async (value) => {
      await this.settingsService.updateNestedSetting("advanced", "generateWikilinks", value);
    });
  }
  setupTemperatureOverride(text) {
    const settings = this.settingsService.getSettings();
    text.setPlaceholder("0.0 - 1.0").setValue(settings.advanced.temperature.toString()).onChange(async (value) => {
      const temp = parseFloat(value);
      if (!isNaN(temp) && temp >= 0 && temp <= 1) {
        await this.settingsService.updateNestedSetting("advanced", "temperature", temp);
      }
    });
  }
  setupMaxTokensOverride(text) {
    const settings = this.settingsService.getSettings();
    text.setPlaceholder("Enter max tokens").setValue(settings.advanced.maxTokens.toString()).onChange(async (value) => {
      const tokens = parseInt(value);
      if (!isNaN(tokens) && tokens > 0) {
        await this.settingsService.updateNestedSetting("advanced", "maxTokens", tokens);
      }
    });
  }
};

// src/services/JsonValidationService.ts
var import_obsidian18 = require("obsidian");
var JsonValidationService = class {
  /**
   * Validates and cleans the JSON string.
   * @param jsonString The JSON string to validate and clean.
   * @returns A promise that resolves to the validated and cleaned JSON object.
   */
  async validateAndCleanJson(jsonString) {
    try {
      jsonString = jsonString.trim();
      jsonString = jsonString.replace(/^```json?\s*|\s*```$/g, "");
      const jsonObject = JSON.parse(jsonString);
      return jsonObject;
    } catch (error) {
      console.error("Error validating JSON:", error);
      new import_obsidian18.Notice(`Failed to validate JSON: ${error instanceof Error ? error.message : "Unknown error occurred"}`);
      throw new Error("Invalid JSON format");
    }
  }
  /**
   * Checks if the provided string is valid JSON.
   * @param str The string to check.
   * @returns True if the string is valid JSON, false otherwise.
   */
  isValidJson(str) {
    try {
      JSON.parse(str);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Attempts to fix common JSON issues and parse the string.
   * @param str The potentially invalid JSON string.
   * @returns A parsed JSON object if successful, or null if parsing fails.
   */
  tryFixAndParseJson(str) {
    str = str.replace(/^```json?\s*|\s*```$/g, "");
    try {
      return JSON.parse(str);
    } catch (e) {
      str = str.replace(/(\w+)(?=\s*:)/g, '"$1"');
      str = str.replace(/'/g, '"');
      str = str.replace(/,\s*([\]}])/g, "$1");
      try {
        return JSON.parse(str);
      } catch (e2) {
        console.error("Failed to parse JSON even after attempting fixes:", e2);
        return null;
      }
    }
  }
};

// main.ts
var GraphWeaverPlugin = class extends import_obsidian19.Plugin {
  async onload() {
    await this.initializeServices();
    this.addPluginFunctionality();
  }
  async initializeServices() {
    await this.loadSettings();
    this.settingsService = new SettingsService(this, this.settings);
    this.databaseService = new DatabaseService();
    await this.databaseService.load(this.loadData.bind(this));
    this.jsonValidationService = new JsonValidationService();
    this.aiService = new AIService(this.app, this.settingsService, this.jsonValidationService);
    this.autoGenerateService = new AutoGenerateService(
      this.app.vault,
      this.aiService,
      this.settingsService,
      this.databaseService
    );
  }
  addPluginFunctionality() {
    this.addSettingTab(new GraphWeaverSettingTab(this.app, this));
    this.addRibbonIcon("brain-circuit", "GraphWeaver", this.showPluginMenu.bind(this));
    this.addCommands();
    this.registerEvent(this.app.workspace.on("layout-change", this.onLayoutChange.bind(this)));
  }
  addCommands() {
    this.addCommand({
      id: "generate-frontmatter",
      name: "Generate Frontmatter",
      callback: this.generateFrontmatter.bind(this)
    });
    this.addCommand({
      id: "generate-wikilinks",
      name: "Generate Wikilinks",
      callback: this.generateWikilinks.bind(this)
    });
  }
  async onunload() {
    await this.databaseService.save(this.saveData.bind(this));
  }
  async loadSettings() {
    const data = await this.loadData();
    this.settings = { ...DEFAULT_SETTINGS, ...data };
  }
  async saveSettings() {
    await this.saveData(this.settings);
    await this.settingsService.updateSettings(this.settings);
  }
  onLayoutChange() {
    if (this.app.workspace.layoutReady) {
      this.onVaultOpen();
    }
  }
  async onVaultOpen() {
    if (this.settings.frontMatter.autoGenerate) {
      await this.autoGenerateService.runAutoGenerate();
    }
  }
  showPluginMenu(evt) {
    const menu = new import_obsidian19.Menu();
    menu.addItem((item) => item.setTitle("Generate Frontmatter").setIcon("file-plus").onClick(this.generateFrontmatter.bind(this)));
    menu.addItem((item) => item.setTitle("Generate Wikilinks").setIcon("link").onClick(this.generateWikilinks.bind(this)));
    menu.showAtMouseEvent(evt);
  }
  async generateFrontmatter() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian19.Notice("No active file. Please open a file to generate frontmatter.");
      return;
    }
    try {
      new import_obsidian19.Notice("Generating frontmatter...");
      const content = await this.app.vault.read(activeFile);
      const frontMatter = await this.aiService.generateFrontMatter(content);
      const updatedContent = this.addOrUpdateFrontMatter(content, frontMatter);
      await this.app.vault.modify(activeFile, updatedContent);
      this.databaseService.markFileAsProcessed(activeFile);
      new import_obsidian19.Notice("Frontmatter generated and applied successfully!");
    } catch (error) {
      console.error("Error generating frontmatter:", error);
      new import_obsidian19.Notice("Error generating frontmatter. Please check the console for details.");
    }
  }
  async generateWikilinks() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian19.Notice("No active file. Please open a file to generate wikilinks.");
      return;
    }
    try {
      new import_obsidian19.Notice("Generating wikilinks...");
      const content = await this.app.vault.read(activeFile);
      const updatedContent = await this.aiService.generateWikilinks(content);
      await this.app.vault.modify(activeFile, updatedContent);
      new import_obsidian19.Notice("Wikilinks generated and applied successfully!");
    } catch (error) {
      console.error("Error generating wikilinks:", error);
      new import_obsidian19.Notice("Error generating wikilinks. Please check the console for details.");
    }
  }
  addOrUpdateFrontMatter(content, newFrontMatter) {
    const frontMatterRegex = /^---\n([\s\S]*?)\n---/;
    const match = content.match(frontMatterRegex);
    if (match) {
      return content.replace(frontMatterRegex, newFrontMatter);
    } else {
      return `${newFrontMatter}

${content}`;
    }
  }
};
var GraphWeaverSettingTab = class extends import_obsidian19.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "GraphWeaver Settings" });
    this.renderAccordions(containerEl);
  }
  renderAccordions(containerEl) {
    new ModelHookupAccordion(this.app, containerEl, this.plugin.settingsService, this.plugin.aiService).render();
    new PropertyManagerAccordion(this.app, containerEl, this.plugin.settingsService, this.plugin.aiService).render();
    new TagManagerAccordion(this.app, containerEl, this.plugin.settingsService, this.plugin.aiService).render();
    new OntologyGenerationAccordion(this.app, containerEl, this.plugin.settingsService, this.plugin.aiService).render();
    new BatchProcessorAccordion(this.app, containerEl, this.plugin.settingsService, this.plugin.aiService).render();
    new AdvancedAccordion(containerEl, this.plugin.settingsService).render();
  }
};
